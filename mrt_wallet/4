// Generated by dart2js (NullSafetyMode.sound, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.4.4.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback, loadId, loadPriority):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error. The loadId argument is the deferred import that resulted in
//    this uri being loaded. The loadPriority argument is the priority the
//    library should be loaded with as specified in the code via the
//    load-priority annotation (0: normal, 1: high).
// dartDeferredLibraryMultiLoader(uris, successCallback, errorCallback, loadId, loadPriority):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of every URI in `uris`,
//    and call successCallback. If it fails to do so, it should call
//    errorCallback with an error. The loadId argument is the deferred import
//    that resulted in this uri being loaded. The loadPriority argument is the
//    priority the library should be loaded with as specified in the code via
//    the load-priority annotation (0: normal, 1: high).
//
// dartCallInstrumentation(id, qualifiedName):
//    if this function is defined, it will be called at each entry of a
//    method or constructor. Used only when compiling programs with
//    --experiment-call-instrumentation.
(function dartProgram() {
  function copyProperties(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      to[key] = from[key];
    }
  }
  function mixinPropertiesHard(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!to.hasOwnProperty(key)) {
        to[key] = from[key];
      }
    }
  }
  function mixinPropertiesEasy(from, to) {
    Object.assign(to, from);
  }
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(Object.getPrototypeOf(object) && Object.getPrototypeOf(object).p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function inherit(cls, sup) {
    cls.prototype.constructor = cls;
    cls.prototype["$is" + cls.name] = cls;
    if (sup != null) {
      if (supportsDirectProtoAccess) {
        Object.setPrototypeOf(cls.prototype, sup.prototype);
        return;
      }
      var clsPrototype = Object.create(sup.prototype);
      copyProperties(cls.prototype, clsPrototype);
      cls.prototype = clsPrototype;
    }
  }
  function inheritMany(sup, classes) {
    for (var i = 0; i < classes.length; i++) {
      inherit(classes[i], sup);
    }
  }
  function mixinEasy(cls, mixin) {
    mixinPropertiesEasy(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function mixinHard(cls, mixin) {
    mixinPropertiesHard(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function lazy(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      if (holder[name] === uninitializedSentinel) {
        holder[name] = initializer();
      }
      holder[getterName] = function() {
        return this[name];
      };
      return holder[name];
    };
  }
  function lazyFinal(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      if (holder[name] === uninitializedSentinel) {
        var value = initializer();
        if (holder[name] !== uninitializedSentinel) {
          A.throwLateFieldADI(name);
        }
        holder[name] = value;
      }
      var finalValue = holder[name];
      holder[getterName] = function() {
        return finalValue;
      };
      return finalValue;
    };
  }
  function makeConstList(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  }
  function convertToFastObject(properties) {
    function t() {
    }
    t.prototype = properties;
    new t();
    return properties;
  }
  function convertAllToFastObject(arrayOfObjects) {
    for (var i = 0; i < arrayOfObjects.length; ++i) {
      convertToFastObject(arrayOfObjects[i]);
    }
  }
  var functionCounter = 0;
  function instanceTearOffGetter(isIntercepted, parameters) {
    var cache = null;
    return isIntercepted ? function(receiver) {
      if (cache === null)
        cache = A.closureFromTearOff(parameters);
      return new cache(receiver, this);
    } : function() {
      if (cache === null)
        cache = A.closureFromTearOff(parameters);
      return new cache(this, null);
    };
  }
  function staticTearOffGetter(parameters) {
    var cache = null;
    return function() {
      if (cache === null)
        cache = A.closureFromTearOff(parameters).prototype;
      return cache;
    };
  }
  var typesOffset = 0;
  function tearOffParameters(container, isStatic, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, needsDirectAccess) {
    if (typeof funType == "number") {
      funType += typesOffset;
    }
    return {co: container, iS: isStatic, iI: isIntercepted, rC: requiredParameterCount, dV: optionalParameterDefaultValues, cs: callNames, fs: funsOrNames, fT: funType, aI: applyIndex || 0, nDA: needsDirectAccess};
  }
  function installStaticTearOff(holder, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    var parameters = tearOffParameters(holder, true, false, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, false);
    var getterFunction = staticTearOffGetter(parameters);
    holder[getterName] = getterFunction;
  }
  function installInstanceTearOff(prototype, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, needsDirectAccess) {
    isIntercepted = !!isIntercepted;
    var parameters = tearOffParameters(prototype, false, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex, !!needsDirectAccess);
    var getterFunction = instanceTearOffGetter(isIntercepted, parameters);
    prototype[getterName] = getterFunction;
  }
  function setOrUpdateInterceptorsByTag(newTags) {
    var tags = init.interceptorsByTag;
    if (!tags) {
      init.interceptorsByTag = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function setOrUpdateLeafTags(newTags) {
    var tags = init.leafTags;
    if (!tags) {
      init.leafTags = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function updateTypes(newTypes) {
    var types = init.types;
    var length = types.length;
    types.push.apply(types, newTypes);
    return length;
  }
  function updateHolder(holder, newHolder) {
    copyProperties(newHolder, holder);
    return holder;
  }
  var hunkHelpers = function() {
    var mkInstance = function(isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex, false);
        };
      },
      mkStatic = function(requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      };
    return {inherit: inherit, inheritMany: inheritMany, mixin: mixinEasy, mixinHard: mixinHard, installStaticTearOff: installStaticTearOff, installInstanceTearOff: installInstanceTearOff, _instance_0u: mkInstance(0, 0, null, ["call$0"], 0), _instance_1u: mkInstance(0, 1, null, ["call$1"], 0), _instance_2u: mkInstance(0, 2, null, ["call$2"], 0), _instance_0i: mkInstance(1, 0, null, ["call$0"], 0), _instance_1i: mkInstance(1, 1, null, ["call$1"], 0), _instance_2i: mkInstance(1, 2, null, ["call$2"], 0), _static_0: mkStatic(0, null, ["call$0"], 0), _static_1: mkStatic(1, null, ["call$1"], 0), _static_2: mkStatic(2, null, ["call$2"], 0), makeConstList: makeConstList, lazy: lazy, lazyFinal: lazyFinal, updateHolder: updateHolder, convertToFastObject: convertToFastObject, updateTypes: updateTypes, setOrUpdateInterceptorsByTag: setOrUpdateInterceptorsByTag, setOrUpdateLeafTags: setOrUpdateLeafTags};
  }();
  function initializeDeferredHunk(hunk) {
    typesOffset = init.types.length;
    hunk(hunkHelpers, init, holders, $);
  }
  var J = {
    makeDispatchRecord(interceptor, proto, extension, indexability) {
      return {i: interceptor, p: proto, e: extension, x: indexability};
    },
    getNativeInterceptor(object) {
      var proto, objectProto, $constructor, interceptor, t1,
        record = object[init.dispatchPropertyName];
      if (record == null)
        if ($.initNativeDispatchFlag == null) {
          A.initNativeDispatch();
          record = object[init.dispatchPropertyName];
        }
      if (record != null) {
        proto = record.p;
        if (false === proto)
          return record.i;
        if (true === proto)
          return object;
        objectProto = Object.getPrototypeOf(object);
        if (proto === objectProto)
          return record.i;
        if (record.e === objectProto)
          throw A.wrapException(A.UnimplementedError$("Return interceptor for " + A.S(proto(object, record))));
      }
      $constructor = object.constructor;
      if ($constructor == null)
        interceptor = null;
      else {
        t1 = $._JS_INTEROP_INTERCEPTOR_TAG;
        if (t1 == null)
          t1 = $._JS_INTEROP_INTERCEPTOR_TAG = init.getIsolateTag("_$dart_js");
        interceptor = $constructor[t1];
      }
      if (interceptor != null)
        return interceptor;
      interceptor = A.lookupAndCacheInterceptor(object);
      if (interceptor != null)
        return interceptor;
      if (typeof object == "function")
        return B.JavaScriptFunction_methods;
      proto = Object.getPrototypeOf(object);
      if (proto == null)
        return B.PlainJavaScriptObject_methods;
      if (proto === Object.prototype)
        return B.PlainJavaScriptObject_methods;
      if (typeof $constructor == "function") {
        t1 = $._JS_INTEROP_INTERCEPTOR_TAG;
        if (t1 == null)
          t1 = $._JS_INTEROP_INTERCEPTOR_TAG = init.getIsolateTag("_$dart_js");
        Object.defineProperty($constructor, t1, {value: B.UnknownJavaScriptObject_methods, enumerable: false, writable: true, configurable: true});
        return B.UnknownJavaScriptObject_methods;
      }
      return B.UnknownJavaScriptObject_methods;
    },
    JSArray_JSArray$fixed($length, $E) {
      if ($length < 0 || $length > 4294967295)
        throw A.wrapException(A.RangeError$range($length, 0, 4294967295, "length", null));
      return J.JSArray_JSArray$markFixed(new Array($length), $E);
    },
    JSArray_JSArray$growable($length, $E) {
      if ($length < 0)
        throw A.wrapException(A.ArgumentError$("Length must be a non-negative integer: " + $length, null));
      return A._setArrayType(new Array($length), $E._eval$1("JSArray<0>"));
    },
    JSArray_JSArray$allocateGrowable($length, $E) {
      return A._setArrayType(new Array($length), $E._eval$1("JSArray<0>"));
    },
    JSArray_JSArray$markFixed(allocation, $E) {
      return J.JSArray_markFixedList(A._setArrayType(allocation, $E._eval$1("JSArray<0>")), $E);
    },
    JSArray_markFixedList(list, $T) {
      list.fixed$length = Array;
      return list;
    },
    JSArray_markUnmodifiableList(list) {
      list.fixed$length = Array;
      list.immutable$list = Array;
      return list;
    },
    JSArray__compareAny(a, b) {
      var t1 = type$.Comparable_dynamic;
      return J.compareTo$1$ns(t1._as(a), t1._as(b));
    },
    JSString__isWhitespace(codeUnit) {
      if (codeUnit < 256)
        switch (codeUnit) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 133:
          case 160:
            return true;
          default:
            return false;
        }
      switch (codeUnit) {
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8232:
        case 8233:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    },
    JSString__skipLeadingWhitespace(string, index) {
      var t1, codeUnit;
      for (t1 = string.length; index < t1;) {
        codeUnit = string.charCodeAt(index);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
        ++index;
      }
      return index;
    },
    JSString__skipTrailingWhitespace(string, index) {
      var t1, index0, codeUnit;
      for (t1 = string.length; index > 0; index = index0) {
        index0 = index - 1;
        if (!(index0 < t1))
          return A.ioore(string, index0);
        codeUnit = string.charCodeAt(index0);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
      }
      return index;
    },
    getInterceptor$(receiver) {
      if (typeof receiver == "number") {
        if (Math.floor(receiver) == receiver)
          return J.JSInt.prototype;
        return J.JSNumNotInt.prototype;
      }
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return J.JSNull.prototype;
      if (typeof receiver == "boolean")
        return J.JSBool.prototype;
      if (Array.isArray(receiver))
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        if (typeof receiver == "symbol")
          return J.JavaScriptSymbol.prototype;
        if (typeof receiver == "bigint")
          return J.JavaScriptBigInt.prototype;
        return receiver;
      }
      if (receiver instanceof A.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$asx(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (Array.isArray(receiver))
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        if (typeof receiver == "symbol")
          return J.JavaScriptSymbol.prototype;
        if (typeof receiver == "bigint")
          return J.JavaScriptBigInt.prototype;
        return receiver;
      }
      if (receiver instanceof A.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ax(receiver) {
      if (receiver == null)
        return receiver;
      if (Array.isArray(receiver))
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        if (typeof receiver == "symbol")
          return J.JavaScriptSymbol.prototype;
        if (typeof receiver == "bigint")
          return J.JavaScriptBigInt.prototype;
        return receiver;
      }
      if (receiver instanceof A.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$n(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof A.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$ns(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof A.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$s(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof A.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    set$length$asx(receiver, value) {
      return J.getInterceptor$asx(receiver).set$length(receiver, value);
    },
    get$hashCode$(receiver) {
      return J.getInterceptor$(receiver).get$hashCode(receiver);
    },
    get$isEmpty$asx(receiver) {
      return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
    },
    get$isNotEmpty$asx(receiver) {
      return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
    },
    get$iterator$ax(receiver) {
      return J.getInterceptor$ax(receiver).get$iterator(receiver);
    },
    get$last$ax(receiver) {
      return J.getInterceptor$ax(receiver).get$last(receiver);
    },
    get$length$asx(receiver) {
      return J.getInterceptor$asx(receiver).get$length(receiver);
    },
    get$reversed$ax(receiver) {
      return J.getInterceptor$ax(receiver).get$reversed(receiver);
    },
    get$runtimeType$(receiver) {
      return J.getInterceptor$(receiver).get$runtimeType(receiver);
    },
    $eq$(receiver, a0) {
      if (receiver == null)
        return a0 == null;
      if (typeof receiver != "object")
        return a0 != null && receiver === a0;
      return J.getInterceptor$(receiver).$eq(receiver, a0);
    },
    $index$asx(receiver, a0) {
      if (typeof a0 === "number")
        if (Array.isArray(receiver) || typeof receiver == "string" || A.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
          if (a0 >>> 0 === a0 && a0 < receiver.length)
            return receiver[a0];
      return J.getInterceptor$asx(receiver).$index(receiver, a0);
    },
    $indexSet$ax(receiver, a0, a1) {
      return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
    },
    $mul$ns(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver * a0;
      return J.getInterceptor$ns(receiver).$mul(receiver, a0);
    },
    add$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).add$1(receiver, a0);
    },
    addAll$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).addAll$1(receiver, a0);
    },
    allMatches$1$s(receiver, a0) {
      return J.getInterceptor$s(receiver).allMatches$1(receiver, a0);
    },
    compareTo$1$ns(receiver, a0) {
      return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
    },
    contains$1$asx(receiver, a0) {
      return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
    },
    elementAt$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
    },
    fold$1$2$ax(receiver, a0, a1, $T1) {
      return J.getInterceptor$ax(receiver).fold$1$2(receiver, a0, a1, $T1);
    },
    getRange$2$ax(receiver, a0, a1) {
      return J.getInterceptor$ax(receiver).getRange$2(receiver, a0, a1);
    },
    join$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).join$1(receiver, a0);
    },
    map$1$1$ax(receiver, a0, $T1) {
      return J.getInterceptor$ax(receiver).map$1$1(receiver, a0, $T1);
    },
    matchAsPrefix$2$s(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
    },
    noSuchMethod$1$(receiver, a0) {
      return J.getInterceptor$(receiver).noSuchMethod$1(receiver, a0);
    },
    skip$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).skip$1(receiver, a0);
    },
    sort$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).sort$1(receiver, a0);
    },
    sublist$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).sublist$1(receiver, a0);
    },
    sublist$2$ax(receiver, a0, a1) {
      return J.getInterceptor$ax(receiver).sublist$2(receiver, a0, a1);
    },
    substring$1$s(receiver, a0) {
      return J.getInterceptor$s(receiver).substring$1(receiver, a0);
    },
    take$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).take$1(receiver, a0);
    },
    toList$0$ax(receiver) {
      return J.getInterceptor$ax(receiver).toList$0(receiver);
    },
    toRadixString$1$n(receiver, a0) {
      return J.getInterceptor$n(receiver).toRadixString$1(receiver, a0);
    },
    toString$0$(receiver) {
      return J.getInterceptor$(receiver).toString$0(receiver);
    },
    trim$0$s(receiver) {
      return J.getInterceptor$s(receiver).trim$0(receiver);
    },
    where$1$ax(receiver, a0) {
      return J.getInterceptor$ax(receiver).where$1(receiver, a0);
    },
    Interceptor: function Interceptor() {
    },
    JSBool: function JSBool() {
    },
    JSNull: function JSNull() {
    },
    JavaScriptObject: function JavaScriptObject() {
    },
    LegacyJavaScriptObject: function LegacyJavaScriptObject() {
    },
    PlainJavaScriptObject: function PlainJavaScriptObject() {
    },
    UnknownJavaScriptObject: function UnknownJavaScriptObject() {
    },
    JavaScriptFunction: function JavaScriptFunction() {
    },
    JavaScriptBigInt: function JavaScriptBigInt() {
    },
    JavaScriptSymbol: function JavaScriptSymbol() {
    },
    JSArray: function JSArray(t0) {
      this.$ti = t0;
    },
    JSUnmodifiableArray: function JSUnmodifiableArray(t0) {
      this.$ti = t0;
    },
    ArrayIterator: function ArrayIterator(t0, t1, t2) {
      var _ = this;
      _._iterable = t0;
      _._length = t1;
      _._index = 0;
      _._current = null;
      _.$ti = t2;
    },
    JSNumber: function JSNumber() {
    },
    JSInt: function JSInt() {
    },
    JSNumNotInt: function JSNumNotInt() {
    },
    JSString: function JSString() {
    }
  },
  A = {JS_CONST: function JS_CONST() {
    },
    createSentinel() {
      return $;
    },
    CastIterable_CastIterable(source, $S, $T) {
      if ($S._eval$1("EfficientLengthIterable<0>")._is(source))
        return new A._EfficientLengthCastIterable(source, $S._eval$1("@<0>")._bind$1($T)._eval$1("_EfficientLengthCastIterable<1,2>"));
      return new A.CastIterable(source, $S._eval$1("@<0>")._bind$1($T)._eval$1("CastIterable<1,2>"));
    },
    LateError$fieldNI(fieldName) {
      return new A.LateError("Field '" + fieldName + "' has not been initialized.");
    },
    CodeUnits$(_string) {
      return new A.CodeUnits(_string);
    },
    hexDigitValue(char) {
      var letter,
        digit = char ^ 48;
      if (digit <= 9)
        return digit;
      letter = char | 32;
      if (97 <= letter && letter <= 102)
        return letter - 87;
      return -1;
    },
    SystemHash_combine(hash, value) {
      hash = hash + value & 536870911;
      hash = hash + ((hash & 524287) << 10) & 536870911;
      return hash ^ hash >>> 6;
    },
    SystemHash_finish(hash) {
      hash = hash + ((hash & 67108863) << 3) & 536870911;
      hash ^= hash >>> 11;
      return hash + ((hash & 16383) << 15) & 536870911;
    },
    checkNotNullable(value, $name, $T) {
      return value;
    },
    isToStringVisiting(object) {
      var t1, i;
      for (t1 = $.toStringVisiting.length, i = 0; i < t1; ++i)
        if (object === $.toStringVisiting[i])
          return true;
      return false;
    },
    SubListIterable$(_iterable, _start, _endOrLength, $E) {
      A.RangeError_checkNotNegative(_start, "start");
      if (_endOrLength != null) {
        A.RangeError_checkNotNegative(_endOrLength, "end");
        if (_start > _endOrLength)
          A.throwExpression(A.RangeError$range(_start, 0, _endOrLength, "start", null));
      }
      return new A.SubListIterable(_iterable, _start, _endOrLength, $E._eval$1("SubListIterable<0>"));
    },
    MappedIterable_MappedIterable(iterable, $function, $S, $T) {
      if (type$.EfficientLengthIterable_dynamic._is(iterable))
        return new A.EfficientLengthMappedIterable(iterable, $function, $S._eval$1("@<0>")._bind$1($T)._eval$1("EfficientLengthMappedIterable<1,2>"));
      return new A.MappedIterable(iterable, $function, $S._eval$1("@<0>")._bind$1($T)._eval$1("MappedIterable<1,2>"));
    },
    TakeIterable_TakeIterable(iterable, takeCount, $E) {
      var _s9_ = "takeCount";
      A.ArgumentError_checkNotNull(takeCount, _s9_, type$.int);
      A.RangeError_checkNotNegative(takeCount, _s9_);
      if (type$.EfficientLengthIterable_dynamic._is(iterable))
        return new A.EfficientLengthTakeIterable(iterable, takeCount, $E._eval$1("EfficientLengthTakeIterable<0>"));
      return new A.TakeIterable(iterable, takeCount, $E._eval$1("TakeIterable<0>"));
    },
    SkipIterable_SkipIterable(iterable, count, $E) {
      var _s5_ = "count";
      if (type$.EfficientLengthIterable_dynamic._is(iterable)) {
        A.ArgumentError_checkNotNull(count, _s5_, type$.int);
        A.RangeError_checkNotNegative(count, _s5_);
        return new A.EfficientLengthSkipIterable(iterable, count, $E._eval$1("EfficientLengthSkipIterable<0>"));
      }
      A.ArgumentError_checkNotNull(count, _s5_, type$.int);
      A.RangeError_checkNotNegative(count, _s5_);
      return new A.SkipIterable(iterable, count, $E._eval$1("SkipIterable<0>"));
    },
    IterableElementError_noElement() {
      return new A.StateError("No element");
    },
    IterableElementError_tooFew() {
      return new A.StateError("Too few elements");
    },
    Sort__doSort(a, left, right, compare, $E) {
      if (right - left <= 32)
        A.Sort__insertionSort(a, left, right, compare, $E);
      else
        A.Sort__dualPivotQuicksort(a, left, right, compare, $E);
    },
    Sort__insertionSort(a, left, right, compare, $E) {
      var i, t1, el, j, t2, j0;
      for (i = left + 1, t1 = J.getInterceptor$asx(a); i <= right; ++i) {
        el = t1.$index(a, i);
        j = i;
        while (true) {
          if (j > left) {
            t2 = compare.call$2(t1.$index(a, j - 1), el);
            if (typeof t2 !== "number")
              return t2.$gt();
            t2 = t2 > 0;
          } else
            t2 = false;
          if (!t2)
            break;
          j0 = j - 1;
          t1.$indexSet(a, j, t1.$index(a, j0));
          j = j0;
        }
        t1.$indexSet(a, j, el);
      }
    },
    Sort__dualPivotQuicksort(a, left, right, compare, $E) {
      var t0, less, great, pivots_are_equal, k, ak, comp, great0, less0,
        sixth = B.JSInt_methods._tdivFast$1(right - left + 1, 6),
        index1 = left + sixth,
        index5 = right - sixth,
        index3 = B.JSInt_methods._tdivFast$1(left + right, 2),
        index2 = index3 - sixth,
        index4 = index3 + sixth,
        t1 = J.getInterceptor$asx(a),
        el1 = t1.$index(a, index1),
        el2 = t1.$index(a, index2),
        el3 = t1.$index(a, index3),
        el4 = t1.$index(a, index4),
        el5 = t1.$index(a, index5),
        t2 = compare.call$2(el1, el2);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el2;
        el2 = el1;
        el1 = t0;
      }
      t2 = compare.call$2(el4, el5);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      t2 = compare.call$2(el1, el3);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el3;
        el3 = el1;
        el1 = t0;
      }
      t2 = compare.call$2(el2, el3);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      t2 = compare.call$2(el1, el4);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el4;
        el4 = el1;
        el1 = t0;
      }
      t2 = compare.call$2(el3, el4);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el4;
        el4 = el3;
        el3 = t0;
      }
      t2 = compare.call$2(el2, el5);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el5;
        el5 = el2;
        el2 = t0;
      }
      t2 = compare.call$2(el2, el3);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      t2 = compare.call$2(el4, el5);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      t1.$indexSet(a, index1, el1);
      t1.$indexSet(a, index3, el3);
      t1.$indexSet(a, index5, el5);
      t1.$indexSet(a, index2, t1.$index(a, left));
      t1.$indexSet(a, index4, t1.$index(a, right));
      less = left + 1;
      great = right - 1;
      pivots_are_equal = J.$eq$(compare.call$2(el2, el4), 0);
      if (pivots_are_equal)
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          comp = compare.call$2(ak, el2);
          if (comp === 0)
            continue;
          if (comp < 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else
            for (; true;) {
              comp = compare.call$2(t1.$index(a, great), el2);
              if (comp > 0) {
                --great;
                continue;
              } else {
                great0 = great - 1;
                if (comp < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                  break;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  break;
                }
              }
            }
        }
      else
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          if (compare.call$2(ak, el2) < 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else if (compare.call$2(ak, el4) > 0)
            for (; true;)
              if (compare.call$2(t1.$index(a, great), el4) > 0) {
                --great;
                if (great < k)
                  break;
                continue;
              } else {
                great0 = great - 1;
                if (compare.call$2(t1.$index(a, great), el2) < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  less = less0;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                }
                great = great0;
                break;
              }
        }
      t2 = less - 1;
      t1.$indexSet(a, left, t1.$index(a, t2));
      t1.$indexSet(a, t2, el2);
      t2 = great + 1;
      t1.$indexSet(a, right, t1.$index(a, t2));
      t1.$indexSet(a, t2, el4);
      A.Sort__doSort(a, left, less - 2, compare, $E);
      A.Sort__doSort(a, great + 2, right, compare, $E);
      if (pivots_are_equal)
        return;
      if (less < index1 && great > index5) {
        for (; J.$eq$(compare.call$2(t1.$index(a, less), el2), 0);)
          ++less;
        for (; J.$eq$(compare.call$2(t1.$index(a, great), el4), 0);)
          --great;
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          if (compare.call$2(ak, el2) === 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else if (compare.call$2(ak, el4) === 0)
            for (; true;)
              if (compare.call$2(t1.$index(a, great), el4) === 0) {
                --great;
                if (great < k)
                  break;
                continue;
              } else {
                great0 = great - 1;
                if (compare.call$2(t1.$index(a, great), el2) < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  less = less0;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                }
                great = great0;
                break;
              }
        }
        A.Sort__doSort(a, less, great, compare, $E);
      } else
        A.Sort__doSort(a, less, great, compare, $E);
    },
    CastStream: function CastStream(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CastStreamSubscription: function CastStreamSubscription(t0, t1, t2) {
      var _ = this;
      _._source = t0;
      _.__internal$_zone = t1;
      _._handleError = _._handleData = null;
      _.$ti = t2;
    },
    _CastIterableBase: function _CastIterableBase() {
    },
    CastIterator: function CastIterator(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CastIterable: function CastIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    _EfficientLengthCastIterable: function _EfficientLengthCastIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    _CastListBase: function _CastListBase() {
    },
    _CastListBase_sort_closure: function _CastListBase_sort_closure(t0, t1) {
      this.$this = t0;
      this.compare = t1;
    },
    CastList: function CastList(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CastMap: function CastMap(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CastMap_forEach_closure: function CastMap_forEach_closure(t0, t1) {
      this.$this = t0;
      this.f = t1;
    },
    CastMap_entries_closure: function CastMap_entries_closure(t0) {
      this.$this = t0;
    },
    LateError: function LateError(t0) {
      this.__internal$_message = t0;
    },
    CodeUnits: function CodeUnits(t0) {
      this.__internal$_string = t0;
    },
    nullFuture_closure: function nullFuture_closure() {
    },
    SentinelValue: function SentinelValue() {
    },
    EfficientLengthIterable: function EfficientLengthIterable() {
    },
    ListIterable: function ListIterable() {
    },
    SubListIterable: function SubListIterable(t0, t1, t2, t3) {
      var _ = this;
      _.__internal$_iterable = t0;
      _._start = t1;
      _._endOrLength = t2;
      _.$ti = t3;
    },
    ListIterator: function ListIterator(t0, t1, t2) {
      var _ = this;
      _.__internal$_iterable = t0;
      _.__internal$_length = t1;
      _.__internal$_index = 0;
      _.__internal$_current = null;
      _.$ti = t2;
    },
    MappedIterable: function MappedIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    EfficientLengthMappedIterable: function EfficientLengthMappedIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    MappedIterator: function MappedIterator(t0, t1, t2) {
      var _ = this;
      _.__internal$_current = null;
      _._iterator = t0;
      _._f = t1;
      _.$ti = t2;
    },
    MappedListIterable: function MappedListIterable(t0, t1, t2) {
      this._source = t0;
      this._f = t1;
      this.$ti = t2;
    },
    WhereIterable: function WhereIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    WhereIterator: function WhereIterator(t0, t1, t2) {
      this._iterator = t0;
      this._f = t1;
      this.$ti = t2;
    },
    ExpandIterable: function ExpandIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    ExpandIterator: function ExpandIterator(t0, t1, t2, t3) {
      var _ = this;
      _._iterator = t0;
      _._f = t1;
      _._currentExpansion = t2;
      _.__internal$_current = null;
      _.$ti = t3;
    },
    TakeIterable: function TakeIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._takeCount = t1;
      this.$ti = t2;
    },
    EfficientLengthTakeIterable: function EfficientLengthTakeIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._takeCount = t1;
      this.$ti = t2;
    },
    TakeIterator: function TakeIterator(t0, t1, t2) {
      this._iterator = t0;
      this._remaining = t1;
      this.$ti = t2;
    },
    SkipIterable: function SkipIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._skipCount = t1;
      this.$ti = t2;
    },
    EfficientLengthSkipIterable: function EfficientLengthSkipIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._skipCount = t1;
      this.$ti = t2;
    },
    SkipIterator: function SkipIterator(t0, t1, t2) {
      this._iterator = t0;
      this._skipCount = t1;
      this.$ti = t2;
    },
    EmptyIterable: function EmptyIterable(t0) {
      this.$ti = t0;
    },
    EmptyIterator: function EmptyIterator(t0) {
      this.$ti = t0;
    },
    WhereTypeIterable: function WhereTypeIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    WhereTypeIterator: function WhereTypeIterator(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    FixedLengthListMixin: function FixedLengthListMixin() {
    },
    UnmodifiableListMixin: function UnmodifiableListMixin() {
    },
    UnmodifiableListBase: function UnmodifiableListBase() {
    },
    _ListIndicesIterable: function _ListIndicesIterable(t0) {
      this._backedList = t0;
    },
    ListMapView: function ListMapView(t0, t1) {
      this.__internal$_values = t0;
      this.$ti = t1;
    },
    ReversedListIterable: function ReversedListIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    Symbol: function Symbol(t0) {
      this.__internal$_name = t0;
    },
    __CastListBase__CastIterableBase_ListMixin: function __CastListBase__CastIterableBase_ListMixin() {
    },
    ConstantMap_ConstantMap$from(other, $K, $V) {
      var allStrings, k, object, index, index0, values, map,
        keys = A.List_List$from(new A.LinkedHashMapKeyIterable(other, A._instanceType(other)._eval$1("LinkedHashMapKeyIterable<1>")), true, $K),
        t1 = keys.length,
        _i = 0;
      while (true) {
        if (!(_i < t1)) {
          allStrings = true;
          break;
        }
        k = keys[_i];
        if (typeof k != "string" || "__proto__" === k) {
          allStrings = false;
          break;
        }
        ++_i;
      }
      if (allStrings) {
        object = {};
        for (index = 0, _i = 0; _i < keys.length; keys.length === t1 || (0, A.throwConcurrentModificationError)(keys), ++_i, index = index0) {
          k = keys[_i];
          $V._as(other.$index(0, k));
          index0 = index + 1;
          object[k] = index;
        }
        values = A.List_List$from(other.get$values(), true, $V);
        map = new A.ConstantStringMap(object, values, $K._eval$1("@<0>")._bind$1($V)._eval$1("ConstantStringMap<1,2>"));
        map.$keys = keys;
        return map;
      }
      return new A.ConstantMapView(A.LinkedHashMap_LinkedHashMap$from(other, $K, $V), $K._eval$1("@<0>")._bind$1($V)._eval$1("ConstantMapView<1,2>"));
    },
    ConstantMap__throwUnmodifiable() {
      throw A.wrapException(A.UnsupportedError$("Cannot modify unmodifiable Map"));
    },
    instantiate1(f, T1) {
      var t1 = new A.Instantiation1(f, T1._eval$1("Instantiation1<0>"));
      t1.Instantiation$1(f);
      return t1;
    },
    unminifyOrTag(rawClassName) {
      var preserved = init.mangledGlobalNames[rawClassName];
      if (preserved != null)
        return preserved;
      return rawClassName;
    },
    isJsIndexable(object, record) {
      var result;
      if (record != null) {
        result = record.x;
        if (result != null)
          return result;
      }
      return type$.JavaScriptIndexingBehavior_dynamic._is(object);
    },
    S(value) {
      var result;
      if (typeof value == "string")
        return value;
      if (typeof value == "number") {
        if (value !== 0)
          return "" + value;
      } else if (true === value)
        return "true";
      else if (false === value)
        return "false";
      else if (value == null)
        return "null";
      result = J.toString$0$(value);
      return result;
    },
    Primitives_objectHashCode(object) {
      var hash,
        property = $.Primitives__identityHashCodeProperty;
      if (property == null)
        property = $.Primitives__identityHashCodeProperty = Symbol("identityHashCode");
      hash = object[property];
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object[property] = hash;
      }
      return hash;
    },
    Primitives_parseInt(source, radix) {
      var decimalMatch, maxCharCode, digitsPart, t1, i, _null = null,
        match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
      if (match == null)
        return _null;
      if (3 >= match.length)
        return A.ioore(match, 3);
      decimalMatch = match[3];
      if (radix == null) {
        if (decimalMatch != null)
          return parseInt(source, 10);
        if (match[2] != null)
          return parseInt(source, 16);
        return _null;
      }
      if (radix < 2 || radix > 36)
        throw A.wrapException(A.RangeError$range(radix, 2, 36, "radix", _null));
      if (radix === 10 && decimalMatch != null)
        return parseInt(source, 10);
      if (radix < 10 || decimalMatch == null) {
        maxCharCode = radix <= 10 ? 47 + radix : 86 + radix;
        digitsPart = match[1];
        for (t1 = digitsPart.length, i = 0; i < t1; ++i)
          if ((digitsPart.charCodeAt(i) | 32) > maxCharCode)
            return _null;
      }
      return parseInt(source, radix);
    },
    Primitives_objectTypeName(object) {
      return A.Primitives__objectTypeNameNewRti(object);
    },
    Primitives__objectTypeNameNewRti(object) {
      var interceptor, dispatchName, $constructor, constructorName;
      if (object instanceof A.Object)
        return A._rtiToString(A.instanceType(object), null);
      interceptor = J.getInterceptor$(object);
      if (interceptor === B.Interceptor_methods || interceptor === B.JavaScriptObject_methods || type$.UnknownJavaScriptObject._is(object)) {
        dispatchName = B.C_JS_CONST(object);
        if (dispatchName !== "Object" && dispatchName !== "")
          return dispatchName;
        $constructor = object.constructor;
        if (typeof $constructor == "function") {
          constructorName = $constructor.name;
          if (typeof constructorName == "string" && constructorName !== "Object" && constructorName !== "")
            return constructorName;
        }
      }
      return A._rtiToString(A.instanceType(object), null);
    },
    Primitives_safeToString(object) {
      if (typeof object == "number" || A._isBool(object))
        return J.toString$0$(object);
      if (typeof object == "string")
        return JSON.stringify(object);
      if (object instanceof A.Closure)
        return object.toString$0(0);
      return "Instance of '" + A.Primitives_objectTypeName(object) + "'";
    },
    Primitives_currentUri() {
      if (!!self.location)
        return self.location.href;
      return null;
    },
    Primitives__fromCharCodeApply(array) {
      var result, i, i0, chunkEnd,
        end = array.length;
      if (end <= 500)
        return String.fromCharCode.apply(null, array);
      for (result = "", i = 0; i < end; i = i0) {
        i0 = i + 500;
        chunkEnd = i0 < end ? i0 : end;
        result += String.fromCharCode.apply(null, array.slice(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCodePoints(codePoints) {
      var t1, _i, i,
        a = A._setArrayType([], type$.JSArray_int);
      for (t1 = codePoints.length, _i = 0; _i < codePoints.length; codePoints.length === t1 || (0, A.throwConcurrentModificationError)(codePoints), ++_i) {
        i = codePoints[_i];
        if (!A._isInt(i))
          throw A.wrapException(A.argumentErrorValue(i));
        if (i <= 65535)
          B.JSArray_methods.add$1(a, i);
        else if (i <= 1114111) {
          B.JSArray_methods.add$1(a, 55296 + (B.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
          B.JSArray_methods.add$1(a, 56320 + (i & 1023));
        } else
          throw A.wrapException(A.argumentErrorValue(i));
      }
      return A.Primitives__fromCharCodeApply(a);
    },
    Primitives_stringFromCharCodes(charCodes) {
      var t1, _i, i;
      for (t1 = charCodes.length, _i = 0; _i < t1; ++_i) {
        i = charCodes[_i];
        if (!A._isInt(i))
          throw A.wrapException(A.argumentErrorValue(i));
        if (i < 0)
          throw A.wrapException(A.argumentErrorValue(i));
        if (i > 65535)
          return A.Primitives_stringFromCodePoints(charCodes);
      }
      return A.Primitives__fromCharCodeApply(charCodes);
    },
    Primitives_stringFromNativeUint8List(charCodes, start, end) {
      var i, result, i0, chunkEnd;
      if (end <= 500 && start === 0 && end === charCodes.length)
        return String.fromCharCode.apply(null, charCodes);
      for (i = start, result = ""; i < end; i = i0) {
        i0 = i + 500;
        chunkEnd = i0 < end ? i0 : end;
        result += String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCharCode(charCode) {
      var bits;
      if (0 <= charCode) {
        if (charCode <= 65535)
          return String.fromCharCode(charCode);
        if (charCode <= 1114111) {
          bits = charCode - 65536;
          return String.fromCharCode((B.JSInt_methods._shrOtherPositive$1(bits, 10) | 55296) >>> 0, bits & 1023 | 56320);
        }
      }
      throw A.wrapException(A.RangeError$range(charCode, 0, 1114111, null, null));
    },
    Primitives_valueFromDecomposedDate(years, month, day, hours, minutes, seconds, milliseconds, isUtc) {
      var value,
        jsMonth = month - 1;
      if (0 <= years && years < 100) {
        years += 400;
        jsMonth -= 4800;
      }
      value = isUtc ? Date.UTC(years, jsMonth, day, hours, minutes, seconds, milliseconds) : new Date(years, jsMonth, day, hours, minutes, seconds, milliseconds).valueOf();
      if (isNaN(value) || value < -864e13 || value > 864e13)
        return null;
      return value;
    },
    Primitives_lazyAsJsDate(receiver) {
      if (receiver.date === void 0)
        receiver.date = new Date(receiver._core$_value);
      return receiver.date;
    },
    Primitives_getYear(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCFullYear() + 0 : A.Primitives_lazyAsJsDate(receiver).getFullYear() + 0;
    },
    Primitives_getMonth(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCMonth() + 1 : A.Primitives_lazyAsJsDate(receiver).getMonth() + 1;
    },
    Primitives_getDay(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCDate() + 0 : A.Primitives_lazyAsJsDate(receiver).getDate() + 0;
    },
    Primitives_getHours(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCHours() + 0 : A.Primitives_lazyAsJsDate(receiver).getHours() + 0;
    },
    Primitives_getMinutes(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCMinutes() + 0 : A.Primitives_lazyAsJsDate(receiver).getMinutes() + 0;
    },
    Primitives_getSeconds(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCSeconds() + 0 : A.Primitives_lazyAsJsDate(receiver).getSeconds() + 0;
    },
    Primitives_getMilliseconds(receiver) {
      return receiver.isUtc ? A.Primitives_lazyAsJsDate(receiver).getUTCMilliseconds() + 0 : A.Primitives_lazyAsJsDate(receiver).getMilliseconds() + 0;
    },
    Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments) {
      var $arguments, namedArgumentList, t1 = {};
      t1.argumentCount = 0;
      $arguments = [];
      namedArgumentList = [];
      t1.argumentCount = positionalArguments.length;
      B.JSArray_methods.addAll$1($arguments, positionalArguments);
      t1.names = "";
      if (namedArguments != null && namedArguments.__js_helper$_length !== 0)
        namedArguments.forEach$1(0, new A.Primitives_functionNoSuchMethod_closure(t1, namedArgumentList, $arguments));
      return J.noSuchMethod$1$($function, new A.JSInvocationMirror(B.Symbol_call, 0, $arguments, namedArgumentList, 0));
    },
    Primitives_applyFunction($function, positionalArguments, namedArguments) {
      var t1, argumentCount, jsStub;
      if (Array.isArray(positionalArguments))
        t1 = namedArguments == null || namedArguments.__js_helper$_length === 0;
      else
        t1 = false;
      if (t1) {
        argumentCount = positionalArguments.length;
        if (argumentCount === 0) {
          if (!!$function.call$0)
            return $function.call$0();
        } else if (argumentCount === 1) {
          if (!!$function.call$1)
            return $function.call$1(positionalArguments[0]);
        } else if (argumentCount === 2) {
          if (!!$function.call$2)
            return $function.call$2(positionalArguments[0], positionalArguments[1]);
        } else if (argumentCount === 3) {
          if (!!$function.call$3)
            return $function.call$3(positionalArguments[0], positionalArguments[1], positionalArguments[2]);
        } else if (argumentCount === 4) {
          if (!!$function.call$4)
            return $function.call$4(positionalArguments[0], positionalArguments[1], positionalArguments[2], positionalArguments[3]);
        } else if (argumentCount === 5)
          if (!!$function.call$5)
            return $function.call$5(positionalArguments[0], positionalArguments[1], positionalArguments[2], positionalArguments[3], positionalArguments[4]);
        jsStub = $function["call" + "$" + argumentCount];
        if (jsStub != null)
          return jsStub.apply($function, positionalArguments);
      }
      return A.Primitives__generalApplyFunction($function, positionalArguments, namedArguments);
    },
    Primitives__generalApplyFunction($function, positionalArguments, namedArguments) {
      var defaultValuesClosure, t1, defaultValues, interceptor, jsFunction, maxArguments, missingDefaults, keys, _i, defaultValue, used, key,
        $arguments = Array.isArray(positionalArguments) ? positionalArguments : A.List_List$of(positionalArguments, true, type$.dynamic),
        argumentCount = $arguments.length,
        requiredParameterCount = $function.$requiredArgCount;
      if (argumentCount < requiredParameterCount)
        return A.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
      defaultValuesClosure = $function.$defaultValues;
      t1 = defaultValuesClosure == null;
      defaultValues = !t1 ? defaultValuesClosure() : null;
      interceptor = J.getInterceptor$($function);
      jsFunction = interceptor["call*"];
      if (typeof jsFunction == "string")
        jsFunction = interceptor[jsFunction];
      if (t1) {
        if (namedArguments != null && namedArguments.__js_helper$_length !== 0)
          return A.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        if (argumentCount === requiredParameterCount)
          return jsFunction.apply($function, $arguments);
        return A.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
      }
      if (Array.isArray(defaultValues)) {
        if (namedArguments != null && namedArguments.__js_helper$_length !== 0)
          return A.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        maxArguments = requiredParameterCount + defaultValues.length;
        if (argumentCount > maxArguments)
          return A.Primitives_functionNoSuchMethod($function, $arguments, null);
        if (argumentCount < maxArguments) {
          missingDefaults = defaultValues.slice(argumentCount - requiredParameterCount);
          if ($arguments === positionalArguments)
            $arguments = A.List_List$of($arguments, true, type$.dynamic);
          B.JSArray_methods.addAll$1($arguments, missingDefaults);
        }
        return jsFunction.apply($function, $arguments);
      } else {
        if (argumentCount > requiredParameterCount)
          return A.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        if ($arguments === positionalArguments)
          $arguments = A.List_List$of($arguments, true, type$.dynamic);
        keys = Object.keys(defaultValues);
        if (namedArguments == null)
          for (t1 = keys.length, _i = 0; _i < keys.length; keys.length === t1 || (0, A.throwConcurrentModificationError)(keys), ++_i) {
            defaultValue = defaultValues[A._asString(keys[_i])];
            if (B.C__Required === defaultValue)
              return A.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
            B.JSArray_methods.add$1($arguments, defaultValue);
          }
        else {
          for (t1 = keys.length, used = 0, _i = 0; _i < keys.length; keys.length === t1 || (0, A.throwConcurrentModificationError)(keys), ++_i) {
            key = A._asString(keys[_i]);
            if (namedArguments.containsKey$1(key)) {
              ++used;
              B.JSArray_methods.add$1($arguments, namedArguments.$index(0, key));
            } else {
              defaultValue = defaultValues[key];
              if (B.C__Required === defaultValue)
                return A.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
              B.JSArray_methods.add$1($arguments, defaultValue);
            }
          }
          if (used !== namedArguments.__js_helper$_length)
            return A.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        }
        return jsFunction.apply($function, $arguments);
      }
    },
    Primitives_extractStackTrace(error) {
      var jsError = error.$thrownJsError;
      if (jsError == null)
        return null;
      return A.getTraceFromException(jsError);
    },
    iae(argument) {
      throw A.wrapException(A.argumentErrorValue(argument));
    },
    ioore(receiver, index) {
      if (receiver == null)
        J.get$length$asx(receiver);
      throw A.wrapException(A.diagnoseIndexError(receiver, index));
    },
    diagnoseIndexError(indexable, index) {
      var $length, _s5_ = "index";
      if (!A._isInt(index))
        return new A.ArgumentError(true, index, _s5_, null);
      $length = A._asInt(J.get$length$asx(indexable));
      if (index < 0 || index >= $length)
        return A.IndexError$withLength(index, $length, indexable, null, _s5_);
      return A.RangeError$value(index, _s5_);
    },
    diagnoseRangeError(start, end, $length) {
      if (start < 0 || start > $length)
        return A.RangeError$range(start, 0, $length, "start", null);
      if (end != null)
        if (end < start || end > $length)
          return A.RangeError$range(end, start, $length, "end", null);
      return new A.ArgumentError(true, end, "end", null);
    },
    argumentErrorValue(object) {
      return new A.ArgumentError(true, object, null, null);
    },
    wrapException(ex) {
      return A.initializeExceptionWrapper(new Error(), ex);
    },
    initializeExceptionWrapper(wrapper, ex) {
      var t1;
      if (ex == null)
        ex = new A.TypeError();
      wrapper.dartException = ex;
      t1 = A.toStringWrapper;
      if ("defineProperty" in Object) {
        Object.defineProperty(wrapper, "message", {get: t1});
        wrapper.name = "";
      } else
        wrapper.toString = t1;
      return wrapper;
    },
    toStringWrapper() {
      return J.toString$0$(this.dartException);
    },
    throwExpression(ex) {
      throw A.wrapException(ex);
    },
    throwExpressionWithWrapper(ex, wrapper) {
      throw A.initializeExceptionWrapper(wrapper, ex);
    },
    throwConcurrentModificationError(collection) {
      throw A.wrapException(A.ConcurrentModificationError$(collection));
    },
    TypeErrorDecoder_extractPattern(message) {
      var match, $arguments, argumentsExpr, expr, method, receiver;
      message = A.quoteStringForRegExp(message.replace(String({}), "$receiver$"));
      match = message.match(/\\\$[a-zA-Z]+\\\$/g);
      if (match == null)
        match = A._setArrayType([], type$.JSArray_String);
      $arguments = match.indexOf("\\$arguments\\$");
      argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
      expr = match.indexOf("\\$expr\\$");
      method = match.indexOf("\\$method\\$");
      receiver = match.indexOf("\\$receiver\\$");
      return new A.TypeErrorDecoder(message.replace(new RegExp("\\\\\\$arguments\\\\\\$", "g"), "((?:x|[^x])*)").replace(new RegExp("\\\\\\$argumentsExpr\\\\\\$", "g"), "((?:x|[^x])*)").replace(new RegExp("\\\\\\$expr\\\\\\$", "g"), "((?:x|[^x])*)").replace(new RegExp("\\\\\\$method\\\\\\$", "g"), "((?:x|[^x])*)").replace(new RegExp("\\\\\\$receiver\\\\\\$", "g"), "((?:x|[^x])*)"), $arguments, argumentsExpr, expr, method, receiver);
    },
    TypeErrorDecoder_provokeCallErrorOn(expression) {
      return function($expr$) {
        var $argumentsExpr$ = "$arguments$";
        try {
          $expr$.$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    TypeErrorDecoder_provokePropertyErrorOn(expression) {
      return function($expr$) {
        try {
          $expr$.$method$;
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    JsNoSuchMethodError$(_message, match) {
      var t1 = match == null,
        t2 = t1 ? null : match.method;
      return new A.JsNoSuchMethodError(_message, t2, t1 ? null : match.receiver);
    },
    unwrapException(ex) {
      var t1;
      if (ex == null)
        return new A.NullThrownFromJavaScriptException(ex);
      if (ex instanceof A.ExceptionAndStackTrace) {
        t1 = ex.dartException;
        return A.saveStackTrace(ex, t1 == null ? type$.Object._as(t1) : t1);
      }
      if (typeof ex !== "object")
        return ex;
      if ("dartException" in ex)
        return A.saveStackTrace(ex, ex.dartException);
      return A._unwrapNonDartException(ex);
    },
    saveStackTrace(ex, error) {
      if (type$.Error._is(error))
        if (error.$thrownJsError == null)
          error.$thrownJsError = ex;
      return error;
    },
    _unwrapNonDartException(ex) {
      var message, number, ieErrorCode, nsme, notClosure, nullCall, nullLiteralCall, undefCall, undefLiteralCall, nullProperty, undefProperty, undefLiteralProperty, match;
      if (!("message" in ex))
        return ex;
      message = ex.message;
      if ("number" in ex && typeof ex.number == "number") {
        number = ex.number;
        ieErrorCode = number & 65535;
        if ((B.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
          switch (ieErrorCode) {
            case 438:
              return A.saveStackTrace(ex, A.JsNoSuchMethodError$(A.S(message) + " (Error " + ieErrorCode + ")", null));
            case 445:
            case 5007:
              A.S(message);
              return A.saveStackTrace(ex, new A.NullError());
          }
      }
      if (ex instanceof TypeError) {
        nsme = $.$get$TypeErrorDecoder_noSuchMethodPattern();
        notClosure = $.$get$TypeErrorDecoder_notClosurePattern();
        nullCall = $.$get$TypeErrorDecoder_nullCallPattern();
        nullLiteralCall = $.$get$TypeErrorDecoder_nullLiteralCallPattern();
        undefCall = $.$get$TypeErrorDecoder_undefinedCallPattern();
        undefLiteralCall = $.$get$TypeErrorDecoder_undefinedLiteralCallPattern();
        nullProperty = $.$get$TypeErrorDecoder_nullPropertyPattern();
        $.$get$TypeErrorDecoder_nullLiteralPropertyPattern();
        undefProperty = $.$get$TypeErrorDecoder_undefinedPropertyPattern();
        undefLiteralProperty = $.$get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
        match = nsme.matchTypeError$1(message);
        if (match != null)
          return A.saveStackTrace(ex, A.JsNoSuchMethodError$(A._asString(message), match));
        else {
          match = notClosure.matchTypeError$1(message);
          if (match != null) {
            match.method = "call";
            return A.saveStackTrace(ex, A.JsNoSuchMethodError$(A._asString(message), match));
          } else if (nullCall.matchTypeError$1(message) != null || nullLiteralCall.matchTypeError$1(message) != null || undefCall.matchTypeError$1(message) != null || undefLiteralCall.matchTypeError$1(message) != null || nullProperty.matchTypeError$1(message) != null || nullLiteralCall.matchTypeError$1(message) != null || undefProperty.matchTypeError$1(message) != null || undefLiteralProperty.matchTypeError$1(message) != null) {
            A._asString(message);
            return A.saveStackTrace(ex, new A.NullError());
          }
        }
        return A.saveStackTrace(ex, new A.UnknownJsTypeError(typeof message == "string" ? message : ""));
      }
      if (ex instanceof RangeError) {
        if (typeof message == "string" && message.indexOf("call stack") !== -1)
          return new A.StackOverflowError();
        message = function(ex) {
          try {
            return String(ex);
          } catch (e) {
          }
          return null;
        }(ex);
        return A.saveStackTrace(ex, new A.ArgumentError(false, null, null, typeof message == "string" ? message.replace(/^RangeError:\s*/, "") : message));
      }
      if (typeof InternalError == "function" && ex instanceof InternalError)
        if (typeof message == "string" && message === "too much recursion")
          return new A.StackOverflowError();
      return ex;
    },
    getTraceFromException(exception) {
      var trace;
      if (exception instanceof A.ExceptionAndStackTrace)
        return exception.stackTrace;
      if (exception == null)
        return new A._StackTrace(exception);
      trace = exception.$cachedTrace;
      if (trace != null)
        return trace;
      trace = new A._StackTrace(exception);
      if (typeof exception === "object")
        exception.$cachedTrace = trace;
      return trace;
    },
    objectHashCode(object) {
      if (object == null)
        return J.get$hashCode$(object);
      if (typeof object == "object")
        return A.Primitives_objectHashCode(object);
      return J.get$hashCode$(object);
    },
    constantHashCode(key) {
      if (typeof key == "number")
        return B.JSNumber_methods.get$hashCode(key);
      if (key instanceof A._Type)
        return A.Primitives_objectHashCode(key);
      if (key instanceof A.Symbol)
        return key.get$hashCode(0);
      return A.objectHashCode(key);
    },
    fillLiteralMap(keyValuePairs, result) {
      var index, index0, index1,
        $length = keyValuePairs.length;
      for (index = 0; index < $length; index = index1) {
        index0 = index + 1;
        index1 = index0 + 1;
        result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
      }
      return result;
    },
    _invokeClosure(closure, numberOfArguments, arg1, arg2, arg3, arg4) {
      type$.Function._as(closure);
      switch (A._asInt(numberOfArguments)) {
        case 0:
          return closure.call$0();
        case 1:
          return closure.call$1(arg1);
        case 2:
          return closure.call$2(arg1, arg2);
        case 3:
          return closure.call$3(arg1, arg2, arg3);
        case 4:
          return closure.call$4(arg1, arg2, arg3, arg4);
      }
      throw A.wrapException(A.Exception_Exception("Unsupported number of arguments for wrapped closure"));
    },
    convertDartClosureToJS(closure, arity) {
      var $function = closure.$identity;
      if (!!$function)
        return $function;
      $function = A.convertDartClosureToJSUncached(closure, arity);
      closure.$identity = $function;
      return $function;
    },
    convertDartClosureToJSUncached(closure, arity) {
      var entry;
      switch (arity) {
        case 0:
          entry = closure.call$0;
          break;
        case 1:
          entry = closure.call$1;
          break;
        case 2:
          entry = closure.call$2;
          break;
        case 3:
          entry = closure.call$3;
          break;
        case 4:
          entry = closure.call$4;
          break;
        default:
          entry = null;
      }
      if (entry != null)
        return entry.bind(closure);
      return function(closure, arity, invoke) {
        return function(a1, a2, a3, a4) {
          return invoke(closure, arity, a1, a2, a3, a4);
        };
      }(closure, arity, A._invokeClosure);
    },
    Closure_fromTearOff(parameters) {
      var $prototype, $constructor, t2, trampoline, applyTrampoline, i, stub, stub0, stubName, stubCallName,
        container = parameters.co,
        isStatic = parameters.iS,
        isIntercepted = parameters.iI,
        needsDirectAccess = parameters.nDA,
        applyTrampolineIndex = parameters.aI,
        funsOrNames = parameters.fs,
        callNames = parameters.cs,
        $name = funsOrNames[0],
        callName = callNames[0],
        $function = container[$name],
        t1 = parameters.fT;
      t1.toString;
      $prototype = isStatic ? Object.create(new A.StaticClosure().constructor.prototype) : Object.create(new A.BoundClosure(null, null).constructor.prototype);
      $prototype.$initialize = $prototype.constructor;
      $constructor = isStatic ? function static_tear_off() {
        this.$initialize();
      } : function tear_off(a, b) {
        this.$initialize(a, b);
      };
      $prototype.constructor = $constructor;
      $constructor.prototype = $prototype;
      $prototype.$_name = $name;
      $prototype.$_target = $function;
      t2 = !isStatic;
      if (t2)
        trampoline = A.Closure_forwardCallTo($name, $function, isIntercepted, needsDirectAccess);
      else {
        $prototype.$static_name = $name;
        trampoline = $function;
      }
      $prototype.$signature = A.Closure__computeSignatureFunctionNewRti(t1, isStatic, isIntercepted);
      $prototype[callName] = trampoline;
      for (applyTrampoline = trampoline, i = 1; i < funsOrNames.length; ++i) {
        stub = funsOrNames[i];
        if (typeof stub == "string") {
          stub0 = container[stub];
          stubName = stub;
          stub = stub0;
        } else
          stubName = "";
        stubCallName = callNames[i];
        if (stubCallName != null) {
          if (t2)
            stub = A.Closure_forwardCallTo(stubName, stub, isIntercepted, needsDirectAccess);
          $prototype[stubCallName] = stub;
        }
        if (i === applyTrampolineIndex)
          applyTrampoline = stub;
      }
      $prototype["call*"] = applyTrampoline;
      $prototype.$requiredArgCount = parameters.rC;
      $prototype.$defaultValues = parameters.dV;
      return $constructor;
    },
    Closure__computeSignatureFunctionNewRti(functionType, isStatic, isIntercepted) {
      if (typeof functionType == "number")
        return functionType;
      if (typeof functionType == "string") {
        if (isStatic)
          throw A.wrapException("Cannot compute signature for static tearoff.");
        return function(recipe, evalOnReceiver) {
          return function() {
            return evalOnReceiver(this, recipe);
          };
        }(functionType, A.BoundClosure_evalRecipe);
      }
      throw A.wrapException("Error in functionType of tearoff");
    },
    Closure_cspForwardCall(arity, needsDirectAccess, stubName, $function) {
      var getReceiver = A.BoundClosure_receiverOf;
      switch (needsDirectAccess ? -1 : arity) {
        case 0:
          return function(entry, receiverOf) {
            return function() {
              return receiverOf(this)[entry]();
            };
          }(stubName, getReceiver);
        case 1:
          return function(entry, receiverOf) {
            return function(a) {
              return receiverOf(this)[entry](a);
            };
          }(stubName, getReceiver);
        case 2:
          return function(entry, receiverOf) {
            return function(a, b) {
              return receiverOf(this)[entry](a, b);
            };
          }(stubName, getReceiver);
        case 3:
          return function(entry, receiverOf) {
            return function(a, b, c) {
              return receiverOf(this)[entry](a, b, c);
            };
          }(stubName, getReceiver);
        case 4:
          return function(entry, receiverOf) {
            return function(a, b, c, d) {
              return receiverOf(this)[entry](a, b, c, d);
            };
          }(stubName, getReceiver);
        case 5:
          return function(entry, receiverOf) {
            return function(a, b, c, d, e) {
              return receiverOf(this)[entry](a, b, c, d, e);
            };
          }(stubName, getReceiver);
        default:
          return function(f, receiverOf) {
            return function() {
              return f.apply(receiverOf(this), arguments);
            };
          }($function, getReceiver);
      }
    },
    Closure_forwardCallTo(stubName, $function, isIntercepted, needsDirectAccess) {
      if (isIntercepted)
        return A.Closure_forwardInterceptedCallTo(stubName, $function, needsDirectAccess);
      return A.Closure_cspForwardCall($function.length, needsDirectAccess, stubName, $function);
    },
    Closure_cspForwardInterceptedCall(arity, needsDirectAccess, stubName, $function) {
      var getReceiver = A.BoundClosure_receiverOf,
        getInterceptor = A.BoundClosure_interceptorOf;
      switch (needsDirectAccess ? -1 : arity) {
        case 0:
          throw A.wrapException(new A.RuntimeError("Intercepted function with no arguments."));
        case 1:
          return function(entry, interceptorOf, receiverOf) {
            return function() {
              return interceptorOf(this)[entry](receiverOf(this));
            };
          }(stubName, getInterceptor, getReceiver);
        case 2:
          return function(entry, interceptorOf, receiverOf) {
            return function(a) {
              return interceptorOf(this)[entry](receiverOf(this), a);
            };
          }(stubName, getInterceptor, getReceiver);
        case 3:
          return function(entry, interceptorOf, receiverOf) {
            return function(a, b) {
              return interceptorOf(this)[entry](receiverOf(this), a, b);
            };
          }(stubName, getInterceptor, getReceiver);
        case 4:
          return function(entry, interceptorOf, receiverOf) {
            return function(a, b, c) {
              return interceptorOf(this)[entry](receiverOf(this), a, b, c);
            };
          }(stubName, getInterceptor, getReceiver);
        case 5:
          return function(entry, interceptorOf, receiverOf) {
            return function(a, b, c, d) {
              return interceptorOf(this)[entry](receiverOf(this), a, b, c, d);
            };
          }(stubName, getInterceptor, getReceiver);
        case 6:
          return function(entry, interceptorOf, receiverOf) {
            return function(a, b, c, d, e) {
              return interceptorOf(this)[entry](receiverOf(this), a, b, c, d, e);
            };
          }(stubName, getInterceptor, getReceiver);
        default:
          return function(f, interceptorOf, receiverOf) {
            return function() {
              var a = [receiverOf(this)];
              Array.prototype.push.apply(a, arguments);
              return f.apply(interceptorOf(this), a);
            };
          }($function, getInterceptor, getReceiver);
      }
    },
    Closure_forwardInterceptedCallTo(stubName, $function, needsDirectAccess) {
      var arity, t1;
      if ($.BoundClosure__interceptorFieldNameCache == null)
        $.BoundClosure__interceptorFieldNameCache = A.BoundClosure__computeFieldNamed("interceptor");
      if ($.BoundClosure__receiverFieldNameCache == null)
        $.BoundClosure__receiverFieldNameCache = A.BoundClosure__computeFieldNamed("receiver");
      arity = $function.length;
      t1 = A.Closure_cspForwardInterceptedCall(arity, needsDirectAccess, stubName, $function);
      return t1;
    },
    closureFromTearOff(parameters) {
      return A.Closure_fromTearOff(parameters);
    },
    BoundClosure_evalRecipe(closure, recipe) {
      return A._Universe_evalInEnvironment(init.typeUniverse, A.instanceType(closure._receiver), recipe);
    },
    BoundClosure_receiverOf(closure) {
      return closure._receiver;
    },
    BoundClosure_interceptorOf(closure) {
      return closure._interceptor;
    },
    BoundClosure__computeFieldNamed(fieldName) {
      var t1, i, $name,
        template = new A.BoundClosure("receiver", "interceptor"),
        names = J.JSArray_markFixedList(Object.getOwnPropertyNames(template), type$.nullable_Object);
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (template[$name] === fieldName)
          return $name;
      }
      throw A.wrapException(A.ArgumentError$("Field name " + fieldName + " not found.", null));
    },
    boolConversionCheck(value) {
      if (value == null)
        A.assertThrow("boolean expression must not be null");
      return value;
    },
    assertThrow(message) {
      throw A.wrapException(new A._AssertionError(message));
    },
    throwCyclicInit(staticName) {
      throw A.wrapException(new A._CyclicInitializationError(staticName));
    },
    getIsolateAffinityTag($name) {
      return init.getIsolateTag($name);
    },
    convertMainArgumentList(args) {
      var i,
        result = A._setArrayType([], type$.JSArray_String);
      if (args == null)
        return result;
      if (Array.isArray(args)) {
        for (i = 0; i < args.length; ++i)
          result.push(String(args[i]));
        return result;
      }
      result.push(String(args));
      return result;
    },
    defineProperty(obj, property, value) {
      Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
    },
    lookupAndCacheInterceptor(obj) {
      var interceptor, interceptorClass, altTag, mark, t1,
        tag = A._asString($.getTagFunction.call$1(obj)),
        record = $.dispatchRecordsForInstanceTags[tag];
      if (record != null) {
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      interceptor = $.interceptorsForUncacheableTags[tag];
      if (interceptor != null)
        return interceptor;
      interceptorClass = init.interceptorsByTag[tag];
      if (interceptorClass == null) {
        altTag = A._asStringQ($.alternateTagFunction.call$2(obj, tag));
        if (altTag != null) {
          record = $.dispatchRecordsForInstanceTags[altTag];
          if (record != null) {
            Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            return record.i;
          }
          interceptor = $.interceptorsForUncacheableTags[altTag];
          if (interceptor != null)
            return interceptor;
          interceptorClass = init.interceptorsByTag[altTag];
          tag = altTag;
        }
      }
      if (interceptorClass == null)
        return null;
      interceptor = interceptorClass.prototype;
      mark = tag[0];
      if (mark === "!") {
        record = A.makeLeafDispatchRecord(interceptor);
        $.dispatchRecordsForInstanceTags[tag] = record;
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      if (mark === "~") {
        $.interceptorsForUncacheableTags[tag] = interceptor;
        return interceptor;
      }
      if (mark === "-") {
        t1 = A.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      }
      if (mark === "+")
        return A.patchInteriorProto(obj, interceptor);
      if (mark === "*")
        throw A.wrapException(A.UnimplementedError$(tag));
      if (init.leafTags[tag] === true) {
        t1 = A.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      } else
        return A.patchInteriorProto(obj, interceptor);
    },
    patchInteriorProto(obj, interceptor) {
      var proto = Object.getPrototypeOf(obj);
      Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
      return interceptor;
    },
    makeLeafDispatchRecord(interceptor) {
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    },
    makeDefaultDispatchRecord(tag, interceptorClass, proto) {
      var interceptor = interceptorClass.prototype;
      if (init.leafTags[tag] === true)
        return A.makeLeafDispatchRecord(interceptor);
      else
        return J.makeDispatchRecord(interceptor, proto, null, null);
    },
    initNativeDispatch() {
      if (true === $.initNativeDispatchFlag)
        return;
      $.initNativeDispatchFlag = true;
      A.initNativeDispatchContinue();
    },
    initNativeDispatchContinue() {
      var map, tags, fun, i, tag, proto, record, interceptorClass;
      $.dispatchRecordsForInstanceTags = Object.create(null);
      $.interceptorsForUncacheableTags = Object.create(null);
      A.initHooks();
      map = init.interceptorsByTag;
      tags = Object.getOwnPropertyNames(map);
      if (typeof window != "undefined") {
        window;
        fun = function() {
        };
        for (i = 0; i < tags.length; ++i) {
          tag = tags[i];
          proto = $.prototypeForTagFunction.call$1(tag);
          if (proto != null) {
            record = A.makeDefaultDispatchRecord(tag, map[tag], proto);
            if (record != null) {
              Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
              fun.prototype = proto;
            }
          }
        }
      }
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        if (/^[A-Za-z_]/.test(tag)) {
          interceptorClass = map[tag];
          map["!" + tag] = interceptorClass;
          map["~" + tag] = interceptorClass;
          map["-" + tag] = interceptorClass;
          map["+" + tag] = interceptorClass;
          map["*" + tag] = interceptorClass;
        }
      }
    },
    initHooks() {
      var transformers, i, transformer, getTag, getUnknownTag, prototypeForTag,
        hooks = B.C_JS_CONST0();
      hooks = A.applyHooksTransformer(B.C_JS_CONST1, A.applyHooksTransformer(B.C_JS_CONST2, A.applyHooksTransformer(B.C_JS_CONST3, A.applyHooksTransformer(B.C_JS_CONST3, A.applyHooksTransformer(B.C_JS_CONST4, A.applyHooksTransformer(B.C_JS_CONST5, A.applyHooksTransformer(B.C_JS_CONST6(B.C_JS_CONST), hooks)))))));
      if (typeof dartNativeDispatchHooksTransformer != "undefined") {
        transformers = dartNativeDispatchHooksTransformer;
        if (typeof transformers == "function")
          transformers = [transformers];
        if (Array.isArray(transformers))
          for (i = 0; i < transformers.length; ++i) {
            transformer = transformers[i];
            if (typeof transformer == "function")
              hooks = transformer(hooks) || hooks;
          }
      }
      getTag = hooks.getTag;
      getUnknownTag = hooks.getUnknownTag;
      prototypeForTag = hooks.prototypeForTag;
      $.getTagFunction = new A.initHooks_closure(getTag);
      $.alternateTagFunction = new A.initHooks_closure0(getUnknownTag);
      $.prototypeForTagFunction = new A.initHooks_closure1(prototypeForTag);
    },
    applyHooksTransformer(transformer, hooks) {
      return transformer(hooks) || hooks;
    },
    createRecordTypePredicate(shape, fieldRtis) {
      var $length = fieldRtis.length,
        $function = init.rttc["" + $length + ";" + shape];
      if ($function == null)
        return null;
      if ($length === 0)
        return $function;
      if ($length === $function.length)
        return $function.apply(null, fieldRtis);
      return $function(fieldRtis);
    },
    JSSyntaxRegExp_makeNative(source, multiLine, caseSensitive, unicode, dotAll, global) {
      var m = multiLine ? "m" : "",
        i = caseSensitive ? "" : "i",
        u = unicode ? "u" : "",
        s = dotAll ? "s" : "",
        g = global ? "g" : "",
        regexp = function(source, modifiers) {
          try {
            return new RegExp(source, modifiers);
          } catch (e) {
            return e;
          }
        }(source, m + i + u + s + g);
      if (regexp instanceof RegExp)
        return regexp;
      throw A.wrapException(A.FormatException$("Illegal RegExp pattern (" + String(regexp) + ")", source, null));
    },
    stringContainsUnchecked(receiver, other, startIndex) {
      var t1;
      if (typeof other == "string")
        return receiver.indexOf(other, startIndex) >= 0;
      else if (other instanceof A.JSSyntaxRegExp) {
        t1 = B.JSString_methods.substring$1(receiver, startIndex);
        return other._nativeRegExp.test(t1);
      } else
        return !J.allMatches$1$s(other, B.JSString_methods.substring$1(receiver, startIndex)).get$isEmpty(0);
    },
    escapeReplacement(replacement) {
      if (replacement.indexOf("$", 0) >= 0)
        return replacement.replace(/\$/g, "$$$$");
      return replacement;
    },
    quoteStringForRegExp(string) {
      if (/[[\]{}()*+?.\\^$|]/.test(string))
        return string.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
      return string;
    },
    stringReplaceAllUnchecked(receiver, pattern, replacement) {
      var nativeRegexp;
      if (typeof pattern == "string")
        return A.stringReplaceAllUncheckedString(receiver, pattern, replacement);
      if (pattern instanceof A.JSSyntaxRegExp) {
        nativeRegexp = pattern.get$_nativeGlobalVersion();
        nativeRegexp.lastIndex = 0;
        return receiver.replace(nativeRegexp, A.escapeReplacement(replacement));
      }
      return A.stringReplaceAllGeneral(receiver, pattern, replacement);
    },
    stringReplaceAllGeneral(receiver, pattern, replacement) {
      var t1, startIndex, t2, match;
      for (t1 = J.allMatches$1$s(pattern, receiver), t1 = t1.get$iterator(t1), startIndex = 0, t2 = ""; t1.moveNext$0();) {
        match = t1.get$current();
        t2 = t2 + receiver.substring(startIndex, match.get$start()) + replacement;
        startIndex = match.get$end();
      }
      t1 = t2 + receiver.substring(startIndex);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    stringReplaceAllUncheckedString(receiver, pattern, replacement) {
      var $length, t1, i;
      if (pattern === "") {
        if (receiver === "")
          return replacement;
        $length = receiver.length;
        t1 = "" + replacement;
        for (i = 0; i < $length; ++i)
          t1 = t1 + receiver[i] + replacement;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      if (receiver.indexOf(pattern, 0) < 0)
        return receiver;
      if (receiver.length < 500 || replacement.indexOf("$", 0) >= 0)
        return receiver.split(pattern).join(replacement);
      return receiver.replace(new RegExp(A.quoteStringForRegExp(pattern), "g"), A.escapeReplacement(replacement));
    },
    _stringIdentity(string) {
      return string;
    },
    stringReplaceAllFuncUnchecked(receiver, pattern, onMatch, onNonMatch) {
      var t1, t2, startIndex, t3, match, t4, t5;
      for (t1 = pattern.allMatches$1(0, receiver), t1 = new A._AllMatchesIterator(t1._re, t1._string, t1.__js_helper$_start), t2 = type$.RegExpMatch, startIndex = 0, t3 = ""; t1.moveNext$0();) {
        match = t1.__js_helper$_current;
        if (match == null)
          match = t2._as(match);
        t4 = match._match;
        t5 = t4.index;
        t3 = t3 + A.S(A._stringIdentity(B.JSString_methods.substring$2(receiver, startIndex, t5))) + A.S(onMatch.call$1(match));
        startIndex = t5 + t4[0].length;
      }
      t1 = t3 + A.S(A._stringIdentity(B.JSString_methods.substring$1(receiver, startIndex)));
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    stringReplaceFirstUnchecked(receiver, pattern, replacement, startIndex) {
      var index = receiver.indexOf(pattern, startIndex);
      if (index < 0)
        return receiver;
      return A.stringReplaceRangeUnchecked(receiver, index, index + pattern.length, replacement);
    },
    stringReplaceRangeUnchecked(receiver, start, end, replacement) {
      return receiver.substring(0, start) + replacement + receiver.substring(end);
    },
    ConstantMapView: function ConstantMapView(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    ConstantMap: function ConstantMap() {
    },
    ConstantStringMap: function ConstantStringMap(t0, t1, t2) {
      this._jsIndex = t0;
      this._values = t1;
      this.$ti = t2;
    },
    _KeysOrValues: function _KeysOrValues(t0, t1) {
      this._elements = t0;
      this.$ti = t1;
    },
    _KeysOrValuesOrElementsIterator: function _KeysOrValuesOrElementsIterator(t0, t1, t2) {
      var _ = this;
      _._elements = t0;
      _.__js_helper$_length = t1;
      _.__js_helper$_index = 0;
      _.__js_helper$_current = null;
      _.$ti = t2;
    },
    GeneralConstantMap: function GeneralConstantMap(t0, t1) {
      this._jsData = t0;
      this.$ti = t1;
    },
    Instantiation: function Instantiation() {
    },
    Instantiation1: function Instantiation1(t0, t1) {
      this._genericClosure = t0;
      this.$ti = t1;
    },
    JSInvocationMirror: function JSInvocationMirror(t0, t1, t2, t3, t4) {
      var _ = this;
      _._memberName = t0;
      _.__js_helper$_kind = t1;
      _._arguments = t2;
      _._namedArgumentNames = t3;
      _._typeArgumentCount = t4;
    },
    Primitives_functionNoSuchMethod_closure: function Primitives_functionNoSuchMethod_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.namedArgumentList = t1;
      this.$arguments = t2;
    },
    TypeErrorDecoder: function TypeErrorDecoder(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._pattern = t0;
      _._arguments = t1;
      _._argumentsExpr = t2;
      _._expr = t3;
      _._method = t4;
      _._receiver = t5;
    },
    NullError: function NullError() {
    },
    JsNoSuchMethodError: function JsNoSuchMethodError(t0, t1, t2) {
      this.__js_helper$_message = t0;
      this._method = t1;
      this._receiver = t2;
    },
    UnknownJsTypeError: function UnknownJsTypeError(t0) {
      this.__js_helper$_message = t0;
    },
    NullThrownFromJavaScriptException: function NullThrownFromJavaScriptException(t0) {
      this._irritant = t0;
    },
    ExceptionAndStackTrace: function ExceptionAndStackTrace(t0, t1) {
      this.dartException = t0;
      this.stackTrace = t1;
    },
    _StackTrace: function _StackTrace(t0) {
      this._exception = t0;
      this._trace = null;
    },
    Closure: function Closure() {
    },
    Closure0Args: function Closure0Args() {
    },
    Closure2Args: function Closure2Args() {
    },
    TearOffClosure: function TearOffClosure() {
    },
    StaticClosure: function StaticClosure() {
    },
    BoundClosure: function BoundClosure(t0, t1) {
      this._receiver = t0;
      this._interceptor = t1;
    },
    _CyclicInitializationError: function _CyclicInitializationError(t0) {
      this.variableName = t0;
    },
    RuntimeError: function RuntimeError(t0) {
      this.message = t0;
    },
    _AssertionError: function _AssertionError(t0) {
      this.message = t0;
    },
    _Required: function _Required() {
    },
    JsLinkedHashMap: function JsLinkedHashMap(t0) {
      var _ = this;
      _.__js_helper$_length = 0;
      _._last = _._first = _.__js_helper$_rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    JsLinkedHashMap_values_closure: function JsLinkedHashMap_values_closure(t0) {
      this.$this = t0;
    },
    JsLinkedHashMap_addAll_closure: function JsLinkedHashMap_addAll_closure(t0) {
      this.$this = t0;
    },
    LinkedHashMapCell: function LinkedHashMapCell(t0, t1) {
      var _ = this;
      _.hashMapCellKey = t0;
      _.hashMapCellValue = t1;
      _._previous = _._next = null;
    },
    LinkedHashMapKeyIterable: function LinkedHashMapKeyIterable(t0, t1) {
      this._map = t0;
      this.$ti = t1;
    },
    LinkedHashMapKeyIterator: function LinkedHashMapKeyIterator(t0, t1, t2) {
      var _ = this;
      _._map = t0;
      _._modifications = t1;
      _.__js_helper$_current = _._cell = null;
      _.$ti = t2;
    },
    JsIdentityLinkedHashMap: function JsIdentityLinkedHashMap(t0) {
      var _ = this;
      _.__js_helper$_length = 0;
      _._last = _._first = _.__js_helper$_rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    JsConstantLinkedHashMap: function JsConstantLinkedHashMap(t0) {
      var _ = this;
      _.__js_helper$_length = 0;
      _._last = _._first = _.__js_helper$_rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    initHooks_closure: function initHooks_closure(t0) {
      this.getTag = t0;
    },
    initHooks_closure0: function initHooks_closure0(t0) {
      this.getUnknownTag = t0;
    },
    initHooks_closure1: function initHooks_closure1(t0) {
      this.prototypeForTag = t0;
    },
    JSSyntaxRegExp: function JSSyntaxRegExp(t0, t1) {
      var _ = this;
      _.pattern = t0;
      _._nativeRegExp = t1;
      _._nativeAnchoredRegExp = _._nativeGlobalRegExp = null;
    },
    _MatchImplementation: function _MatchImplementation(t0) {
      this._match = t0;
    },
    _AllMatchesIterable: function _AllMatchesIterable(t0, t1, t2) {
      this._re = t0;
      this._string = t1;
      this.__js_helper$_start = t2;
    },
    _AllMatchesIterator: function _AllMatchesIterator(t0, t1, t2) {
      var _ = this;
      _._regExp = t0;
      _._string = t1;
      _._nextIndex = t2;
      _.__js_helper$_current = null;
    },
    StringMatch: function StringMatch(t0, t1) {
      this.start = t0;
      this.pattern = t1;
    },
    _StringAllMatchesIterable: function _StringAllMatchesIterable(t0, t1, t2) {
      this._input = t0;
      this._pattern = t1;
      this.__js_helper$_index = t2;
    },
    _StringAllMatchesIterator: function _StringAllMatchesIterator(t0, t1, t2) {
      var _ = this;
      _._input = t0;
      _._pattern = t1;
      _.__js_helper$_index = t2;
      _.__js_helper$_current = null;
    },
    throwLateFieldNI(fieldName) {
      A.throwExpressionWithWrapper(new A.LateError("Field '" + fieldName + "' has not been initialized."), new Error());
    },
    throwLateFieldAI(fieldName) {
      A.throwExpressionWithWrapper(new A.LateError("Field '" + fieldName + "' has already been initialized."), new Error());
    },
    throwLateFieldADI(fieldName) {
      A.throwExpressionWithWrapper(new A.LateError("Field '" + fieldName + "' has been assigned during initialization."), new Error());
    },
    _Cell$named(_name) {
      var t1 = new A._Cell(_name);
      return t1._value = t1;
    },
    _Cell: function _Cell(t0) {
      this._name = t0;
      this._value = null;
    },
    _checkViewArguments(buffer, offsetInBytes, $length) {
    },
    _ensureNativeList(list) {
      return list;
    },
    NativeByteData_NativeByteData($length) {
      return new DataView(new ArrayBuffer($length));
    },
    NativeByteData_NativeByteData$view(buffer, offsetInBytes, $length) {
      A._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? new DataView(buffer, offsetInBytes) : new DataView(buffer, offsetInBytes, $length);
    },
    NativeInt8List__create1(arg) {
      return new Int8Array(arg);
    },
    NativeUint16List_NativeUint16List($length) {
      return new Uint16Array($length);
    },
    NativeUint8List_NativeUint8List($length) {
      return new Uint8Array($length);
    },
    NativeUint8List_NativeUint8List$view(buffer, offsetInBytes, $length) {
      A._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? new Uint8Array(buffer, offsetInBytes) : new Uint8Array(buffer, offsetInBytes, $length);
    },
    _checkValidIndex(index, list, $length) {
      if (index >>> 0 !== index || index >= $length)
        throw A.wrapException(A.diagnoseIndexError(list, index));
    },
    _checkValidRange(start, end, $length) {
      var t1;
      if (!(start >>> 0 !== start))
        if (end == null)
          t1 = start > $length;
        else
          t1 = end >>> 0 !== end || start > end || end > $length;
      else
        t1 = true;
      if (t1)
        throw A.wrapException(A.diagnoseRangeError(start, end, $length));
      if (end == null)
        return $length;
      return end;
    },
    NativeByteBuffer: function NativeByteBuffer() {
    },
    NativeTypedData: function NativeTypedData() {
    },
    NativeByteData: function NativeByteData() {
    },
    NativeTypedArray: function NativeTypedArray() {
    },
    NativeTypedArrayOfDouble: function NativeTypedArrayOfDouble() {
    },
    NativeTypedArrayOfInt: function NativeTypedArrayOfInt() {
    },
    NativeFloat32List: function NativeFloat32List() {
    },
    NativeFloat64List: function NativeFloat64List() {
    },
    NativeInt16List: function NativeInt16List() {
    },
    NativeInt32List: function NativeInt32List() {
    },
    NativeInt8List: function NativeInt8List() {
    },
    NativeUint16List: function NativeUint16List() {
    },
    NativeUint32List: function NativeUint32List() {
    },
    NativeUint8ClampedList: function NativeUint8ClampedList() {
    },
    NativeUint8List: function NativeUint8List() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    Rti__getQuestionFromStar(universe, rti) {
      var question = rti._precomputed1;
      return question == null ? rti._precomputed1 = A._Universe__lookupQuestionRti(universe, rti._primary, true) : question;
    },
    Rti__getFutureFromFutureOr(universe, rti) {
      var future = rti._precomputed1;
      return future == null ? rti._precomputed1 = A._Universe__lookupInterfaceRti(universe, "Future", [rti._primary]) : future;
    },
    Rti__isUnionOfFunctionType(rti) {
      var kind = rti._kind;
      if (kind === 6 || kind === 7 || kind === 8)
        return A.Rti__isUnionOfFunctionType(rti._primary);
      return kind === 12 || kind === 13;
    },
    Rti__getCanonicalRecipe(rti) {
      return rti._canonicalRecipe;
    },
    findType(recipe) {
      return A._Universe_eval(init.typeUniverse, recipe, false);
    },
    instantiatedGenericFunctionType(genericFunctionRti, instantiationRti) {
      var t1, cache, key, probe, rti;
      if (genericFunctionRti == null)
        return null;
      t1 = instantiationRti._rest;
      cache = genericFunctionRti._bindCache;
      if (cache == null)
        cache = genericFunctionRti._bindCache = new Map();
      key = instantiationRti._canonicalRecipe;
      probe = cache.get(key);
      if (probe != null)
        return probe;
      rti = A._substitute(init.typeUniverse, genericFunctionRti._primary, t1, 0);
      cache.set(key, rti);
      return rti;
    },
    _substitute(universe, rti, typeArguments, depth) {
      var baseType, substitutedBaseType, interfaceTypeArguments, substitutedInterfaceTypeArguments, base, substitutedBase, $arguments, substitutedArguments, t1, fields, substitutedFields, returnType, substitutedReturnType, functionParameters, substitutedFunctionParameters, bounds, substitutedBounds, index, argument,
        kind = rti._kind;
      switch (kind) {
        case 5:
        case 1:
        case 2:
        case 3:
        case 4:
          return rti;
        case 6:
          baseType = rti._primary;
          substitutedBaseType = A._substitute(universe, baseType, typeArguments, depth);
          if (substitutedBaseType === baseType)
            return rti;
          return A._Universe__lookupStarRti(universe, substitutedBaseType, true);
        case 7:
          baseType = rti._primary;
          substitutedBaseType = A._substitute(universe, baseType, typeArguments, depth);
          if (substitutedBaseType === baseType)
            return rti;
          return A._Universe__lookupQuestionRti(universe, substitutedBaseType, true);
        case 8:
          baseType = rti._primary;
          substitutedBaseType = A._substitute(universe, baseType, typeArguments, depth);
          if (substitutedBaseType === baseType)
            return rti;
          return A._Universe__lookupFutureOrRti(universe, substitutedBaseType, true);
        case 9:
          interfaceTypeArguments = rti._rest;
          substitutedInterfaceTypeArguments = A._substituteArray(universe, interfaceTypeArguments, typeArguments, depth);
          if (substitutedInterfaceTypeArguments === interfaceTypeArguments)
            return rti;
          return A._Universe__lookupInterfaceRti(universe, rti._primary, substitutedInterfaceTypeArguments);
        case 10:
          base = rti._primary;
          substitutedBase = A._substitute(universe, base, typeArguments, depth);
          $arguments = rti._rest;
          substitutedArguments = A._substituteArray(universe, $arguments, typeArguments, depth);
          if (substitutedBase === base && substitutedArguments === $arguments)
            return rti;
          return A._Universe__lookupBindingRti(universe, substitutedBase, substitutedArguments);
        case 11:
          t1 = rti._primary;
          fields = rti._rest;
          substitutedFields = A._substituteArray(universe, fields, typeArguments, depth);
          if (substitutedFields === fields)
            return rti;
          return A._Universe__lookupRecordRti(universe, t1, substitutedFields);
        case 12:
          returnType = rti._primary;
          substitutedReturnType = A._substitute(universe, returnType, typeArguments, depth);
          functionParameters = rti._rest;
          substitutedFunctionParameters = A._substituteFunctionParameters(universe, functionParameters, typeArguments, depth);
          if (substitutedReturnType === returnType && substitutedFunctionParameters === functionParameters)
            return rti;
          return A._Universe__lookupFunctionRti(universe, substitutedReturnType, substitutedFunctionParameters);
        case 13:
          bounds = rti._rest;
          depth += bounds.length;
          substitutedBounds = A._substituteArray(universe, bounds, typeArguments, depth);
          base = rti._primary;
          substitutedBase = A._substitute(universe, base, typeArguments, depth);
          if (substitutedBounds === bounds && substitutedBase === base)
            return rti;
          return A._Universe__lookupGenericFunctionRti(universe, substitutedBase, substitutedBounds, true);
        case 14:
          index = rti._primary;
          if (index < depth)
            return rti;
          argument = typeArguments[index - depth];
          if (argument == null)
            return rti;
          return argument;
        default:
          throw A.wrapException(A.AssertionError$("Attempted to substitute unexpected RTI kind " + kind));
      }
    },
    _substituteArray(universe, rtiArray, typeArguments, depth) {
      var changed, i, rti, substitutedRti,
        $length = rtiArray.length,
        result = A._Utils_newArrayOrEmpty($length);
      for (changed = false, i = 0; i < $length; ++i) {
        rti = rtiArray[i];
        substitutedRti = A._substitute(universe, rti, typeArguments, depth);
        if (substitutedRti !== rti)
          changed = true;
        result[i] = substitutedRti;
      }
      return changed ? result : rtiArray;
    },
    _substituteNamed(universe, namedArray, typeArguments, depth) {
      var changed, i, t1, t2, rti, substitutedRti,
        $length = namedArray.length,
        result = A._Utils_newArrayOrEmpty($length);
      for (changed = false, i = 0; i < $length; i += 3) {
        t1 = namedArray[i];
        t2 = namedArray[i + 1];
        rti = namedArray[i + 2];
        substitutedRti = A._substitute(universe, rti, typeArguments, depth);
        if (substitutedRti !== rti)
          changed = true;
        result.splice(i, 3, t1, t2, substitutedRti);
      }
      return changed ? result : namedArray;
    },
    _substituteFunctionParameters(universe, functionParameters, typeArguments, depth) {
      var result,
        requiredPositional = functionParameters._requiredPositional,
        substitutedRequiredPositional = A._substituteArray(universe, requiredPositional, typeArguments, depth),
        optionalPositional = functionParameters._optionalPositional,
        substitutedOptionalPositional = A._substituteArray(universe, optionalPositional, typeArguments, depth),
        named = functionParameters._named,
        substitutedNamed = A._substituteNamed(universe, named, typeArguments, depth);
      if (substitutedRequiredPositional === requiredPositional && substitutedOptionalPositional === optionalPositional && substitutedNamed === named)
        return functionParameters;
      result = new A._FunctionParameters();
      result._requiredPositional = substitutedRequiredPositional;
      result._optionalPositional = substitutedOptionalPositional;
      result._named = substitutedNamed;
      return result;
    },
    _setArrayType(target, rti) {
      target[init.arrayRti] = rti;
      return target;
    },
    closureFunctionType(closure) {
      var signature = closure.$signature;
      if (signature != null) {
        if (typeof signature == "number")
          return A.getTypeFromTypesTable(signature);
        return closure.$signature();
      }
      return null;
    },
    instanceOrFunctionType(object, testRti) {
      var rti;
      if (A.Rti__isUnionOfFunctionType(testRti))
        if (object instanceof A.Closure) {
          rti = A.closureFunctionType(object);
          if (rti != null)
            return rti;
        }
      return A.instanceType(object);
    },
    instanceType(object) {
      if (object instanceof A.Object)
        return A._instanceType(object);
      if (Array.isArray(object))
        return A._arrayInstanceType(object);
      return A._instanceTypeFromConstructor(J.getInterceptor$(object));
    },
    _arrayInstanceType(object) {
      var rti = object[init.arrayRti],
        defaultRti = type$.JSArray_dynamic;
      if (rti == null)
        return defaultRti;
      if (rti.constructor !== defaultRti.constructor)
        return defaultRti;
      return rti;
    },
    _instanceType(object) {
      var rti = object.$ti;
      return rti != null ? rti : A._instanceTypeFromConstructor(object);
    },
    _instanceTypeFromConstructor(instance) {
      var $constructor = instance.constructor,
        probe = $constructor.$ccache;
      if (probe != null)
        return probe;
      return A._instanceTypeFromConstructorMiss(instance, $constructor);
    },
    _instanceTypeFromConstructorMiss(instance, $constructor) {
      var effectiveConstructor = instance instanceof A.Closure ? Object.getPrototypeOf(Object.getPrototypeOf(instance)).constructor : $constructor,
        rti = A._Universe_findErasedType(init.typeUniverse, effectiveConstructor.name);
      $constructor.$ccache = rti;
      return rti;
    },
    getTypeFromTypesTable(index) {
      var rti,
        table = init.types,
        type = table[index];
      if (typeof type == "string") {
        rti = A._Universe_eval(init.typeUniverse, type, false);
        table[index] = rti;
        return rti;
      }
      return type;
    },
    getRuntimeTypeOfDartObject(object) {
      return A.createRuntimeType(A._instanceType(object));
    },
    getRuntimeTypeOfClosure(closure) {
      var rti = A.closureFunctionType(closure);
      return A.createRuntimeType(rti == null ? A.instanceType(closure) : rti);
    },
    _structuralTypeOf(object) {
      var functionRti = object instanceof A.Closure ? A.closureFunctionType(object) : null;
      if (functionRti != null)
        return functionRti;
      if (type$.TrustedGetRuntimeType._is(object))
        return J.get$runtimeType$(object)._rti;
      if (Array.isArray(object))
        return A._arrayInstanceType(object);
      return A.instanceType(object);
    },
    createRuntimeType(rti) {
      var t1 = rti._cachedRuntimeType;
      return t1 == null ? rti._cachedRuntimeType = A._createRuntimeType(rti) : t1;
    },
    _createRuntimeType(rti) {
      var starErasedRti, t1,
        s = rti._canonicalRecipe,
        starErasedRecipe = s.replace(/\*/g, "");
      if (starErasedRecipe === s)
        return rti._cachedRuntimeType = new A._Type(rti);
      starErasedRti = A._Universe_eval(init.typeUniverse, starErasedRecipe, true);
      t1 = starErasedRti._cachedRuntimeType;
      return t1 == null ? starErasedRti._cachedRuntimeType = A._createRuntimeType(starErasedRti) : t1;
    },
    typeLiteral(recipe) {
      return A.createRuntimeType(A._Universe_eval(init.typeUniverse, recipe, false));
    },
    _installSpecializedIsTest(object) {
      var t1, unstarred, unstarredKind, isFn, $name, predicate, testRti = this;
      if (testRti === type$.Object)
        return A._finishIsFn(testRti, object, A._isObject);
      if (!A.isSoundTopType(testRti))
        t1 = testRti === type$.legacy_Object;
      else
        t1 = true;
      if (t1)
        return A._finishIsFn(testRti, object, A._isTop);
      t1 = testRti._kind;
      if (t1 === 7)
        return A._finishIsFn(testRti, object, A._generalNullableIsTestImplementation);
      if (t1 === 1)
        return A._finishIsFn(testRti, object, A._isNever);
      unstarred = t1 === 6 ? testRti._primary : testRti;
      unstarredKind = unstarred._kind;
      if (unstarredKind === 8)
        return A._finishIsFn(testRti, object, A._isFutureOr);
      if (unstarred === type$.int)
        isFn = A._isInt;
      else if (unstarred === type$.double || unstarred === type$.num)
        isFn = A._isNum;
      else if (unstarred === type$.String)
        isFn = A._isString;
      else
        isFn = unstarred === type$.bool ? A._isBool : null;
      if (isFn != null)
        return A._finishIsFn(testRti, object, isFn);
      if (unstarredKind === 9) {
        $name = unstarred._primary;
        if (unstarred._rest.every(A.isDefinitelyTopType)) {
          testRti._specializedTestResource = "$is" + $name;
          if ($name === "List")
            return A._finishIsFn(testRti, object, A._isListTestViaProperty);
          return A._finishIsFn(testRti, object, A._isTestViaProperty);
        }
      } else if (unstarredKind === 11) {
        predicate = A.createRecordTypePredicate(unstarred._primary, unstarred._rest);
        return A._finishIsFn(testRti, object, predicate == null ? A._isNever : predicate);
      }
      return A._finishIsFn(testRti, object, A._generalIsTestImplementation);
    },
    _finishIsFn(testRti, object, isFn) {
      testRti._is = isFn;
      return testRti._is(object);
    },
    _installSpecializedAsCheck(object) {
      var t1, testRti = this,
        asFn = A._generalAsCheckImplementation;
      if (!A.isSoundTopType(testRti))
        t1 = testRti === type$.legacy_Object;
      else
        t1 = true;
      if (t1)
        asFn = A._asTop;
      else if (testRti === type$.Object)
        asFn = A._asObject;
      else {
        t1 = A.isNullable(testRti);
        if (t1)
          asFn = A._generalNullableAsCheckImplementation;
      }
      testRti._as = asFn;
      return testRti._as(object);
    },
    _nullIs(testRti) {
      var t1,
        kind = testRti._kind;
      if (!A.isSoundTopType(testRti))
        if (!(testRti === type$.legacy_Object))
          if (!(testRti === type$.legacy_Never))
            if (kind !== 7)
              if (!(kind === 6 && A._nullIs(testRti._primary)))
                t1 = kind === 8 && A._nullIs(testRti._primary) || testRti === type$.Null || testRti === type$.JSNull;
              else
                t1 = true;
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
      else
        t1 = true;
      return t1;
    },
    _generalIsTestImplementation(object) {
      var testRti = this;
      if (object == null)
        return A._nullIs(testRti);
      return A.isSubtype(init.typeUniverse, A.instanceOrFunctionType(object, testRti), testRti);
    },
    _generalNullableIsTestImplementation(object) {
      if (object == null)
        return true;
      return this._primary._is(object);
    },
    _isTestViaProperty(object) {
      var tag, testRti = this;
      if (object == null)
        return A._nullIs(testRti);
      tag = testRti._specializedTestResource;
      if (object instanceof A.Object)
        return !!object[tag];
      return !!J.getInterceptor$(object)[tag];
    },
    _isListTestViaProperty(object) {
      var tag, testRti = this;
      if (object == null)
        return A._nullIs(testRti);
      if (typeof object != "object")
        return false;
      if (Array.isArray(object))
        return true;
      tag = testRti._specializedTestResource;
      if (object instanceof A.Object)
        return !!object[tag];
      return !!J.getInterceptor$(object)[tag];
    },
    _generalAsCheckImplementation(object) {
      var testRti = this;
      if (object == null) {
        if (A.isNullable(testRti))
          return object;
      } else if (testRti._is(object))
        return object;
      A._failedAsCheck(object, testRti);
    },
    _generalNullableAsCheckImplementation(object) {
      var testRti = this;
      if (object == null)
        return object;
      else if (testRti._is(object))
        return object;
      A._failedAsCheck(object, testRti);
    },
    _failedAsCheck(object, testRti) {
      throw A.wrapException(A._TypeError$fromMessage(A._Error_compose(object, A._rtiToString(testRti, null))));
    },
    checkTypeBound(type, bound, variable, methodName) {
      if (A.isSubtype(init.typeUniverse, type, bound))
        return type;
      throw A.wrapException(A._TypeError$fromMessage("The type argument '" + A._rtiToString(type, null) + "' is not a subtype of the type variable bound '" + A._rtiToString(bound, null) + "' of type variable '" + variable + "' in '" + methodName + "'."));
    },
    _Error_compose(object, checkedTypeDescription) {
      return A.Error_safeToString(object) + ": type '" + A._rtiToString(A._structuralTypeOf(object), null) + "' is not a subtype of type '" + checkedTypeDescription + "'";
    },
    _TypeError$fromMessage(message) {
      return new A._TypeError("TypeError: " + message);
    },
    _TypeError__TypeError$forType(object, type) {
      return new A._TypeError("TypeError: " + A._Error_compose(object, type));
    },
    _isFutureOr(object) {
      var testRti = this,
        unstarred = testRti._kind === 6 ? testRti._primary : testRti;
      return unstarred._primary._is(object) || A.Rti__getFutureFromFutureOr(init.typeUniverse, unstarred)._is(object);
    },
    _isObject(object) {
      return object != null;
    },
    _asObject(object) {
      if (object != null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "Object"));
    },
    _isTop(object) {
      return true;
    },
    _asTop(object) {
      return object;
    },
    _isNever(object) {
      return false;
    },
    _isBool(object) {
      return true === object || false === object;
    },
    _asBool(object) {
      if (true === object)
        return true;
      if (false === object)
        return false;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "bool"));
    },
    _asBoolS(object) {
      if (true === object)
        return true;
      if (false === object)
        return false;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "bool"));
    },
    _asBoolQ(object) {
      if (true === object)
        return true;
      if (false === object)
        return false;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "bool?"));
    },
    _asDouble(object) {
      if (typeof object == "number")
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "double"));
    },
    _asDoubleS(object) {
      if (typeof object == "number")
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "double"));
    },
    _asDoubleQ(object) {
      if (typeof object == "number")
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "double?"));
    },
    _isInt(object) {
      return typeof object == "number" && Math.floor(object) === object;
    },
    _asInt(object) {
      if (typeof object == "number" && Math.floor(object) === object)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "int"));
    },
    _asIntS(object) {
      if (typeof object == "number" && Math.floor(object) === object)
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "int"));
    },
    _asIntQ(object) {
      if (typeof object == "number" && Math.floor(object) === object)
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "int?"));
    },
    _isNum(object) {
      return typeof object == "number";
    },
    _asNum(object) {
      if (typeof object == "number")
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "num"));
    },
    _asNumS(object) {
      if (typeof object == "number")
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "num"));
    },
    _asNumQ(object) {
      if (typeof object == "number")
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "num?"));
    },
    _isString(object) {
      return typeof object == "string";
    },
    _asString(object) {
      if (typeof object == "string")
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "String"));
    },
    _asStringS(object) {
      if (typeof object == "string")
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "String"));
    },
    _asStringQ(object) {
      if (typeof object == "string")
        return object;
      if (object == null)
        return object;
      throw A.wrapException(A._TypeError__TypeError$forType(object, "String?"));
    },
    _rtiArrayToString(array, genericContext) {
      var s, sep, i;
      for (s = "", sep = "", i = 0; i < array.length; ++i, sep = ", ")
        s += sep + A._rtiToString(array[i], genericContext);
      return s;
    },
    _recordRtiToString(recordType, genericContext) {
      var fieldCount, names, namesIndex, s, comma, i,
        partialShape = recordType._primary,
        fields = recordType._rest;
      if ("" === partialShape)
        return "(" + A._rtiArrayToString(fields, genericContext) + ")";
      fieldCount = fields.length;
      names = partialShape.split(",");
      namesIndex = names.length - fieldCount;
      for (s = "(", comma = "", i = 0; i < fieldCount; ++i, comma = ", ") {
        s += comma;
        if (namesIndex === 0)
          s += "{";
        s += A._rtiToString(fields[i], genericContext);
        if (namesIndex >= 0)
          s += " " + names[namesIndex];
        ++namesIndex;
      }
      return s + "})";
    },
    _functionRtiToString(functionType, genericContext, bounds) {
      var boundsLength, outerContextLength, offset, i, t1, t2, typeParametersText, typeSep, t3, t4, boundRti, kind, parameters, requiredPositional, requiredPositionalLength, optionalPositional, optionalPositionalLength, named, namedLength, returnTypeText, argumentsText, sep, _s2_ = ", ";
      if (bounds != null) {
        boundsLength = bounds.length;
        if (genericContext == null) {
          genericContext = A._setArrayType([], type$.JSArray_String);
          outerContextLength = null;
        } else
          outerContextLength = genericContext.length;
        offset = genericContext.length;
        for (i = boundsLength; i > 0; --i)
          B.JSArray_methods.add$1(genericContext, "T" + (offset + i));
        for (t1 = type$.nullable_Object, t2 = type$.legacy_Object, typeParametersText = "<", typeSep = "", i = 0; i < boundsLength; ++i, typeSep = _s2_) {
          t3 = genericContext.length;
          t4 = t3 - 1 - i;
          if (!(t4 >= 0))
            return A.ioore(genericContext, t4);
          typeParametersText = B.JSString_methods.$add(typeParametersText + typeSep, genericContext[t4]);
          boundRti = bounds[i];
          kind = boundRti._kind;
          if (!(kind === 2 || kind === 3 || kind === 4 || kind === 5 || boundRti === t1))
            t3 = boundRti === t2;
          else
            t3 = true;
          if (!t3)
            typeParametersText += " extends " + A._rtiToString(boundRti, genericContext);
        }
        typeParametersText += ">";
      } else {
        typeParametersText = "";
        outerContextLength = null;
      }
      t1 = functionType._primary;
      parameters = functionType._rest;
      requiredPositional = parameters._requiredPositional;
      requiredPositionalLength = requiredPositional.length;
      optionalPositional = parameters._optionalPositional;
      optionalPositionalLength = optionalPositional.length;
      named = parameters._named;
      namedLength = named.length;
      returnTypeText = A._rtiToString(t1, genericContext);
      for (argumentsText = "", sep = "", i = 0; i < requiredPositionalLength; ++i, sep = _s2_)
        argumentsText += sep + A._rtiToString(requiredPositional[i], genericContext);
      if (optionalPositionalLength > 0) {
        argumentsText += sep + "[";
        for (sep = "", i = 0; i < optionalPositionalLength; ++i, sep = _s2_)
          argumentsText += sep + A._rtiToString(optionalPositional[i], genericContext);
        argumentsText += "]";
      }
      if (namedLength > 0) {
        argumentsText += sep + "{";
        for (sep = "", i = 0; i < namedLength; i += 3, sep = _s2_) {
          argumentsText += sep;
          if (named[i + 1])
            argumentsText += "required ";
          argumentsText += A._rtiToString(named[i + 2], genericContext) + " " + named[i];
        }
        argumentsText += "}";
      }
      if (outerContextLength != null) {
        genericContext.toString;
        genericContext.length = outerContextLength;
      }
      return typeParametersText + "(" + argumentsText + ") => " + returnTypeText;
    },
    _rtiToString(rti, genericContext) {
      var questionArgument, s, argumentKind, $name, $arguments, t1, t2,
        kind = rti._kind;
      if (kind === 5)
        return "erased";
      if (kind === 2)
        return "dynamic";
      if (kind === 3)
        return "void";
      if (kind === 1)
        return "Never";
      if (kind === 4)
        return "any";
      if (kind === 6)
        return A._rtiToString(rti._primary, genericContext);
      if (kind === 7) {
        questionArgument = rti._primary;
        s = A._rtiToString(questionArgument, genericContext);
        argumentKind = questionArgument._kind;
        return (argumentKind === 12 || argumentKind === 13 ? "(" + s + ")" : s) + "?";
      }
      if (kind === 8)
        return "FutureOr<" + A._rtiToString(rti._primary, genericContext) + ">";
      if (kind === 9) {
        $name = A._unminifyOrTag(rti._primary);
        $arguments = rti._rest;
        return $arguments.length > 0 ? $name + ("<" + A._rtiArrayToString($arguments, genericContext) + ">") : $name;
      }
      if (kind === 11)
        return A._recordRtiToString(rti, genericContext);
      if (kind === 12)
        return A._functionRtiToString(rti, genericContext, null);
      if (kind === 13)
        return A._functionRtiToString(rti._primary, genericContext, rti._rest);
      if (kind === 14) {
        t1 = rti._primary;
        t2 = genericContext.length;
        t1 = t2 - 1 - t1;
        if (!(t1 >= 0 && t1 < t2))
          return A.ioore(genericContext, t1);
        return genericContext[t1];
      }
      return "?";
    },
    _unminifyOrTag(rawClassName) {
      var preserved = init.mangledGlobalNames[rawClassName];
      if (preserved != null)
        return preserved;
      return rawClassName;
    },
    _Universe_findRule(universe, targetType) {
      var rule = universe.tR[targetType];
      for (; typeof rule == "string";)
        rule = universe.tR[rule];
      return rule;
    },
    _Universe_findErasedType(universe, cls) {
      var $length, erased, $arguments, i, $interface,
        t1 = universe.eT,
        probe = t1[cls];
      if (probe == null)
        return A._Universe_eval(universe, cls, false);
      else if (typeof probe == "number") {
        $length = probe;
        erased = A._Universe__lookupTerminalRti(universe, 5, "#");
        $arguments = A._Utils_newArrayOrEmpty($length);
        for (i = 0; i < $length; ++i)
          $arguments[i] = erased;
        $interface = A._Universe__lookupInterfaceRti(universe, cls, $arguments);
        t1[cls] = $interface;
        return $interface;
      } else
        return probe;
    },
    _Universe_addRules(universe, rules) {
      return A._Utils_objectAssign(universe.tR, rules);
    },
    _Universe_addErasedTypes(universe, types) {
      return A._Utils_objectAssign(universe.eT, types);
    },
    _Universe_eval(universe, recipe, normalize) {
      var rti,
        t1 = universe.eC,
        probe = t1.get(recipe);
      if (probe != null)
        return probe;
      rti = A._Parser_parse(A._Parser_create(universe, null, recipe, normalize));
      t1.set(recipe, rti);
      return rti;
    },
    _Universe_evalInEnvironment(universe, environment, recipe) {
      var probe, rti,
        cache = environment._evalCache;
      if (cache == null)
        cache = environment._evalCache = new Map();
      probe = cache.get(recipe);
      if (probe != null)
        return probe;
      rti = A._Parser_parse(A._Parser_create(universe, environment, recipe, true));
      cache.set(recipe, rti);
      return rti;
    },
    _Universe_bind(universe, environment, argumentsRti) {
      var argumentsRecipe, probe, rti,
        cache = environment._bindCache;
      if (cache == null)
        cache = environment._bindCache = new Map();
      argumentsRecipe = argumentsRti._canonicalRecipe;
      probe = cache.get(argumentsRecipe);
      if (probe != null)
        return probe;
      rti = A._Universe__lookupBindingRti(universe, environment, argumentsRti._kind === 10 ? argumentsRti._rest : [argumentsRti]);
      cache.set(argumentsRecipe, rti);
      return rti;
    },
    _Universe__installTypeTests(universe, rti) {
      rti._as = A._installSpecializedAsCheck;
      rti._is = A._installSpecializedIsTest;
      return rti;
    },
    _Universe__lookupTerminalRti(universe, kind, key) {
      var rti, t1,
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = kind;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__lookupStarRti(universe, baseType, normalize) {
      var t1,
        key = baseType._canonicalRecipe + "*",
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      t1 = A._Universe__createStarRti(universe, baseType, key, normalize);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__createStarRti(universe, baseType, key, normalize) {
      var baseKind, t1, rti;
      if (normalize) {
        baseKind = baseType._kind;
        if (!A.isSoundTopType(baseType))
          t1 = baseType === type$.Null || baseType === type$.JSNull || baseKind === 7 || baseKind === 6;
        else
          t1 = true;
        if (t1)
          return baseType;
      }
      rti = new A.Rti(null, null);
      rti._kind = 6;
      rti._primary = baseType;
      rti._canonicalRecipe = key;
      return A._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupQuestionRti(universe, baseType, normalize) {
      var t1,
        key = baseType._canonicalRecipe + "?",
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      t1 = A._Universe__createQuestionRti(universe, baseType, key, normalize);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__createQuestionRti(universe, baseType, key, normalize) {
      var baseKind, t1, starArgument, rti;
      if (normalize) {
        baseKind = baseType._kind;
        if (!A.isSoundTopType(baseType))
          if (!(baseType === type$.Null || baseType === type$.JSNull))
            if (baseKind !== 7)
              t1 = baseKind === 8 && A.isNullable(baseType._primary);
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
        if (t1)
          return baseType;
        else if (baseKind === 1 || baseType === type$.legacy_Never)
          return type$.Null;
        else if (baseKind === 6) {
          starArgument = baseType._primary;
          if (starArgument._kind === 8 && A.isNullable(starArgument._primary))
            return starArgument;
          else
            return A.Rti__getQuestionFromStar(universe, baseType);
        }
      }
      rti = new A.Rti(null, null);
      rti._kind = 7;
      rti._primary = baseType;
      rti._canonicalRecipe = key;
      return A._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupFutureOrRti(universe, baseType, normalize) {
      var t1,
        key = baseType._canonicalRecipe + "/",
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      t1 = A._Universe__createFutureOrRti(universe, baseType, key, normalize);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__createFutureOrRti(universe, baseType, key, normalize) {
      var t1, rti;
      if (normalize) {
        t1 = baseType._kind;
        if (A.isSoundTopType(baseType) || baseType === type$.Object || baseType === type$.legacy_Object)
          return baseType;
        else if (t1 === 1)
          return A._Universe__lookupInterfaceRti(universe, "Future", [baseType]);
        else if (baseType === type$.Null || baseType === type$.JSNull)
          return type$.nullable_Future_Null;
      }
      rti = new A.Rti(null, null);
      rti._kind = 8;
      rti._primary = baseType;
      rti._canonicalRecipe = key;
      return A._Universe__installTypeTests(universe, rti);
    },
    _Universe__lookupGenericFunctionParameterRti(universe, index) {
      var rti, t1,
        key = "" + index + "^",
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 14;
      rti._primary = index;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__canonicalRecipeJoin($arguments) {
      var s, sep, i,
        $length = $arguments.length;
      for (s = "", sep = "", i = 0; i < $length; ++i, sep = ",")
        s += sep + $arguments[i]._canonicalRecipe;
      return s;
    },
    _Universe__canonicalRecipeJoinNamed($arguments) {
      var s, sep, i, t1, nameSep,
        $length = $arguments.length;
      for (s = "", sep = "", i = 0; i < $length; i += 3, sep = ",") {
        t1 = $arguments[i];
        nameSep = $arguments[i + 1] ? "!" : ":";
        s += sep + t1 + nameSep + $arguments[i + 2]._canonicalRecipe;
      }
      return s;
    },
    _Universe__lookupInterfaceRti(universe, $name, $arguments) {
      var probe, rti, t1,
        s = $name;
      if ($arguments.length > 0)
        s += "<" + A._Universe__canonicalRecipeJoin($arguments) + ">";
      probe = universe.eC.get(s);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 9;
      rti._primary = $name;
      rti._rest = $arguments;
      if ($arguments.length > 0)
        rti._precomputed1 = $arguments[0];
      rti._canonicalRecipe = s;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(s, t1);
      return t1;
    },
    _Universe__lookupBindingRti(universe, base, $arguments) {
      var newBase, newArguments, key, probe, rti, t1;
      if (base._kind === 10) {
        newBase = base._primary;
        newArguments = base._rest.concat($arguments);
      } else {
        newArguments = $arguments;
        newBase = base;
      }
      key = newBase._canonicalRecipe + (";<" + A._Universe__canonicalRecipeJoin(newArguments) + ">");
      probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 10;
      rti._primary = newBase;
      rti._rest = newArguments;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__lookupRecordRti(universe, partialShapeTag, fields) {
      var rti, t1,
        key = "+" + (partialShapeTag + "(" + A._Universe__canonicalRecipeJoin(fields) + ")"),
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 11;
      rti._primary = partialShapeTag;
      rti._rest = fields;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__lookupFunctionRti(universe, returnType, parameters) {
      var sep, key, probe, rti, t1,
        s = returnType._canonicalRecipe,
        requiredPositional = parameters._requiredPositional,
        requiredPositionalLength = requiredPositional.length,
        optionalPositional = parameters._optionalPositional,
        optionalPositionalLength = optionalPositional.length,
        named = parameters._named,
        namedLength = named.length,
        recipe = "(" + A._Universe__canonicalRecipeJoin(requiredPositional);
      if (optionalPositionalLength > 0) {
        sep = requiredPositionalLength > 0 ? "," : "";
        recipe += sep + "[" + A._Universe__canonicalRecipeJoin(optionalPositional) + "]";
      }
      if (namedLength > 0) {
        sep = requiredPositionalLength > 0 ? "," : "";
        recipe += sep + "{" + A._Universe__canonicalRecipeJoinNamed(named) + "}";
      }
      key = s + (recipe + ")");
      probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      rti = new A.Rti(null, null);
      rti._kind = 12;
      rti._primary = returnType;
      rti._rest = parameters;
      rti._canonicalRecipe = key;
      t1 = A._Universe__installTypeTests(universe, rti);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__lookupGenericFunctionRti(universe, baseFunctionType, bounds, normalize) {
      var t1,
        key = baseFunctionType._canonicalRecipe + ("<" + A._Universe__canonicalRecipeJoin(bounds) + ">"),
        probe = universe.eC.get(key);
      if (probe != null)
        return probe;
      t1 = A._Universe__createGenericFunctionRti(universe, baseFunctionType, bounds, key, normalize);
      universe.eC.set(key, t1);
      return t1;
    },
    _Universe__createGenericFunctionRti(universe, baseFunctionType, bounds, key, normalize) {
      var $length, typeArguments, count, i, bound, substitutedBase, substitutedBounds, rti;
      if (normalize) {
        $length = bounds.length;
        typeArguments = A._Utils_newArrayOrEmpty($length);
        for (count = 0, i = 0; i < $length; ++i) {
          bound = bounds[i];
          if (bound._kind === 1) {
            typeArguments[i] = bound;
            ++count;
          }
        }
        if (count > 0) {
          substitutedBase = A._substitute(universe, baseFunctionType, typeArguments, 0);
          substitutedBounds = A._substituteArray(universe, bounds, typeArguments, 0);
          return A._Universe__lookupGenericFunctionRti(universe, substitutedBase, substitutedBounds, bounds !== substitutedBounds);
        }
      }
      rti = new A.Rti(null, null);
      rti._kind = 13;
      rti._primary = baseFunctionType;
      rti._rest = bounds;
      rti._canonicalRecipe = key;
      return A._Universe__installTypeTests(universe, rti);
    },
    _Parser_create(universe, environment, recipe, normalize) {
      return {u: universe, e: environment, r: recipe, s: [], p: 0, n: normalize};
    },
    _Parser_parse(parser) {
      var t2, i, ch, t3, array, end, item,
        source = parser.r,
        t1 = parser.s;
      for (t2 = source.length, i = 0; i < t2;) {
        ch = source.charCodeAt(i);
        if (ch >= 48 && ch <= 57)
          i = A._Parser_handleDigit(i + 1, ch, source, t1);
        else if ((((ch | 32) >>> 0) - 97 & 65535) < 26 || ch === 95 || ch === 36 || ch === 124)
          i = A._Parser_handleIdentifier(parser, i, source, t1, false);
        else if (ch === 46)
          i = A._Parser_handleIdentifier(parser, i, source, t1, true);
        else {
          ++i;
          switch (ch) {
            case 44:
              break;
            case 58:
              t1.push(false);
              break;
            case 33:
              t1.push(true);
              break;
            case 59:
              t1.push(A._Parser_toType(parser.u, parser.e, t1.pop()));
              break;
            case 94:
              t1.push(A._Universe__lookupGenericFunctionParameterRti(parser.u, t1.pop()));
              break;
            case 35:
              t1.push(A._Universe__lookupTerminalRti(parser.u, 5, "#"));
              break;
            case 64:
              t1.push(A._Universe__lookupTerminalRti(parser.u, 2, "@"));
              break;
            case 126:
              t1.push(A._Universe__lookupTerminalRti(parser.u, 3, "~"));
              break;
            case 60:
              t1.push(parser.p);
              parser.p = t1.length;
              break;
            case 62:
              A._Parser_handleTypeArguments(parser, t1);
              break;
            case 38:
              A._Parser_handleExtendedOperations(parser, t1);
              break;
            case 42:
              t3 = parser.u;
              t1.push(A._Universe__lookupStarRti(t3, A._Parser_toType(t3, parser.e, t1.pop()), parser.n));
              break;
            case 63:
              t3 = parser.u;
              t1.push(A._Universe__lookupQuestionRti(t3, A._Parser_toType(t3, parser.e, t1.pop()), parser.n));
              break;
            case 47:
              t3 = parser.u;
              t1.push(A._Universe__lookupFutureOrRti(t3, A._Parser_toType(t3, parser.e, t1.pop()), parser.n));
              break;
            case 40:
              t1.push(-3);
              t1.push(parser.p);
              parser.p = t1.length;
              break;
            case 41:
              A._Parser_handleArguments(parser, t1);
              break;
            case 91:
              t1.push(parser.p);
              parser.p = t1.length;
              break;
            case 93:
              array = t1.splice(parser.p);
              A._Parser_toTypes(parser.u, parser.e, array);
              parser.p = t1.pop();
              t1.push(array);
              t1.push(-1);
              break;
            case 123:
              t1.push(parser.p);
              parser.p = t1.length;
              break;
            case 125:
              array = t1.splice(parser.p);
              A._Parser_toTypesNamed(parser.u, parser.e, array);
              parser.p = t1.pop();
              t1.push(array);
              t1.push(-2);
              break;
            case 43:
              end = source.indexOf("(", i);
              t1.push(source.substring(i, end));
              t1.push(-4);
              t1.push(parser.p);
              parser.p = t1.length;
              i = end + 1;
              break;
            default:
              throw "Bad character " + ch;
          }
        }
      }
      item = t1.pop();
      return A._Parser_toType(parser.u, parser.e, item);
    },
    _Parser_handleDigit(i, digit, source, stack) {
      var t1, ch,
        value = digit - 48;
      for (t1 = source.length; i < t1; ++i) {
        ch = source.charCodeAt(i);
        if (!(ch >= 48 && ch <= 57))
          break;
        value = value * 10 + (ch - 48);
      }
      stack.push(value);
      return i;
    },
    _Parser_handleIdentifier(parser, start, source, stack, hasPeriod) {
      var t1, ch, t2, string, environment, recipe,
        i = start + 1;
      for (t1 = source.length; i < t1; ++i) {
        ch = source.charCodeAt(i);
        if (ch === 46) {
          if (hasPeriod)
            break;
          hasPeriod = true;
        } else {
          if (!((((ch | 32) >>> 0) - 97 & 65535) < 26 || ch === 95 || ch === 36 || ch === 124))
            t2 = ch >= 48 && ch <= 57;
          else
            t2 = true;
          if (!t2)
            break;
        }
      }
      string = source.substring(start, i);
      if (hasPeriod) {
        t1 = parser.u;
        environment = parser.e;
        if (environment._kind === 10)
          environment = environment._primary;
        recipe = A._Universe_findRule(t1, environment._primary)[string];
        if (recipe == null)
          A.throwExpression('No "' + string + '" in "' + A.Rti__getCanonicalRecipe(environment) + '"');
        stack.push(A._Universe_evalInEnvironment(t1, environment, recipe));
      } else
        stack.push(string);
      return i;
    },
    _Parser_handleTypeArguments(parser, stack) {
      var base,
        t1 = parser.u,
        $arguments = A._Parser_collectArray(parser, stack),
        head = stack.pop();
      if (typeof head == "string")
        stack.push(A._Universe__lookupInterfaceRti(t1, head, $arguments));
      else {
        base = A._Parser_toType(t1, parser.e, head);
        switch (base._kind) {
          case 12:
            stack.push(A._Universe__lookupGenericFunctionRti(t1, base, $arguments, parser.n));
            break;
          default:
            stack.push(A._Universe__lookupBindingRti(t1, base, $arguments));
            break;
        }
      }
    },
    _Parser_handleArguments(parser, stack) {
      var optionalPositional, named, requiredPositional, returnType, parameters, _null = null,
        t1 = parser.u,
        head = stack.pop();
      if (typeof head == "number")
        switch (head) {
          case -1:
            optionalPositional = stack.pop();
            named = _null;
            break;
          case -2:
            named = stack.pop();
            optionalPositional = _null;
            break;
          default:
            stack.push(head);
            named = _null;
            optionalPositional = named;
            break;
        }
      else {
        stack.push(head);
        named = _null;
        optionalPositional = named;
      }
      requiredPositional = A._Parser_collectArray(parser, stack);
      head = stack.pop();
      switch (head) {
        case -3:
          head = stack.pop();
          if (optionalPositional == null)
            optionalPositional = t1.sEA;
          if (named == null)
            named = t1.sEA;
          returnType = A._Parser_toType(t1, parser.e, head);
          parameters = new A._FunctionParameters();
          parameters._requiredPositional = requiredPositional;
          parameters._optionalPositional = optionalPositional;
          parameters._named = named;
          stack.push(A._Universe__lookupFunctionRti(t1, returnType, parameters));
          return;
        case -4:
          stack.push(A._Universe__lookupRecordRti(t1, stack.pop(), requiredPositional));
          return;
        default:
          throw A.wrapException(A.AssertionError$("Unexpected state under `()`: " + A.S(head)));
      }
    },
    _Parser_handleExtendedOperations(parser, stack) {
      var $top = stack.pop();
      if (0 === $top) {
        stack.push(A._Universe__lookupTerminalRti(parser.u, 1, "0&"));
        return;
      }
      if (1 === $top) {
        stack.push(A._Universe__lookupTerminalRti(parser.u, 4, "1&"));
        return;
      }
      throw A.wrapException(A.AssertionError$("Unexpected extended operation " + A.S($top)));
    },
    _Parser_collectArray(parser, stack) {
      var array = stack.splice(parser.p);
      A._Parser_toTypes(parser.u, parser.e, array);
      parser.p = stack.pop();
      return array;
    },
    _Parser_toType(universe, environment, item) {
      if (typeof item == "string")
        return A._Universe__lookupInterfaceRti(universe, item, universe.sEA);
      else if (typeof item == "number") {
        environment.toString;
        return A._Parser_indexToType(universe, environment, item);
      } else
        return item;
    },
    _Parser_toTypes(universe, environment, items) {
      var i,
        $length = items.length;
      for (i = 0; i < $length; ++i)
        items[i] = A._Parser_toType(universe, environment, items[i]);
    },
    _Parser_toTypesNamed(universe, environment, items) {
      var i,
        $length = items.length;
      for (i = 2; i < $length; i += 3)
        items[i] = A._Parser_toType(universe, environment, items[i]);
    },
    _Parser_indexToType(universe, environment, index) {
      var typeArguments, len,
        kind = environment._kind;
      if (kind === 10) {
        if (index === 0)
          return environment._primary;
        typeArguments = environment._rest;
        len = typeArguments.length;
        if (index <= len)
          return typeArguments[index - 1];
        index -= len;
        environment = environment._primary;
        kind = environment._kind;
      } else if (index === 0)
        return environment;
      if (kind !== 9)
        throw A.wrapException(A.AssertionError$("Indexed base must be an interface type"));
      typeArguments = environment._rest;
      if (index <= typeArguments.length)
        return typeArguments[index - 1];
      throw A.wrapException(A.AssertionError$("Bad index " + index + " for " + environment.toString$0(0)));
    },
    isSubtype(universe, s, t) {
      var result,
        sCache = s._isSubtypeCache;
      if (sCache == null)
        sCache = s._isSubtypeCache = new Map();
      result = sCache.get(t);
      if (result == null) {
        result = A._isSubtype(universe, s, null, t, null, false) ? 1 : 0;
        sCache.set(t, result);
      }
      if (0 === result)
        return false;
      if (1 === result)
        return true;
      return true;
    },
    _isSubtype(universe, s, sEnv, t, tEnv, isLegacy) {
      var t1, sKind, leftTypeVariable, tKind, t2, sBounds, tBounds, sLength, i, sBound, tBound;
      if (s === t)
        return true;
      if (!A.isSoundTopType(t))
        t1 = t === type$.legacy_Object;
      else
        t1 = true;
      if (t1)
        return true;
      sKind = s._kind;
      if (sKind === 4)
        return true;
      if (A.isSoundTopType(s))
        return false;
      t1 = s._kind;
      if (t1 === 1)
        return true;
      leftTypeVariable = sKind === 14;
      if (leftTypeVariable)
        if (A._isSubtype(universe, sEnv[s._primary], sEnv, t, tEnv, false))
          return true;
      tKind = t._kind;
      t1 = s === type$.Null || s === type$.JSNull;
      if (t1) {
        if (tKind === 8)
          return A._isSubtype(universe, s, sEnv, t._primary, tEnv, false);
        return t === type$.Null || t === type$.JSNull || tKind === 7 || tKind === 6;
      }
      if (t === type$.Object) {
        if (sKind === 8)
          return A._isSubtype(universe, s._primary, sEnv, t, tEnv, false);
        if (sKind === 6)
          return A._isSubtype(universe, s._primary, sEnv, t, tEnv, false);
        return sKind !== 7;
      }
      if (sKind === 6)
        return A._isSubtype(universe, s._primary, sEnv, t, tEnv, false);
      if (tKind === 6) {
        t1 = A.Rti__getQuestionFromStar(universe, t);
        return A._isSubtype(universe, s, sEnv, t1, tEnv, false);
      }
      if (sKind === 8) {
        if (!A._isSubtype(universe, s._primary, sEnv, t, tEnv, false))
          return false;
        return A._isSubtype(universe, A.Rti__getFutureFromFutureOr(universe, s), sEnv, t, tEnv, false);
      }
      if (sKind === 7) {
        t1 = A._isSubtype(universe, type$.Null, sEnv, t, tEnv, false);
        return t1 && A._isSubtype(universe, s._primary, sEnv, t, tEnv, false);
      }
      if (tKind === 8) {
        if (A._isSubtype(universe, s, sEnv, t._primary, tEnv, false))
          return true;
        return A._isSubtype(universe, s, sEnv, A.Rti__getFutureFromFutureOr(universe, t), tEnv, false);
      }
      if (tKind === 7) {
        t1 = A._isSubtype(universe, s, sEnv, type$.Null, tEnv, false);
        return t1 || A._isSubtype(universe, s, sEnv, t._primary, tEnv, false);
      }
      if (leftTypeVariable)
        return false;
      t1 = sKind !== 12;
      if ((!t1 || sKind === 13) && t === type$.Function)
        return true;
      t2 = sKind === 11;
      if (t2 && t === type$.Record)
        return true;
      if (tKind === 13) {
        if (s === type$.JavaScriptFunction)
          return true;
        if (sKind !== 13)
          return false;
        sBounds = s._rest;
        tBounds = t._rest;
        sLength = sBounds.length;
        if (sLength !== tBounds.length)
          return false;
        sEnv = sEnv == null ? sBounds : sBounds.concat(sEnv);
        tEnv = tEnv == null ? tBounds : tBounds.concat(tEnv);
        for (i = 0; i < sLength; ++i) {
          sBound = sBounds[i];
          tBound = tBounds[i];
          if (!A._isSubtype(universe, sBound, sEnv, tBound, tEnv, false) || !A._isSubtype(universe, tBound, tEnv, sBound, sEnv, false))
            return false;
        }
        return A._isFunctionSubtype(universe, s._primary, sEnv, t._primary, tEnv, false);
      }
      if (tKind === 12) {
        if (s === type$.JavaScriptFunction)
          return true;
        if (t1)
          return false;
        return A._isFunctionSubtype(universe, s, sEnv, t, tEnv, false);
      }
      if (sKind === 9) {
        if (tKind !== 9)
          return false;
        return A._isInterfaceSubtype(universe, s, sEnv, t, tEnv, false);
      }
      if (t2 && tKind === 11)
        return A._isRecordSubtype(universe, s, sEnv, t, tEnv, false);
      return false;
    },
    _isFunctionSubtype(universe, s, sEnv, t, tEnv, isLegacy) {
      var sParameters, tParameters, sRequiredPositional, tRequiredPositional, sRequiredPositionalLength, tRequiredPositionalLength, requiredPositionalDelta, sOptionalPositional, tOptionalPositional, sOptionalPositionalLength, tOptionalPositionalLength, i, t1, sNamed, tNamed, sNamedLength, tNamedLength, sIndex, tIndex, tName, sName, sIsRequired;
      if (!A._isSubtype(universe, s._primary, sEnv, t._primary, tEnv, false))
        return false;
      sParameters = s._rest;
      tParameters = t._rest;
      sRequiredPositional = sParameters._requiredPositional;
      tRequiredPositional = tParameters._requiredPositional;
      sRequiredPositionalLength = sRequiredPositional.length;
      tRequiredPositionalLength = tRequiredPositional.length;
      if (sRequiredPositionalLength > tRequiredPositionalLength)
        return false;
      requiredPositionalDelta = tRequiredPositionalLength - sRequiredPositionalLength;
      sOptionalPositional = sParameters._optionalPositional;
      tOptionalPositional = tParameters._optionalPositional;
      sOptionalPositionalLength = sOptionalPositional.length;
      tOptionalPositionalLength = tOptionalPositional.length;
      if (sRequiredPositionalLength + sOptionalPositionalLength < tRequiredPositionalLength + tOptionalPositionalLength)
        return false;
      for (i = 0; i < sRequiredPositionalLength; ++i) {
        t1 = sRequiredPositional[i];
        if (!A._isSubtype(universe, tRequiredPositional[i], tEnv, t1, sEnv, false))
          return false;
      }
      for (i = 0; i < requiredPositionalDelta; ++i) {
        t1 = sOptionalPositional[i];
        if (!A._isSubtype(universe, tRequiredPositional[sRequiredPositionalLength + i], tEnv, t1, sEnv, false))
          return false;
      }
      for (i = 0; i < tOptionalPositionalLength; ++i) {
        t1 = sOptionalPositional[requiredPositionalDelta + i];
        if (!A._isSubtype(universe, tOptionalPositional[i], tEnv, t1, sEnv, false))
          return false;
      }
      sNamed = sParameters._named;
      tNamed = tParameters._named;
      sNamedLength = sNamed.length;
      tNamedLength = tNamed.length;
      for (sIndex = 0, tIndex = 0; tIndex < tNamedLength; tIndex += 3) {
        tName = tNamed[tIndex];
        for (; true;) {
          if (sIndex >= sNamedLength)
            return false;
          sName = sNamed[sIndex];
          sIndex += 3;
          if (tName < sName)
            return false;
          sIsRequired = sNamed[sIndex - 2];
          if (sName < tName) {
            if (sIsRequired)
              return false;
            continue;
          }
          t1 = tNamed[tIndex + 1];
          if (sIsRequired && !t1)
            return false;
          t1 = sNamed[sIndex - 1];
          if (!A._isSubtype(universe, tNamed[tIndex + 2], tEnv, t1, sEnv, false))
            return false;
          break;
        }
      }
      for (; sIndex < sNamedLength;) {
        if (sNamed[sIndex + 1])
          return false;
        sIndex += 3;
      }
      return true;
    },
    _isInterfaceSubtype(universe, s, sEnv, t, tEnv, isLegacy) {
      var rule, recipes, $length, supertypeArgs, i,
        sName = s._primary,
        tName = t._primary;
      for (; sName !== tName;) {
        rule = universe.tR[sName];
        if (rule == null)
          return false;
        if (typeof rule == "string") {
          sName = rule;
          continue;
        }
        recipes = rule[tName];
        if (recipes == null)
          return false;
        $length = recipes.length;
        supertypeArgs = $length > 0 ? new Array($length) : init.typeUniverse.sEA;
        for (i = 0; i < $length; ++i)
          supertypeArgs[i] = A._Universe_evalInEnvironment(universe, s, recipes[i]);
        return A._areArgumentsSubtypes(universe, supertypeArgs, null, sEnv, t._rest, tEnv, false);
      }
      return A._areArgumentsSubtypes(universe, s._rest, null, sEnv, t._rest, tEnv, false);
    },
    _areArgumentsSubtypes(universe, sArgs, sVariances, sEnv, tArgs, tEnv, isLegacy) {
      var i,
        $length = sArgs.length;
      for (i = 0; i < $length; ++i)
        if (!A._isSubtype(universe, sArgs[i], sEnv, tArgs[i], tEnv, false))
          return false;
      return true;
    },
    _isRecordSubtype(universe, s, sEnv, t, tEnv, isLegacy) {
      var i,
        sFields = s._rest,
        tFields = t._rest,
        sCount = sFields.length;
      if (sCount !== tFields.length)
        return false;
      if (s._primary !== t._primary)
        return false;
      for (i = 0; i < sCount; ++i)
        if (!A._isSubtype(universe, sFields[i], sEnv, tFields[i], tEnv, false))
          return false;
      return true;
    },
    isNullable(t) {
      var t1,
        kind = t._kind;
      if (!(t === type$.Null || t === type$.JSNull))
        if (!A.isSoundTopType(t))
          if (kind !== 7)
            if (!(kind === 6 && A.isNullable(t._primary)))
              t1 = kind === 8 && A.isNullable(t._primary);
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
      else
        t1 = true;
      return t1;
    },
    isDefinitelyTopType(t) {
      var t1;
      if (!A.isSoundTopType(t))
        t1 = t === type$.legacy_Object;
      else
        t1 = true;
      return t1;
    },
    isSoundTopType(t) {
      var kind = t._kind;
      return kind === 2 || kind === 3 || kind === 4 || kind === 5 || t === type$.nullable_Object;
    },
    _Utils_objectAssign(o, other) {
      var i, key,
        keys = Object.keys(other),
        $length = keys.length;
      for (i = 0; i < $length; ++i) {
        key = keys[i];
        o[key] = other[key];
      }
    },
    _Utils_newArrayOrEmpty($length) {
      return $length > 0 ? new Array($length) : init.typeUniverse.sEA;
    },
    Rti: function Rti(t0, t1) {
      var _ = this;
      _._as = t0;
      _._is = t1;
      _._cachedRuntimeType = _._specializedTestResource = _._isSubtypeCache = _._precomputed1 = null;
      _._kind = 0;
      _._canonicalRecipe = _._bindCache = _._evalCache = _._rest = _._primary = null;
    },
    _FunctionParameters: function _FunctionParameters() {
      this._named = this._optionalPositional = this._requiredPositional = null;
    },
    _Type: function _Type(t0) {
      this._rti = t0;
    },
    _Error: function _Error() {
    },
    _TypeError: function _TypeError(t0) {
      this._message = t0;
    },
    _AsyncRun__initializeScheduleImmediate() {
      var div, span, t1 = {};
      if (self.scheduleImmediate != null)
        return A.async__AsyncRun__scheduleImmediateJsOverride$closure();
      if (self.MutationObserver != null && self.document != null) {
        div = self.document.createElement("div");
        span = self.document.createElement("span");
        t1.storedCallback = null;
        new self.MutationObserver(A.convertDartClosureToJS(new A._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
        return new A._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
      } else if (self.setImmediate != null)
        return A.async__AsyncRun__scheduleImmediateWithSetImmediate$closure();
      return A.async__AsyncRun__scheduleImmediateWithTimer$closure();
    },
    _AsyncRun__scheduleImmediateJsOverride(callback) {
      self.scheduleImmediate(A.convertDartClosureToJS(new A._AsyncRun__scheduleImmediateJsOverride_internalCallback(type$.void_Function._as(callback)), 0));
    },
    _AsyncRun__scheduleImmediateWithSetImmediate(callback) {
      self.setImmediate(A.convertDartClosureToJS(new A._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(type$.void_Function._as(callback)), 0));
    },
    _AsyncRun__scheduleImmediateWithTimer(callback) {
      A.Timer__createTimer(B.Duration_0, type$.void_Function._as(callback));
    },
    Timer__createTimer(duration, callback) {
      var milliseconds = B.JSInt_methods._tdivFast$1(duration._duration, 1000);
      return A._TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
    },
    _TimerImpl$(milliseconds, callback) {
      var t1 = new A._TimerImpl();
      t1._TimerImpl$2(milliseconds, callback);
      return t1;
    },
    _makeAsyncAwaitCompleter($T) {
      return new A._AsyncAwaitCompleter(new A._Future($.Zone__current, $T._eval$1("_Future<0>")), $T._eval$1("_AsyncAwaitCompleter<0>"));
    },
    _asyncStartSync(bodyFunction, completer) {
      bodyFunction.call$2(0, null);
      completer.isSync = true;
      return completer._future;
    },
    _asyncAwait(object, bodyFunction) {
      A._awaitOnObject(object, bodyFunction);
    },
    _asyncReturn(object, completer) {
      completer.complete$1(object);
    },
    _asyncRethrow(object, completer) {
      completer.completeError$2(A.unwrapException(object), A.getTraceFromException(object));
    },
    _awaitOnObject(object, bodyFunction) {
      var t1, future,
        thenCallback = new A._awaitOnObject_closure(bodyFunction),
        errorCallback = new A._awaitOnObject_closure0(bodyFunction);
      if (object instanceof A._Future)
        object._thenAwait$1$2(thenCallback, errorCallback, type$.dynamic);
      else {
        t1 = type$.dynamic;
        if (object instanceof A._Future)
          object.then$1$2$onError(thenCallback, errorCallback, t1);
        else {
          future = new A._Future($.Zone__current, type$._Future_dynamic);
          future._state = 8;
          future._resultOrListeners = object;
          future._thenAwait$1$2(thenCallback, errorCallback, t1);
        }
      }
    },
    _wrapJsFunctionForAsync($function) {
      var $protected = function(fn, ERROR) {
        return function(errorCode, result) {
          while (true) {
            try {
              fn(errorCode, result);
              break;
            } catch (error) {
              result = error;
              errorCode = ERROR;
            }
          }
        };
      }($function, 1);
      return $.Zone__current.registerBinaryCallback$3$1(new A._wrapJsFunctionForAsync_closure($protected), type$.void, type$.int, type$.dynamic);
    },
    _SyncStarIterator__terminatedBody(_1, _2, _3) {
      return 0;
    },
    AsyncError$(error, stackTrace) {
      var t1 = A.checkNotNullable(error, "error", type$.Object);
      return new A.AsyncError(t1, stackTrace == null ? A.AsyncError_defaultStackTrace(error) : stackTrace);
    },
    AsyncError_defaultStackTrace(error) {
      var stackTrace;
      if (type$.Error._is(error)) {
        stackTrace = error.get$stackTrace();
        if (stackTrace != null)
          return stackTrace;
      }
      return B.C__StringStackTrace;
    },
    Future_Future$value(value, $T) {
      var t1;
      $T._as(value);
      t1 = new A._Future($.Zone__current, $T._eval$1("_Future<0>"));
      t1._asyncComplete$1(value);
      return t1;
    },
    Future_Future$delayed(duration, $T) {
      var result,
        t1 = !$T._is(null);
      if (t1)
        throw A.wrapException(A.ArgumentError$value(null, "computation", "The type parameter is not nullable"));
      result = new A._Future($.Zone__current, $T._eval$1("_Future<0>"));
      A.Timer_Timer(duration, new A.Future_Future$delayed_closure(null, result, $T));
      return result;
    },
    _completeWithErrorCallback(result, error, stackTrace) {
      if (stackTrace == null)
        stackTrace = A.AsyncError_defaultStackTrace(error);
      result._completeError$2(error, stackTrace);
    },
    _Future__chainCoreFutureSync(source, target) {
      var t1, t2, listeners;
      for (t1 = type$._Future_dynamic; t2 = source._state, (t2 & 4) !== 0;)
        source = t1._as(source._resultOrListeners);
      t1 = t2 | target._state & 1;
      source._state = t1;
      if ((t1 & 24) !== 0) {
        listeners = target._removeListeners$0();
        target._cloneResult$1(source);
        A._Future__propagateToListeners(target, listeners);
      } else {
        listeners = type$.nullable__FutureListener_dynamic_dynamic._as(target._resultOrListeners);
        target._setChained$1(source);
        source._prependListeners$1(listeners);
      }
    },
    _Future__chainCoreFutureAsync(source, target) {
      var t2, t3, listeners, _box_0 = {},
        t1 = _box_0.source = source;
      for (t2 = type$._Future_dynamic; t3 = t1._state, (t3 & 4) !== 0; t1 = source) {
        source = t2._as(t1._resultOrListeners);
        _box_0.source = source;
      }
      if ((t3 & 24) === 0) {
        listeners = type$.nullable__FutureListener_dynamic_dynamic._as(target._resultOrListeners);
        target._setChained$1(t1);
        _box_0.source._prependListeners$1(listeners);
        return;
      }
      if ((t3 & 16) === 0 && target._resultOrListeners == null) {
        target._cloneResult$1(t1);
        return;
      }
      target._state ^= 2;
      A._rootScheduleMicrotask(null, null, target._zone, type$.void_Function._as(new A._Future__chainCoreFutureAsync_closure(_box_0, target)));
    },
    _Future__propagateToListeners(source, listeners) {
      var t2, t3, t4, _box_0, t5, t6, hasError, asyncError, nextListener, nextListener0, sourceResult, t7, zone, oldZone, result, current, _box_1 = {},
        t1 = _box_1.source = source;
      for (t2 = type$.AsyncError, t3 = type$.nullable__FutureListener_dynamic_dynamic, t4 = type$.Future_dynamic; true;) {
        _box_0 = {};
        t5 = t1._state;
        t6 = (t5 & 16) === 0;
        hasError = !t6;
        if (listeners == null) {
          if (hasError && (t5 & 1) === 0) {
            asyncError = t2._as(t1._resultOrListeners);
            A._rootHandleError(asyncError.error, asyncError.stackTrace);
          }
          return;
        }
        _box_0.listener = listeners;
        nextListener = listeners._nextListener;
        for (t1 = listeners; nextListener != null; t1 = nextListener, nextListener = nextListener0) {
          t1._nextListener = null;
          A._Future__propagateToListeners(_box_1.source, t1);
          _box_0.listener = nextListener;
          nextListener0 = nextListener._nextListener;
        }
        t5 = _box_1.source;
        sourceResult = t5._resultOrListeners;
        _box_0.listenerHasError = hasError;
        _box_0.listenerValueOrError = sourceResult;
        if (t6) {
          t7 = t1.state;
          t7 = (t7 & 1) !== 0 || (t7 & 15) === 8;
        } else
          t7 = true;
        if (t7) {
          zone = t1.result._zone;
          if (hasError) {
            t5 = t5._zone === zone;
            t5 = !(t5 || t5);
          } else
            t5 = false;
          if (t5) {
            t2._as(sourceResult);
            A._rootHandleError(sourceResult.error, sourceResult.stackTrace);
            return;
          }
          oldZone = $.Zone__current;
          if (oldZone !== zone)
            $.Zone__current = zone;
          else
            oldZone = null;
          t1 = t1.state;
          if ((t1 & 15) === 8)
            new A._Future__propagateToListeners_handleWhenCompleteCallback(_box_0, _box_1, hasError).call$0();
          else if (t6) {
            if ((t1 & 1) !== 0)
              new A._Future__propagateToListeners_handleValueCallback(_box_0, sourceResult).call$0();
          } else if ((t1 & 2) !== 0)
            new A._Future__propagateToListeners_handleError(_box_1, _box_0).call$0();
          if (oldZone != null)
            $.Zone__current = oldZone;
          t1 = _box_0.listenerValueOrError;
          if (t1 instanceof A._Future) {
            t5 = _box_0.listener.$ti;
            t5 = t5._eval$1("Future<2>")._is(t1) || !t5._rest[1]._is(t1);
          } else
            t5 = false;
          if (t5) {
            t4._as(t1);
            result = _box_0.listener.result;
            if ((t1._state & 24) !== 0) {
              current = t3._as(result._resultOrListeners);
              result._resultOrListeners = null;
              listeners = result._reverseListeners$1(current);
              result._state = t1._state & 30 | result._state & 1;
              result._resultOrListeners = t1._resultOrListeners;
              _box_1.source = t1;
              continue;
            } else
              A._Future__chainCoreFutureSync(t1, result);
            return;
          }
        }
        result = _box_0.listener.result;
        current = t3._as(result._resultOrListeners);
        result._resultOrListeners = null;
        listeners = result._reverseListeners$1(current);
        t1 = _box_0.listenerHasError;
        t5 = _box_0.listenerValueOrError;
        if (!t1) {
          result.$ti._precomputed1._as(t5);
          result._state = 8;
          result._resultOrListeners = t5;
        } else {
          t2._as(t5);
          result._state = result._state & 1 | 16;
          result._resultOrListeners = t5;
        }
        _box_1.source = result;
        t1 = result;
      }
    },
    _registerErrorHandler(errorHandler, zone) {
      var t1;
      if (type$.dynamic_Function_Object_StackTrace._is(errorHandler))
        return zone.registerBinaryCallback$3$1(errorHandler, type$.dynamic, type$.Object, type$.StackTrace);
      t1 = type$.dynamic_Function_Object;
      if (t1._is(errorHandler))
        return t1._as(errorHandler);
      throw A.wrapException(A.ArgumentError$value(errorHandler, "onError", string$.Error_));
    },
    _microtaskLoop() {
      var entry, next;
      for (entry = $._nextCallback; entry != null; entry = $._nextCallback) {
        $._lastPriorityCallback = null;
        next = entry.next;
        $._nextCallback = next;
        if (next == null)
          $._lastCallback = null;
        entry.callback.call$0();
      }
    },
    _startMicrotaskLoop() {
      $._isInCallbackLoop = true;
      try {
        A._microtaskLoop();
      } finally {
        $._lastPriorityCallback = null;
        $._isInCallbackLoop = false;
        if ($._nextCallback != null)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(A.async___startMicrotaskLoop$closure());
      }
    },
    _scheduleAsyncCallback(callback) {
      var newEntry = new A._AsyncCallbackEntry(callback),
        lastCallback = $._lastCallback;
      if (lastCallback == null) {
        $._nextCallback = $._lastCallback = newEntry;
        if (!$._isInCallbackLoop)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(A.async___startMicrotaskLoop$closure());
      } else
        $._lastCallback = lastCallback.next = newEntry;
    },
    _schedulePriorityAsyncCallback(callback) {
      var entry, lastPriorityCallback, next,
        t1 = $._nextCallback;
      if (t1 == null) {
        A._scheduleAsyncCallback(callback);
        $._lastPriorityCallback = $._lastCallback;
        return;
      }
      entry = new A._AsyncCallbackEntry(callback);
      lastPriorityCallback = $._lastPriorityCallback;
      if (lastPriorityCallback == null) {
        entry.next = t1;
        $._nextCallback = $._lastPriorityCallback = entry;
      } else {
        next = lastPriorityCallback.next;
        entry.next = next;
        $._lastPriorityCallback = lastPriorityCallback.next = entry;
        if (next == null)
          $._lastCallback = entry;
      }
    },
    scheduleMicrotask(callback) {
      var _null = null,
        currentZone = $.Zone__current;
      if (B.C__RootZone === currentZone) {
        A._rootScheduleMicrotask(_null, _null, B.C__RootZone, callback);
        return;
      }
      A._rootScheduleMicrotask(_null, _null, currentZone, type$.void_Function._as(currentZone.bindCallbackGuarded$1(callback)));
    },
    Stream_Stream$value(value, $T) {
      var _null = null,
        t1 = $T._eval$1("_AsyncStreamController<0>"),
        t2 = new A._AsyncStreamController(_null, _null, _null, _null, t1);
      t2._async$_add$1(value);
      t2._closeUnchecked$0();
      return new A._ControllerStream(t2, t1._eval$1("_ControllerStream<1>"));
    },
    StreamIterator_StreamIterator(stream, $T) {
      A.checkNotNullable(stream, "stream", type$.Object);
      return new A._StreamIterator($T._eval$1("_StreamIterator<0>"));
    },
    StreamController_StreamController(sync, $T) {
      var _null = null;
      return sync ? new A._SyncStreamController(_null, _null, _null, _null, $T._eval$1("_SyncStreamController<0>")) : new A._AsyncStreamController(_null, _null, _null, _null, $T._eval$1("_AsyncStreamController<0>"));
    },
    _runGuarded(notificationHandler) {
      var e, s, exception;
      if (notificationHandler == null)
        return;
      try {
        notificationHandler.call$0();
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A._rootHandleError(type$.Object._as(e), type$.StackTrace._as(s));
      }
    },
    _BufferingStreamSubscription__registerDataHandler(zone, handleData, $T) {
      var t1 = handleData == null ? A.async___nullDataHandler$closure() : handleData;
      return type$.$env_1_1_void._bind$1($T)._eval$1("1(2)")._as(t1);
    },
    _BufferingStreamSubscription__registerErrorHandler(zone, handleError) {
      if (handleError == null)
        handleError = A.async___nullErrorHandler$closure();
      if (type$.void_Function_Object_StackTrace._is(handleError))
        return zone.registerBinaryCallback$3$1(handleError, type$.dynamic, type$.Object, type$.StackTrace);
      if (type$.void_Function_Object._is(handleError))
        return type$.dynamic_Function_Object._as(handleError);
      throw A.wrapException(A.ArgumentError$(string$.handle, null));
    },
    _BufferingStreamSubscription__registerDoneHandler(zone, handleDone) {
      var t1 = handleDone == null ? A.async___nullDoneHandler$closure() : handleDone;
      return type$.void_Function._as(t1);
    },
    _nullDataHandler(value) {
    },
    _nullErrorHandler(error, stackTrace) {
      A._rootHandleError(type$.Object._as(error), type$.StackTrace._as(stackTrace));
    },
    _nullDoneHandler() {
    },
    _cancelAndValue(subscription, future, value) {
      var cancelFuture = subscription.cancel$0(),
        t1 = $.$get$Future__nullFuture();
      if (cancelFuture !== t1)
        cancelFuture.whenComplete$1(new A._cancelAndValue_closure(future, value));
      else
        future._complete$1(value);
    },
    Timer_Timer(duration, callback) {
      var t1 = $.Zone__current;
      if (t1 === B.C__RootZone)
        return A.Timer__createTimer(duration, type$.void_Function._as(callback));
      return A.Timer__createTimer(duration, type$.void_Function._as(t1.bindCallbackGuarded$1(callback)));
    },
    _rootHandleError(error, stackTrace) {
      A._schedulePriorityAsyncCallback(new A._rootHandleError_closure(error, stackTrace));
    },
    _rootRun($self, $parent, zone, f, $R) {
      var old,
        t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$0();
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$0();
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunUnary($self, $parent, zone, f, arg, $R, $T) {
      var old,
        t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$1(arg);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$1(arg);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunBinary($self, $parent, zone, f, arg1, arg2, $R, T1, T2) {
      var old,
        t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$2(arg1, arg2);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$2(arg1, arg2);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootScheduleMicrotask($self, $parent, zone, f) {
      type$.void_Function._as(f);
      if (B.C__RootZone !== zone)
        f = zone.bindCallbackGuarded$1(f);
      A._scheduleAsyncCallback(f);
    },
    _AsyncRun__initializeScheduleImmediate_internalCallback: function _AsyncRun__initializeScheduleImmediate_internalCallback(t0) {
      this._box_0 = t0;
    },
    _AsyncRun__initializeScheduleImmediate_closure: function _AsyncRun__initializeScheduleImmediate_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.div = t1;
      this.span = t2;
    },
    _AsyncRun__scheduleImmediateJsOverride_internalCallback: function _AsyncRun__scheduleImmediateJsOverride_internalCallback(t0) {
      this.callback = t0;
    },
    _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: function _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(t0) {
      this.callback = t0;
    },
    _TimerImpl: function _TimerImpl() {
      this._handle = null;
    },
    _TimerImpl_internalCallback: function _TimerImpl_internalCallback(t0, t1) {
      this.$this = t0;
      this.callback = t1;
    },
    _AsyncAwaitCompleter: function _AsyncAwaitCompleter(t0, t1) {
      this._future = t0;
      this.isSync = false;
      this.$ti = t1;
    },
    _awaitOnObject_closure: function _awaitOnObject_closure(t0) {
      this.bodyFunction = t0;
    },
    _awaitOnObject_closure0: function _awaitOnObject_closure0(t0) {
      this.bodyFunction = t0;
    },
    _wrapJsFunctionForAsync_closure: function _wrapJsFunctionForAsync_closure(t0) {
      this.$protected = t0;
    },
    _SyncStarIterator: function _SyncStarIterator(t0, t1) {
      var _ = this;
      _._body = t0;
      _._suspendedBodies = _._nestedIterator = _._datum = _._async$_current = null;
      _.$ti = t1;
    },
    _SyncStarIterable: function _SyncStarIterable(t0, t1) {
      this._outerHelper = t0;
      this.$ti = t1;
    },
    AsyncError: function AsyncError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    Future_Future$delayed_closure: function Future_Future$delayed_closure(t0, t1, t2) {
      this.computation = t0;
      this.result = t1;
      this.T = t2;
    },
    TimeoutException: function TimeoutException(t0, t1) {
      this.message = t0;
      this.duration = t1;
    },
    _Completer: function _Completer() {
    },
    _AsyncCompleter: function _AsyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _SyncCompleter: function _SyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _FutureListener: function _FutureListener(t0, t1, t2, t3, t4) {
      var _ = this;
      _._nextListener = null;
      _.result = t0;
      _.state = t1;
      _.callback = t2;
      _.errorCallback = t3;
      _.$ti = t4;
    },
    _Future: function _Future(t0, t1) {
      var _ = this;
      _._state = 0;
      _._zone = t0;
      _._resultOrListeners = null;
      _.$ti = t1;
    },
    _Future__addListener_closure: function _Future__addListener_closure(t0, t1) {
      this.$this = t0;
      this.listener = t1;
    },
    _Future__prependListeners_closure: function _Future__prependListeners_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _Future__chainForeignFuture_closure: function _Future__chainForeignFuture_closure(t0) {
      this.$this = t0;
    },
    _Future__chainForeignFuture_closure0: function _Future__chainForeignFuture_closure0(t0) {
      this.$this = t0;
    },
    _Future__chainForeignFuture_closure1: function _Future__chainForeignFuture_closure1(t0, t1, t2) {
      this.$this = t0;
      this.e = t1;
      this.s = t2;
    },
    _Future__chainCoreFutureAsync_closure: function _Future__chainCoreFutureAsync_closure(t0, t1) {
      this._box_0 = t0;
      this.target = t1;
    },
    _Future__asyncCompleteWithValue_closure: function _Future__asyncCompleteWithValue_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _Future__asyncCompleteError_closure: function _Future__asyncCompleteError_closure(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback: function _Future__propagateToListeners_handleWhenCompleteCallback(t0, t1, t2) {
      this._box_0 = t0;
      this._box_1 = t1;
      this.hasError = t2;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback_closure: function _Future__propagateToListeners_handleWhenCompleteCallback_closure(t0) {
      this.originalSource = t0;
    },
    _Future__propagateToListeners_handleValueCallback: function _Future__propagateToListeners_handleValueCallback(t0, t1) {
      this._box_0 = t0;
      this.sourceResult = t1;
    },
    _Future__propagateToListeners_handleError: function _Future__propagateToListeners_handleError(t0, t1) {
      this._box_1 = t0;
      this._box_0 = t1;
    },
    _Future_timeout_closure: function _Future_timeout_closure(t0, t1) {
      this._future = t0;
      this.timeLimit = t1;
    },
    _Future_timeout_closure0: function _Future_timeout_closure0(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this._future = t2;
    },
    _Future_timeout_closure1: function _Future_timeout_closure1(t0, t1) {
      this._box_0 = t0;
      this._future = t1;
    },
    _AsyncCallbackEntry: function _AsyncCallbackEntry(t0) {
      this.callback = t0;
      this.next = null;
    },
    Stream: function Stream() {
    },
    Stream_length_closure: function Stream_length_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Stream_length_closure0: function Stream_length_closure0(t0, t1) {
      this._box_0 = t0;
      this.future = t1;
    },
    Stream_first_closure: function Stream_first_closure(t0) {
      this.future = t0;
    },
    Stream_first_closure0: function Stream_first_closure0(t0, t1, t2) {
      this.$this = t0;
      this.subscription = t1;
      this.future = t2;
    },
    StreamView: function StreamView() {
    },
    _StreamController: function _StreamController() {
    },
    _StreamController__subscribe_closure: function _StreamController__subscribe_closure(t0) {
      this.$this = t0;
    },
    _StreamController__recordCancel_complete: function _StreamController__recordCancel_complete(t0) {
      this.$this = t0;
    },
    _SyncStreamControllerDispatch: function _SyncStreamControllerDispatch() {
    },
    _AsyncStreamControllerDispatch: function _AsyncStreamControllerDispatch() {
    },
    _AsyncStreamController: function _AsyncStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    _SyncStreamController: function _SyncStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    _ControllerStream: function _ControllerStream(t0, t1) {
      this._controller = t0;
      this.$ti = t1;
    },
    _ControllerSubscription: function _ControllerSubscription(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._controller = t0;
      _._async$_onData = t1;
      _._onError = t2;
      _._onDone = t3;
      _._zone = t4;
      _._state = t5;
      _._pending = _._cancelFuture = null;
      _.$ti = t6;
    },
    _BufferingStreamSubscription: function _BufferingStreamSubscription() {
    },
    _BufferingStreamSubscription__sendError_sendError: function _BufferingStreamSubscription__sendError_sendError(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _BufferingStreamSubscription__sendDone_sendDone: function _BufferingStreamSubscription__sendDone_sendDone(t0) {
      this.$this = t0;
    },
    _StreamImpl: function _StreamImpl() {
    },
    _DelayedEvent: function _DelayedEvent() {
    },
    _DelayedData: function _DelayedData(t0, t1) {
      this.value = t0;
      this.next = null;
      this.$ti = t1;
    },
    _DelayedError: function _DelayedError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
      this.next = null;
    },
    _DelayedDone: function _DelayedDone() {
    },
    _PendingEvents: function _PendingEvents(t0) {
      var _ = this;
      _._state = 0;
      _.lastPendingEvent = _.firstPendingEvent = null;
      _.$ti = t0;
    },
    _PendingEvents_schedule_closure: function _PendingEvents_schedule_closure(t0, t1) {
      this.$this = t0;
      this.dispatch = t1;
    },
    _DoneStreamSubscription: function _DoneStreamSubscription(t0, t1) {
      var _ = this;
      _._state = 1;
      _._zone = t0;
      _._onDone = null;
      _.$ti = t1;
    },
    _StreamIterator: function _StreamIterator(t0) {
      this.$ti = t0;
    },
    _EmptyStream: function _EmptyStream(t0) {
      this.$ti = t0;
    },
    _cancelAndValue_closure: function _cancelAndValue_closure(t0, t1) {
      this.future = t0;
      this.value = t1;
    },
    _Zone: function _Zone() {
    },
    _rootHandleError_closure: function _rootHandleError_closure(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    _RootZone: function _RootZone() {
    },
    _RootZone_bindCallbackGuarded_closure: function _RootZone_bindCallbackGuarded_closure(t0, t1) {
      this.$this = t0;
      this.f = t1;
    },
    _RootZone_bindUnaryCallbackGuarded_closure: function _RootZone_bindUnaryCallbackGuarded_closure(t0, t1, t2) {
      this.$this = t0;
      this.f = t1;
      this.T = t2;
    },
    _HashMap__getTableEntry(table, key) {
      var entry = table[key];
      return entry === table ? null : entry;
    },
    _HashMap__setTableEntry(table, key, value) {
      if (value == null)
        table[key] = table;
      else
        table[key] = value;
    },
    _HashMap__newHashTable() {
      var table = Object.create(null);
      A._HashMap__setTableEntry(table, "<non-identifier-key>", table);
      delete table["<non-identifier-key>"];
      return table;
    },
    LinkedHashMap_LinkedHashMap(equals, hashCode, $K, $V) {
      if (hashCode == null) {
        if (equals == null)
          return new A.JsLinkedHashMap($K._eval$1("@<0>")._bind$1($V)._eval$1("JsLinkedHashMap<1,2>"));
        hashCode = A.collection___defaultHashCode$closure();
      } else {
        if (A.core__identityHashCode$closure() === hashCode && A.core__identical$closure() === equals)
          return new A.JsIdentityLinkedHashMap($K._eval$1("@<0>")._bind$1($V)._eval$1("JsIdentityLinkedHashMap<1,2>"));
        if (equals == null)
          equals = A.collection___defaultEquals$closure();
      }
      return A._LinkedCustomHashMap$(equals, hashCode, null, $K, $V);
    },
    LinkedHashMap_LinkedHashMap$_literal(keyValuePairs, $K, $V) {
      return $K._eval$1("@<0>")._bind$1($V)._eval$1("LinkedHashMap<1,2>")._as(A.fillLiteralMap(keyValuePairs, new A.JsLinkedHashMap($K._eval$1("@<0>")._bind$1($V)._eval$1("JsLinkedHashMap<1,2>"))));
    },
    LinkedHashMap_LinkedHashMap$_empty($K, $V) {
      return new A.JsLinkedHashMap($K._eval$1("@<0>")._bind$1($V)._eval$1("JsLinkedHashMap<1,2>"));
    },
    _LinkedCustomHashMap$(_equals, _hashCode, validKey, $K, $V) {
      return new A._LinkedCustomHashMap(_equals, _hashCode, new A._LinkedCustomHashMap_closure($K), $K._eval$1("@<0>")._bind$1($V)._eval$1("_LinkedCustomHashMap<1,2>"));
    },
    LinkedHashSet_LinkedHashSet($E) {
      return new A._LinkedHashSet($E._eval$1("_LinkedHashSet<0>"));
    },
    LinkedHashSet_LinkedHashSet$_empty($E) {
      return new A._LinkedHashSet($E._eval$1("_LinkedHashSet<0>"));
    },
    _LinkedHashSet__newHashTable() {
      var table = Object.create(null);
      table["<non-identifier-key>"] = table;
      delete table["<non-identifier-key>"];
      return table;
    },
    _LinkedHashSetIterator$(_set, _modifications, $E) {
      var t1 = new A._LinkedHashSetIterator(_set, _modifications, $E._eval$1("_LinkedHashSetIterator<0>"));
      t1._collection$_cell = _set._collection$_first;
      return t1;
    },
    _defaultEquals(a, b) {
      return J.$eq$(a, b);
    },
    _defaultHashCode(a) {
      return J.get$hashCode$(a);
    },
    LinkedHashMap_LinkedHashMap$from(other, $K, $V) {
      var result = A.LinkedHashMap_LinkedHashMap(null, null, $K, $V);
      other.forEach$1(0, new A.LinkedHashMap_LinkedHashMap$from_closure(result, $K, $V));
      return result;
    },
    LinkedHashSet_LinkedHashSet$from(elements, $E) {
      var t1, _i,
        result = A.LinkedHashSet_LinkedHashSet($E);
      for (t1 = elements.length, _i = 0; _i < elements.length; elements.length === t1 || (0, A.throwConcurrentModificationError)(elements), ++_i)
        result.add$1(0, $E._as(elements[_i]));
      return result;
    },
    ListBase__compareAny(a, b) {
      var t1 = type$.Comparable_dynamic;
      return J.compareTo$1$ns(t1._as(a), t1._as(b));
    },
    MapBase_mapToString(m) {
      var result, t1 = {};
      if (A.isToStringVisiting(m))
        return "{...}";
      result = new A.StringBuffer("");
      try {
        B.JSArray_methods.add$1($.toStringVisiting, m);
        result._contents += "{";
        t1.first = true;
        m.forEach$1(0, new A.MapBase_mapToString_closure(t1, result));
        result._contents += "}";
      } finally {
        if (0 >= $.toStringVisiting.length)
          return A.ioore($.toStringVisiting, -1);
        $.toStringVisiting.pop();
      }
      t1 = result._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _HashMap: function _HashMap() {
    },
    _IdentityHashMap: function _IdentityHashMap(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_keys = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _.$ti = t0;
    },
    _HashMapKeyIterable: function _HashMapKeyIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _HashMapKeyIterator: function _HashMapKeyIterator(t0, t1, t2) {
      var _ = this;
      _._collection$_map = t0;
      _._collection$_keys = t1;
      _._offset = 0;
      _._collection$_current = null;
      _.$ti = t2;
    },
    _LinkedCustomHashMap: function _LinkedCustomHashMap(t0, t1, t2, t3) {
      var _ = this;
      _._equals = t0;
      _._hashCode = t1;
      _._validKey = t2;
      _.__js_helper$_length = 0;
      _._last = _._first = _.__js_helper$_rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t3;
    },
    _LinkedCustomHashMap_closure: function _LinkedCustomHashMap_closure(t0) {
      this.K = t0;
    },
    _LinkedHashSet: function _LinkedHashSet(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_last = _._collection$_first = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _._collection$_modifications = 0;
      _.$ti = t0;
    },
    _LinkedHashSetCell: function _LinkedHashSetCell(t0) {
      this._element = t0;
      this._collection$_previous = this._collection$_next = null;
    },
    _LinkedHashSetIterator: function _LinkedHashSetIterator(t0, t1, t2) {
      var _ = this;
      _._set = t0;
      _._collection$_modifications = t1;
      _._collection$_current = _._collection$_cell = null;
      _.$ti = t2;
    },
    LinkedHashMap_LinkedHashMap$from_closure: function LinkedHashMap_LinkedHashMap$from_closure(t0, t1, t2) {
      this.result = t0;
      this.K = t1;
      this.V = t2;
    },
    ListBase: function ListBase() {
    },
    MapBase: function MapBase() {
    },
    MapBase_entries_closure: function MapBase_entries_closure(t0) {
      this.$this = t0;
    },
    MapBase_mapToString_closure: function MapBase_mapToString_closure(t0, t1) {
      this._box_0 = t0;
      this.result = t1;
    },
    UnmodifiableMapBase: function UnmodifiableMapBase() {
    },
    _UnmodifiableMapMixin: function _UnmodifiableMapMixin() {
    },
    MapView: function MapView() {
    },
    UnmodifiableMapView: function UnmodifiableMapView(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    SetBase: function SetBase() {
    },
    _SetBase: function _SetBase() {
    },
    _UnmodifiableMapView_MapView__UnmodifiableMapMixin: function _UnmodifiableMapView_MapView__UnmodifiableMapMixin() {
    },
    _parseJson(source, reviver) {
      var e, exception, t1, parsed = null;
      try {
        parsed = JSON.parse(source);
      } catch (exception) {
        e = A.unwrapException(exception);
        t1 = A.FormatException$(String(e), null, null);
        throw A.wrapException(t1);
      }
      t1 = A._convertJsonToDartLazy(parsed);
      return t1;
    },
    _convertJsonToDartLazy(object) {
      var i;
      if (object == null)
        return null;
      if (typeof object != "object")
        return object;
      if (!Array.isArray(object))
        return new A._JsonMap(object, Object.create(null));
      for (i = 0; i < object.length; ++i)
        object[i] = A._convertJsonToDartLazy(object[i]);
      return object;
    },
    _Utf8Decoder__makeNativeUint8List(codeUnits, start, end) {
      var bytes, t1, i, b,
        $length = end - start;
      if ($length <= 4096)
        bytes = $.$get$_Utf8Decoder__reusableBuffer();
      else
        bytes = new Uint8Array($length);
      for (t1 = J.getInterceptor$asx(codeUnits), i = 0; i < $length; ++i) {
        b = t1.$index(codeUnits, start + i);
        if ((b & 255) !== b)
          b = 255;
        bytes[i] = b;
      }
      return bytes;
    },
    _Utf8Decoder__convertInterceptedUint8List(allowMalformed, codeUnits, start, end) {
      var decoder = allowMalformed ? $.$get$_Utf8Decoder__decoderNonfatal() : $.$get$_Utf8Decoder__decoder();
      if (decoder == null)
        return null;
      if (0 === start && end === codeUnits.length)
        return A._Utf8Decoder__useTextDecoder(decoder, codeUnits);
      return A._Utf8Decoder__useTextDecoder(decoder, codeUnits.subarray(start, end));
    },
    _Utf8Decoder__useTextDecoder(decoder, codeUnits) {
      var t1, exception;
      try {
        t1 = decoder.decode(codeUnits);
        return t1;
      } catch (exception) {
      }
      return null;
    },
    Base64Codec__checkPadding(source, sourceIndex, sourceEnd, firstPadding, paddingCount, $length) {
      if (B.JSInt_methods.$mod($length, 4) !== 0)
        throw A.wrapException(A.FormatException$("Invalid base64 padding, padded length must be multiple of four, is " + $length, source, sourceEnd));
      if (firstPadding + paddingCount !== $length)
        throw A.wrapException(A.FormatException$("Invalid base64 padding, '=' not at the end", source, sourceIndex));
      if (paddingCount > 2)
        throw A.wrapException(A.FormatException$("Invalid base64 padding, more than two '=' characters", source, sourceIndex));
    },
    _Base64Encoder_encodeChunk(alphabet, bytes, start, end, isLast, output, outputIndex, state) {
      var t1, t2, t3, i, byteOr, byte, outputIndex0, t4, outputIndex1,
        bits = state >>> 2,
        expectedChars = 3 - (state & 3);
      for (t1 = J.getInterceptor$asx(bytes), t2 = alphabet.length, t3 = output.length, i = start, byteOr = 0; i < end; ++i) {
        byte = t1.$index(bytes, i);
        byteOr = (byteOr | byte) >>> 0;
        bits = (bits << 8 | byte) & 16777215;
        --expectedChars;
        if (expectedChars === 0) {
          outputIndex0 = outputIndex + 1;
          t4 = bits >>> 18 & 63;
          if (!(t4 < t2))
            return A.ioore(alphabet, t4);
          if (!(outputIndex < t3))
            return A.ioore(output, outputIndex);
          output[outputIndex] = alphabet.charCodeAt(t4);
          outputIndex = outputIndex0 + 1;
          t4 = bits >>> 12 & 63;
          if (!(t4 < t2))
            return A.ioore(alphabet, t4);
          if (!(outputIndex0 < t3))
            return A.ioore(output, outputIndex0);
          output[outputIndex0] = alphabet.charCodeAt(t4);
          outputIndex0 = outputIndex + 1;
          t4 = bits >>> 6 & 63;
          if (!(t4 < t2))
            return A.ioore(alphabet, t4);
          if (!(outputIndex < t3))
            return A.ioore(output, outputIndex);
          output[outputIndex] = alphabet.charCodeAt(t4);
          outputIndex = outputIndex0 + 1;
          t4 = bits & 63;
          if (!(t4 < t2))
            return A.ioore(alphabet, t4);
          if (!(outputIndex0 < t3))
            return A.ioore(output, outputIndex0);
          output[outputIndex0] = alphabet.charCodeAt(t4);
          bits = 0;
          expectedChars = 3;
        }
      }
      if (byteOr >= 0 && byteOr <= 255) {
        if (expectedChars < 3) {
          outputIndex0 = outputIndex + 1;
          outputIndex1 = outputIndex0 + 1;
          if (3 - expectedChars === 1) {
            t1 = bits >>> 2 & 63;
            if (!(t1 < t2))
              return A.ioore(alphabet, t1);
            if (!(outputIndex < t3))
              return A.ioore(output, outputIndex);
            output[outputIndex] = alphabet.charCodeAt(t1);
            t1 = bits << 4 & 63;
            if (!(t1 < t2))
              return A.ioore(alphabet, t1);
            if (!(outputIndex0 < t3))
              return A.ioore(output, outputIndex0);
            output[outputIndex0] = alphabet.charCodeAt(t1);
            outputIndex = outputIndex1 + 1;
            if (!(outputIndex1 < t3))
              return A.ioore(output, outputIndex1);
            output[outputIndex1] = 61;
            if (!(outputIndex < t3))
              return A.ioore(output, outputIndex);
            output[outputIndex] = 61;
          } else {
            t1 = bits >>> 10 & 63;
            if (!(t1 < t2))
              return A.ioore(alphabet, t1);
            if (!(outputIndex < t3))
              return A.ioore(output, outputIndex);
            output[outputIndex] = alphabet.charCodeAt(t1);
            t1 = bits >>> 4 & 63;
            if (!(t1 < t2))
              return A.ioore(alphabet, t1);
            if (!(outputIndex0 < t3))
              return A.ioore(output, outputIndex0);
            output[outputIndex0] = alphabet.charCodeAt(t1);
            outputIndex = outputIndex1 + 1;
            t1 = bits << 2 & 63;
            if (!(t1 < t2))
              return A.ioore(alphabet, t1);
            if (!(outputIndex1 < t3))
              return A.ioore(output, outputIndex1);
            output[outputIndex1] = alphabet.charCodeAt(t1);
            if (!(outputIndex < t3))
              return A.ioore(output, outputIndex);
            output[outputIndex] = 61;
          }
          return 0;
        }
        return (bits << 2 | 3 - expectedChars) >>> 0;
      }
      for (i = start; i < end;) {
        byte = t1.$index(bytes, i);
        if (byte < 0 || byte > 255)
          break;
        ++i;
      }
      throw A.wrapException(A.ArgumentError$value(bytes, "Not a byte value at index " + i + ": 0x" + J.toRadixString$1$n(t1.$index(bytes, i), 16), null));
    },
    _Base64Decoder_decodeChunk(input, start, end, output, outIndex, state) {
      var t1, t2, t3, i, charOr, char, t4, code, outIndex0, expectedPadding,
        _s31_ = "Invalid encoding before padding",
        _s17_ = "Invalid character",
        bits = B.JSInt_methods._shrOtherPositive$1(state, 2),
        count = state & 3,
        inverseAlphabet = $.$get$_Base64Decoder__inverseAlphabet();
      for (t1 = input.length, t2 = inverseAlphabet.length, t3 = output.length, i = start, charOr = 0; i < end; ++i) {
        if (!(i < t1))
          return A.ioore(input, i);
        char = input.charCodeAt(i);
        charOr |= char;
        t4 = char & 127;
        if (!(t4 < t2))
          return A.ioore(inverseAlphabet, t4);
        code = inverseAlphabet[t4];
        if (code >= 0) {
          bits = (bits << 6 | code) & 16777215;
          count = count + 1 & 3;
          if (count === 0) {
            outIndex0 = outIndex + 1;
            if (!(outIndex < t3))
              return A.ioore(output, outIndex);
            output[outIndex] = bits >>> 16 & 255;
            outIndex = outIndex0 + 1;
            if (!(outIndex0 < t3))
              return A.ioore(output, outIndex0);
            output[outIndex0] = bits >>> 8 & 255;
            outIndex0 = outIndex + 1;
            if (!(outIndex < t3))
              return A.ioore(output, outIndex);
            output[outIndex] = bits & 255;
            outIndex = outIndex0;
            bits = 0;
          }
          continue;
        } else if (code === -1 && count > 1) {
          if (charOr > 127)
            break;
          if (count === 3) {
            if ((bits & 3) !== 0)
              throw A.wrapException(A.FormatException$(_s31_, input, i));
            outIndex0 = outIndex + 1;
            if (!(outIndex < t3))
              return A.ioore(output, outIndex);
            output[outIndex] = bits >>> 10;
            if (!(outIndex0 < t3))
              return A.ioore(output, outIndex0);
            output[outIndex0] = bits >>> 2;
          } else {
            if ((bits & 15) !== 0)
              throw A.wrapException(A.FormatException$(_s31_, input, i));
            if (!(outIndex < t3))
              return A.ioore(output, outIndex);
            output[outIndex] = bits >>> 4;
          }
          expectedPadding = (3 - count) * 3;
          if (char === 37)
            expectedPadding += 2;
          return A._Base64Decoder__checkPadding(input, i + 1, end, -expectedPadding - 1);
        }
        throw A.wrapException(A.FormatException$(_s17_, input, i));
      }
      if (charOr >= 0 && charOr <= 127)
        return (bits << 2 | count) >>> 0;
      for (i = start; i < end; ++i) {
        if (!(i < t1))
          return A.ioore(input, i);
        if (input.charCodeAt(i) > 127)
          break;
      }
      throw A.wrapException(A.FormatException$(_s17_, input, i));
    },
    _Base64Decoder__allocateBuffer(input, start, end, state) {
      var paddingStart = A._Base64Decoder__trimPaddingChars(input, start, end),
        $length = (state & 3) + (paddingStart - start),
        bufferLength = B.JSInt_methods._shrOtherPositive$1($length, 2) * 3,
        remainderLength = $length & 3;
      if (remainderLength !== 0 && paddingStart < end)
        bufferLength += remainderLength - 1;
      if (bufferLength > 0)
        return new Uint8Array(bufferLength);
      return $.$get$_Base64Decoder__emptyBuffer();
    },
    _Base64Decoder__trimPaddingChars(input, start, end) {
      var char,
        t1 = input.length,
        newEnd = end,
        index = newEnd,
        padding = 0;
      while (true) {
        if (!(index > start && padding < 2))
          break;
        c$0: {
          --index;
          if (!(index >= 0 && index < t1))
            return A.ioore(input, index);
          char = input.charCodeAt(index);
          if (char === 61) {
            ++padding;
            newEnd = index;
            break c$0;
          }
          if ((char | 32) === 100) {
            if (index === start)
              break;
            --index;
            if (!(index >= 0 && index < t1))
              return A.ioore(input, index);
            char = input.charCodeAt(index);
          }
          if (char === 51) {
            if (index === start)
              break;
            --index;
            if (!(index >= 0 && index < t1))
              return A.ioore(input, index);
            char = input.charCodeAt(index);
          }
          if (char === 37) {
            ++padding;
            newEnd = index;
            break c$0;
          }
          break;
        }
      }
      return newEnd;
    },
    _Base64Decoder__checkPadding(input, start, end, state) {
      var expectedPadding, t1, char;
      if (start === end)
        return state;
      expectedPadding = -state - 1;
      for (t1 = input.length; expectedPadding > 0;) {
        if (!(start < t1))
          return A.ioore(input, start);
        char = input.charCodeAt(start);
        if (expectedPadding === 3) {
          if (char === 61) {
            expectedPadding -= 3;
            ++start;
            break;
          }
          if (char === 37) {
            --expectedPadding;
            ++start;
            if (start === end)
              break;
            if (!(start < t1))
              return A.ioore(input, start);
            char = input.charCodeAt(start);
          } else
            break;
        }
        if ((expectedPadding > 3 ? expectedPadding - 3 : expectedPadding) === 2) {
          if (char !== 51)
            break;
          ++start;
          --expectedPadding;
          if (start === end)
            break;
          if (!(start < t1))
            return A.ioore(input, start);
          char = input.charCodeAt(start);
        }
        if ((char | 32) !== 100)
          break;
        ++start;
        --expectedPadding;
        if (start === end)
          break;
      }
      if (start !== end)
        throw A.wrapException(A.FormatException$("Invalid padding character", input, start));
      return -expectedPadding - 1;
    },
    Encoding_getByName($name) {
      return $.$get$Encoding__nameToEncoding().$index(0, $name.toLowerCase());
    },
    JsonUnsupportedObjectError$(unsupportedObject, cause, partialResult) {
      return new A.JsonUnsupportedObjectError(unsupportedObject, cause);
    },
    _defaultToEncodable(object) {
      return object.toJson$0();
    },
    _JsonStringStringifier$(_sink, _toEncodable) {
      return new A._JsonStringStringifier(_sink, [], A.convert___defaultToEncodable$closure());
    },
    _JsonStringStringifier_stringify(object, toEncodable, indent) {
      var t1,
        output = new A.StringBuffer(""),
        stringifier = A._JsonStringStringifier$(output, toEncodable);
      stringifier.writeObject$1(object);
      t1 = output._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Utf8Decoder_errorDescription(state) {
      switch (state) {
        case 65:
          return "Missing extension byte";
        case 67:
          return "Unexpected extension byte";
        case 69:
          return "Invalid UTF-8 byte";
        case 71:
          return "Overlong encoding";
        case 73:
          return "Out of unicode range";
        case 75:
          return "Encoded surrogate";
        case 77:
          return "Unfinished UTF-8 octet sequence";
        default:
          return "";
      }
    },
    _JsonMap: function _JsonMap(t0, t1) {
      this._original = t0;
      this._processed = t1;
      this._data = null;
    },
    _JsonMapKeyIterable: function _JsonMapKeyIterable(t0) {
      this._parent = t0;
    },
    _Utf8Decoder__decoder_closure: function _Utf8Decoder__decoder_closure() {
    },
    _Utf8Decoder__decoderNonfatal_closure: function _Utf8Decoder__decoderNonfatal_closure() {
    },
    AsciiCodec: function AsciiCodec() {
    },
    _UnicodeSubsetEncoder: function _UnicodeSubsetEncoder() {
    },
    AsciiEncoder: function AsciiEncoder(t0) {
      this._subsetMask = t0;
    },
    _UnicodeSubsetDecoder: function _UnicodeSubsetDecoder() {
    },
    AsciiDecoder: function AsciiDecoder(t0, t1) {
      this._allowInvalid = t0;
      this._subsetMask = t1;
    },
    Base64Codec: function Base64Codec(t0) {
      this._encoder = t0;
    },
    Base64Encoder: function Base64Encoder(t0) {
      this._urlSafe = t0;
    },
    _Base64Encoder: function _Base64Encoder(t0) {
      this._convert$_state = 0;
      this._alphabet = t0;
    },
    Base64Decoder: function Base64Decoder() {
    },
    _Base64Decoder: function _Base64Decoder() {
      this._convert$_state = 0;
    },
    ByteConversionSink: function ByteConversionSink() {
    },
    _ByteCallbackSink: function _ByteCallbackSink(t0, t1) {
      this._callback = t0;
      this._convert$_buffer = t1;
      this._bufferIndex = 0;
    },
    Codec: function Codec() {
    },
    Converter: function Converter() {
    },
    Encoding: function Encoding() {
    },
    JsonUnsupportedObjectError: function JsonUnsupportedObjectError(t0, t1) {
      this.unsupportedObject = t0;
      this.cause = t1;
    },
    JsonCyclicError: function JsonCyclicError(t0, t1) {
      this.unsupportedObject = t0;
      this.cause = t1;
    },
    JsonCodec: function JsonCodec() {
    },
    JsonEncoder: function JsonEncoder(t0) {
      this._toEncodable = t0;
    },
    JsonDecoder: function JsonDecoder(t0) {
      this._reviver = t0;
    },
    _JsonStringifier: function _JsonStringifier() {
    },
    _JsonStringifier_writeMap_closure: function _JsonStringifier_writeMap_closure(t0, t1) {
      this._box_0 = t0;
      this.keyValueList = t1;
    },
    _JsonStringStringifier: function _JsonStringStringifier(t0, t1, t2) {
      this._sink = t0;
      this._seen = t1;
      this._toEncodable = t2;
    },
    Latin1Codec: function Latin1Codec() {
    },
    Latin1Encoder: function Latin1Encoder(t0) {
      this._subsetMask = t0;
    },
    Latin1Decoder: function Latin1Decoder(t0, t1) {
      this._allowInvalid = t0;
      this._subsetMask = t1;
    },
    Utf8Codec: function Utf8Codec() {
    },
    Utf8Encoder: function Utf8Encoder() {
    },
    _Utf8Encoder: function _Utf8Encoder(t0) {
      this._bufferIndex = 0;
      this._convert$_buffer = t0;
    },
    Utf8Decoder: function Utf8Decoder(t0) {
      this._allowMalformed = t0;
    },
    _Utf8Decoder: function _Utf8Decoder(t0) {
      this.allowMalformed = t0;
      this._convert$_state = 16;
      this._charOrIndex = 0;
    },
    _BigIntImpl_parse(source, radix) {
      var result = A._BigIntImpl__tryParse(source, radix);
      if (result == null)
        throw A.wrapException(A.FormatException$("Could not parse BigInt", source, null));
      return result;
    },
    _BigIntImpl__parseDecimal(source, isNegative) {
      var part, i,
        result = $.$get$_BigIntImpl_zero(),
        t1 = source.length,
        digitInPartCount = 4 - t1 % 4;
      if (digitInPartCount === 4)
        digitInPartCount = 0;
      for (part = 0, i = 0; i < t1; ++i) {
        part = part * 10 + source.charCodeAt(i) - 48;
        ++digitInPartCount;
        if (digitInPartCount === 4) {
          result = result.$mul(0, $.$get$_BigIntImpl__bigInt10000()).$add(0, A._BigIntImpl__BigIntImpl$_fromInt(part));
          part = 0;
          digitInPartCount = 0;
        }
      }
      if (isNegative)
        return result.$negate(0);
      return result;
    },
    _BigIntImpl__codeUnitToRadixValue(codeUnit) {
      if (48 <= codeUnit && codeUnit <= 57)
        return codeUnit - 48;
      return (codeUnit | 32) - 97 + 10;
    },
    _BigIntImpl__parseHex(source, startPos, isNegative) {
      var i, chunk, j, i0, digitValue, digitIndex, digitIndex0,
        t1 = source.length,
        sourceLength = t1 - startPos,
        chunkCount = B.JSNumber_methods.ceil$0(sourceLength / 4),
        digits = new Uint16Array(chunkCount),
        t2 = chunkCount - 1,
        lastDigitLength = sourceLength - t2 * 4;
      for (i = startPos, chunk = 0, j = 0; j < lastDigitLength; ++j, i = i0) {
        i0 = i + 1;
        if (!(i < t1))
          return A.ioore(source, i);
        digitValue = A._BigIntImpl__codeUnitToRadixValue(source.charCodeAt(i));
        if (digitValue >= 16)
          return null;
        chunk = chunk * 16 + digitValue;
      }
      digitIndex = t2 - 1;
      if (!(t2 >= 0 && t2 < chunkCount))
        return A.ioore(digits, t2);
      digits[t2] = chunk;
      for (; i < t1; digitIndex = digitIndex0) {
        for (chunk = 0, j = 0; j < 4; ++j, i = i0) {
          i0 = i + 1;
          if (!(i >= 0 && i < t1))
            return A.ioore(source, i);
          digitValue = A._BigIntImpl__codeUnitToRadixValue(source.charCodeAt(i));
          if (digitValue >= 16)
            return null;
          chunk = chunk * 16 + digitValue;
        }
        digitIndex0 = digitIndex - 1;
        if (!(digitIndex >= 0 && digitIndex < chunkCount))
          return A.ioore(digits, digitIndex);
        digits[digitIndex] = chunk;
      }
      if (chunkCount === 1) {
        if (0 >= chunkCount)
          return A.ioore(digits, 0);
        t1 = digits[0] === 0;
      } else
        t1 = false;
      if (t1)
        return $.$get$_BigIntImpl_zero();
      t1 = A._BigIntImpl__normalize(chunkCount, digits);
      return new A._BigIntImpl(t1 === 0 ? false : isNegative, digits, t1);
    },
    _BigIntImpl__parseRadix(source, radix, isNegative) {
      var t1, i, digitValue,
        result = $.$get$_BigIntImpl_zero(),
        base = A._BigIntImpl__BigIntImpl$_fromInt(radix);
      for (t1 = source.length, i = 0; i < t1; ++i) {
        digitValue = A._BigIntImpl__codeUnitToRadixValue(source.charCodeAt(i));
        if (digitValue >= radix)
          return null;
        result = result.$mul(0, base).$add(0, A._BigIntImpl__BigIntImpl$_fromInt(digitValue));
      }
      if (isNegative)
        return result.$negate(0);
      return result;
    },
    _BigIntImpl__tryParse(source, radix) {
      var match, t1, t2, isNegative, decimalMatch, hexMatch, nonDecimalMatch, _null = null;
      if (source === "")
        return _null;
      match = $.$get$_BigIntImpl__parseRE().firstMatch$1(source);
      if (match == null)
        return _null;
      t1 = match._match;
      t2 = t1.length;
      if (1 >= t2)
        return A.ioore(t1, 1);
      isNegative = t1[1] === "-";
      if (4 >= t2)
        return A.ioore(t1, 4);
      decimalMatch = t1[4];
      hexMatch = t1[3];
      if (5 >= t2)
        return A.ioore(t1, 5);
      nonDecimalMatch = t1[5];
      if (radix == null) {
        if (decimalMatch != null)
          return A._BigIntImpl__parseDecimal(decimalMatch, isNegative);
        if (hexMatch != null)
          return A._BigIntImpl__parseHex(hexMatch, 2, isNegative);
        return _null;
      }
      if (radix < 2 || radix > 36)
        throw A.wrapException(A.RangeError$range(radix, 2, 36, "radix", _null));
      if (radix === 10 && decimalMatch != null)
        return A._BigIntImpl__parseDecimal(decimalMatch, isNegative);
      if (radix === 16)
        t1 = decimalMatch != null || nonDecimalMatch != null;
      else
        t1 = false;
      if (t1) {
        if (decimalMatch == null) {
          nonDecimalMatch.toString;
          t1 = nonDecimalMatch;
        } else
          t1 = decimalMatch;
        return A._BigIntImpl__parseHex(t1, 0, isNegative);
      }
      t1 = decimalMatch == null ? nonDecimalMatch : decimalMatch;
      if (t1 == null) {
        hexMatch.toString;
        t1 = hexMatch;
      }
      return A._BigIntImpl__parseRadix(t1, radix, isNegative);
    },
    _BigIntImpl__normalize(used, digits) {
      var t2,
        t1 = digits.length;
      while (true) {
        if (used > 0) {
          t2 = used - 1;
          if (!(t2 < t1))
            return A.ioore(digits, t2);
          t2 = digits[t2] === 0;
        } else
          t2 = false;
        if (!t2)
          break;
        --used;
      }
      return used;
    },
    _BigIntImpl__cloneDigits(digits, from, to, $length) {
      var t1, i, t2,
        resultDigits = new Uint16Array($length),
        n = to - from;
      for (t1 = digits.length, i = 0; i < n; ++i) {
        t2 = from + i;
        if (!(t2 >= 0 && t2 < t1))
          return A.ioore(digits, t2);
        t2 = digits[t2];
        if (!(i < $length))
          return A.ioore(resultDigits, i);
        resultDigits[i] = t2;
      }
      return resultDigits;
    },
    _BigIntImpl__BigIntImpl$from(value) {
      var t1;
      if (value === 0)
        return $.$get$_BigIntImpl_zero();
      if (value === 1)
        return $.$get$_BigIntImpl_one();
      if (value === 2)
        return $.$get$_BigIntImpl_two();
      if (Math.abs(value) < 4294967296)
        return A._BigIntImpl__BigIntImpl$_fromInt(B.JSNumber_methods.toInt$0(value));
      t1 = A._BigIntImpl__BigIntImpl$_fromDouble(value);
      return t1;
    },
    _BigIntImpl__BigIntImpl$_fromInt(value) {
      var digits, t1, i, i0,
        isNegative = value < 0;
      if (isNegative) {
        if (value === -9223372036854776e3) {
          digits = new Uint16Array(4);
          digits[3] = 32768;
          t1 = A._BigIntImpl__normalize(4, digits);
          return new A._BigIntImpl(t1 !== 0, digits, t1);
        }
        value = -value;
      }
      if (value < 65536) {
        digits = new Uint16Array(1);
        digits[0] = value;
        t1 = A._BigIntImpl__normalize(1, digits);
        return new A._BigIntImpl(t1 === 0 ? false : isNegative, digits, t1);
      }
      if (value <= 4294967295) {
        digits = new Uint16Array(2);
        digits[0] = value & 65535;
        digits[1] = B.JSInt_methods._shrOtherPositive$1(value, 16);
        t1 = A._BigIntImpl__normalize(2, digits);
        return new A._BigIntImpl(t1 === 0 ? false : isNegative, digits, t1);
      }
      t1 = B.JSInt_methods._tdivFast$1(B.JSInt_methods.get$bitLength(value) - 1, 16) + 1;
      digits = new Uint16Array(t1);
      for (i = 0; value !== 0; i = i0) {
        i0 = i + 1;
        if (!(i < t1))
          return A.ioore(digits, i);
        digits[i] = value & 65535;
        value = B.JSInt_methods._tdivFast$1(value, 65536);
      }
      t1 = A._BigIntImpl__normalize(t1, digits);
      return new A._BigIntImpl(t1 === 0 ? false : isNegative, digits, t1);
    },
    _BigIntImpl__BigIntImpl$_fromDouble(value) {
      var isNegative, bits, i, t1, t2, exponent, unshiftedDigits, unshiftedBig, absResult;
      if (isNaN(value) || value == 1 / 0 || value == -1 / 0)
        throw A.wrapException(A.ArgumentError$("Value must be finite: " + A.S(value), null));
      isNegative = value < 0;
      if (isNegative)
        value = -value;
      value = Math.floor(value);
      if (value === 0)
        return $.$get$_BigIntImpl_zero();
      bits = $.$get$_BigIntImpl__bitsForFromDouble();
      for (i = 0; i < 8; ++i)
        bits[i] = 0;
      B.NativeByteData_methods._setFloat64$3(A.NativeByteData_NativeByteData$view(bits.buffer, 0, null), 0, value, true);
      t1 = bits[7];
      t2 = bits[6];
      exponent = (t1 << 4 >>> 0) + (t2 >>> 4) - 1075;
      unshiftedDigits = new Uint16Array(4);
      unshiftedDigits[0] = (bits[1] << 8 >>> 0) + bits[0];
      unshiftedDigits[1] = (bits[3] << 8 >>> 0) + bits[2];
      unshiftedDigits[2] = (bits[5] << 8 >>> 0) + bits[4];
      unshiftedDigits[3] = t2 & 15 | 16;
      unshiftedBig = new A._BigIntImpl(false, unshiftedDigits, 4);
      if (exponent < 0)
        absResult = unshiftedBig.$shr(0, -exponent);
      else
        absResult = exponent > 0 ? unshiftedBig.$shl(0, exponent) : unshiftedBig;
      if (isNegative)
        return absResult.$negate(0);
      return absResult;
    },
    _BigIntImpl__dlShiftDigits(xDigits, xUsed, n, resultDigits) {
      var i, t1, t2, t3, t4;
      if (xUsed === 0)
        return 0;
      if (n === 0 && resultDigits === xDigits)
        return xUsed;
      for (i = xUsed - 1, t1 = xDigits.length, t2 = resultDigits.length; i >= 0; --i) {
        t3 = i + n;
        if (!(i < t1))
          return A.ioore(xDigits, i);
        t4 = xDigits[i];
        if (!(t3 >= 0 && t3 < t2))
          return A.ioore(resultDigits, t3);
        resultDigits[t3] = t4;
      }
      for (i = n - 1; i >= 0; --i) {
        if (!(i < t2))
          return A.ioore(resultDigits, i);
        resultDigits[i] = 0;
      }
      return xUsed + n;
    },
    _BigIntImpl__lsh(xDigits, xUsed, n, resultDigits) {
      var i, t1, t2, carry, digit, t3, t4,
        digitShift = B.JSInt_methods._tdivFast$1(n, 16),
        bitShift = B.JSInt_methods.$mod(n, 16),
        carryBitShift = 16 - bitShift,
        bitMask = B.JSInt_methods.$shl(1, carryBitShift) - 1;
      for (i = xUsed - 1, t1 = xDigits.length, t2 = resultDigits.length, carry = 0; i >= 0; --i) {
        if (!(i < t1))
          return A.ioore(xDigits, i);
        digit = xDigits[i];
        t3 = i + digitShift + 1;
        t4 = B.JSInt_methods._shrReceiverPositive$1(digit, carryBitShift);
        if (!(t3 >= 0 && t3 < t2))
          return A.ioore(resultDigits, t3);
        resultDigits[t3] = (t4 | carry) >>> 0;
        carry = B.JSInt_methods.$shl(digit & bitMask, bitShift);
      }
      if (!(digitShift >= 0 && digitShift < t2))
        return A.ioore(resultDigits, digitShift);
      resultDigits[digitShift] = carry;
    },
    _BigIntImpl__lShiftDigits(xDigits, xUsed, n, resultDigits) {
      var resultUsed, t1, i, t2,
        digitsShift = B.JSInt_methods._tdivFast$1(n, 16);
      if (B.JSInt_methods.$mod(n, 16) === 0)
        return A._BigIntImpl__dlShiftDigits(xDigits, xUsed, digitsShift, resultDigits);
      resultUsed = xUsed + digitsShift + 1;
      A._BigIntImpl__lsh(xDigits, xUsed, n, resultDigits);
      for (t1 = resultDigits.length, i = digitsShift; --i, i >= 0;) {
        if (!(i < t1))
          return A.ioore(resultDigits, i);
        resultDigits[i] = 0;
      }
      t2 = resultUsed - 1;
      if (!(t2 >= 0 && t2 < t1))
        return A.ioore(resultDigits, t2);
      if (resultDigits[t2] === 0)
        resultUsed = t2;
      return resultUsed;
    },
    _BigIntImpl__rsh(xDigits, xUsed, n, resultDigits) {
      var carry, last, t2, i, t3, digit,
        digitsShift = B.JSInt_methods._tdivFast$1(n, 16),
        bitShift = B.JSInt_methods.$mod(n, 16),
        carryBitShift = 16 - bitShift,
        bitMask = B.JSInt_methods.$shl(1, bitShift) - 1,
        t1 = xDigits.length;
      if (!(digitsShift >= 0 && digitsShift < t1))
        return A.ioore(xDigits, digitsShift);
      carry = B.JSInt_methods._shrReceiverPositive$1(xDigits[digitsShift], bitShift);
      last = xUsed - digitsShift - 1;
      for (t2 = resultDigits.length, i = 0; i < last; ++i) {
        t3 = i + digitsShift + 1;
        if (!(t3 < t1))
          return A.ioore(xDigits, t3);
        digit = xDigits[t3];
        t3 = B.JSInt_methods.$shl((digit & bitMask) >>> 0, carryBitShift);
        if (!(i < t2))
          return A.ioore(resultDigits, i);
        resultDigits[i] = (t3 | carry) >>> 0;
        carry = B.JSInt_methods._shrReceiverPositive$1(digit, bitShift);
      }
      if (!(last >= 0 && last < t2))
        return A.ioore(resultDigits, last);
      resultDigits[last] = carry;
    },
    _BigIntImpl__compareDigits(digits, used, otherDigits, otherUsed) {
      var i, t1, t2, t3,
        result = used - otherUsed;
      if (result === 0)
        for (i = used - 1, t1 = digits.length, t2 = otherDigits.length; i >= 0; --i) {
          if (!(i < t1))
            return A.ioore(digits, i);
          t3 = digits[i];
          if (!(i < t2))
            return A.ioore(otherDigits, i);
          result = t3 - otherDigits[i];
          if (result !== 0)
            return result;
        }
      return result;
    },
    _BigIntImpl__absAdd(digits, used, otherDigits, otherUsed, resultDigits) {
      var t1, t2, t3, carry, i, t4;
      for (t1 = digits.length, t2 = otherDigits.length, t3 = resultDigits.length, carry = 0, i = 0; i < otherUsed; ++i) {
        if (!(i < t1))
          return A.ioore(digits, i);
        t4 = digits[i];
        if (!(i < t2))
          return A.ioore(otherDigits, i);
        carry += t4 + otherDigits[i];
        if (!(i < t3))
          return A.ioore(resultDigits, i);
        resultDigits[i] = carry & 65535;
        carry = carry >>> 16;
      }
      for (i = otherUsed; i < used; ++i) {
        if (!(i >= 0 && i < t1))
          return A.ioore(digits, i);
        carry += digits[i];
        if (!(i < t3))
          return A.ioore(resultDigits, i);
        resultDigits[i] = carry & 65535;
        carry = carry >>> 16;
      }
      if (!(used >= 0 && used < t3))
        return A.ioore(resultDigits, used);
      resultDigits[used] = carry;
    },
    _BigIntImpl__absSub(digits, used, otherDigits, otherUsed, resultDigits) {
      var t1, t2, t3, carry, i, t4;
      for (t1 = digits.length, t2 = otherDigits.length, t3 = resultDigits.length, carry = 0, i = 0; i < otherUsed; ++i) {
        if (!(i < t1))
          return A.ioore(digits, i);
        t4 = digits[i];
        if (!(i < t2))
          return A.ioore(otherDigits, i);
        carry += t4 - otherDigits[i];
        if (!(i < t3))
          return A.ioore(resultDigits, i);
        resultDigits[i] = carry & 65535;
        carry = 0 - (B.JSInt_methods._shrOtherPositive$1(carry, 16) & 1);
      }
      for (i = otherUsed; i < used; ++i) {
        if (!(i >= 0 && i < t1))
          return A.ioore(digits, i);
        carry += digits[i];
        if (!(i < t3))
          return A.ioore(resultDigits, i);
        resultDigits[i] = carry & 65535;
        carry = 0 - (B.JSInt_methods._shrOtherPositive$1(carry, 16) & 1);
      }
    },
    _BigIntImpl__mulAdd(x, multiplicandDigits, i, accumulatorDigits, j, n) {
      var t1, t2, c, i0, t3, combined, j0, l;
      if (x === 0)
        return;
      for (t1 = multiplicandDigits.length, t2 = accumulatorDigits.length, c = 0; --n, n >= 0; j = j0, i = i0) {
        i0 = i + 1;
        if (!(i < t1))
          return A.ioore(multiplicandDigits, i);
        t3 = multiplicandDigits[i];
        if (!(j >= 0 && j < t2))
          return A.ioore(accumulatorDigits, j);
        combined = x * t3 + accumulatorDigits[j] + c;
        j0 = j + 1;
        accumulatorDigits[j] = combined & 65535;
        c = B.JSInt_methods._tdivFast$1(combined, 65536);
      }
      for (; c !== 0; j = j0) {
        if (!(j >= 0 && j < t2))
          return A.ioore(accumulatorDigits, j);
        l = accumulatorDigits[j] + c;
        j0 = j + 1;
        accumulatorDigits[j] = l & 65535;
        c = B.JSInt_methods._tdivFast$1(l, 65536);
      }
    },
    _BigIntImpl__mulDigits(xDigits, xUsed, otherDigits, otherUsed, resultDigits) {
      var t1, i,
        resultUsed = xUsed + otherUsed;
      for (t1 = resultDigits.length, i = resultUsed; --i, i >= 0;) {
        if (!(i < t1))
          return A.ioore(resultDigits, i);
        resultDigits[i] = 0;
      }
      for (t1 = otherDigits.length, i = 0; i < otherUsed;) {
        if (!(i < t1))
          return A.ioore(otherDigits, i);
        A._BigIntImpl__mulAdd(otherDigits[i], xDigits, 0, resultDigits, i, xUsed);
        ++i;
      }
      return resultUsed;
    },
    _BigIntImpl__estimateQuotientDigit(topDigitDivisor, digits, i) {
      var t2, t3, quotientDigit,
        t1 = digits.length;
      if (!(i >= 0 && i < t1))
        return A.ioore(digits, i);
      t2 = digits[i];
      if (t2 === topDigitDivisor)
        return 65535;
      t3 = i - 1;
      if (!(t3 >= 0 && t3 < t1))
        return A.ioore(digits, t3);
      quotientDigit = B.JSInt_methods.$tdiv((t2 << 16 | digits[t3]) >>> 0, topDigitDivisor);
      if (quotientDigit > 65535)
        return 65535;
      return quotientDigit;
    },
    _BigIntImpl__binaryGcd(x, y, inv) {
      var t1, uDigits, vDigits, ac, abcdUsed, abcdLen, aDigits, cDigits, bDigits, dDigits, t2, t3, t4, aIsNegative, cIsNegative, bIsNegative, dIsNegative, t5, a_cmp_c, b_cmp_d, c_cmp_a, d_cmp_b, i,
        _s11_ = "Not coprime",
        xUsed = x._used,
        yUsed = y._used,
        maxUsed = xUsed > yUsed ? xUsed : yUsed,
        xDigits = A._BigIntImpl__cloneDigits(x._digits, 0, xUsed, maxUsed),
        yDigits = A._BigIntImpl__cloneDigits(y._digits, 0, yUsed, maxUsed);
      if (yUsed === 1) {
        if (0 >= yDigits.length)
          return A.ioore(yDigits, 0);
        t1 = yDigits[0] === 1;
      } else
        t1 = false;
      if (t1)
        return $.$get$_BigIntImpl_one();
      if (yUsed !== 0) {
        if (0 >= yDigits.length)
          return A.ioore(yDigits, 0);
        if ((yDigits[0] & 1) === 0) {
          if (0 >= xDigits.length)
            return A.ioore(xDigits, 0);
          t1 = (xDigits[0] & 1) === 0;
        } else
          t1 = false;
      } else
        t1 = true;
      if (t1)
        throw A.wrapException(A.Exception_Exception(_s11_));
      uDigits = A._BigIntImpl__cloneDigits(xDigits, 0, xUsed, maxUsed);
      vDigits = A._BigIntImpl__cloneDigits(yDigits, 0, yUsed, maxUsed + 2);
      if (0 >= xDigits.length)
        return A.ioore(xDigits, 0);
      ac = (xDigits[0] & 1) === 0;
      abcdUsed = maxUsed + 1;
      abcdLen = abcdUsed + 2;
      aDigits = $.$get$_dummyList();
      if (ac) {
        aDigits = new Uint16Array(abcdLen);
        if (0 >= abcdLen)
          return A.ioore(aDigits, 0);
        aDigits[0] = 1;
        cDigits = new Uint16Array(abcdLen);
      } else
        cDigits = aDigits;
      bDigits = new Uint16Array(abcdLen);
      dDigits = new Uint16Array(abcdLen);
      if (0 >= abcdLen)
        return A.ioore(dDigits, 0);
      dDigits[0] = 1;
      for (t1 = uDigits.length, t2 = vDigits.length, t3 = cDigits.length, t4 = aDigits.length, aIsNegative = false, cIsNegative = false, bIsNegative = false, dIsNegative = false; true;) {
        if (0 >= t1)
          return A.ioore(uDigits, 0);
        for (; (uDigits[0] & 1) === 0;) {
          A._BigIntImpl__rsh(uDigits, maxUsed, 1, uDigits);
          if (ac) {
            if (0 >= t4)
              return A.ioore(aDigits, 0);
            if ((aDigits[0] & 1) !== 1) {
              if (0 >= abcdLen)
                return A.ioore(bDigits, 0);
              t5 = (bDigits[0] & 1) === 1;
            } else
              t5 = true;
            if (t5) {
              if (aIsNegative) {
                if (!(maxUsed >= 0 && maxUsed < t4))
                  return A.ioore(aDigits, maxUsed);
                aIsNegative = aDigits[maxUsed] !== 0 || A._BigIntImpl__compareDigits(aDigits, maxUsed, yDigits, maxUsed) > 0;
                if (aIsNegative)
                  A._BigIntImpl__absSub(aDigits, abcdUsed, yDigits, maxUsed, aDigits);
                else
                  A._BigIntImpl__absSub(yDigits, maxUsed, aDigits, maxUsed, aDigits);
              } else
                A._BigIntImpl__absAdd(aDigits, abcdUsed, yDigits, maxUsed, aDigits);
              if (bIsNegative)
                A._BigIntImpl__absAdd(bDigits, abcdUsed, xDigits, maxUsed, bDigits);
              else {
                if (!(maxUsed >= 0 && maxUsed < abcdLen))
                  return A.ioore(bDigits, maxUsed);
                t5 = bDigits[maxUsed] !== 0 || A._BigIntImpl__compareDigits(bDigits, maxUsed, xDigits, maxUsed) > 0;
                if (t5)
                  A._BigIntImpl__absSub(bDigits, abcdUsed, xDigits, maxUsed, bDigits);
                else
                  A._BigIntImpl__absSub(xDigits, maxUsed, bDigits, maxUsed, bDigits);
                bIsNegative = !t5;
              }
            }
            A._BigIntImpl__rsh(aDigits, abcdUsed, 1, aDigits);
          } else {
            if (0 >= abcdLen)
              return A.ioore(bDigits, 0);
            if ((bDigits[0] & 1) === 1)
              if (bIsNegative)
                A._BigIntImpl__absAdd(bDigits, abcdUsed, xDigits, maxUsed, bDigits);
              else {
                if (!(maxUsed >= 0 && maxUsed < abcdLen))
                  return A.ioore(bDigits, maxUsed);
                t5 = bDigits[maxUsed] !== 0 || A._BigIntImpl__compareDigits(bDigits, maxUsed, xDigits, maxUsed) > 0;
                if (t5)
                  A._BigIntImpl__absSub(bDigits, abcdUsed, xDigits, maxUsed, bDigits);
                else
                  A._BigIntImpl__absSub(xDigits, maxUsed, bDigits, maxUsed, bDigits);
                bIsNegative = !t5;
              }
          }
          A._BigIntImpl__rsh(bDigits, abcdUsed, 1, bDigits);
        }
        if (0 >= t2)
          return A.ioore(vDigits, 0);
        for (; (vDigits[0] & 1) === 0;) {
          A._BigIntImpl__rsh(vDigits, maxUsed, 1, vDigits);
          if (ac) {
            if (0 >= t3)
              return A.ioore(cDigits, 0);
            if ((cDigits[0] & 1) === 1 || (dDigits[0] & 1) === 1) {
              if (cIsNegative) {
                if (!(maxUsed >= 0 && maxUsed < t3))
                  return A.ioore(cDigits, maxUsed);
                cIsNegative = cDigits[maxUsed] !== 0 || A._BigIntImpl__compareDigits(cDigits, maxUsed, yDigits, maxUsed) > 0;
                if (cIsNegative)
                  A._BigIntImpl__absSub(cDigits, abcdUsed, yDigits, maxUsed, cDigits);
                else
                  A._BigIntImpl__absSub(yDigits, maxUsed, cDigits, maxUsed, cDigits);
              } else
                A._BigIntImpl__absAdd(cDigits, abcdUsed, yDigits, maxUsed, cDigits);
              if (dIsNegative)
                A._BigIntImpl__absAdd(dDigits, abcdUsed, xDigits, maxUsed, dDigits);
              else {
                if (!(maxUsed >= 0 && maxUsed < abcdLen))
                  return A.ioore(dDigits, maxUsed);
                t5 = dDigits[maxUsed] !== 0 || A._BigIntImpl__compareDigits(dDigits, maxUsed, xDigits, maxUsed) > 0;
                if (t5)
                  A._BigIntImpl__absSub(dDigits, abcdUsed, xDigits, maxUsed, dDigits);
                else
                  A._BigIntImpl__absSub(xDigits, maxUsed, dDigits, maxUsed, dDigits);
                dIsNegative = !t5;
              }
            }
            A._BigIntImpl__rsh(cDigits, abcdUsed, 1, cDigits);
          } else if ((dDigits[0] & 1) === 1)
            if (dIsNegative)
              A._BigIntImpl__absAdd(dDigits, abcdUsed, xDigits, maxUsed, dDigits);
            else {
              if (!(maxUsed >= 0 && maxUsed < abcdLen))
                return A.ioore(dDigits, maxUsed);
              t5 = dDigits[maxUsed] !== 0 || A._BigIntImpl__compareDigits(dDigits, maxUsed, xDigits, maxUsed) > 0;
              if (t5)
                A._BigIntImpl__absSub(dDigits, abcdUsed, xDigits, maxUsed, dDigits);
              else
                A._BigIntImpl__absSub(xDigits, maxUsed, dDigits, maxUsed, dDigits);
              dIsNegative = !t5;
            }
          A._BigIntImpl__rsh(dDigits, abcdUsed, 1, dDigits);
        }
        if (A._BigIntImpl__compareDigits(uDigits, maxUsed, vDigits, maxUsed) >= 0) {
          A._BigIntImpl__absSub(uDigits, maxUsed, vDigits, maxUsed, uDigits);
          if (ac)
            if (aIsNegative === cIsNegative) {
              a_cmp_c = A._BigIntImpl__compareDigits(aDigits, abcdUsed, cDigits, abcdUsed);
              if (a_cmp_c > 0)
                A._BigIntImpl__absSub(aDigits, abcdUsed, cDigits, abcdUsed, aDigits);
              else {
                A._BigIntImpl__absSub(cDigits, abcdUsed, aDigits, abcdUsed, aDigits);
                aIsNegative = !aIsNegative && a_cmp_c !== 0;
              }
            } else
              A._BigIntImpl__absAdd(aDigits, abcdUsed, cDigits, abcdUsed, aDigits);
          if (bIsNegative === dIsNegative) {
            b_cmp_d = A._BigIntImpl__compareDigits(bDigits, abcdUsed, dDigits, abcdUsed);
            if (b_cmp_d > 0)
              A._BigIntImpl__absSub(bDigits, abcdUsed, dDigits, abcdUsed, bDigits);
            else {
              A._BigIntImpl__absSub(dDigits, abcdUsed, bDigits, abcdUsed, bDigits);
              bIsNegative = !bIsNegative && b_cmp_d !== 0;
            }
          } else
            A._BigIntImpl__absAdd(bDigits, abcdUsed, dDigits, abcdUsed, bDigits);
        } else {
          A._BigIntImpl__absSub(vDigits, maxUsed, uDigits, maxUsed, vDigits);
          if (ac)
            if (cIsNegative === aIsNegative) {
              c_cmp_a = A._BigIntImpl__compareDigits(cDigits, abcdUsed, aDigits, abcdUsed);
              if (c_cmp_a > 0)
                A._BigIntImpl__absSub(cDigits, abcdUsed, aDigits, abcdUsed, cDigits);
              else {
                A._BigIntImpl__absSub(aDigits, abcdUsed, cDigits, abcdUsed, cDigits);
                cIsNegative = !cIsNegative && c_cmp_a !== 0;
              }
            } else
              A._BigIntImpl__absAdd(cDigits, abcdUsed, aDigits, abcdUsed, cDigits);
          if (dIsNegative === bIsNegative) {
            d_cmp_b = A._BigIntImpl__compareDigits(dDigits, abcdUsed, bDigits, abcdUsed);
            if (d_cmp_b > 0)
              A._BigIntImpl__absSub(dDigits, abcdUsed, bDigits, abcdUsed, dDigits);
            else {
              A._BigIntImpl__absSub(bDigits, abcdUsed, dDigits, abcdUsed, dDigits);
              dIsNegative = !dIsNegative && d_cmp_b !== 0;
            }
          } else
            A._BigIntImpl__absAdd(dDigits, abcdUsed, bDigits, abcdUsed, dDigits);
        }
        i = maxUsed;
        while (true) {
          if (i > 0) {
            t5 = i - 1;
            if (!(t5 < t1))
              return A.ioore(uDigits, t5);
            t5 = uDigits[t5] === 0;
          } else
            t5 = false;
          if (!t5)
            break;
          --i;
        }
        if (i === 0)
          break;
      }
      i = maxUsed - 1;
      while (true) {
        if (i > 0) {
          if (!(i < t2))
            return A.ioore(vDigits, i);
          t1 = vDigits[i] === 0;
        } else
          t1 = false;
        if (!t1)
          break;
        --i;
      }
      if (i === 0) {
        if (0 >= t2)
          return A.ioore(vDigits, 0);
        t1 = vDigits[0] !== 1;
      } else
        t1 = true;
      if (t1)
        throw A.wrapException(A.Exception_Exception(_s11_));
      if (dIsNegative) {
        if (!(maxUsed >= 0 && maxUsed < abcdLen))
          return A.ioore(dDigits, maxUsed);
        while (true) {
          if (!(dDigits[maxUsed] !== 0 || A._BigIntImpl__compareDigits(dDigits, maxUsed, xDigits, maxUsed) > 0))
            break;
          A._BigIntImpl__absSub(dDigits, abcdUsed, xDigits, maxUsed, dDigits);
        }
        A._BigIntImpl__absSub(xDigits, maxUsed, dDigits, maxUsed, dDigits);
      } else {
        if (!(maxUsed >= 0 && maxUsed < abcdLen))
          return A.ioore(dDigits, maxUsed);
        while (true) {
          if (!(dDigits[maxUsed] !== 0 || A._BigIntImpl__compareDigits(dDigits, maxUsed, xDigits, maxUsed) >= 0))
            break;
          A._BigIntImpl__absSub(dDigits, abcdUsed, xDigits, maxUsed, dDigits);
        }
      }
      t1 = A._BigIntImpl__normalize(maxUsed, dDigits);
      return new A._BigIntImpl(false, dDigits, t1);
    },
    identityHashCode(object) {
      return A.objectHashCode(object);
    },
    int_parse(source, radix) {
      var value = A.Primitives_parseInt(source, radix);
      if (value != null)
        return value;
      throw A.wrapException(A.FormatException$(source, null, null));
    },
    Error__throw(error, stackTrace) {
      error = A.wrapException(error);
      if (error == null)
        error = type$.Object._as(error);
      error.stack = stackTrace.toString$0(0);
      throw error;
      throw A.wrapException("unreachable");
    },
    DateTime$fromMillisecondsSinceEpoch(millisecondsSinceEpoch, isUtc) {
      if (Math.abs(millisecondsSinceEpoch) > 864e13)
        A.throwExpression(A.ArgumentError$("DateTime is outside valid range: " + millisecondsSinceEpoch, null));
      A.checkNotNullable(isUtc, "isUtc", type$.bool);
      return new A.DateTime(millisecondsSinceEpoch, isUtc);
    },
    List_List$filled($length, fill, growable, $E) {
      var i,
        result = growable ? J.JSArray_JSArray$growable($length, $E) : J.JSArray_JSArray$fixed($length, $E);
      if ($length !== 0 && fill != null)
        for (i = 0; i < result.length; ++i)
          result[i] = fill;
      return result;
    },
    List_List$empty(growable, $E) {
      return growable ? J.JSArray_JSArray$growable(0, $E) : J.JSArray_JSArray$fixed(0, $E);
    },
    List_List$from(elements, growable, $E) {
      var t1,
        list = A._setArrayType([], $E._eval$1("JSArray<0>"));
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        B.JSArray_methods.add$1(list, $E._as(t1.get$current()));
      if (growable)
        return list;
      return J.JSArray_markFixedList(list, $E);
    },
    List_List$of(elements, growable, $E) {
      var t1;
      if (growable)
        return A.List_List$_of(elements, $E);
      t1 = J.JSArray_markFixedList(A.List_List$_of(elements, $E), $E);
      return t1;
    },
    List_List$_of(elements, $E) {
      var list, t1;
      if (Array.isArray(elements))
        return A._setArrayType(elements.slice(0), $E._eval$1("JSArray<0>"));
      list = A._setArrayType([], $E._eval$1("JSArray<0>"));
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        B.JSArray_methods.add$1(list, t1.get$current());
      return list;
    },
    List_List$generate($length, generator, $E) {
      var i,
        result = J.JSArray_JSArray$growable($length, $E);
      for (i = 0; i < $length; ++i)
        B.JSArray_methods.$indexSet(result, i, generator.call$1(i));
      return result;
    },
    List_List$unmodifiable(elements, $E) {
      return J.JSArray_markUnmodifiableList(A.List_List$from(elements, false, $E));
    },
    String_String$fromCharCodes(charCodes, start, end) {
      var t1, t2, maxLength, array, len;
      A.RangeError_checkNotNegative(start, "start");
      t1 = end == null;
      t2 = !t1;
      if (t2) {
        maxLength = end - start;
        if (maxLength < 0)
          throw A.wrapException(A.RangeError$range(end, start, null, "end", null));
        if (maxLength === 0)
          return "";
      }
      if (Array.isArray(charCodes)) {
        array = charCodes;
        len = array.length;
        if (t1)
          end = len;
        return A.Primitives_stringFromCharCodes(start > 0 || end < len ? array.slice(start, end) : array);
      }
      if (type$.NativeUint8List._is(charCodes))
        return A.String__stringFromUint8List(charCodes, start, end);
      if (t2)
        charCodes = J.take$1$ax(charCodes, end);
      if (start > 0)
        charCodes = J.skip$1$ax(charCodes, start);
      return A.Primitives_stringFromCharCodes(A.List_List$of(charCodes, true, type$.int));
    },
    String__stringFromUint8List(charCodes, start, endOrNull) {
      var len = charCodes.length;
      if (start >= len)
        return "";
      return A.Primitives_stringFromNativeUint8List(charCodes, start, endOrNull == null || endOrNull > len ? len : endOrNull);
    },
    RegExp_RegExp(source, caseSensitive) {
      return new A.JSSyntaxRegExp(source, A.JSSyntaxRegExp_makeNative(source, false, caseSensitive, false, false, false));
    },
    identical(a, b) {
      return a == null ? b == null : a === b;
    },
    StringBuffer__writeAll(string, objects, separator) {
      var iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return string;
      if (separator.length === 0) {
        do
          string += A.S(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        string += A.S(iterator.get$current());
        for (; iterator.moveNext$0();)
          string = string + separator + A.S(iterator.get$current());
      }
      return string;
    },
    NoSuchMethodError_NoSuchMethodError$withInvocation(receiver, invocation) {
      return new A.NoSuchMethodError(receiver, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments());
    },
    Uri_base() {
      var cachedUri, uri,
        current = A.Primitives_currentUri();
      if (current == null)
        throw A.wrapException(A.UnsupportedError$("'Uri.base' is not supported"));
      cachedUri = $.Uri__cachedBaseUri;
      if (cachedUri != null && current === $.Uri__cachedBaseString)
        return cachedUri;
      uri = A.Uri_parse(current);
      $.Uri__cachedBaseUri = uri;
      $.Uri__cachedBaseString = current;
      return uri;
    },
    StackTrace_current() {
      return A.getTraceFromException(new Error());
    },
    DateTime_parse(formattedString) {
      var t1, t2, t3, years, month, day, hour, minute, second, milliAndMicroseconds, millisecond, isUtc, tzSign, sign, hourDifference, value, _null = null,
        match = $.$get$DateTime__parseFormat().firstMatch$1(formattedString);
      if (match != null) {
        t1 = new A.DateTime_parse_parseIntOrZero();
        t2 = match._match;
        if (1 >= t2.length)
          return A.ioore(t2, 1);
        t3 = t2[1];
        t3.toString;
        years = A.int_parse(t3, _null);
        if (2 >= t2.length)
          return A.ioore(t2, 2);
        t3 = t2[2];
        t3.toString;
        month = A.int_parse(t3, _null);
        if (3 >= t2.length)
          return A.ioore(t2, 3);
        t3 = t2[3];
        t3.toString;
        day = A.int_parse(t3, _null);
        if (4 >= t2.length)
          return A.ioore(t2, 4);
        hour = t1.call$1(t2[4]);
        if (5 >= t2.length)
          return A.ioore(t2, 5);
        minute = t1.call$1(t2[5]);
        if (6 >= t2.length)
          return A.ioore(t2, 6);
        second = t1.call$1(t2[6]);
        if (7 >= t2.length)
          return A.ioore(t2, 7);
        milliAndMicroseconds = new A.DateTime_parse_parseMilliAndMicroseconds().call$1(t2[7]);
        millisecond = B.JSInt_methods._tdivFast$1(milliAndMicroseconds, 1000);
        t3 = t2.length;
        if (8 >= t3)
          return A.ioore(t2, 8);
        isUtc = t2[8] != null;
        if (isUtc) {
          if (9 >= t3)
            return A.ioore(t2, 9);
          tzSign = t2[9];
          if (tzSign != null) {
            sign = tzSign === "-" ? -1 : 1;
            if (10 >= t3)
              return A.ioore(t2, 10);
            t3 = t2[10];
            t3.toString;
            hourDifference = A.int_parse(t3, _null);
            if (11 >= t2.length)
              return A.ioore(t2, 11);
            minute -= sign * (t1.call$1(t2[11]) + 60 * hourDifference);
          }
        }
        value = A.Primitives_valueFromDecomposedDate(years, month, day, hour, minute, second, millisecond + B.JSNumber_methods.round$0(milliAndMicroseconds % 1000 / 1000), isUtc);
        if (value == null)
          throw A.wrapException(A.FormatException$("Time out of range", formattedString, _null));
        return A.DateTime$_withValue(value, isUtc);
      } else
        throw A.wrapException(A.FormatException$("Invalid date format", formattedString, _null));
    },
    DateTime$_withValue(_value, isUtc) {
      if (Math.abs(_value) > 864e13)
        A.throwExpression(A.ArgumentError$("DateTime is outside valid range: " + _value, null));
      A.checkNotNullable(isUtc, "isUtc", type$.bool);
      return new A.DateTime(_value, isUtc);
    },
    DateTime__fourDigits(n) {
      var absN = Math.abs(n),
        sign = n < 0 ? "-" : "";
      if (absN >= 1000)
        return "" + n;
      if (absN >= 100)
        return sign + "0" + absN;
      if (absN >= 10)
        return sign + "00" + absN;
      return sign + "000" + absN;
    },
    DateTime__sixDigits(n) {
      var absN = Math.abs(n),
        sign = n < 0 ? "-" : "+";
      if (absN >= 100000)
        return sign + absN;
      return sign + "0" + absN;
    },
    DateTime__threeDigits(n) {
      if (n >= 100)
        return "" + n;
      if (n >= 10)
        return "0" + n;
      return "00" + n;
    },
    DateTime__twoDigits(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    },
    Duration$(minutes) {
      return new A.Duration(60000000 * minutes);
    },
    Error_safeToString(object) {
      if (typeof object == "number" || A._isBool(object) || object == null)
        return J.toString$0$(object);
      if (typeof object == "string")
        return JSON.stringify(object);
      return A.Primitives_safeToString(object);
    },
    Error_throwWithStackTrace(error, stackTrace) {
      A.checkNotNullable(error, "error", type$.Object);
      A.checkNotNullable(stackTrace, "stackTrace", type$.StackTrace);
      A.Error__throw(error, stackTrace);
    },
    AssertionError$(message) {
      return new A.AssertionError(message);
    },
    ArgumentError$(message, $name) {
      return new A.ArgumentError(false, null, $name, message);
    },
    ArgumentError$value(value, $name, message) {
      return new A.ArgumentError(true, value, $name, message);
    },
    ArgumentError_checkNotNull(argument, $name, $T) {
      return argument;
    },
    RangeError$(message) {
      var _null = null;
      return new A.RangeError(_null, _null, false, _null, _null, message);
    },
    RangeError$value(value, $name) {
      return new A.RangeError(null, null, true, value, $name, "Value not in range");
    },
    RangeError$range(invalidValue, minValue, maxValue, $name, message) {
      return new A.RangeError(minValue, maxValue, true, invalidValue, $name, "Invalid value");
    },
    RangeError_checkValueInInterval(value, minValue, maxValue, $name) {
      if (value < minValue || value > maxValue)
        throw A.wrapException(A.RangeError$range(value, minValue, maxValue, $name, null));
      return value;
    },
    RangeError_checkValidRange(start, end, $length) {
      if (0 > start || start > $length)
        throw A.wrapException(A.RangeError$range(start, 0, $length, "start", null));
      if (end != null) {
        if (start > end || end > $length)
          throw A.wrapException(A.RangeError$range(end, start, $length, "end", null));
        return end;
      }
      return $length;
    },
    RangeError_checkNotNegative(value, $name) {
      if (value < 0)
        throw A.wrapException(A.RangeError$range(value, 0, null, $name, null));
      return value;
    },
    IndexError$withLength(invalidValue, $length, indexable, message, $name) {
      return new A.IndexError($length, true, invalidValue, $name, "Index out of range");
    },
    UnsupportedError$(message) {
      return new A.UnsupportedError(message);
    },
    UnimplementedError$(message) {
      return new A.UnimplementedError(message);
    },
    StateError$(message) {
      return new A.StateError(message);
    },
    ConcurrentModificationError$(modifiedObject) {
      return new A.ConcurrentModificationError(modifiedObject);
    },
    Exception_Exception(message) {
      return new A._Exception(message);
    },
    FormatException$(message, source, offset) {
      return new A.FormatException(message, source, offset);
    },
    Iterable_iterableToShortString(iterable, leftDelimiter, rightDelimiter) {
      var parts, t1;
      if (A.isToStringVisiting(iterable)) {
        if (leftDelimiter === "(" && rightDelimiter === ")")
          return "(...)";
        return leftDelimiter + "..." + rightDelimiter;
      }
      parts = A._setArrayType([], type$.JSArray_String);
      B.JSArray_methods.add$1($.toStringVisiting, iterable);
      try {
        A._iterablePartsToStrings(iterable, parts);
      } finally {
        if (0 >= $.toStringVisiting.length)
          return A.ioore($.toStringVisiting, -1);
        $.toStringVisiting.pop();
      }
      t1 = A.StringBuffer__writeAll(leftDelimiter, type$.Iterable_dynamic._as(parts), ", ") + rightDelimiter;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    Iterable_iterableToFullString(iterable, leftDelimiter, rightDelimiter) {
      var buffer, t1;
      if (A.isToStringVisiting(iterable))
        return leftDelimiter + "..." + rightDelimiter;
      buffer = new A.StringBuffer(leftDelimiter);
      B.JSArray_methods.add$1($.toStringVisiting, iterable);
      try {
        t1 = buffer;
        t1._contents = A.StringBuffer__writeAll(t1._contents, iterable, ", ");
      } finally {
        if (0 >= $.toStringVisiting.length)
          return A.ioore($.toStringVisiting, -1);
        $.toStringVisiting.pop();
      }
      buffer._contents += rightDelimiter;
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _iterablePartsToStrings(iterable, parts) {
      var next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision,
        it = iterable.get$iterator(iterable),
        $length = 0, count = 0;
      while (true) {
        if (!($length < 80 || count < 3))
          break;
        if (!it.moveNext$0())
          return;
        next = A.S(it.get$current());
        B.JSArray_methods.add$1(parts, next);
        $length += next.length + 2;
        ++count;
      }
      if (!it.moveNext$0()) {
        if (count <= 5)
          return;
        if (0 >= parts.length)
          return A.ioore(parts, -1);
        ultimateString = parts.pop();
        if (0 >= parts.length)
          return A.ioore(parts, -1);
        penultimateString = parts.pop();
      } else {
        penultimate = it.get$current();
        ++count;
        if (!it.moveNext$0()) {
          if (count <= 4) {
            B.JSArray_methods.add$1(parts, A.S(penultimate));
            return;
          }
          ultimateString = A.S(penultimate);
          if (0 >= parts.length)
            return A.ioore(parts, -1);
          penultimateString = parts.pop();
          $length += ultimateString.length + 2;
        } else {
          ultimate = it.get$current();
          ++count;
          for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
            ultimate0 = it.get$current();
            ++count;
            if (count > 100) {
              while (true) {
                if (!($length > 75 && count > 3))
                  break;
                if (0 >= parts.length)
                  return A.ioore(parts, -1);
                $length -= parts.pop().length + 2;
                --count;
              }
              B.JSArray_methods.add$1(parts, "...");
              return;
            }
          }
          penultimateString = A.S(penultimate);
          ultimateString = A.S(ultimate);
          $length += ultimateString.length + penultimateString.length + 4;
        }
      }
      if (count > parts.length + 2) {
        $length += 5;
        elision = "...";
      } else
        elision = null;
      while (true) {
        if (!($length > 80 && parts.length > 3))
          break;
        if (0 >= parts.length)
          return A.ioore(parts, -1);
        $length -= parts.pop().length + 2;
        if (elision == null) {
          $length += 5;
          elision = "...";
        }
      }
      if (elision != null)
        B.JSArray_methods.add$1(parts, elision);
      B.JSArray_methods.add$1(parts, penultimateString);
      B.JSArray_methods.add$1(parts, ultimateString);
    },
    Map_castFrom(source, $K, $V, K2, V2) {
      return new A.CastMap(source, $K._eval$1("@<0>")._bind$1($V)._bind$1(K2)._bind$1(V2)._eval$1("CastMap<1,2,3,4>"));
    },
    Map_Map$fromEntries(entries, $K, $V) {
      var t1 = A.LinkedHashMap_LinkedHashMap$_empty($K, $V);
      t1.addEntries$1(entries);
      return t1;
    },
    Object_hash(object1, object2, object3) {
      var t1;
      if (B.C_SentinelValue === object3) {
        t1 = J.get$hashCode$(object1);
        object2 = J.get$hashCode$(object2);
        return A.SystemHash_finish(A.SystemHash_combine(A.SystemHash_combine($.$get$_hashSeed(), t1), object2));
      }
      t1 = J.get$hashCode$(object1);
      object2 = J.get$hashCode$(object2);
      object3 = J.get$hashCode$(object3);
      object3 = A.SystemHash_finish(A.SystemHash_combine(A.SystemHash_combine(A.SystemHash_combine($.$get$_hashSeed(), t1), object2), object3));
      return object3;
    },
    print(object) {
      A.printString(object);
    },
    _combineSurrogatePair(start, end) {
      return 65536 + ((start & 1023) << 10) + (end & 1023);
    },
    Uri_parse(uri) {
      var delta, indices, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, isSimple, scheme, t1, t2, schemeAuth, queryStart0, pathStart0, userInfoStart, userInfo, host, portNumber, port, path, query, _null = null,
        end = uri.length;
      if (end >= 5) {
        if (4 >= end)
          return A.ioore(uri, 4);
        delta = ((uri.charCodeAt(4) ^ 58) * 3 | uri.charCodeAt(0) ^ 100 | uri.charCodeAt(1) ^ 97 | uri.charCodeAt(2) ^ 116 | uri.charCodeAt(3) ^ 97) >>> 0;
        if (delta === 0)
          return A.UriData__parse(end < end ? B.JSString_methods.substring$2(uri, 0, end) : uri, 5, _null).get$uri();
        else if (delta === 32)
          return A.UriData__parse(B.JSString_methods.substring$2(uri, 5, end), 0, _null).get$uri();
      }
      indices = A.List_List$filled(8, 0, false, type$.int);
      B.JSArray_methods.$indexSet(indices, 0, 0);
      B.JSArray_methods.$indexSet(indices, 1, -1);
      B.JSArray_methods.$indexSet(indices, 2, -1);
      B.JSArray_methods.$indexSet(indices, 7, -1);
      B.JSArray_methods.$indexSet(indices, 3, 0);
      B.JSArray_methods.$indexSet(indices, 4, 0);
      B.JSArray_methods.$indexSet(indices, 5, end);
      B.JSArray_methods.$indexSet(indices, 6, end);
      if (A._scan(uri, 0, end, 0, indices) >= 14)
        B.JSArray_methods.$indexSet(indices, 7, end);
      schemeEnd = indices[1];
      if (schemeEnd >= 0)
        if (A._scan(uri, 0, schemeEnd, 20, indices) === 20)
          indices[7] = schemeEnd;
      hostStart = indices[2] + 1;
      portStart = indices[3];
      pathStart = indices[4];
      queryStart = indices[5];
      fragmentStart = indices[6];
      if (fragmentStart < queryStart)
        queryStart = fragmentStart;
      if (pathStart < hostStart)
        pathStart = queryStart;
      else if (pathStart <= schemeEnd)
        pathStart = schemeEnd + 1;
      if (portStart < hostStart)
        portStart = pathStart;
      isSimple = indices[7] < 0;
      if (isSimple)
        if (hostStart > schemeEnd + 3) {
          scheme = _null;
          isSimple = false;
        } else {
          t1 = portStart > 0;
          if (t1 && portStart + 1 === pathStart) {
            scheme = _null;
            isSimple = false;
          } else {
            if (!B.JSString_methods.startsWith$2(uri, "\\", pathStart))
              if (hostStart > 0)
                t2 = B.JSString_methods.startsWith$2(uri, "\\", hostStart - 1) || B.JSString_methods.startsWith$2(uri, "\\", hostStart - 2);
              else
                t2 = false;
            else
              t2 = true;
            if (t2) {
              scheme = _null;
              isSimple = false;
            } else {
              if (!(queryStart < end && queryStart === pathStart + 2 && B.JSString_methods.startsWith$2(uri, "..", pathStart)))
                t2 = queryStart > pathStart + 2 && B.JSString_methods.startsWith$2(uri, "/..", queryStart - 3);
              else
                t2 = true;
              if (t2)
                scheme = _null;
              else if (schemeEnd === 4)
                if (B.JSString_methods.startsWith$2(uri, "file", 0)) {
                  if (hostStart <= 0) {
                    if (!B.JSString_methods.startsWith$2(uri, "/", pathStart)) {
                      schemeAuth = "file:///";
                      delta = 3;
                    } else {
                      schemeAuth = "file://";
                      delta = 2;
                    }
                    uri = schemeAuth + B.JSString_methods.substring$2(uri, pathStart, end);
                    schemeEnd -= 0;
                    t1 = delta - 0;
                    queryStart += t1;
                    fragmentStart += t1;
                    end = uri.length;
                    hostStart = 7;
                    portStart = 7;
                    pathStart = 7;
                  } else if (pathStart === queryStart) {
                    ++fragmentStart;
                    queryStart0 = queryStart + 1;
                    uri = B.JSString_methods.replaceRange$3(uri, pathStart, queryStart, "/");
                    ++end;
                    queryStart = queryStart0;
                  }
                  scheme = "file";
                } else if (B.JSString_methods.startsWith$2(uri, "http", 0)) {
                  if (t1 && portStart + 3 === pathStart && B.JSString_methods.startsWith$2(uri, "80", portStart + 1)) {
                    fragmentStart -= 3;
                    pathStart0 = pathStart - 3;
                    queryStart -= 3;
                    uri = B.JSString_methods.replaceRange$3(uri, portStart, pathStart, "");
                    end -= 3;
                    pathStart = pathStart0;
                  }
                  scheme = "http";
                } else
                  scheme = _null;
              else if (schemeEnd === 5 && B.JSString_methods.startsWith$2(uri, "https", 0)) {
                if (t1 && portStart + 4 === pathStart && B.JSString_methods.startsWith$2(uri, "443", portStart + 1)) {
                  fragmentStart -= 4;
                  pathStart0 = pathStart - 4;
                  queryStart -= 4;
                  uri = B.JSString_methods.replaceRange$3(uri, portStart, pathStart, "");
                  end -= 3;
                  pathStart = pathStart0;
                }
                scheme = "https";
              } else
                scheme = _null;
              isSimple = !t2;
            }
          }
        }
      else
        scheme = _null;
      if (isSimple) {
        if (end < uri.length) {
          uri = B.JSString_methods.substring$2(uri, 0, end);
          schemeEnd -= 0;
          hostStart -= 0;
          portStart -= 0;
          pathStart -= 0;
          queryStart -= 0;
          fragmentStart -= 0;
        }
        return new A._SimpleUri(uri, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
      }
      if (scheme == null)
        if (schemeEnd > 0)
          scheme = A._Uri__makeScheme(uri, 0, schemeEnd);
        else {
          if (schemeEnd === 0)
            A._Uri__fail(uri, 0, "Invalid empty scheme");
          scheme = "";
        }
      if (hostStart > 0) {
        userInfoStart = schemeEnd + 3;
        userInfo = userInfoStart < hostStart ? A._Uri__makeUserInfo(uri, userInfoStart, hostStart - 1) : "";
        host = A._Uri__makeHost(uri, hostStart, portStart, false);
        t1 = portStart + 1;
        if (t1 < pathStart) {
          portNumber = A.Primitives_parseInt(B.JSString_methods.substring$2(uri, t1, pathStart), _null);
          port = A._Uri__makePort(portNumber == null ? A.throwExpression(A.FormatException$("Invalid port", uri, t1)) : portNumber, scheme);
        } else
          port = _null;
      } else {
        port = _null;
        host = port;
        userInfo = "";
      }
      path = A._Uri__makePath(uri, pathStart, queryStart, _null, scheme, host != null);
      query = queryStart < fragmentStart ? A._Uri__makeQuery(uri, queryStart + 1, fragmentStart, _null) : _null;
      return A._Uri$_internal(scheme, userInfo, host, port, path, query, fragmentStart < end ? A._Uri__makeFragment(uri, fragmentStart + 1, end) : _null);
    },
    Uri_decodeComponent(encodedComponent) {
      A._asString(encodedComponent);
      return A._Uri__uriDecode(encodedComponent, 0, encodedComponent.length, B.C_Utf8Codec, false);
    },
    Uri__parseIPv4Address(host, start, end) {
      var t1, i, partStart, partIndex, char, part, partIndex0,
        _s43_ = "IPv4 address should contain exactly 4 parts",
        _s37_ = "each part must be in the range 0..255",
        error = new A.Uri__parseIPv4Address_error(host),
        result = new Uint8Array(4);
      for (t1 = host.length, i = start, partStart = i, partIndex = 0; i < end; ++i) {
        if (!(i >= 0 && i < t1))
          return A.ioore(host, i);
        char = host.charCodeAt(i);
        if (char !== 46) {
          if ((char ^ 48) > 9)
            error.call$2("invalid character", i);
        } else {
          if (partIndex === 3)
            error.call$2(_s43_, i);
          part = A.int_parse(B.JSString_methods.substring$2(host, partStart, i), null);
          if (part > 255)
            error.call$2(_s37_, partStart);
          partIndex0 = partIndex + 1;
          if (!(partIndex < 4))
            return A.ioore(result, partIndex);
          result[partIndex] = part;
          partStart = i + 1;
          partIndex = partIndex0;
        }
      }
      if (partIndex !== 3)
        error.call$2(_s43_, end);
      part = A.int_parse(B.JSString_methods.substring$2(host, partStart, end), null);
      if (part > 255)
        error.call$2(_s37_, partStart);
      if (!(partIndex < 4))
        return A.ioore(result, partIndex);
      result[partIndex] = part;
      return result;
    },
    Uri_parseIPv6Address(host, start, end) {
      var parts, i, partStart, wildcardSeen, seenDot, char, atEnd, last, bytes, wildCardLength, index, value, j, t2, _null = null,
        error = new A.Uri_parseIPv6Address_error(host),
        parseHex = new A.Uri_parseIPv6Address_parseHex(error, host),
        t1 = host.length;
      if (t1 < 2)
        error.call$2("address is too short", _null);
      parts = A._setArrayType([], type$.JSArray_int);
      for (i = start, partStart = i, wildcardSeen = false, seenDot = false; i < end; ++i) {
        if (!(i >= 0 && i < t1))
          return A.ioore(host, i);
        char = host.charCodeAt(i);
        if (char === 58) {
          if (i === start) {
            ++i;
            if (!(i < t1))
              return A.ioore(host, i);
            if (host.charCodeAt(i) !== 58)
              error.call$2("invalid start colon.", i);
            partStart = i;
          }
          if (i === partStart) {
            if (wildcardSeen)
              error.call$2("only one wildcard `::` is allowed", i);
            B.JSArray_methods.add$1(parts, -1);
            wildcardSeen = true;
          } else
            B.JSArray_methods.add$1(parts, parseHex.call$2(partStart, i));
          partStart = i + 1;
        } else if (char === 46)
          seenDot = true;
      }
      if (parts.length === 0)
        error.call$2("too few parts", _null);
      atEnd = partStart === end;
      t1 = B.JSArray_methods.get$last(parts);
      if (atEnd && t1 !== -1)
        error.call$2("expected a part after last `:`", end);
      if (!atEnd)
        if (!seenDot)
          B.JSArray_methods.add$1(parts, parseHex.call$2(partStart, end));
        else {
          last = A.Uri__parseIPv4Address(host, partStart, end);
          B.JSArray_methods.add$1(parts, (last[0] << 8 | last[1]) >>> 0);
          B.JSArray_methods.add$1(parts, (last[2] << 8 | last[3]) >>> 0);
        }
      if (wildcardSeen) {
        if (parts.length > 7)
          error.call$2("an address with a wildcard must have less than 7 parts", _null);
      } else if (parts.length !== 8)
        error.call$2("an address without a wildcard must contain exactly 8 parts", _null);
      bytes = new Uint8Array(16);
      for (t1 = parts.length, wildCardLength = 9 - t1, i = 0, index = 0; i < t1; ++i) {
        value = parts[i];
        if (value === -1)
          for (j = 0; j < wildCardLength; ++j) {
            if (!(index >= 0 && index < 16))
              return A.ioore(bytes, index);
            bytes[index] = 0;
            t2 = index + 1;
            if (!(t2 < 16))
              return A.ioore(bytes, t2);
            bytes[t2] = 0;
            index += 2;
          }
        else {
          t2 = B.JSInt_methods._shrOtherPositive$1(value, 8);
          if (!(index >= 0 && index < 16))
            return A.ioore(bytes, index);
          bytes[index] = t2;
          t2 = index + 1;
          if (!(t2 < 16))
            return A.ioore(bytes, t2);
          bytes[t2] = value & 255;
          index += 2;
        }
      }
      return bytes;
    },
    _Uri$_internal(scheme, _userInfo, _host, _port, path, _query, _fragment) {
      return new A._Uri(scheme, _userInfo, _host, _port, path, _query, _fragment);
    },
    _Uri__defaultPort(scheme) {
      if (scheme === "http")
        return 80;
      if (scheme === "https")
        return 443;
      return 0;
    },
    _Uri__fail(uri, index, message) {
      throw A.wrapException(A.FormatException$(message, uri, index));
    },
    _Uri__checkNonWindowsPathReservedCharacters(segments, argumentError) {
      var t1, _i, segment;
      for (t1 = segments.length, _i = 0; _i < t1; ++_i) {
        segment = segments[_i];
        if (J.contains$1$asx(segment, "/")) {
          t1 = A.UnsupportedError$("Illegal path character " + A.S(segment));
          throw A.wrapException(t1);
        }
      }
    },
    _Uri__makePort(port, scheme) {
      if (port != null && port === A._Uri__defaultPort(scheme))
        return null;
      return port;
    },
    _Uri__makeHost(host, start, end, strictIPv6) {
      var t1, t2, index, zoneIDstart, zoneID, i;
      if (host == null)
        return null;
      if (start === end)
        return "";
      t1 = host.length;
      if (!(start >= 0 && start < t1))
        return A.ioore(host, start);
      if (host.charCodeAt(start) === 91) {
        t2 = end - 1;
        if (!(t2 >= 0 && t2 < t1))
          return A.ioore(host, t2);
        if (host.charCodeAt(t2) !== 93)
          A._Uri__fail(host, start, "Missing end `]` to match `[` in host");
        t1 = start + 1;
        index = A._Uri__checkZoneID(host, t1, t2);
        if (index < t2) {
          zoneIDstart = index + 1;
          zoneID = A._Uri__normalizeZoneID(host, B.JSString_methods.startsWith$2(host, "25", zoneIDstart) ? index + 3 : zoneIDstart, t2, "%25");
        } else
          zoneID = "";
        A.Uri_parseIPv6Address(host, t1, index);
        return B.JSString_methods.substring$2(host, start, index).toLowerCase() + zoneID + "]";
      }
      for (i = start; i < end; ++i) {
        if (!(i < t1))
          return A.ioore(host, i);
        if (host.charCodeAt(i) === 58) {
          index = B.JSString_methods.indexOf$2(host, "%", start);
          index = index >= start && index < end ? index : end;
          if (index < end) {
            zoneIDstart = index + 1;
            zoneID = A._Uri__normalizeZoneID(host, B.JSString_methods.startsWith$2(host, "25", zoneIDstart) ? index + 3 : zoneIDstart, end, "%25");
          } else
            zoneID = "";
          A.Uri_parseIPv6Address(host, start, index);
          return "[" + B.JSString_methods.substring$2(host, start, index) + zoneID + "]";
        }
      }
      return A._Uri__normalizeRegName(host, start, end);
    },
    _Uri__checkZoneID(host, start, end) {
      var index = B.JSString_methods.indexOf$2(host, "%", start);
      return index >= start && index < end ? index : end;
    },
    _Uri__normalizeZoneID(host, start, end, prefix) {
      var t1, index, sectionStart, isNormalized, char, replacement, t2, t3, tail, sourceLength, slice,
        buffer = prefix !== "" ? new A.StringBuffer(prefix) : null;
      for (t1 = host.length, index = start, sectionStart = index, isNormalized = true; index < end;) {
        if (!(index >= 0 && index < t1))
          return A.ioore(host, index);
        char = host.charCodeAt(index);
        if (char === 37) {
          replacement = A._Uri__normalizeEscape(host, index, true);
          t2 = replacement == null;
          if (t2 && isNormalized) {
            index += 3;
            continue;
          }
          if (buffer == null)
            buffer = new A.StringBuffer("");
          t3 = buffer._contents += B.JSString_methods.substring$2(host, sectionStart, index);
          if (t2)
            replacement = B.JSString_methods.substring$2(host, index, index + 3);
          else if (replacement === "%")
            A._Uri__fail(host, index, "ZoneID should not contain % anymore");
          buffer._contents = t3 + replacement;
          index += 3;
          sectionStart = index;
          isNormalized = true;
        } else {
          if (char < 127) {
            t2 = char >>> 4;
            if (!(t2 < 8))
              return A.ioore(B.List_piR, t2);
            t2 = (B.List_piR[t2] & 1 << (char & 15)) !== 0;
          } else
            t2 = false;
          if (t2) {
            if (isNormalized && 65 <= char && 90 >= char) {
              if (buffer == null)
                buffer = new A.StringBuffer("");
              if (sectionStart < index) {
                buffer._contents += B.JSString_methods.substring$2(host, sectionStart, index);
                sectionStart = index;
              }
              isNormalized = false;
            }
            ++index;
          } else {
            if ((char & 64512) === 55296 && index + 1 < end) {
              t2 = index + 1;
              if (!(t2 < t1))
                return A.ioore(host, t2);
              tail = host.charCodeAt(t2);
              if ((tail & 64512) === 56320) {
                char = (char & 1023) << 10 | tail & 1023 | 65536;
                sourceLength = 2;
              } else
                sourceLength = 1;
            } else
              sourceLength = 1;
            slice = B.JSString_methods.substring$2(host, sectionStart, index);
            if (buffer == null) {
              buffer = new A.StringBuffer("");
              t2 = buffer;
            } else
              t2 = buffer;
            t2._contents += slice;
            t3 = A._Uri__escapeChar(char);
            t2._contents += t3;
            index += sourceLength;
            sectionStart = index;
          }
        }
      }
      if (buffer == null)
        return B.JSString_methods.substring$2(host, start, end);
      if (sectionStart < end) {
        slice = B.JSString_methods.substring$2(host, sectionStart, end);
        buffer._contents += slice;
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__normalizeRegName(host, start, end) {
      var t1, index, sectionStart, buffer, isNormalized, char, replacement, t2, slice, t3, sourceLength, tail;
      for (t1 = host.length, index = start, sectionStart = index, buffer = null, isNormalized = true; index < end;) {
        if (!(index >= 0 && index < t1))
          return A.ioore(host, index);
        char = host.charCodeAt(index);
        if (char === 37) {
          replacement = A._Uri__normalizeEscape(host, index, true);
          t2 = replacement == null;
          if (t2 && isNormalized) {
            index += 3;
            continue;
          }
          if (buffer == null)
            buffer = new A.StringBuffer("");
          slice = B.JSString_methods.substring$2(host, sectionStart, index);
          if (!isNormalized)
            slice = slice.toLowerCase();
          t3 = buffer._contents += slice;
          if (t2) {
            replacement = B.JSString_methods.substring$2(host, index, index + 3);
            sourceLength = 3;
          } else if (replacement === "%") {
            replacement = "%25";
            sourceLength = 1;
          } else
            sourceLength = 3;
          buffer._contents = t3 + replacement;
          index += sourceLength;
          sectionStart = index;
          isNormalized = true;
        } else {
          if (char < 127) {
            t2 = char >>> 4;
            if (!(t2 < 8))
              return A.ioore(B.List_4AN, t2);
            t2 = (B.List_4AN[t2] & 1 << (char & 15)) !== 0;
          } else
            t2 = false;
          if (t2) {
            if (isNormalized && 65 <= char && 90 >= char) {
              if (buffer == null)
                buffer = new A.StringBuffer("");
              if (sectionStart < index) {
                buffer._contents += B.JSString_methods.substring$2(host, sectionStart, index);
                sectionStart = index;
              }
              isNormalized = false;
            }
            ++index;
          } else {
            if (char <= 93) {
              t2 = char >>> 4;
              if (!(t2 < 8))
                return A.ioore(B.List_VOY, t2);
              t2 = (B.List_VOY[t2] & 1 << (char & 15)) !== 0;
            } else
              t2 = false;
            if (t2)
              A._Uri__fail(host, index, "Invalid character");
            else {
              if ((char & 64512) === 55296 && index + 1 < end) {
                t2 = index + 1;
                if (!(t2 < t1))
                  return A.ioore(host, t2);
                tail = host.charCodeAt(t2);
                if ((tail & 64512) === 56320) {
                  char = (char & 1023) << 10 | tail & 1023 | 65536;
                  sourceLength = 2;
                } else
                  sourceLength = 1;
              } else
                sourceLength = 1;
              slice = B.JSString_methods.substring$2(host, sectionStart, index);
              if (!isNormalized)
                slice = slice.toLowerCase();
              if (buffer == null) {
                buffer = new A.StringBuffer("");
                t2 = buffer;
              } else
                t2 = buffer;
              t2._contents += slice;
              t3 = A._Uri__escapeChar(char);
              t2._contents += t3;
              index += sourceLength;
              sectionStart = index;
            }
          }
        }
      }
      if (buffer == null)
        return B.JSString_methods.substring$2(host, start, end);
      if (sectionStart < end) {
        slice = B.JSString_methods.substring$2(host, sectionStart, end);
        if (!isNormalized)
          slice = slice.toLowerCase();
        buffer._contents += slice;
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__makeScheme(scheme, start, end) {
      var t1, i, containsUpperCase, codeUnit, t2;
      if (start === end)
        return "";
      t1 = scheme.length;
      if (!(start < t1))
        return A.ioore(scheme, start);
      if (!A._Uri__isAlphabeticCharacter(scheme.charCodeAt(start)))
        A._Uri__fail(scheme, start, "Scheme not starting with alphabetic character");
      for (i = start, containsUpperCase = false; i < end; ++i) {
        if (!(i < t1))
          return A.ioore(scheme, i);
        codeUnit = scheme.charCodeAt(i);
        if (codeUnit < 128) {
          t2 = codeUnit >>> 4;
          if (!(t2 < 8))
            return A.ioore(B.List_GVy, t2);
          t2 = (B.List_GVy[t2] & 1 << (codeUnit & 15)) !== 0;
        } else
          t2 = false;
        if (!t2)
          A._Uri__fail(scheme, i, "Illegal scheme character");
        if (65 <= codeUnit && codeUnit <= 90)
          containsUpperCase = true;
      }
      scheme = B.JSString_methods.substring$2(scheme, start, end);
      return A._Uri__canonicalizeScheme(containsUpperCase ? scheme.toLowerCase() : scheme);
    },
    _Uri__canonicalizeScheme(scheme) {
      if (scheme === "http")
        return "http";
      if (scheme === "file")
        return "file";
      if (scheme === "https")
        return "https";
      if (scheme === "package")
        return "package";
      return scheme;
    },
    _Uri__makeUserInfo(userInfo, start, end) {
      if (userInfo == null)
        return "";
      return A._Uri__normalizeOrSubstring(userInfo, start, end, B.List_2jN, false, false);
    },
    _Uri__makePath(path, start, end, pathSegments, scheme, hasAuthority) {
      var result,
        isFile = scheme === "file",
        ensureLeadingSlash = isFile || hasAuthority;
      if (path == null)
        return isFile ? "/" : "";
      else
        result = A._Uri__normalizeOrSubstring(path, start, end, B.List_M2I, true, true);
      if (result.length === 0) {
        if (isFile)
          return "/";
      } else if (ensureLeadingSlash && !B.JSString_methods.startsWith$1(result, "/"))
        result = "/" + result;
      return A._Uri__normalizePath(result, scheme, hasAuthority);
    },
    _Uri__normalizePath(path, scheme, hasAuthority) {
      var t1 = scheme.length === 0;
      if (t1 && !hasAuthority && !B.JSString_methods.startsWith$1(path, "/") && !B.JSString_methods.startsWith$1(path, "\\"))
        return A._Uri__normalizeRelativePath(path, !t1 || hasAuthority);
      return A._Uri__removeDotSegments(path);
    },
    _Uri__makeQuery(query, start, end, queryParameters) {
      if (query != null)
        return A._Uri__normalizeOrSubstring(query, start, end, B.List_42A, true, false);
      return null;
    },
    _Uri__makeFragment(fragment, start, end) {
      if (fragment == null)
        return null;
      return A._Uri__normalizeOrSubstring(fragment, start, end, B.List_42A, true, false);
    },
    _Uri__normalizeEscape(source, index, lowerCase) {
      var t3, firstDigit, secondDigit, firstDigitValue, secondDigitValue, value,
        t1 = index + 2,
        t2 = source.length;
      if (t1 >= t2)
        return "%";
      t3 = index + 1;
      if (!(t3 >= 0 && t3 < t2))
        return A.ioore(source, t3);
      firstDigit = source.charCodeAt(t3);
      if (!(t1 >= 0))
        return A.ioore(source, t1);
      secondDigit = source.charCodeAt(t1);
      firstDigitValue = A.hexDigitValue(firstDigit);
      secondDigitValue = A.hexDigitValue(secondDigit);
      if (firstDigitValue < 0 || secondDigitValue < 0)
        return "%";
      value = firstDigitValue * 16 + secondDigitValue;
      if (value < 127) {
        t1 = B.JSInt_methods._shrOtherPositive$1(value, 4);
        if (!(t1 < 8))
          return A.ioore(B.List_piR, t1);
        t1 = (B.List_piR[t1] & 1 << (value & 15)) !== 0;
      } else
        t1 = false;
      if (t1)
        return A.Primitives_stringFromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
      if (firstDigit >= 97 || secondDigit >= 97)
        return B.JSString_methods.substring$2(source, index, index + 3).toUpperCase();
      return null;
    },
    _Uri__escapeChar(char) {
      var codeUnits, t1, flag, encodedBytes, index, byte, t2, t3,
        _s16_ = "0123456789ABCDEF";
      if (char < 128) {
        codeUnits = new Uint8Array(3);
        codeUnits[0] = 37;
        t1 = char >>> 4;
        if (!(t1 < 16))
          return A.ioore(_s16_, t1);
        codeUnits[1] = _s16_.charCodeAt(t1);
        codeUnits[2] = _s16_.charCodeAt(char & 15);
      } else {
        if (char > 2047)
          if (char > 65535) {
            flag = 240;
            encodedBytes = 4;
          } else {
            flag = 224;
            encodedBytes = 3;
          }
        else {
          flag = 192;
          encodedBytes = 2;
        }
        t1 = 3 * encodedBytes;
        codeUnits = new Uint8Array(t1);
        for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
          byte = B.JSInt_methods._shrReceiverPositive$1(char, 6 * encodedBytes) & 63 | flag;
          if (!(index < t1))
            return A.ioore(codeUnits, index);
          codeUnits[index] = 37;
          t2 = index + 1;
          t3 = byte >>> 4;
          if (!(t3 < 16))
            return A.ioore(_s16_, t3);
          if (!(t2 < t1))
            return A.ioore(codeUnits, t2);
          codeUnits[t2] = _s16_.charCodeAt(t3);
          t3 = index + 2;
          if (!(t3 < t1))
            return A.ioore(codeUnits, t3);
          codeUnits[t3] = _s16_.charCodeAt(byte & 15);
          index += 3;
        }
      }
      return A.String_String$fromCharCodes(codeUnits, 0, null);
    },
    _Uri__normalizeOrSubstring(component, start, end, charTable, escapeDelimiters, replaceBackslash) {
      var t1 = A._Uri__normalize(component, start, end, charTable, escapeDelimiters, replaceBackslash);
      return t1 == null ? B.JSString_methods.substring$2(component, start, end) : t1;
    },
    _Uri__normalize(component, start, end, charTable, escapeDelimiters, replaceBackslash) {
      var t1, t2, index, sectionStart, buffer, char, t3, replacement, sourceLength, tail, t4, _null = null;
      for (t1 = !escapeDelimiters, t2 = component.length, index = start, sectionStart = index, buffer = _null; index < end;) {
        if (!(index >= 0 && index < t2))
          return A.ioore(component, index);
        char = component.charCodeAt(index);
        if (char < 127) {
          t3 = char >>> 4;
          if (!(t3 < 8))
            return A.ioore(charTable, t3);
          t3 = (charTable[t3] & 1 << (char & 15)) !== 0;
        } else
          t3 = false;
        if (t3)
          ++index;
        else {
          if (char === 37) {
            replacement = A._Uri__normalizeEscape(component, index, false);
            if (replacement == null) {
              index += 3;
              continue;
            }
            if ("%" === replacement) {
              replacement = "%25";
              sourceLength = 1;
            } else
              sourceLength = 3;
          } else if (char === 92 && replaceBackslash) {
            replacement = "/";
            sourceLength = 1;
          } else {
            if (t1)
              if (char <= 93) {
                t3 = char >>> 4;
                if (!(t3 < 8))
                  return A.ioore(B.List_VOY, t3);
                t3 = (B.List_VOY[t3] & 1 << (char & 15)) !== 0;
              } else
                t3 = false;
            else
              t3 = false;
            if (t3) {
              A._Uri__fail(component, index, "Invalid character");
              sourceLength = _null;
              replacement = sourceLength;
            } else {
              if ((char & 64512) === 55296) {
                t3 = index + 1;
                if (t3 < end) {
                  if (!(t3 < t2))
                    return A.ioore(component, t3);
                  tail = component.charCodeAt(t3);
                  if ((tail & 64512) === 56320) {
                    char = (char & 1023) << 10 | tail & 1023 | 65536;
                    sourceLength = 2;
                  } else
                    sourceLength = 1;
                } else
                  sourceLength = 1;
              } else
                sourceLength = 1;
              replacement = A._Uri__escapeChar(char);
            }
          }
          if (buffer == null) {
            buffer = new A.StringBuffer("");
            t3 = buffer;
          } else
            t3 = buffer;
          t4 = t3._contents += B.JSString_methods.substring$2(component, sectionStart, index);
          t3._contents = t4 + A.S(replacement);
          if (typeof sourceLength !== "number")
            return A.iae(sourceLength);
          index += sourceLength;
          sectionStart = index;
        }
      }
      if (buffer == null)
        return _null;
      if (sectionStart < end) {
        t1 = B.JSString_methods.substring$2(component, sectionStart, end);
        buffer._contents += t1;
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__mayContainDotSegments(path) {
      if (B.JSString_methods.startsWith$1(path, "."))
        return true;
      return B.JSString_methods.indexOf$1(path, "/.") !== -1;
    },
    _Uri__removeDotSegments(path) {
      var output, t1, t2, appendSlash, _i, segment, t3;
      if (!A._Uri__mayContainDotSegments(path))
        return path;
      output = A._setArrayType([], type$.JSArray_String);
      for (t1 = path.split("/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t2; ++_i) {
        segment = t1[_i];
        if (J.$eq$(segment, "..")) {
          t3 = output.length;
          if (t3 !== 0) {
            if (0 >= t3)
              return A.ioore(output, -1);
            output.pop();
            if (output.length === 0)
              B.JSArray_methods.add$1(output, "");
          }
          appendSlash = true;
        } else {
          appendSlash = "." === segment;
          if (!appendSlash)
            B.JSArray_methods.add$1(output, segment);
        }
      }
      if (appendSlash)
        B.JSArray_methods.add$1(output, "");
      return B.JSArray_methods.join$1(output, "/");
    },
    _Uri__normalizeRelativePath(path, allowScheme) {
      var output, t1, t2, appendSlash, _i, segment;
      if (!A._Uri__mayContainDotSegments(path))
        return !allowScheme ? A._Uri__escapeScheme(path) : path;
      output = A._setArrayType([], type$.JSArray_String);
      for (t1 = path.split("/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t2; ++_i) {
        segment = t1[_i];
        if (".." === segment) {
          appendSlash = output.length !== 0 && B.JSArray_methods.get$last(output) !== "..";
          if (appendSlash) {
            if (0 >= output.length)
              return A.ioore(output, -1);
            output.pop();
          } else
            B.JSArray_methods.add$1(output, "..");
        } else {
          appendSlash = "." === segment;
          if (!appendSlash)
            B.JSArray_methods.add$1(output, segment);
        }
      }
      t1 = output.length;
      if (t1 !== 0)
        if (t1 === 1) {
          if (0 >= t1)
            return A.ioore(output, 0);
          t1 = output[0].length === 0;
        } else
          t1 = false;
      else
        t1 = true;
      if (t1)
        return "./";
      if (appendSlash || B.JSArray_methods.get$last(output) === "..")
        B.JSArray_methods.add$1(output, "");
      if (!allowScheme) {
        if (0 >= output.length)
          return A.ioore(output, 0);
        B.JSArray_methods.$indexSet(output, 0, A._Uri__escapeScheme(output[0]));
      }
      return B.JSArray_methods.join$1(output, "/");
    },
    _Uri__escapeScheme(path) {
      var i, char, t2,
        t1 = path.length;
      if (t1 >= 2 && A._Uri__isAlphabeticCharacter(path.charCodeAt(0)))
        for (i = 1; i < t1; ++i) {
          char = path.charCodeAt(i);
          if (char === 58)
            return B.JSString_methods.substring$2(path, 0, i) + "%3A" + B.JSString_methods.substring$1(path, i + 1);
          if (char <= 127) {
            t2 = char >>> 4;
            if (!(t2 < 8))
              return A.ioore(B.List_GVy, t2);
            t2 = (B.List_GVy[t2] & 1 << (char & 15)) === 0;
          } else
            t2 = true;
          if (t2)
            break;
        }
      return path;
    },
    _Uri__packageNameEnd(uri, path) {
      if (uri.isScheme$1("package") && uri._host == null)
        return A._skipPackageNameChars(path, 0, path.length);
      return -1;
    },
    _Uri__hexCharPairToByte(s, pos) {
      var t1, byte, i, t2, charCode;
      for (t1 = s.length, byte = 0, i = 0; i < 2; ++i) {
        t2 = pos + i;
        if (!(t2 < t1))
          return A.ioore(s, t2);
        charCode = s.charCodeAt(t2);
        if (48 <= charCode && charCode <= 57)
          byte = byte * 16 + charCode - 48;
        else {
          charCode |= 32;
          if (97 <= charCode && charCode <= 102)
            byte = byte * 16 + charCode - 87;
          else
            throw A.wrapException(A.ArgumentError$("Invalid URL encoding", null));
        }
      }
      return byte;
    },
    _Uri__uriDecode(text, start, end, encoding, plusToSpace) {
      var simple, codeUnit, t2, bytes,
        t1 = text.length,
        i = start;
      while (true) {
        if (!(i < end)) {
          simple = true;
          break;
        }
        if (!(i < t1))
          return A.ioore(text, i);
        codeUnit = text.charCodeAt(i);
        if (codeUnit <= 127)
          t2 = codeUnit === 37;
        else
          t2 = true;
        if (t2) {
          simple = false;
          break;
        }
        ++i;
      }
      if (simple)
        if (B.C_Utf8Codec === encoding)
          return B.JSString_methods.substring$2(text, start, end);
        else
          bytes = new A.CodeUnits(B.JSString_methods.substring$2(text, start, end));
      else {
        bytes = A._setArrayType([], type$.JSArray_int);
        for (i = start; i < end; ++i) {
          if (!(i < t1))
            return A.ioore(text, i);
          codeUnit = text.charCodeAt(i);
          if (codeUnit > 127)
            throw A.wrapException(A.ArgumentError$("Illegal percent encoding in URI", null));
          if (codeUnit === 37) {
            if (i + 3 > t1)
              throw A.wrapException(A.ArgumentError$("Truncated URI", null));
            B.JSArray_methods.add$1(bytes, A._Uri__hexCharPairToByte(text, i + 1));
            i += 2;
          } else
            B.JSArray_methods.add$1(bytes, codeUnit);
        }
      }
      return encoding.decode$1(bytes);
    },
    _Uri__isAlphabeticCharacter(codeUnit) {
      var lowerCase = codeUnit | 32;
      return 97 <= lowerCase && lowerCase <= 122;
    },
    UriData__parse(text, start, sourceUri) {
      var t1, i, slashIndex, char, equalsIndex, lastSeparator, t2, data,
        _s17_ = "Invalid MIME type",
        indices = A._setArrayType([start - 1], type$.JSArray_int);
      for (t1 = text.length, i = start, slashIndex = -1, char = null; i < t1; ++i) {
        char = text.charCodeAt(i);
        if (char === 44 || char === 59)
          break;
        if (char === 47) {
          if (slashIndex < 0) {
            slashIndex = i;
            continue;
          }
          throw A.wrapException(A.FormatException$(_s17_, text, i));
        }
      }
      if (slashIndex < 0 && i > start)
        throw A.wrapException(A.FormatException$(_s17_, text, i));
      for (; char !== 44;) {
        B.JSArray_methods.add$1(indices, i);
        ++i;
        for (equalsIndex = -1; i < t1; ++i) {
          if (!(i >= 0))
            return A.ioore(text, i);
          char = text.charCodeAt(i);
          if (char === 61) {
            if (equalsIndex < 0)
              equalsIndex = i;
          } else if (char === 59 || char === 44)
            break;
        }
        if (equalsIndex >= 0)
          B.JSArray_methods.add$1(indices, equalsIndex);
        else {
          lastSeparator = B.JSArray_methods.get$last(indices);
          if (char !== 44 || i !== lastSeparator + 7 || !B.JSString_methods.startsWith$2(text, "base64", lastSeparator + 1))
            throw A.wrapException(A.FormatException$("Expecting '='", text, i));
          break;
        }
      }
      B.JSArray_methods.add$1(indices, i);
      t2 = i + 1;
      if ((indices.length & 1) === 1)
        text = B.Base64Codec_Base64Encoder_false.normalize$3(text, t2, t1);
      else {
        data = A._Uri__normalize(text, t2, t1, B.List_42A, true, false);
        if (data != null)
          text = B.JSString_methods.replaceRange$3(text, t2, t1, data);
      }
      return new A.UriData(text, indices, sourceUri);
    },
    _createTables() {
      var _i, t1, t2, t3, b,
        _s77_ = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=",
        _s1_ = ".", _s1_0 = ":", _s1_1 = "/", _s1_2 = "\\", _s1_3 = "?", _s1_4 = "#", _s2_ = "/\\",
        tables = J.JSArray_JSArray$allocateGrowable(22, type$.Uint8List);
      for (_i = 0; _i < 22; ++_i)
        tables[_i] = new Uint8Array(96);
      t1 = new A._createTables_build(tables);
      t2 = new A._createTables_setChars();
      t3 = new A._createTables_setRange();
      b = t1.call$2(0, 225);
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_, 14);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 3);
      t2.call$3(b, _s1_2, 227);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(14, 225);
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_, 15);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s2_, 234);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(15, 225);
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, "%", 225);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 9);
      t2.call$3(b, _s1_2, 233);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(1, 225);
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 10);
      t2.call$3(b, _s1_2, 234);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(2, 235);
      t2.call$3(b, _s77_, 139);
      t2.call$3(b, _s1_1, 131);
      t2.call$3(b, _s1_2, 131);
      t2.call$3(b, _s1_, 146);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(3, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 68);
      t2.call$3(b, _s1_2, 68);
      t2.call$3(b, _s1_, 18);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(4, 229);
      t2.call$3(b, _s77_, 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, _s1_0, 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "[", 232);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 138);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(5, 229);
      t2.call$3(b, _s77_, 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, _s1_0, 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 138);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(6, 231);
      t3.call$3(b, "19", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 138);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(7, 231);
      t3.call$3(b, "09", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 138);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      t2.call$3(t1.call$2(8, 8), "]", 5);
      b = t1.call$2(9, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 16);
      t2.call$3(b, _s2_, 234);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(16, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 17);
      t2.call$3(b, _s2_, 234);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(17, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 9);
      t2.call$3(b, _s1_2, 233);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(10, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 18);
      t2.call$3(b, _s1_1, 10);
      t2.call$3(b, _s1_2, 234);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(18, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 19);
      t2.call$3(b, _s2_, 234);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(19, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s2_, 234);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(11, 235);
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 10);
      t2.call$3(b, _s1_2, 234);
      t2.call$3(b, _s1_3, 172);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(12, 236);
      t2.call$3(b, _s77_, 12);
      t2.call$3(b, _s1_3, 12);
      t2.call$3(b, _s1_4, 205);
      b = t1.call$2(13, 237);
      t2.call$3(b, _s77_, 13);
      t2.call$3(b, _s1_3, 13);
      t3.call$3(t1.call$2(20, 245), "az", 21);
      b = t1.call$2(21, 245);
      t3.call$3(b, "az", 21);
      t3.call$3(b, "09", 21);
      t2.call$3(b, "+-.", 21);
      return tables;
    },
    _scan(uri, start, end, state, indices) {
      var t1, i, table, char, transition,
        tables = $.$get$_scannerTables();
      for (t1 = uri.length, i = start; i < end; ++i) {
        if (!(state >= 0 && state < tables.length))
          return A.ioore(tables, state);
        table = tables[state];
        if (!(i < t1))
          return A.ioore(uri, i);
        char = uri.charCodeAt(i) ^ 96;
        transition = table[char > 95 ? 31 : char];
        state = transition & 31;
        B.JSArray_methods.$indexSet(indices, transition >>> 5, i);
      }
      return state;
    },
    _SimpleUri__packageNameEnd(uri) {
      if (uri._schemeEnd === 7 && B.JSString_methods.startsWith$1(uri._uri, "package") && uri._hostStart <= 0)
        return A._skipPackageNameChars(uri._uri, uri._pathStart, uri._queryStart);
      return -1;
    },
    _skipPackageNameChars(source, start, end) {
      var t1, i, dots, char;
      for (t1 = source.length, i = start, dots = 0; i < end; ++i) {
        if (!(i >= 0 && i < t1))
          return A.ioore(source, i);
        char = source.charCodeAt(i);
        if (char === 47)
          return dots !== 0 ? i : -1;
        if (char === 37 || char === 58)
          return -1;
        dots |= char ^ 46;
      }
      return -1;
    },
    _caseInsensitiveCompareStart(prefix, string, start) {
      var t1, t2, result, i, t3, stringChar, delta, lowerChar;
      for (t1 = prefix.length, t2 = string.length, result = 0, i = 0; i < t1; ++i) {
        t3 = start + i;
        if (!(t3 < t2))
          return A.ioore(string, t3);
        stringChar = string.charCodeAt(t3);
        delta = prefix.charCodeAt(i) ^ stringChar;
        if (delta !== 0) {
          if (delta === 32) {
            lowerChar = stringChar | delta;
            if (97 <= lowerChar && lowerChar <= 122) {
              result = 32;
              continue;
            }
          }
          return -1;
        }
      }
      return result;
    },
    _BigIntImpl: function _BigIntImpl(t0, t1, t2) {
      this._isNegative = t0;
      this._digits = t1;
      this._used = t2;
    },
    _BigIntImpl_hashCode_combine: function _BigIntImpl_hashCode_combine() {
    },
    _BigIntImpl_hashCode_finish: function _BigIntImpl_hashCode_finish() {
    },
    _BigIntClassic: function _BigIntClassic(t0, t1) {
      this._modulus = t0;
      this._normalizedModulus = t1;
    },
    NoSuchMethodError_toString_closure: function NoSuchMethodError_toString_closure(t0, t1) {
      this._box_0 = t0;
      this.sb = t1;
    },
    DateTime: function DateTime(t0, t1) {
      this._core$_value = t0;
      this.isUtc = t1;
    },
    DateTime_parse_parseIntOrZero: function DateTime_parse_parseIntOrZero() {
    },
    DateTime_parse_parseMilliAndMicroseconds: function DateTime_parse_parseMilliAndMicroseconds() {
    },
    Duration: function Duration(t0) {
      this._duration = t0;
    },
    _Enum: function _Enum() {
    },
    Error: function Error() {
    },
    AssertionError: function AssertionError(t0) {
      this.message = t0;
    },
    TypeError: function TypeError() {
    },
    ArgumentError: function ArgumentError(t0, t1, t2, t3) {
      var _ = this;
      _._hasValue = t0;
      _.invalidValue = t1;
      _.name = t2;
      _.message = t3;
    },
    RangeError: function RangeError(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.start = t0;
      _.end = t1;
      _._hasValue = t2;
      _.invalidValue = t3;
      _.name = t4;
      _.message = t5;
    },
    IndexError: function IndexError(t0, t1, t2, t3, t4) {
      var _ = this;
      _.length = t0;
      _._hasValue = t1;
      _.invalidValue = t2;
      _.name = t3;
      _.message = t4;
    },
    NoSuchMethodError: function NoSuchMethodError(t0, t1, t2, t3) {
      var _ = this;
      _._core$_receiver = t0;
      _._core$_memberName = t1;
      _._core$_arguments = t2;
      _._namedArguments = t3;
    },
    UnsupportedError: function UnsupportedError(t0) {
      this.message = t0;
    },
    UnimplementedError: function UnimplementedError(t0) {
      this.message = t0;
    },
    StateError: function StateError(t0) {
      this.message = t0;
    },
    ConcurrentModificationError: function ConcurrentModificationError(t0) {
      this.modifiedObject = t0;
    },
    OutOfMemoryError: function OutOfMemoryError() {
    },
    StackOverflowError: function StackOverflowError() {
    },
    _Exception: function _Exception(t0) {
      this.message = t0;
    },
    FormatException: function FormatException(t0, t1, t2) {
      this.message = t0;
      this.source = t1;
      this.offset = t2;
    },
    IntegerDivisionByZeroException: function IntegerDivisionByZeroException() {
    },
    Iterable: function Iterable() {
    },
    MapEntry: function MapEntry(t0, t1, t2) {
      this.key = t0;
      this.value = t1;
      this.$ti = t2;
    },
    Null: function Null() {
    },
    Object: function Object() {
    },
    _StringStackTrace: function _StringStackTrace() {
    },
    Runes: function Runes(t0) {
      this.string = t0;
    },
    RuneIterator: function RuneIterator(t0) {
      var _ = this;
      _.string = t0;
      _._nextPosition = _._position = 0;
      _._currentCodePoint = -1;
    },
    StringBuffer: function StringBuffer(t0) {
      this._contents = t0;
    },
    Uri__parseIPv4Address_error: function Uri__parseIPv4Address_error(t0) {
      this.host = t0;
    },
    Uri_parseIPv6Address_error: function Uri_parseIPv6Address_error(t0) {
      this.host = t0;
    },
    Uri_parseIPv6Address_parseHex: function Uri_parseIPv6Address_parseHex(t0, t1) {
      this.error = t0;
      this.host = t1;
    },
    _Uri: function _Uri(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.scheme = t0;
      _._userInfo = t1;
      _._host = t2;
      _._port = t3;
      _.path = t4;
      _._query = t5;
      _._fragment = t6;
      _.___Uri_hashCode_FI = _.___Uri_pathSegments_FI = _.___Uri__text_FI = $;
    },
    UriData: function UriData(t0, t1, t2) {
      this._text = t0;
      this._separatorIndices = t1;
      this._uriCache = t2;
    },
    _createTables_build: function _createTables_build(t0) {
      this.tables = t0;
    },
    _createTables_setChars: function _createTables_setChars() {
    },
    _createTables_setRange: function _createTables_setRange() {
    },
    _SimpleUri: function _SimpleUri(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _._uri = t0;
      _._schemeEnd = t1;
      _._hostStart = t2;
      _._portStart = t3;
      _._pathStart = t4;
      _._queryStart = t5;
      _._fragmentStart = t6;
      _._schemeCache = t7;
      _._hashCodeCache = null;
    },
    _DataUri: function _DataUri(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.scheme = t0;
      _._userInfo = t1;
      _._host = t2;
      _._port = t3;
      _.path = t4;
      _._query = t5;
      _._fragment = t6;
      _.___Uri_hashCode_FI = _.___Uri_pathSegments_FI = _.___Uri__text_FI = $;
    },
    Expando: function Expando(t0, t1) {
      this._jsWeakMap = t0;
      this.$ti = t1;
    },
    RawSocket_connect(host, port, timeout) {
      throw A.wrapException(A.UnsupportedError$("RawSocket constructor"));
    },
    Socket__connect(host, port, sourceAddress, sourcePort, timeout) {
      throw A.wrapException(A.UnsupportedError$("Socket constructor"));
    },
    SecureSocket_SecureSocket$_(rawSocket) {
      throw A.wrapException(A.UnsupportedError$("SecureSocket constructor"));
    },
    SecurityContext_defaultContext() {
      throw A.wrapException(A.UnsupportedError$("default SecurityContext getter"));
    },
    _SecureFilter__SecureFilter$_() {
      throw A.wrapException(A.UnsupportedError$("_SecureFilter._SecureFilter"));
    },
    _IOService__dispatch(request, data) {
      throw A.wrapException(A.UnsupportedError$("_IOService._dispatch"));
    },
    IOOverrides_current() {
      $.$get$_ioOverridesToken();
      return null;
    },
    SecureSocket_connect(host, port, context, onBadCertificate) {
      return A.RawSecureSocket_connect(host, port, context, null, onBadCertificate, null, null).then$1$1(new A.SecureSocket_connect_closure(), type$.SecureSocket);
    },
    RawSecureSocket_connect(host, port, context, keyLog, onBadCertificate, supportedProtocols, timeout) {
      A._RawSecureSocket__verifyFields(host, port, false, false);
      return A.RawSocket_connect(host, port, timeout).then$1$1(new A.RawSecureSocket_connect_closure(context, onBadCertificate, keyLog, supportedProtocols), type$.RawSecureSocket);
    },
    _RawSecureSocket$(address, requestedPort, isServer, context, _socket, subscription, _bufferedData, requestClientCertificate, requireClientCertificate, onBadCertificate, keyLog, supportedProtocols) {
      var t1 = $.Zone__current;
      t1 = new A._RawSecureSocket(_socket, new A._AsyncCompleter(new A._Future(t1, type$._Future__RawSecureSocket), type$._AsyncCompleter__RawSecureSocket), A.StreamController_StreamController(true, type$.RawSocketEvent), _bufferedData, address, false, context, false, false, onBadCertificate, keyLog, new A._AsyncCompleter(new A._Future(t1, type$._Future_RawSecureSocket), type$._AsyncCompleter_RawSecureSocket), new A._FilterStatus(), A._SecureFilter__SecureFilter$_());
      t1._RawSecureSocket$12(address, requestedPort, false, context, _socket, subscription, _bufferedData, false, false, onBadCertificate, keyLog, supportedProtocols);
      return t1;
    },
    _RawSecureSocket__verifyFields(host, requestedPort, requestClientCertificate, requireClientCertificate) {
      var t1;
      A.ArgumentError_checkNotNull(requestedPort, "requestedPort", type$.int);
      if (requestedPort < 0 || requestedPort > 65535)
        throw A.wrapException(A.ArgumentError$("requestedPort is not in the range 0..65535", null));
      t1 = type$.bool;
      A.ArgumentError_checkNotNull(false, "requestClientCertificate", t1);
      A.ArgumentError_checkNotNull(false, "requireClientCertificate", t1);
    },
    HandshakeException$(message) {
      return new A.HandshakeException("HandshakeException", message, null);
    },
    SecurityContext__protocolsToLengthEncoding(protocols) {
      return new Uint8Array(0);
    },
    Socket_connect(host, port) {
      var t1;
      A.IOOverrides_current();
      t1 = A.Socket__connect(host, port, null, 0, null);
      return t1;
    },
    SecureSocket_connect_closure: function SecureSocket_connect_closure() {
    },
    RawSecureSocket_connect_closure: function RawSecureSocket_connect_closure(t0, t1, t2, t3) {
      var _ = this;
      _.context = t0;
      _.onBadCertificate = t1;
      _.keyLog = t2;
      _.supportedProtocols = t3;
    },
    _FilterStatus: function _FilterStatus() {
      var _ = this;
      _.progress = false;
      _.writeEmpty = _.readEmpty = true;
      _.writeEncryptedNoLongerEmpty = _.readEncryptedNoLongerFull = _.writePlaintextNoLongerFull = _.readPlaintextNoLongerEmpty = false;
    },
    _RawSecureSocket: function _RawSecureSocket(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) {
      var _ = this;
      _._io$_socket = t0;
      _._handshakeComplete = t1;
      _._io$_controller = t2;
      _.___RawSecureSocket__socketSubscription_F = $;
      _._bufferedData = t3;
      _._bufferedDataIndex = 0;
      _.address = t4;
      _.isServer = t5;
      _.context = t6;
      _.requestClientCertificate = t7;
      _.requireClientCertificate = t8;
      _.onBadCertificate = t9;
      _.keyLog = t10;
      _.keyLogPort = null;
      _._io$_status = 201;
      _._readEventsEnabled = _._writeEventsEnabled = true;
      _._io$_pauseCount = 0;
      _._closedWrite = _._closedRead = _._socketClosedWrite = _._socketClosedRead = _._pendingReadEvent = false;
      _._closeCompleter = t11;
      _._filterStatus = t12;
      _._connectPending = true;
      _._filterActive = _._filterPending = false;
      _._secureFilter = t13;
    },
    _RawSecureSocket__secureHandshakeCompleteHandler_closure: function _RawSecureSocket__secureHandshakeCompleteHandler_closure(t0) {
      this.$this = t0;
    },
    TlsException: function TlsException() {
    },
    HandshakeException: function HandshakeException(t0, t1, t2) {
      this.type = t0;
      this.message = t1;
      this.osError = t2;
    },
    SocketDirection: function SocketDirection() {
    },
    RawSocketEvent: function RawSocketEvent(t0) {
      this._io$_value = t0;
    },
    _convertDartFunctionFast(f) {
      var ret,
        existing = f.$dart_jsFunction;
      if (existing != null)
        return existing;
      ret = function(_call, f) {
        return function() {
          return _call(f, Array.prototype.slice.apply(arguments));
        };
      }(A._callDartFunctionFast, f);
      ret[$.$get$DART_CLOSURE_PROPERTY_NAME()] = f;
      f.$dart_jsFunction = ret;
      return ret;
    },
    _callDartFunctionFast(callback, $arguments) {
      type$.List_dynamic._as($arguments);
      type$.Function._as(callback);
      return A.Primitives_applyFunction(callback, $arguments, null);
    },
    allowInterop(f, $F) {
      if (typeof f == "function")
        return f;
      else
        return $F._as(A._convertDartFunctionFast(f));
    },
    _noJsifyRequired(o) {
      return o == null || A._isBool(o) || typeof o == "number" || typeof o == "string" || type$.Int8List._is(o) || type$.Uint8List._is(o) || type$.Uint8ClampedList._is(o) || type$.Int16List._is(o) || type$.Uint16List._is(o) || type$.Int32List._is(o) || type$.Uint32List._is(o) || type$.Float32List._is(o) || type$.Float64List._is(o) || type$.ByteBuffer._is(o) || type$.ByteData._is(o);
    },
    jsify(object) {
      if (A._noJsifyRequired(object))
        return object;
      return new A.jsify__convert(new A._IdentityHashMap(type$._IdentityHashMap_of_nullable_Object_and_nullable_Object)).call$1(object);
    },
    getProperty(o, $name, $T) {
      return $T._as(o[$name]);
    },
    callMethod(o, method, args, $T) {
      return $T._as(o[method].apply(o, args));
    },
    promiseToFuture(jsPromise, $T) {
      var t1 = new A._Future($.Zone__current, $T._eval$1("_Future<0>")),
        completer = new A._AsyncCompleter(t1, $T._eval$1("_AsyncCompleter<0>"));
      jsPromise.then(A.convertDartClosureToJS(new A.promiseToFuture_closure(completer, $T), 1), A.convertDartClosureToJS(new A.promiseToFuture_closure0(completer), 1));
      return t1;
    },
    _noDartifyRequired(o) {
      return o == null || typeof o === "boolean" || typeof o === "number" || typeof o === "string" || o instanceof Int8Array || o instanceof Uint8Array || o instanceof Uint8ClampedArray || o instanceof Int16Array || o instanceof Uint16Array || o instanceof Int32Array || o instanceof Uint32Array || o instanceof Float32Array || o instanceof Float64Array || o instanceof ArrayBuffer || o instanceof DataView;
    },
    dartify(o) {
      if (A._noDartifyRequired(o))
        return o;
      return new A.dartify_convert(new A._IdentityHashMap(type$._IdentityHashMap_of_nullable_Object_and_nullable_Object)).call$1(o);
    },
    jsify__convert: function jsify__convert(t0) {
      this._convertedObjects = t0;
    },
    promiseToFuture_closure: function promiseToFuture_closure(t0, t1) {
      this.completer = t0;
      this.T = t1;
    },
    promiseToFuture_closure0: function promiseToFuture_closure0(t0) {
      this.completer = t0;
    },
    dartify_convert: function dartify_convert(t0) {
      this._convertedObjects = t0;
    },
    NullRejectionException: function NullRejectionException(t0) {
      this.isUndefined = t0;
    },
    max(a, b, $T) {
      A.checkTypeBound($T, type$.num, "T", "max");
      return Math.max($T._as(a), $T._as(b));
    },
    _JSSecureRandom: function _JSSecureRandom(t0) {
      this._math$_buffer = t0;
    },
    Endian: function Endian() {
    },
    BitcoinAddressType_fromValue(value) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_oyU, new A.BitcoinAddressType_fromValue_closure(value), new A.BitcoinAddressType_fromValue_closure0(value));
    },
    _BitcoinAddressUtils_decodeLagacyAddress(address) {
      var decode, scriptBytes, version, data, checksum, hash, exception;
      try {
        decode = A.List_List$unmodifiable(A.Base58Decoder_decode(address, B.Base58Alphabets_0), type$.int);
        scriptBytes = J.sublist$2$ax(decode, 1, J.get$length$asx(decode) - 4);
        if (J.get$length$asx(scriptBytes) !== 20)
          return null;
        version = A._setArrayType([J.$index$asx(decode, 0)], type$.JSArray_int);
        data = J.sublist$2$ax(decode, 0, J.get$length$asx(decode) - 4);
        checksum = J.sublist$1$ax(decode, J.get$length$asx(decode) - 4);
        hash = B.JSArray_methods.sublist$2(A.SHA256_hash(A.SHA256_hash(data)), 0, 4);
        if (!A.BytesUtils_bytesEqual(checksum, hash))
          return null;
        return new A.Tuple(scriptBytes, version, type$.Tuple_of_List_int_and_List_int);
      } catch (exception) {
        return null;
      }
    },
    _BitcoinAddressUtils_toLegacy(address, networks) {
      var decodedHex, t1,
        decode = A._BitcoinAddressUtils_decodeLagacyAddress(address);
      if (decode == null)
        return null;
      decodedHex = A.BytesUtils_toHexString(decode.item1, true, null);
      t1 = decode.item2;
      if (A.BytesUtils_bytesEqual(t1, networks.get$p2pkhNetVer()))
        return new A.P2pkhAddress(B.P2pkhAddressType_P2PKH, A._BitcoinAddressUtils_validateAddressProgram(decodedHex, B.P2pkhAddressType_P2PKH));
      else if (A.BytesUtils_bytesEqual(t1, networks.get$p2shNetVer()))
        return new A.P2shAddress(B.P2shAddressType_g2q, A._BitcoinAddressUtils_validateAddressProgram(decodedHex, B.P2shAddressType_g2q));
      return null;
    },
    _BitcoinAddressUtils_toSegwitAddress(address, network) {
      var convert, witnessVersion, decodedBytesHex, t1, exception;
      try {
        convert = A.SegwitBech32Decoder_decode(network.get$p2wpkhHrp(), address);
        witnessVersion = convert.item1;
        decodedBytesHex = A.BytesUtils_toHexString(convert.item2, true, null);
        if (J.$eq$(witnessVersion, 1)) {
          t1 = A._BitcoinAddressUtils_validateAddressProgram(decodedBytesHex, B.SegwitAddresType_P2TR);
          return new A.P2trAddress(t1, 1);
        } else if (J.$eq$(witnessVersion, 0))
          if (J.get$length$asx(convert.item2) === 20) {
            t1 = A._BitcoinAddressUtils_validateAddressProgram(decodedBytesHex, B.SegwitAddresType_P2WPKH);
            return new A.P2wpkhAddress(t1, 0);
          } else if (J.get$length$asx(convert.item2) === 32) {
            t1 = A._BitcoinAddressUtils_validateAddressProgram(decodedBytesHex, B.SegwitAddresType_P2WSH);
            return new A.P2wshAddress(t1, 0);
          }
        return null;
      } catch (exception) {
        return null;
      }
    },
    _BitcoinAddressUtils_validateAddress(address, network) {
      if (B.JSArray_methods.contains$1(network.get$supportedAddress(), address.get$type()))
        return address;
      throw A.wrapException(A.BitcoinBasePluginException$(network.get$value() + " does not support " + address.get$type().get$value() + " address"));
    },
    _BitcoinAddressUtils_decodeAddress(address, network) {
      var baseAddress = B.JSArray_methods.contains$1(network.get$supportedAddress(), B.SegwitAddresType_P2WPKH) ? A._BitcoinAddressUtils_toSegwitAddress(address, network) : null;
      if (baseAddress == null)
        baseAddress = A._BitcoinAddressUtils_toLegacy(address, network);
      if (baseAddress == null)
        throw A.wrapException(B.BitcoinBasePluginException_b1g);
      return A._BitcoinAddressUtils_validateAddress(baseAddress, network);
    },
    _BitcoinAddressUtils_validateAddressProgram(hash160, addressType) {
      var toBytes, exception;
      try {
        toBytes = A.BytesUtils_fromHexString(hash160);
        if (J.get$length$asx(toBytes) === addressType.get$hashLength())
          return hash160;
      } catch (exception) {
      }
      throw A.wrapException(B.BitcoinBasePluginException_uH4);
    },
    _BitcoinAddressUtils_decodeBchAddress(address, network, validateNetworkHRP) {
      var hrp, decode, scriptBytes, version, hrp0, t1, decode0, convData, ver, exception;
      try {
        hrp0 = B.JSString_methods.substring$2(address, 0, B.JSString_methods.indexOf$1(address, ":"));
        hrp = hrp0;
        t1 = hrp;
        decode0 = A.Bech32DecoderBase_decodeBech32(address, ":", 8, A.bch_bech32__BchBech32Utils_verifyChecksum$closure());
        if (!J.$eq$(decode0.item1, t1))
          A.throwExpression(A.ArgumentException$("Invalid format (HRP not valid, expected " + t1 + ", got " + A.S(decode0.item2) + ")"));
        convData = A.Bech32BaseUtils_convertFromBase32(decode0.item2);
        if (0 >= convData.length)
          return A.ioore(convData, 0);
        ver = convData[0];
        decode = new A.Tuple(A.IntUtils_toBytes(ver, B.C_Endian0, A.IntUtils_bitlengthInBytes(ver)), B.JSArray_methods.sublist$1(convData, 1), type$.Tuple_of_List_int_and_List_int);
        scriptBytes = decode.item2;
        version = decode.item1;
        t1 = A._BitcoinAddressUtils__validateBchScriptBytes(network, scriptBytes, version);
        return t1;
      } catch (exception) {
        return null;
      }
    },
    _BitcoinAddressUtils__validateBchScriptBytes(network, scriptBytes, version) {
      var t2, legacyP2pk, legacyP2sh,
        scriptHex = A.BytesUtils_toHexString(scriptBytes, true, null),
        scriptLength = J.get$length$asx(scriptBytes),
        t1 = scriptLength === 20;
      if (!t1 && scriptLength !== 32)
        return null;
      if (t1) {
        t1 = network.conf.params;
        t2 = t1.p2pkhStdNetVer;
        t2.toString;
        legacyP2pk = A.BytesUtils_bytesEqual(t2, version);
        if (A.BytesUtils_bytesEqual(t2, version) || A.BytesUtils_bytesEqual(B.List_16, version)) {
          t1 = legacyP2pk ? B.P2pkhAddressType_P2PKH : B.P2pkhAddressType_P2PKHWT;
          return new A.P2pkhAddress(t1, A._BitcoinAddressUtils_validateAddressProgram(scriptHex, t1));
        }
        t1 = t1.p2shStdNetVer;
        t1.toString;
        legacyP2sh = A.BytesUtils_bytesEqual(t1, version);
        if (A.BytesUtils_bytesEqual(t1, version) || A.BytesUtils_bytesEqual(B.List_24, version)) {
          t1 = legacyP2sh ? B.P2shAddressType_sc9 : B.P2shAddressType_lhG;
          return new A.P2shAddress(t1, A._BitcoinAddressUtils_validateAddressProgram(scriptHex, t1));
        }
      } else {
        legacyP2sh = A.BytesUtils_bytesEqual(B.List_11, version);
        if (A.BytesUtils_bytesEqual(B.List_11, version) || A.BytesUtils_bytesEqual(B.List_27, version)) {
          t1 = legacyP2sh ? B.P2shAddressType_hK7 : B.P2shAddressType_0;
          return new A.P2shAddress(t1, A._BitcoinAddressUtils_validateAddressProgram(scriptHex, t1));
        }
      }
      return null;
    },
    _BitcoinAddressUtils_decodeLagacyAddressWithNetworkAndType(address, network, type) {
      var decode, t1, version, scriptHex, _null = null;
      if (!B.JSArray_methods.contains$1(network.get$supportedAddress(), type))
        throw A.wrapException(A.BitcoinBasePluginException$(network.get$value() + " does not support " + type.get$value() + " address type"));
      if (network instanceof A.BitcoinCashNetwork) {
        decode = A._BitcoinAddressUtils_decodeBchAddress(address, network, false);
        if (decode != null)
          if (decode.get$type() === type) {
            decode.get$type();
            t1 = decode.__LegacyAddress__addressProgram_F;
            t1 === $ && A.throwLateFieldNI("_addressProgram");
            return t1;
          }
        return _null;
      }
      decode = A._BitcoinAddressUtils_decodeLagacyAddress(address);
      if (decode == null)
        return _null;
      version = decode.item2;
      scriptHex = A.BytesUtils_toHexString(decode.item1, true, _null);
      switch (type) {
        case B.P2pkhAddressType_P2PKH:
          if (A.BytesUtils_bytesEqual(version, network.get$p2pkhNetVer()))
            return scriptHex;
          return _null;
        case B.P2shAddressType_sc9:
        case B.P2shAddressType_g2q:
        case B.P2shAddressType_qI5:
        case B.P2shAddressType_SfU:
          if (A.BytesUtils_bytesEqual(version, network.get$p2shNetVer()))
            return scriptHex;
          return _null;
      }
      return scriptHex;
    },
    _BitcoinAddressUtils_segwitScriptToSHA256(script) {
      return A.BytesUtils_toHexString(A.SHA256_hash(script.toBytes$0()), true, null);
    },
    _BitcoinAddressUtils__getBchNetVersion(network, secriptLength, type) {
      var t1,
        isToken = B.JSString_methods.contains$1(type.get$value(), "WT");
      if (!type.get$isP2sh()) {
        if (!isToken) {
          t1 = network.conf.params.p2pkhStdNetVer;
          t1.toString;
          return t1;
        }
        return B.List_16;
      } else {
        if (!isToken) {
          if (secriptLength === 20) {
            t1 = network.conf.params.p2shStdNetVer;
            t1.toString;
            return t1;
          }
          return B.List_11;
        }
        if (secriptLength === 20)
          return B.List_24;
        return B.List_27;
      }
    },
    _BitcoinAddressUtils_legacyToAddress(addressProgram, network, type) {
      var programBytes, netVersion, t1, t2;
      if (network instanceof A.BitcoinCashNetwork) {
        programBytes = A.BytesUtils_fromHexString(addressProgram);
        netVersion = A._BitcoinAddressUtils__getBchNetVersion(network, programBytes.length, type);
        t1 = network.conf.params.p2pkhStdHrp;
        t1.toString;
        t2 = A.List_List$of(netVersion, true, type$.dynamic);
        B.JSArray_methods.addAll$1(t2, programBytes);
        return A.Bech32EncoderBase_encodeBech32(t1, A.Bech32BaseUtils_convertToBase32(A.List_List$from(t2, true, type$.int)), ":", A.bch_bech32__BchBech32Utils_computeChecksum$closure());
      }
      programBytes = A.BytesUtils_fromHexString(addressProgram);
      switch (type) {
        case B.P2shAddressType_SfU:
        case B.P2shAddressType_qI5:
        case B.P2shAddressType_sc9:
        case B.P2shAddressType_g2q:
          t1 = A.List_List$of(network.get$p2shNetVer(), true, type$.int);
          B.JSArray_methods.addAll$1(t1, programBytes);
          programBytes = t1;
          break;
        case B.P2pkhAddressType_P2PKH:
        case B.C_PubKeyAddressType:
          t1 = A.List_List$of(network.get$p2pkhNetVer(), true, type$.int);
          B.JSArray_methods.addAll$1(t1, programBytes);
          programBytes = t1;
          break;
      }
      return A.Base58Encoder_checkEncode(programBytes, B.Base58Alphabets_0);
    },
    _BitcoinAddressUtils_scriptToHash160(s) {
      return A.BytesUtils_toHexString(A.RIPEMD160_hash(A.SHA256_hash(s.toBytes$0())), true, null);
    },
    BitcoinAddressType_fromValue_closure: function BitcoinAddressType_fromValue_closure(t0) {
      this.value = t0;
    },
    BitcoinAddressType_fromValue_closure0: function BitcoinAddressType_fromValue_closure0(t0) {
      this.value = t0;
    },
    PubKeyAddressType: function PubKeyAddressType() {
    },
    P2pkhAddressType: function P2pkhAddressType(t0) {
      this.value = t0;
    },
    P2shAddressType: function P2shAddressType(t0, t1) {
      this.hashLength = t0;
      this.value = t1;
    },
    SegwitAddresType: function SegwitAddresType(t0) {
      this.value = t0;
    },
    LegacyAddress: function LegacyAddress() {
    },
    P2shAddress: function P2shAddress(t0, t1) {
      this.type = t0;
      this.__LegacyAddress__addressProgram_F = t1;
    },
    P2pkhAddress: function P2pkhAddress(t0, t1) {
      this.type = t0;
      this.__LegacyAddress__addressProgram_F = t1;
    },
    P2pkAddress: function P2pkAddress(t0) {
      this.__P2pkAddress_publicHex_F = $;
      this.__LegacyAddress__addressProgram_F = t0;
    },
    BitcoinNetworkAddress: function BitcoinNetworkAddress() {
    },
    BitcoinAddress: function BitcoinAddress(t0) {
      this.baseAddress = t0;
    },
    DogeAddress: function DogeAddress(t0) {
      this.baseAddress = t0;
    },
    PepeAddress: function PepeAddress(t0) {
      this.baseAddress = t0;
    },
    LitecoinAddress: function LitecoinAddress(t0) {
      this.baseAddress = t0;
    },
    BitcoinCashAddress: function BitcoinCashAddress(t0) {
      this.baseAddress = t0;
    },
    DashAddress: function DashAddress(t0) {
      this.baseAddress = t0;
    },
    SegwitAddress: function SegwitAddress() {
    },
    P2wpkhAddress: function P2wpkhAddress(t0, t1) {
      this.__SegwitAddress_addressProgram_F = t0;
      this.segwitVersion = t1;
    },
    P2trAddress: function P2trAddress(t0, t1) {
      this.__SegwitAddress_addressProgram_F = t0;
      this.segwitVersion = t1;
    },
    P2wshAddress: function P2wshAddress(t0, t1) {
      this.__SegwitAddress_addressProgram_F = t0;
      this.segwitVersion = t1;
    },
    Script: function Script(t0) {
      this.script = t0;
    },
    ECPublic: function ECPublic(t0) {
      this.publicKey = t0;
    },
    BitcoinBasePluginException$(message) {
      return new A.BitcoinBasePluginException(message);
    },
    BitcoinBasePluginException: function BitcoinBasePluginException(t0) {
      this.message = t0;
    },
    BasedUtxoNetwork_fromName($name) {
      return B.JSArray_methods.firstWhere$1(B.List_01, new A.BasedUtxoNetwork_fromName_closure($name));
    },
    BasedUtxoNetwork_fromName_closure: function BasedUtxoNetwork_fromName_closure(t0) {
      this.name = t0;
    },
    BitcoinSVNetwork: function BitcoinSVNetwork(t0, t1) {
      this.conf = t0;
      this.value = t1;
    },
    BitcoinNetwork: function BitcoinNetwork(t0, t1) {
      this.conf = t0;
      this.value = t1;
    },
    LitecoinNetwork: function LitecoinNetwork(t0, t1) {
      this.conf = t0;
      this.value = t1;
    },
    DashNetwork: function DashNetwork(t0, t1) {
      this.conf = t0;
      this.value = t1;
    },
    DogecoinNetwork: function DogecoinNetwork(t0, t1) {
      this.conf = t0;
      this.value = t1;
    },
    BitcoinCashNetwork: function BitcoinCashNetwork(t0, t1) {
      this.conf = t0;
      this.value = t1;
    },
    PepeNetwork: function PepeNetwork() {
    },
    ApiProvider: function ApiProvider() {
    },
    APIConfig_APIConfig$fromBlockCypher(network) {
      switch (network) {
        case B.BitcoinNetwork_qBr:
          break;
        case B.BitcoinNetwork_DSc:
          break;
        case B.DashNetwork_XbV:
          break;
        case B.DogecoinNetwork_6L0:
          break;
        case B.LitecoinNetwork_OXY:
          break;
        default:
          throw A.wrapException(A.BitcoinBasePluginException$("blockcypher does not support " + network.get$conf().coinName.name + ", u must use your own provider"));
      }
      return new A.APIConfig();
    },
    APIConfig_APIConfig$mempool(network) {
      switch (network) {
        case B.BitcoinNetwork_qBr:
          break;
        case B.BitcoinNetwork_DSc:
          break;
        default:
          throw A.wrapException(A.BitcoinBasePluginException$("mempool does not support " + network.get$conf().coinName.name));
      }
      return new A.APIConfig();
    },
    APIType: function APIType(t0) {
      this._core$_name = t0;
    },
    APIConfig: function APIConfig() {
    },
    Base58Encoder_encode(dataBytes, base58alphabets) {
      var val, t2, enc, t3, div, zero, _i,
        t1 = B.Map_inkaS.$index(0, base58alphabets);
      t1.toString;
      val = A.BigintUtils_fromBytes(dataBytes, B.C_Endian, false);
      for (t2 = t1.length, enc = ""; val.compareTo$1(0, $.$get$_BigIntImpl_zero()) > 0; val = div) {
        t3 = A._BigIntImpl__BigIntImpl$from(58);
        if (t3._used === 0)
          A.throwExpression(B.C_IntegerDivisionByZeroException);
        div = val._div$1(t3);
        t3 = val.$mod(0, A._BigIntImpl__BigIntImpl$from(58)).toInt$0(0);
        if (!(t3 >= 0 && t3 < t2))
          return A.ioore(t1, t3);
        enc = t1[t3] + enc;
      }
      for (t3 = dataBytes.length, zero = 0, _i = 0; _i < dataBytes.length; dataBytes.length === t3 || (0, A.throwConcurrentModificationError)(dataBytes), ++_i)
        if (J.$eq$(dataBytes[_i], 0))
          ++zero;
        else
          break;
      t3 = dataBytes.length;
      if (0 >= t2)
        return A.ioore(t1, 0);
      return B.JSString_methods.$mul(t1[0], t3 - (t3 - zero)) + enc;
    },
    Base58Encoder_checkEncode(dataBytes, base58alphabets) {
      var checksum = B.JSArray_methods.sublist$2(A.SHA256_hash(A.SHA256_hash(dataBytes)), 0, 4),
        t1 = A.List_List$of(dataBytes, true, type$.dynamic);
      B.JSArray_methods.addAll$1(t1, checksum);
      return A.Base58Encoder_encode(A.List_List$from(t1, true, type$.int), base58alphabets);
    },
    Base58Decoder_decode(data, base58alphabets) {
      var val, t2, t3, i, t4, charIndex, bytes, padLen,
        t1 = B.Map_inkaS.$index(0, base58alphabets);
      t1.toString;
      val = $.$get$_BigIntImpl_zero();
      for (t2 = data.length, t3 = t2 - 1, i = 0; i < t2; ++i) {
        t4 = t3 - i;
        if (!(t4 >= 0))
          return A.ioore(data, t4);
        charIndex = B.JSString_methods.indexOf$1(t1, data[t4]);
        if (charIndex === -1)
          throw A.wrapException(B.MessageException_IMr);
        val = val.$add(0, A._BigIntImpl__BigIntImpl$from(charIndex).$mul(0, A._BigIntImpl__BigIntImpl$from(58).pow$1(i)));
      }
      bytes = A.BigintUtils_toBytes(val, B.JSInt_methods._tdivFast$1((val._isNegative ? val.$negate(0) : val).get$bitLength(0) + 7, 8), B.C_Endian);
      for (t3 = t1.length, padLen = 0, i = 0; i < t2; ++i) {
        t4 = data[i];
        if (0 >= t3)
          return A.ioore(t1, 0);
        if (t4 === t1[0])
          ++padLen;
        else
          break;
      }
      t1 = type$.int;
      t2 = A.List_List$of(A.List_List$filled(padLen, 0, false, t1), true, type$.dynamic);
      B.JSArray_methods.addAll$1(t2, bytes);
      return A.List_List$from(t2, true, t1);
    },
    Base58Decoder_checkDecode(data, base58alphabets) {
      var decodedBytes = A.Base58Decoder_decode(data, base58alphabets),
        dataBytes = B.JSArray_methods.sublist$2(decodedBytes, 0, decodedBytes.length - 4),
        checksumBytes = B.JSArray_methods.sublist$1(decodedBytes, decodedBytes.length - 4),
        computedChecksum = B.JSArray_methods.sublist$2(A.SHA256_hash(A.SHA256_hash(dataBytes)), 0, 4);
      if (!A.BytesUtils_bytesEqual(checksumBytes, computedChecksum))
        throw A.wrapException(new A.Base58ChecksumError("Invalid checksum (expected " + A.BytesUtils_toHexString(computedChecksum, true, null) + ", got " + A.BytesUtils_toHexString(checksumBytes, true, null) + ")"));
      return dataBytes;
    },
    Base58Alphabets: function Base58Alphabets(t0) {
      this._core$_name = t0;
    },
    Base58ChecksumError: function Base58ChecksumError(t0) {
      this.message = t0;
    },
    _BchBech32Utils_polyMod(values) {
      var _i, value, $top, valueBig, _i0, i, t2,
        t1 = type$.JSArray_BigInt,
        generator = [A._setArrayType([A._BigIntImpl__BigIntImpl$from(1), A._BigIntImpl__BigIntImpl$from(656907472481)], t1), A._setArrayType([A._BigIntImpl__BigIntImpl$from(2), A._BigIntImpl__BigIntImpl$from(522768456162)], t1), A._setArrayType([A._BigIntImpl__BigIntImpl$from(4), A._BigIntImpl__BigIntImpl$from(1044723512260)], t1), A._setArrayType([A._BigIntImpl__BigIntImpl$from(8), A._BigIntImpl__BigIntImpl$from(748107326120)], t1), A._setArrayType([A._BigIntImpl__BigIntImpl$from(16), A._BigIntImpl__BigIntImpl$from(130178868336)], t1)],
        chk = $.$get$_BigIntImpl_one();
      for (t1 = values.length, _i = 0; _i < values.length; values.length === t1 || (0, A.throwConcurrentModificationError)(values), ++_i) {
        value = values[_i];
        $top = chk.$shr(0, 35);
        valueBig = A._BigIntImpl__BigIntImpl$from(value);
        chk = chk.$and(0, A._BigIntImpl__BigIntImpl$from(34359738367)).$shl(0, 5).$xor(0, valueBig);
        for (_i0 = 0; _i0 < 5; ++_i0) {
          i = generator[_i0];
          if (0 >= i.length)
            return A.ioore(i, 0);
          t2 = $top.$and(0, i[0]).compareTo$1(0, $.$get$_BigIntImpl_zero());
          if (t2 !== 0) {
            if (1 >= i.length)
              return A.ioore(i, 1);
            chk = chk.$xor(0, i[1]);
          }
        }
      }
      return chk.$xor(0, $.$get$_BigIntImpl_one());
    },
    _BchBech32Utils_hrpExpand(hrp) {
      var expandedHrp,
        t1 = type$.Runes;
      t1 = A.MappedIterable_MappedIterable(new A.Runes(hrp), t1._eval$1("int(Iterable.E)")._as(new A._BchBech32Utils_hrpExpand_closure()), t1._eval$1("Iterable.E"), type$.int);
      expandedHrp = A.List_List$of(t1, true, A._instanceType(t1)._eval$1("Iterable.E"));
      B.JSArray_methods.add$1(expandedHrp, 0);
      return expandedHrp;
    },
    _BchBech32Utils_computeChecksum(hrp, data) {
      var polymod, _list, i;
      type$.List_int._as(data);
      polymod = A._BchBech32Utils_polyMod(B.JSArray_methods.$add(B.JSArray_methods.$add(A._BchBech32Utils_hrpExpand(hrp), data), A._setArrayType([0, 0, 0, 0, 0, 0, 0, 0], type$.JSArray_int)));
      _list = J.JSArray_JSArray$allocateGrowable(8, type$.int);
      for (i = 0; i < 8; ++i)
        _list[i] = polymod.$shr(0, 5 * (7 - i)).$and(0, $.$get$_BchBech32Utils__mask5()).toInt$0(0);
      return _list;
    },
    _BchBech32Utils_verifyChecksum(hrp, data) {
      var t1;
      type$.List_int._as(data);
      t1 = A.List_List$of(A._BchBech32Utils_hrpExpand(hrp), true, type$.int);
      B.JSArray_methods.addAll$1(t1, data);
      t1 = A._BchBech32Utils_polyMod(t1).compareTo$1(0, $.$get$_BigIntImpl_zero());
      return t1 === 0;
    },
    _BchBech32Utils_hrpExpand_closure: function _BchBech32Utils_hrpExpand_closure() {
    },
    Bech32Utils_polyMod(values) {
      var t1, chk, _i, value, $top, i,
        generator = [996825010, 642813549, 513874426, 1027748829, 705979059];
      for (t1 = values.length, chk = 1, _i = 0; _i < t1; ++_i) {
        value = values[_i];
        $top = chk >>> 25;
        if (typeof value !== "number")
          return A.iae(value);
        chk = ((chk & 33554431) << 5 ^ value) >>> 0;
        for (i = 0; i < 5; ++i)
          chk = (chk ^ ((B.JSInt_methods._shrBothPositive$1($top, i) & 1) !== 0 ? generator[i] : 0)) >>> 0;
      }
      return chk;
    },
    Bech32Utils_hrpExpand(hrp) {
      var t1, i,
        expand = A._setArrayType([], type$.JSArray_int);
      for (t1 = hrp.length, i = 0; i < t1; ++i)
        B.JSArray_methods.add$1(expand, hrp.charCodeAt(i) >>> 5);
      B.JSArray_methods.add$1(expand, 0);
      for (i = 0; i < t1; ++i)
        B.JSArray_methods.add$1(expand, hrp.charCodeAt(i) & 31);
      return expand;
    },
    Bech32Utils_computeChecksum(hrp, data, encoding) {
      var t1, t2, t3, polymod, i;
      A._asString(hrp);
      type$.List_int._as(data);
      type$.Bech32Encodings._as(encoding);
      t1 = type$.int;
      t2 = A.List_List$of(A.Bech32Utils_hrpExpand(hrp), true, t1);
      B.JSArray_methods.addAll$1(t2, data);
      t2 = A.List_List$of(t2, true, t1);
      t2.push(0);
      t2.push(0);
      t2.push(0);
      t2.push(0);
      t2.push(0);
      t2.push(0);
      t2 = A.Bech32Utils_polyMod(t2);
      t3 = B.Map_2NhUP.$index(0, encoding);
      t3.toString;
      polymod = (t2 ^ t3) >>> 0;
      t3 = [];
      for (i = 0; i < 6; ++i)
        t3.push(B.JSInt_methods._shrReceiverPositive$1(polymod, 5 * (5 - i)) & 31);
      return A.List_List$from(t3, true, t1);
    },
    Bech32Utils_verifyChecksum(hrp, data, encoding) {
      var t1;
      A._asString(hrp);
      type$.List_int._as(data);
      type$.Bech32Encodings._as(encoding);
      t1 = A.List_List$of(A.Bech32Utils_hrpExpand(hrp), true, type$.int);
      B.JSArray_methods.addAll$1(t1, data);
      return A.Bech32Utils_polyMod(t1) === B.Map_2NhUP.$index(0, encoding);
    },
    Bech32Decoder_decodeWithoutHRP(address) {
      var decode = A.Bech32DecoderBase_decodeBech32(address, "1", 6, A.bech32_base_Bech32Utils_verifyChecksum$closure());
      return new A.Tuple(decode.item1, A.Bech32BaseUtils_convertFromBase32(decode.item2), type$.Tuple_of_String_and_List_int);
    },
    Bech32Encodings: function Bech32Encodings(t0) {
      this._core$_name = t0;
    },
    Bech32ChecksumError: function Bech32ChecksumError() {
    },
    Bech32BaseUtils_convertToBase32(data) {
      var convData = A.Bech32BaseUtils__convertBits(data, 8, 5, true);
      if (convData == null)
        throw A.wrapException(B.ArgumentException_mxs);
      return convData;
    },
    Bech32BaseUtils_convertFromBase32(data) {
      var convData = A.Bech32BaseUtils__convertBits(data, 5, 8, false);
      if (convData == null)
        throw A.wrapException(B.ArgumentException_a51);
      return convData;
    },
    Bech32BaseUtils__convertBits(data, fromBits, toBits, pad) {
      var t1, acc, bits, t2,
        maxOutVal = B.JSInt_methods._shlPositive$1(1, toBits) - 1,
        maxAcc = B.JSInt_methods.$shl(1, fromBits + toBits - 1) - 1,
        ret = A._setArrayType([], type$.JSArray_int);
      for (t1 = J.get$iterator$ax(data), acc = 0, bits = 0; t1.moveNext$0();) {
        t2 = t1.get$current();
        if (t2 < 0 || B.JSInt_methods._shrOtherPositive$1(t2, fromBits) !== 0)
          return null;
        acc = ((B.JSInt_methods._shlPositive$1(acc, fromBits) | t2) & maxAcc) >>> 0;
        bits += fromBits;
        for (; bits >= toBits;) {
          bits -= toBits;
          B.JSArray_methods.add$1(ret, (B.JSInt_methods._shrReceiverPositive$1(acc, bits) & maxOutVal) >>> 0);
        }
      }
      if (pad) {
        if (bits > 0)
          B.JSArray_methods.add$1(ret, (B.JSInt_methods.$shl(acc, toBits - bits) & maxOutVal) >>> 0);
      } else if (bits >= fromBits || (B.JSInt_methods.$shl(acc, toBits - bits) & maxOutVal) >>> 0 !== 0)
        return null;
      return A.List_List$from(ret, true, type$.int);
    },
    Bech32EncoderBase_encodeBech32(hrp, data, sep, computeChecksum) {
      var checksum = computeChecksum.call$2(hrp, data),
        t1 = A.List_List$of(data, true, type$.dynamic);
      B.JSArray_methods.addAll$1(t1, checksum);
      data = A.List_List$from(t1, true, type$.int);
      t1 = A._arrayInstanceType(data);
      return hrp + sep + new A.MappedListIterable(data, t1._eval$1("String(1)")._as(new A.Bech32EncoderBase_encodeBech32_closure()), t1._eval$1("MappedListIterable<1,String>")).join$0(0);
    },
    Bech32DecoderBase_decodeBech32(bechStr, sep, checksumLen, verifyChecksum) {
      var sepPos, hrp, t1, dataPart, t2, intData,
        hasLowerCase = B.JSString_methods.contains$1(bechStr, A.RegExp_RegExp("[a-z]", true)),
        hasUpperCase = B.JSString_methods.contains$1(bechStr, A.RegExp_RegExp("[A-Z]", true));
      if (hasLowerCase && hasUpperCase)
        throw A.wrapException(B.ArgumentException_sDr);
      bechStr = bechStr.toLowerCase();
      sepPos = B.JSString_methods.lastIndexOf$1(bechStr, sep);
      if (sepPos === -1)
        throw A.wrapException(B.ArgumentException_92p);
      hrp = B.JSString_methods.substring$2(bechStr, 0, sepPos);
      if (hrp.length !== 0) {
        t1 = new A.CodeUnits(hrp);
        t1 = t1.any$1(t1, new A.Bech32DecoderBase_decodeBech32_closure());
      } else
        t1 = true;
      if (t1)
        throw A.wrapException(A.ArgumentException$("Invalid bech32 format (HRP not valid: " + hrp + ")"));
      dataPart = B.JSString_methods.substring$1(bechStr, sepPos + 1);
      if (dataPart.length >= checksumLen + 1) {
        t1 = new A.CodeUnits(dataPart);
        t1 = t1.any$1(t1, new A.Bech32DecoderBase_decodeBech32_closure0());
      } else
        t1 = true;
      if (t1)
        throw A.wrapException(B.ArgumentException_TTS);
      t1 = type$.CodeUnits;
      t2 = t1._eval$1("MappedListIterable<ListBase.E,int>");
      intData = A.List_List$of(new A.MappedListIterable(new A.CodeUnits(dataPart), t1._eval$1("int(ListBase.E)")._as(new A.Bech32DecoderBase_decodeBech32_closure1()), t2), true, t2._eval$1("ListIterable.E"));
      if (!A.boolConversionCheck(verifyChecksum.call$2(hrp, intData)))
        throw A.wrapException(B.C_Bech32ChecksumError);
      return new A.Tuple(hrp, A.List_List$from(B.JSArray_methods.sublist$2(intData, 0, intData.length - checksumLen), true, type$.int), type$.Tuple_of_String_and_List_int);
    },
    Bech32EncoderBase_encodeBech32_closure: function Bech32EncoderBase_encodeBech32_closure() {
    },
    Bech32DecoderBase_decodeBech32_closure: function Bech32DecoderBase_decodeBech32_closure() {
    },
    Bech32DecoderBase_decodeBech32_closure0: function Bech32DecoderBase_decodeBech32_closure0() {
    },
    Bech32DecoderBase_decodeBech32_closure1: function Bech32DecoderBase_decodeBech32_closure1() {
    },
    ADAAddressType_decodeAddressType(header) {
      switch (header >>> 4 & 15) {
        case 0:
        case 1:
        case 2:
        case 3:
          return B.ADAAddressType_0_Base;
        case 14:
        case 15:
          return B.ADAAddressType_14_Reward;
        case 6:
        case 7:
          return B.ADAAddressType_6_Enterprise;
        case 4:
        case 5:
          return B.ADAAddressType_4_Pointer;
        case 8:
          return B.ADAAddressType_8_Byron;
      }
      throw A.wrapException(A.AddressConverterException$("Invalid address header bytes.", A.LinkedHashMap_LinkedHashMap$_literal(["value", header], type$.String, type$.dynamic)));
    },
    ADAAddressType_fromHeader(header) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_yH3, new A.ADAAddressType_fromHeader_closure(header), new A.ADAAddressType_fromHeader_closure0());
    },
    ADAAddressType: function ADAAddressType(t0, t1) {
      this.header = t0;
      this.name = t1;
    },
    ADAAddressType_fromHeader_closure: function ADAAddressType_fromHeader_closure(t0) {
      this.header = t0;
    },
    ADAAddressType_fromHeader_closure0: function ADAAddressType_fromHeader_closure0() {
    },
    ADAByronAddrTypes_ADAByronAddrTypes$fromCbor(value) {
      return B.JSArray_methods.firstWhere$1(B.List_ugX, new A.ADAByronAddrTypes_ADAByronAddrTypes$fromCbor_closure(value));
    },
    ADAByronAddr_ADAByronAddr$deserialize(serAddrBytes) {
      var t2, t3, crcTag, payloadBytes, crc32Got, t4, t5, t6, hdPath, networkMagic, _null = null,
        t1 = A.CborUtils__decode(serAddrBytes).item1;
      if (!(t1 instanceof A.CborListValue) || t1.value.length !== 2)
        throw A.wrapException(B.AddressConverterException_6uL);
      t1 = t1.value;
      t2 = t1.length;
      if (0 >= t2)
        return A.ioore(t1, 0);
      t3 = t1[0];
      if (t3 instanceof A.CborTagValue) {
        if (1 >= t2)
          return A.ioore(t1, 1);
        t2 = !(t1[1] instanceof A.CborIntValue);
      } else
        t2 = true;
      if (t2)
        throw A.wrapException(B.AddressConverterException_6uL);
      type$.CborTagValue_dynamic._as(t3);
      t2 = t3.tags;
      if (t2.length === 0 || !J.$eq$(B.JSArray_methods.get$first(t2), 24) || !(t3.value instanceof A.CborBytesValue))
        throw A.wrapException(B.AddressConverterException_fw6);
      if (1 >= t1.length)
        return A.ioore(t1, 1);
      t2 = type$.CborIntValue;
      crcTag = t2._as(t1[1]).value;
      payloadBytes = type$.List_int._as(t3.value.get$value());
      crc32Got = A.Crc32_quickIntDigest(payloadBytes);
      if (crc32Got !== crcTag)
        throw A.wrapException(A.AddressConverterException$("Invalid CRC (expected: " + crcTag + ", got: " + crc32Got + ")", _null));
      t1 = A.CborUtils__decode(payloadBytes).item1;
      if (!(t1 instanceof A.CborListValue) || t1.value.length !== 3)
        A.throwExpression(B.AddressConverterException_4Df);
      t1 = t1.value;
      t3 = t1.length;
      if (0 >= t3)
        return A.ioore(t1, 0);
      t4 = t1[0];
      if (t4 instanceof A.CborBytesValue) {
        if (1 >= t3)
          return A.ioore(t1, 1);
        if (t1[1] instanceof A.CborMapValue) {
          if (2 >= t3)
            return A.ioore(t1, 2);
          t3 = !(t1[2] instanceof A.CborIntValue);
        } else
          t3 = true;
      } else
        t3 = true;
      if (t3)
        A.throwExpression(B.AddressConverterException_4Df);
      t3 = type$.CborBytesValue;
      t4 = t3._as(t4).value;
      A.AddrDecUtils_validateBytesLength(t4, 28, _null);
      if (1 >= t1.length)
        return A.ioore(t1, 1);
      t5 = type$.CborMapValue_dynamic_dynamic._as(t1[1]).value;
      if (t5.get$length(t5) <= 2)
        t6 = t5.get$isNotEmpty(t5) && !t5.containsKey$1(B.CborIntValue_1) && !t5.containsKey$1(B.CborIntValue_2);
      else
        t6 = true;
      if (t6)
        A.throwExpression(B.AddressConverterException_yZp);
      if (t5.containsKey$1(B.CborIntValue_1)) {
        t6 = t5.$index(0, B.CborIntValue_1);
        t6.toString;
        hdPath = A.CborUtils__decode(t3._as(t6).value).item1.get$value();
      } else
        hdPath = _null;
      if (t5.containsKey$1(B.CborIntValue_2)) {
        t5 = t5.$index(0, B.CborIntValue_2);
        t5.toString;
        networkMagic = A.CborUtils__decode(t3._as(t5).value).item1.get$value();
      } else
        networkMagic = _null;
      type$.nullable_List_int._as(hdPath);
      A._asIntQ(networkMagic);
      if (2 >= t1.length)
        return A.ioore(t1, 2);
      return new A.ADAByronAddr(new A.ADAByronAddrPayload(t4, new A.ADAByronAddrAttrs(hdPath, networkMagic), A.ADAByronAddrTypes_ADAByronAddrTypes$fromCbor(t2._as(t1[2]))));
    },
    _AdaByronAddrUtils_encodeKey(pubKeyBytes, chainCodeBytes, addrType, hdPathEncBytes, networkMagic) {
      var t2, t3, t4, t5, h, out,
        addrAttrs = new A.ADAByronAddrAttrs(hdPathEncBytes, networkMagic),
        t1 = A.List_List$of(B.JSArray_methods.sublist$1(pubKeyBytes, 1), true, type$.dynamic);
      B.JSArray_methods.addAll$1(t1, chainCodeBytes);
      t2 = type$.int;
      t3 = addrType.value;
      t4 = type$.JSArray_Object;
      t5 = type$.CborListValue_Object;
      t5 = new A.CborListValue(A._setArrayType([new A.CborIntValue(t3), new A.CborListValue(A._setArrayType([t3, A.List_List$from(t1, true, t2)], t4), true, t5), addrAttrs.toJson$0()], t4), true, t5).encode$0();
      h = new A.SHA3256(32, A.List_List$filled(25, 0, false, t2), A.List_List$filled(25, 0, false, t2), A.List_List$filled(200, 0, false, t2));
      h._Keccack$1(64);
      t4 = type$.List_int;
      h.super$_Keccack$update(t4._as(t5));
      out = A.List_List$filled(32, 0, false, t2);
      t4._as(out);
      if (!h._hash$_finished)
        h._padAndPermute$1(6);
      else
        h._pos = 0;
      h._squeeze$1(out);
      h.reset$0();
      return new A.ADAByronAddr(new A.ADAByronAddrPayload(A.QuickCrypto_blake2b224Hash(out), addrAttrs, addrType));
    },
    ADAByronAddrTypes: function ADAByronAddrTypes(t0, t1) {
      this.value = t0;
      this.name = t1;
    },
    ADAByronAddrTypes_ADAByronAddrTypes$fromCbor_closure: function ADAByronAddrTypes_ADAByronAddrTypes$fromCbor_closure(t0) {
      this.value = t0;
    },
    ADAByronAddrAttrs: function ADAByronAddrAttrs(t0, t1) {
      this.hdPathEncBytes = t0;
      this.networkMagic = t1;
    },
    ADAByronAddrPayload: function ADAByronAddrPayload(t0, t1, t2) {
      this.rootHashBytes = t0;
      this.attrs = t1;
      this.type = t2;
    },
    ADAByronAddr: function ADAByronAddr(t0) {
      this.payload = t0;
    },
    AdaByronIcarusAddrEncoder: function AdaByronIcarusAddrEncoder() {
    },
    AdaByronLegacyAddrEncoder: function AdaByronLegacyAddrEncoder() {
    },
    AdaStakeCredential_AdaStakeCredential(hash, type) {
      var t1 = hash.length;
      if (t1 !== 28)
        throw A.wrapException(A.AddressConverterException$("Invalid credential hash length. ", A.LinkedHashMap_LinkedHashMap$_literal(["Excepted", 28, "length", t1], type$.String, type$.dynamic)));
      return new A.AdaStakeCredential(type, A.BytesUtils_toBytes(hash, true));
    },
    AdaShelleyAddrUtils_encodePrefix(hdrType, netTag, credType, stakeType) {
      var hdr = (hdrType.header << 4 | credType.value << 4) >>> 0;
      hdr = (hdrType === B.ADAAddressType_0_Base && stakeType != null ? (hdr | stakeType.value << 5) >>> 0 : hdr) + netTag;
      return A.IntUtils_toBytes(hdr, B.C_Endian0, A.IntUtils_bitlengthInBytes(hdr));
    },
    AdaShelleyAddrUtils_encode(credential, hrp, netTag, stakeCredential, type) {
      var t1 = stakeCredential == null,
        t2 = t1 ? null : stakeCredential.type;
      t2 = A.List_List$of(A.AdaShelleyAddrUtils_encodePrefix(type, netTag.value, credential.type, t2), true, type$.dynamic);
      B.JSArray_methods.addAll$1(t2, credential.hash);
      t1 = t1 ? null : stakeCredential.hash;
      B.JSArray_methods.addAll$1(t2, t1 == null ? A._setArrayType([], type$.JSArray_int) : t1);
      t1 = A._setArrayType([], type$.JSArray_int);
      B.JSArray_methods.addAll$1(t2, t1);
      return A.Bech32EncoderBase_encodeBech32(hrp, A.Bech32BaseUtils_convertToBase32(A.List_List$from(t2, true, type$.int)), "1", A.bech32_base_Bech32Utils_computeChecksum$closure());
    },
    Pointer: function Pointer(t0, t1, t2) {
      this.slot = t0;
      this.txIndex = t1;
      this.certIndex = t2;
    },
    AdaStakeCredType: function AdaStakeCredType(t0, t1) {
      this.name = t0;
      this.value = t1;
    },
    AdaStakeCredential: function AdaStakeCredential(t0, t1) {
      this.type = t0;
      this.hash = t1;
    },
    AdaShelleyAddrEncoder: function AdaShelleyAddrEncoder() {
    },
    AdaShelleyStakingAddrEncoder: function AdaShelleyStakingAddrEncoder() {
    },
    AdaGenericAddrDecoderResult$_(addressBytes, baseHashBytes, byronAddrPayload, network, pointer, prefixBytes, stakeHashBytes, type) {
      A.BytesUtils_toBytes(addressBytes, true);
      A.BytesUtils_tryToBytes(prefixBytes, true);
      return new A.AdaGenericAddrDecoderResult(type, baseHashBytes, stakeHashBytes, pointer, byronAddrPayload, network);
    },
    AdaGenericAddrDecoderResult: function AdaGenericAddrDecoderResult(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.type = t0;
      _.baseHashBytes = t1;
      _.stakeHashBytes = t2;
      _.pointer = t3;
      _.byronAddrPayload = t4;
      _.network = t5;
    },
    AdaGenericAddrDecoder: function AdaGenericAddrDecoder() {
    },
    ADANetwork_fromTag(tag) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_6yO, new A.ADANetwork_fromTag_closure(tag), new A.ADANetwork_fromTag_closure0(tag));
    },
    ADANetwork_fromProtocolMagic(protocolMagic) {
      if (protocolMagic == null)
        return B.ADANetwork_1_764824073_mainnet;
      return B.JSArray_methods.firstWhere$2$orElse(B.List_6yO, new A.ADANetwork_fromProtocolMagic_closure(protocolMagic), new A.ADANetwork_fromProtocolMagic_closure0());
    },
    ADANetwork: function ADANetwork(t0, t1, t2) {
      this.value = t0;
      this.protocolMagic = t1;
      this.name = t2;
    },
    ADANetwork_fromTag_closure: function ADANetwork_fromTag_closure(t0) {
      this.tag = t0;
    },
    ADANetwork_fromTag_closure0: function ADANetwork_fromTag_closure0(t0) {
      this.tag = t0;
    },
    ADANetwork_fromProtocolMagic_closure: function ADANetwork_fromProtocolMagic_closure(t0) {
      this.protocolMagic = t0;
    },
    ADANetwork_fromProtocolMagic_closure0: function ADANetwork_fromProtocolMagic_closure0() {
    },
    AlgoAddrEncoder: function AlgoAddrEncoder() {
    },
    AptosAddrEncoder: function AptosAddrEncoder() {
    },
    AtomAddrEncoder: function AtomAddrEncoder() {
    },
    AtomNist256P1AddrEncoder: function AtomNist256P1AddrEncoder() {
    },
    AvaxPChainAddrEncoder: function AvaxPChainAddrEncoder() {
    },
    AvaxXChainAddrEncoder: function AvaxXChainAddrEncoder() {
    },
    EgldAddrEncoder: function EgldAddrEncoder() {
    },
    BlockchainAddressEncoder: function BlockchainAddressEncoder() {
    },
    EosAddrEncoder: function EosAddrEncoder() {
    },
    ErgoNetworkTypes: function ErgoNetworkTypes(t0) {
      this.value = t0;
    },
    ErgoP2PKHAddrEncoder: function ErgoP2PKHAddrEncoder() {
    },
    EthAddrUtils__checksumEncode(addr) {
      var addrHexDigest = A.BytesUtils_toHexString(A.Keccack_hash(A.StringUtils_encode(addr.toLowerCase(), B.StringEncoding_1), 32), true, null);
      return B.JSArray_methods.join$0(new A.ListMapView(A._setArrayType(addr.split(""), type$.JSArray_String), type$.ListMapView_String).get$entries().map$1$1(0, new A.EthAddrUtils__checksumEncode_closure(addrHexDigest), type$.String).toList$0(0));
    },
    EthAddrUtils__checksumEncode_closure: function EthAddrUtils__checksumEncode_closure(t0) {
      this.addrHexDigest = t0;
    },
    EthAddrDecoder: function EthAddrDecoder() {
    },
    EthAddrEncoder: function EthAddrEncoder() {
    },
    AddressConverterException$(message, details) {
      return new A.AddressConverterException(message);
    },
    AddressConverterException: function AddressConverterException(t0) {
      this.message = t0;
    },
    FilSecp256k1AddrEncoder: function FilSecp256k1AddrEncoder() {
    },
    IcxAddrEncoder: function IcxAddrEncoder() {
    },
    InjAddrEncoder: function InjAddrEncoder() {
    },
    NanoAddrEncoder: function NanoAddrEncoder() {
    },
    NearAddrEncoder: function NearAddrEncoder() {
    },
    NeoAddrEncoder: function NeoAddrEncoder() {
    },
    OkexAddrEncoder: function OkexAddrEncoder() {
    },
    OneAddrEncoder: function OneAddrEncoder() {
    },
    P2PKHAddrEncoder: function P2PKHAddrEncoder() {
    },
    BchP2PKHAddrEncoder: function BchP2PKHAddrEncoder() {
    },
    P2SHAddrEncoder: function P2SHAddrEncoder() {
    },
    BchP2SHAddrEncoder: function BchP2SHAddrEncoder() {
    },
    P2TRUtils_taggedHash(tag, dataBytes) {
      var t2,
        t1 = A.SHA256_hash(A.StringUtils_encode(tag, B.StringEncoding_1));
      type$.List_int._as(t1);
      t2 = A.List_List$of(t1, true, type$.dynamic);
      B.JSArray_methods.addAll$1(t2, t1);
      B.JSArray_methods.addAll$1(t2, dataBytes);
      return A.SHA256_hash(A.List_List$from(t2, true, type$.int));
    },
    P2TRUtils_calculateTweek(pubPoint, script) {
      var tweek = A.P2TRUtils_taggedHash("TapTweak", A.BigintUtils_toBytes(pubPoint.get$x(), A.BigintUtils_orderLen(pubPoint.curve.p), B.C_Endian));
      return tweek;
    },
    P2TRAddrEncoder: function P2TRAddrEncoder() {
    },
    P2WPKHAddrEncoder: function P2WPKHAddrEncoder() {
    },
    SolAddrDecoder: function SolAddrDecoder() {
    },
    SolAddrEncoder: function SolAddrEncoder() {
    },
    SubstrateEd25519AddrEncoder: function SubstrateEd25519AddrEncoder() {
    },
    SubstrateSr25519AddrEncoder: function SubstrateSr25519AddrEncoder() {
    },
    SubstrateSecp256k1AddrEncoder: function SubstrateSecp256k1AddrEncoder() {
    },
    TonAddressUtils_isFriendly(source) {
      var t1;
      if (source.length === 48) {
        t1 = $.$get$TonAddressUtils__friendlyRegixAddress();
        t1 = t1._nativeRegExp.test(source);
      } else
        t1 = false;
      if (t1)
        return true;
      return false;
    },
    TonAddressUtils_isRaw(source) {
      var hashBytes, exception,
        parts = A._setArrayType(source.split(":"), type$.JSArray_String);
      try {
        A.int_parse(J.$index$asx(parts, 0), null);
        hashBytes = A.BytesUtils_fromHexString(J.$index$asx(parts, 1));
        if (J.get$length$asx(hashBytes) === 32)
          return true;
        return false;
      } catch (exception) {
        return false;
      }
    },
    TonAddressUtils_fromRawAddress(address) {
      var parts, workChain, hash, t1, exception;
      try {
        parts = A._setArrayType(address.split(":"), type$.JSArray_String);
        workChain = A.int_parse(J.$index$asx(parts, 0), null);
        hash = A.BytesUtils_fromHexString(J.$index$asx(parts, 1));
        t1 = A.List_List$unmodifiable(A._setArrayType([], type$.JSArray_FriendlyAddressFlags), type$.FriendlyAddressFlags);
        return new A.DecodeAddressResult(workChain, hash, t1);
      } catch (exception) {
        t1 = A.AddressConverterException$("Invalid raw address", A.LinkedHashMap_LinkedHashMap$_literal(["address", address], type$.String, type$.dynamic));
        throw A.wrapException(t1);
      }
    },
    TonAddressUtils_encodeAddress(bounceable, hash, testOnly, urlSafe, workChain) {
      var t1, t2, addr, encode,
        tag = bounceable ? 17 : 81;
      if (testOnly)
        tag |= 128;
      t1 = [tag, workChain & 255];
      B.JSArray_methods.addAll$1(t1, hash);
      t2 = type$.int;
      addr = A.List_List$unmodifiable(t1, t2);
      t2 = A.List_List$of(addr, true, t2);
      B.JSArray_methods.addAll$1(t2, A.Crc16_quickIntDigest(addr));
      encode = A.StringUtils_decode(t2, false, B.StringEncoding_2);
      t1 = A.stringReplaceAllUnchecked(encode, "+", "-");
      return A.stringReplaceAllUnchecked(t1, "/", "_");
    },
    TonAddressUtils_decodeAddress(address) {
      var data, t1, addr, crc, calcedCrc, flags, tag, t2, workchain;
      if (A.TonAddressUtils_isFriendly(address)) {
        data = A.StringUtils_encode(address, B.StringEncoding_2);
        t1 = data.length;
        if (t1 !== 36)
          A.throwExpression(A.AddressConverterException$("Unknown address type. byte length is not equal to 36", A.LinkedHashMap_LinkedHashMap$_literal(["length", t1], type$.String, type$.dynamic)));
        addr = B.NativeUint8List_methods.sublist$2(data, 0, 34);
        crc = B.NativeUint8List_methods.sublist$2(data, 34, 36);
        calcedCrc = A.Crc16_quickIntDigest(addr);
        if (!A.BytesUtils_bytesEqual(crc, calcedCrc))
          A.throwExpression(A.AddressConverterException$("Invalid checksum", A.LinkedHashMap_LinkedHashMap$_literal(["excepted", calcedCrc, "checksum", crc], type$.String, type$.dynamic)));
        flags = A._setArrayType([], type$.JSArray_FriendlyAddressFlags);
        t1 = addr.length;
        if (0 >= t1)
          return A.ioore(addr, 0);
        tag = addr[0];
        if ((tag & 128) !== 0) {
          B.JSArray_methods.add$1(flags, B.FriendlyAddressFlags_128);
          tag ^= 128;
        }
        t2 = tag === 17;
        if (!t2 && tag !== 81)
          A.throwExpression(A.AddressConverterException$("Unknown address tag", A.LinkedHashMap_LinkedHashMap$_literal(["tag", tag], type$.String, type$.dynamic)));
        if (t2)
          B.JSArray_methods.add$1(flags, B.FriendlyAddressFlags_17);
        else
          B.JSArray_methods.add$1(flags, B.FriendlyAddressFlags_81);
        if (1 >= t1)
          return A.ioore(addr, 1);
        workchain = addr[1];
        if (workchain === 255)
          workchain = -1;
        return new A.DecodeAddressResult(workchain, B.NativeUint8List_methods.sublist$2(addr, 2, 34), A.List_List$unmodifiable(flags, type$.FriendlyAddressFlags));
      } else if (A.TonAddressUtils_isRaw(address))
        return A.TonAddressUtils_fromRawAddress(address);
      else
        throw A.wrapException(A.AddressConverterException$("Unknown address type.", A.LinkedHashMap_LinkedHashMap$_literal(["address", address], type$.String, type$.dynamic)));
    },
    DecodeAddressResult: function DecodeAddressResult(t0, t1, t2) {
      this.workchain = t0;
      this.hash = t1;
      this.flags = t2;
    },
    FriendlyAddressFlags: function FriendlyAddressFlags(t0) {
      this.flag = t0;
    },
    TonAddrDecoder: function TonAddrDecoder() {
    },
    TonAddrEncoder: function TonAddrEncoder() {
    },
    TrxAddressUtils_fromHexBytes(bytes) {
      var t1,
        validateBytes = A.AddrDecUtils_validateAndRemovePrefixBytes(bytes, B.List_65);
      A.AddrDecUtils_validateBytesLength(validateBytes, 20, null);
      t1 = A.List_List$of(B.List_65, true, type$.dynamic);
      B.JSArray_methods.addAll$1(t1, validateBytes);
      return A.Base58Encoder_checkEncode(A.List_List$from(t1, true, type$.int), B.Base58Alphabets_0);
    },
    TrxAddrDecoder: function TrxAddrDecoder() {
    },
    TrxAddrEncoder: function TrxAddrEncoder() {
    },
    XlmAddrTypes: function XlmAddrTypes() {
    },
    XlmAddrEncoder: function XlmAddrEncoder() {
    },
    XmrAddrEncoder: function XmrAddrEncoder() {
    },
    XRPAddressUtils_decodeXAddress(addr, prefix) {
      var prefixBytes, t1, addrHash, tagBytes, tagFlag, tag, _null = null,
        addrDecBytes = A.Base58Decoder_checkDecode(addr, B.Base58Alphabets_1);
      A.AddrDecUtils_validateBytesLength(addrDecBytes, 31, _null);
      prefixBytes = B.JSArray_methods.sublist$2(addrDecBytes, 0, 2);
      if (prefix != null) {
        if (!A.BytesUtils_bytesEqual(prefix, prefixBytes))
          throw A.wrapException(A.AddressConverterException$("Invalid prefix (expected " + A.S(prefix) + ", got " + A.S(prefixBytes) + ")", _null));
      } else if (!A.BytesUtils_bytesEqual(prefixBytes, B.List_5_68) && !A.BytesUtils_bytesEqual(prefixBytes, B.List_4_147))
        throw A.wrapException(B.AddressConverterException_6hT);
      t1 = prefixBytes.length;
      addrHash = B.JSArray_methods.sublist$2(addrDecBytes, t1, 20 + t1);
      tagBytes = B.JSArray_methods.sublist$1(addrDecBytes, addrDecBytes.length - 9);
      if (0 >= tagBytes.length)
        return A.ioore(tagBytes, 0);
      tagFlag = tagBytes[0];
      t1 = tagFlag === 0;
      if (!t1 && tagFlag !== 1)
        throw A.wrapException(A.AddressConverterException$("Invalid tag flag, tag flag should be 0 or 1 but got " + A.S(tagFlag), _null));
      tagBytes = B.JSArray_methods.sublist$1(tagBytes, 1);
      if (t1 && !A.BytesUtils_bytesEqual(tagBytes, A.List_List$filled(8, 0, false, type$.int)))
        throw A.wrapException(B.AddressConverterException_8aB);
      tag = tagFlag === 1 ? A.readUint32LE(tagBytes, 0) : _null;
      t1 = A.BytesUtils_bytesEqual(prefixBytes, B.List_4_147);
      return new A.XRPXAddressDecodeResult(A.BytesUtils_toBytes(addrHash, true), tag, t1);
    },
    XRPAddressUtils_isXAddress(address) {
      var exception;
      try {
        A.XRPAddressUtils_decodeXAddress(address, null);
        return true;
      } catch (exception) {
        return false;
      }
    },
    XRPXAddressDecodeResult: function XRPXAddressDecodeResult(t0, t1, t2) {
      this.bytes = t0;
      this.tag = t1;
      this.isTestnet = t2;
    },
    XrpAddrEncoder: function XrpAddrEncoder() {
    },
    XtzAddrPrefixes: function XtzAddrPrefixes() {
    },
    XtzAddrEncoder: function XtzAddrEncoder() {
    },
    ZilAddrEncoder: function ZilAddrEncoder() {
    },
    Bip32PathError: function Bip32PathError(t0) {
      this.message = t0;
    },
    Bip32KeyIndex_Bip32KeyIndex(index) {
      if (index < 0 || index > 4294967295)
        throw A.wrapException(A.ArgumentException$("Invalid key index (" + index + ")"));
      return new A.Bip32KeyIndex(index);
    },
    Bip32KeyData$() {
      A.Bip32KeyIndex_Bip32KeyIndex(0);
      A.List_List$filled(32, 0, false, type$.int);
      var fprint = A.List_List$from(B.List_0_0_0_0, true, type$.int);
      if (fprint.length < 4)
        A.throwExpression(B.ArgumentException_ezC);
      B.JSArray_methods.sublist$2(fprint, 0, 4);
      return new A.Bip32KeyData();
    },
    Bip32ChainCode: function Bip32ChainCode(t0) {
      this._chainCode = t0;
    },
    Bip32FingerPrint: function Bip32FingerPrint() {
    },
    Bip32KeyIndex: function Bip32KeyIndex(t0) {
      this.index = t0;
    },
    Bip32KeyData: function Bip32KeyData() {
    },
    Bip32KeyNetVersions$(pubNetVer, privNetVer) {
      var t2,
        t1 = new A.Bip32KeyNetVersions();
      if (pubNetVer.length !== 4 || privNetVer.length !== 4)
        A.throwExpression(B.ArgumentException_JNA);
      t2 = type$.List_int;
      t1.set$__Bip32KeyNetVersions__pubNetVer_F(t2._as(pubNetVer));
      t2._as(privNetVer);
      t1.__Bip32KeyNetVersions__privNetVer_F !== $ && A.throwLateFieldAI("_privNetVer");
      t1.set$__Bip32KeyNetVersions__privNetVer_F(privNetVer);
      return t1;
    },
    Bip32KeyNetVersions: function Bip32KeyNetVersions() {
      this.__Bip32KeyNetVersions__privNetVer_F = this.__Bip32KeyNetVersions__pubNetVer_F = $;
    },
    Bip32KeyBase: function Bip32KeyBase() {
    },
    Bip32PublicKey: function Bip32PublicKey(t0) {
      this.pubKey = t0;
    },
    Bip32PathParser_parse(path) {
      var isAbsolute, t2, parsedElems,
        t1 = type$.WhereIterable_String,
        pathElems = A.List_List$of(new A.WhereIterable(A._setArrayType((B.JSString_methods.endsWith$1(path, "/") ? B.JSString_methods.substring$2(path, 0, path.length - 1) : path).split("/"), type$.JSArray_String), type$.bool_Function_String._as(new A.Bip32PathParser_parse_closure()), t1), true, t1._eval$1("Iterable.E"));
      t1 = pathElems.length;
      if (t1 !== 0) {
        if (0 >= t1)
          return A.ioore(pathElems, 0);
        isAbsolute = J.$eq$(pathElems[0], "m");
      } else
        isAbsolute = false;
      if (isAbsolute)
        pathElems = B.JSArray_methods.sublist$1(pathElems, 1);
      t1 = A._arrayInstanceType(pathElems);
      t2 = t1._eval$1("MappedListIterable<1,Bip32KeyIndex>");
      parsedElems = A.List_List$of(new A.MappedListIterable(pathElems, t1._eval$1("Bip32KeyIndex(1)")._as(A.bip32_path_Bip32PathParser__parseElem$closure()), t2), true, t2._eval$1("ListIterable.E"));
      return new A.Bip32Path(parsedElems, isAbsolute);
    },
    Bip32PathParser__parseElem(pathElem) {
      var isHardened, t2, t1 = {};
      t1.pathElem = pathElem;
      t1.pathElem = J.trim$0$s(pathElem);
      isHardened = !new A.WhereIterable(B.List_0uY, type$.bool_Function_String._as(new A.Bip32PathParser__parseElem_closure(t1)), type$.WhereIterable_String).get$isEmpty(0);
      if (isHardened) {
        t2 = t1.pathElem;
        t1.pathElem = B.JSString_methods.substring$2(t2, 0, t2.length - 1);
      }
      if (A.Primitives_parseInt(t1.pathElem, null) == null)
        throw A.wrapException(new A.Bip32PathError("Invalid path element (" + t1.pathElem + ")"));
      t1 = t1.pathElem;
      return isHardened ? A.Bip32KeyIndex_Bip32KeyIndex((A.int_parse(t1, null) | 2147483648) >>> 0) : A.Bip32KeyIndex_Bip32KeyIndex(A.int_parse(t1, null));
    },
    Bip32Path: function Bip32Path(t0, t1) {
      this.elems = t0;
      this.isAbsolute = t1;
    },
    Bip32PathParser_parse_closure: function Bip32PathParser_parse_closure() {
    },
    Bip32PathParser__parseElem_closure: function Bip32PathParser__parseElem_closure(t0) {
      this._box_0 = t0;
    },
    BipCoins_fromName($name, proposal) {
      switch (proposal) {
        case B.BipProposal_bip44:
          return A.Bip44Coins_fromName($name);
        case B.BipProposal_bip49:
          return A.Bip49Coins_fromName($name);
        case B.BipProposal_bip84:
          return A.Bip84Coins_fromName($name);
        case B.BipProposal_bip86:
          return A.Bip86Coins_fromName($name);
        default:
          return null;
      }
    },
    BipCoins: function BipCoins() {
    },
    BipProposal: function BipProposal(t0) {
      this.name = t0;
    },
    Bip44Coins_fromName($name) {
      var t1, exception;
      try {
        t1 = $.$get$Bip44Coins__coinToConf();
        t1 = new A.LinkedHashMapKeyIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapKeyIterable<1>")).firstWhere$1(0, new A.Bip44Coins_fromName_closure($name));
        return t1;
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.StateError)
          return null;
        else
          throw exception;
      }
    },
    Bip44Coins: function Bip44Coins(t0) {
      this.name = t0;
    },
    Bip44Coins_fromName_closure: function Bip44Coins_fromName_closure(t0) {
      this.name = t0;
    },
    Bip44Conf_akashNetwork_closure: function Bip44Conf_akashNetwork_closure() {
    },
    Bip44Conf_algorand_closure: function Bip44Conf_algorand_closure() {
    },
    Bip44Conf_aptos_closure: function Bip44Conf_aptos_closure() {
    },
    Bip44Conf_avaxCChain_closure: function Bip44Conf_avaxCChain_closure() {
    },
    Bip44Conf_avaxPChain_closure: function Bip44Conf_avaxPChain_closure() {
    },
    Bip44Conf_avaxXChain_closure: function Bip44Conf_avaxXChain_closure() {
    },
    Bip44Conf_axelar_closure: function Bip44Conf_axelar_closure() {
    },
    Bip44Conf_bandProtocol_closure: function Bip44Conf_bandProtocol_closure() {
    },
    Bip44Conf_binanceChain_closure: function Bip44Conf_binanceChain_closure() {
    },
    Bip44Conf_binanceSmartChain_closure: function Bip44Conf_binanceSmartChain_closure() {
    },
    Bip44Conf_bitcoinMainNet_closure: function Bip44Conf_bitcoinMainNet_closure() {
    },
    Bip44Conf_bitcoinTestNet_closure: function Bip44Conf_bitcoinTestNet_closure() {
    },
    Bip44Conf_bitcoinCashMainNet_closure: function Bip44Conf_bitcoinCashMainNet_closure() {
    },
    Bip44Conf_bitcoinCashTestNet_closure: function Bip44Conf_bitcoinCashTestNet_closure() {
    },
    Bip44Conf_bitcoinCashSlpMainNet_closure: function Bip44Conf_bitcoinCashSlpMainNet_closure() {
    },
    Bip44Conf_bitcoinCashSlpTestNet_closure: function Bip44Conf_bitcoinCashSlpTestNet_closure() {
    },
    Bip44Conf_bitcoinSvMainNet_closure: function Bip44Conf_bitcoinSvMainNet_closure() {
    },
    Bip44Conf_bitcoinSvTestNet_closure: function Bip44Conf_bitcoinSvTestNet_closure() {
    },
    Bip44Conf_cardanoByronIcarus_closure: function Bip44Conf_cardanoByronIcarus_closure() {
    },
    Bip44Conf_cardanoByronLedger_closure: function Bip44Conf_cardanoByronLedger_closure() {
    },
    Bip44Conf_cardanoByronIcarusTestnet_closure: function Bip44Conf_cardanoByronIcarusTestnet_closure() {
    },
    Bip44Conf_cardanoByronLedgerTestnet_closure: function Bip44Conf_cardanoByronLedgerTestnet_closure() {
    },
    Bip44Conf_celo_closure: function Bip44Conf_celo_closure() {
    },
    Bip44Conf_certik_closure: function Bip44Conf_certik_closure() {
    },
    Bip44Conf_chihuahua_closure: function Bip44Conf_chihuahua_closure() {
    },
    Bip44Conf_cosmos_closure: function Bip44Conf_cosmos_closure() {
    },
    Bip44Conf_cosmosTestnet_closure: function Bip44Conf_cosmosTestnet_closure() {
    },
    Bip44Conf_cosmosNist256p1_closure: function Bip44Conf_cosmosNist256p1_closure() {
    },
    Bip44Conf_cosmosTestnetNist256p1_closure: function Bip44Conf_cosmosTestnetNist256p1_closure() {
    },
    Bip44Conf_dashMainNet_closure: function Bip44Conf_dashMainNet_closure() {
    },
    Bip44Conf_dashTestNet_closure: function Bip44Conf_dashTestNet_closure() {
    },
    Bip44Conf_dogecoinMainNet_closure: function Bip44Conf_dogecoinMainNet_closure() {
    },
    Bip44Conf_dogecoinTestNet_closure: function Bip44Conf_dogecoinTestNet_closure() {
    },
    Bip44Conf_pepeMainnet_closure: function Bip44Conf_pepeMainnet_closure() {
    },
    Bip44Conf_pepeTestnet_closure: function Bip44Conf_pepeTestnet_closure() {
    },
    Bip44Conf_ecashMainNet_closure: function Bip44Conf_ecashMainNet_closure() {
    },
    Bip44Conf_ecashTestNet_closure: function Bip44Conf_ecashTestNet_closure() {
    },
    Bip44Conf_elrond_closure: function Bip44Conf_elrond_closure() {
    },
    Bip44Conf_eos_closure: function Bip44Conf_eos_closure() {
    },
    Bip44Conf_ergoMainNet_closure: function Bip44Conf_ergoMainNet_closure() {
    },
    Bip44Conf_ergoTestNet_closure: function Bip44Conf_ergoTestNet_closure() {
    },
    Bip44Conf_ethereum_closure: function Bip44Conf_ethereum_closure() {
    },
    Bip44Conf_ethereumTestnet_closure: function Bip44Conf_ethereumTestnet_closure() {
    },
    Bip44Conf_ethereumClassic_closure: function Bip44Conf_ethereumClassic_closure() {
    },
    Bip44Conf_fantomOpera_closure: function Bip44Conf_fantomOpera_closure() {
    },
    Bip44Conf_filecoin_closure: function Bip44Conf_filecoin_closure() {
    },
    Bip44Conf_harmonyOneMetamask_closure: function Bip44Conf_harmonyOneMetamask_closure() {
    },
    Bip44Conf_harmonyOneEth_closure: function Bip44Conf_harmonyOneEth_closure() {
    },
    Bip44Conf_harmonyOneAtom_closure: function Bip44Conf_harmonyOneAtom_closure() {
    },
    Bip44Conf_huobiChain_closure: function Bip44Conf_huobiChain_closure() {
    },
    Bip44Conf_icon_closure: function Bip44Conf_icon_closure() {
    },
    Bip44Conf_injective_closure: function Bip44Conf_injective_closure() {
    },
    Bip44Conf_irisNet_closure: function Bip44Conf_irisNet_closure() {
    },
    Bip44Conf_kava_closure: function Bip44Conf_kava_closure() {
    },
    Bip44Conf_kusamaEd25519Slip_closure: function Bip44Conf_kusamaEd25519Slip_closure() {
    },
    Bip44Conf_kusamaTestnetEd25519Slip_closure: function Bip44Conf_kusamaTestnetEd25519Slip_closure() {
    },
    Bip44Conf_litecoinMainNet_closure: function Bip44Conf_litecoinMainNet_closure() {
    },
    Bip44Conf_litecoinTestNet_closure: function Bip44Conf_litecoinTestNet_closure() {
    },
    Bip44Conf_moneroEd25519Slip_closure: function Bip44Conf_moneroEd25519Slip_closure() {
    },
    Bip44Conf_moneroSecp256k1_closure: function Bip44Conf_moneroSecp256k1_closure() {
    },
    Bip44Conf_nano_closure: function Bip44Conf_nano_closure() {
    },
    Bip44Conf_nearProtocol_closure: function Bip44Conf_nearProtocol_closure() {
    },
    Bip44Conf_neo_closure: function Bip44Conf_neo_closure() {
    },
    Bip44Conf_nineChroniclesGold_closure: function Bip44Conf_nineChroniclesGold_closure() {
    },
    Bip44Conf_okexChainEth_closure: function Bip44Conf_okexChainEth_closure() {
    },
    Bip44Conf_okexChainAtom_closure: function Bip44Conf_okexChainAtom_closure() {
    },
    Bip44Conf_okexChainAtomOld_closure: function Bip44Conf_okexChainAtomOld_closure() {
    },
    Bip44Conf_ontology_closure: function Bip44Conf_ontology_closure() {
    },
    Bip44Conf_osmosis_closure: function Bip44Conf_osmosis_closure() {
    },
    Bip44Conf_piNetwork_closure: function Bip44Conf_piNetwork_closure() {
    },
    Bip44Conf_polkadotEd25519Slip_closure: function Bip44Conf_polkadotEd25519Slip_closure() {
    },
    Bip44Conf_polkadotTestnetEd25519Slip_closure: function Bip44Conf_polkadotTestnetEd25519Slip_closure() {
    },
    Bip44Conf_polygon_closure: function Bip44Conf_polygon_closure() {
    },
    Bip44Conf_ripple_closure: function Bip44Conf_ripple_closure() {
    },
    Bip44Conf_rippleTestnet_closure: function Bip44Conf_rippleTestnet_closure() {
    },
    Bip44Conf_rippleEd25519_closure: function Bip44Conf_rippleEd25519_closure() {
    },
    Bip44Conf_rippleTestnetEd25519_closure: function Bip44Conf_rippleTestnetEd25519_closure() {
    },
    Bip44Conf_secretNetworkOld_closure: function Bip44Conf_secretNetworkOld_closure() {
    },
    Bip44Conf_secretNetworkNew_closure: function Bip44Conf_secretNetworkNew_closure() {
    },
    Bip44Conf_solana_closure: function Bip44Conf_solana_closure() {
    },
    Bip44Conf_solanaTestnet_closure: function Bip44Conf_solanaTestnet_closure() {
    },
    Bip44Conf_stellar_closure: function Bip44Conf_stellar_closure() {
    },
    Bip44Conf_terra_closure: function Bip44Conf_terra_closure() {
    },
    Bip44Conf_tezos_closure: function Bip44Conf_tezos_closure() {
    },
    Bip44Conf_theta_closure: function Bip44Conf_theta_closure() {
    },
    Bip44Conf_tron_closure: function Bip44Conf_tron_closure() {
    },
    Bip44Conf_tronTestnet_closure: function Bip44Conf_tronTestnet_closure() {
    },
    Bip44Conf_vechain_closure: function Bip44Conf_vechain_closure() {
    },
    Bip44Conf_verge_closure: function Bip44Conf_verge_closure() {
    },
    Bip44Conf_zcashMainNet_closure: function Bip44Conf_zcashMainNet_closure() {
    },
    Bip44Conf_zcashTestNet_closure: function Bip44Conf_zcashTestNet_closure() {
    },
    Bip44Conf_zilliqa_closure: function Bip44Conf_zilliqa_closure() {
    },
    Bip44Conf_tonMainnet_closure: function Bip44Conf_tonMainnet_closure() {
    },
    Bip44Conf_tonTestnet_closure: function Bip44Conf_tonTestnet_closure() {
    },
    Bip49Coins_fromName($name) {
      var t1, exception;
      try {
        t1 = $.$get$Bip49Coins__coinToConf();
        t1 = new A.LinkedHashMapKeyIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapKeyIterable<1>")).firstWhere$1(0, new A.Bip49Coins_fromName_closure($name));
        return t1;
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.StateError)
          return null;
        else
          throw exception;
      }
    },
    Bip49Coins: function Bip49Coins(t0) {
      this.name = t0;
    },
    Bip49Coins_fromName_closure: function Bip49Coins_fromName_closure(t0) {
      this.name = t0;
    },
    Bip49Conf_dashMainNet_closure: function Bip49Conf_dashMainNet_closure() {
    },
    Bip49Conf_dashTestNet_closure: function Bip49Conf_dashTestNet_closure() {
    },
    Bip49Conf_dogecoinMainNet_closure: function Bip49Conf_dogecoinMainNet_closure() {
    },
    Bip49Conf_dogecoinTestNet_closure: function Bip49Conf_dogecoinTestNet_closure() {
    },
    Bip49Conf_litecoinMainNet_closure: function Bip49Conf_litecoinMainNet_closure() {
    },
    Bip49Conf_litecoinTestNet_closure: function Bip49Conf_litecoinTestNet_closure() {
    },
    Bip49Conf_zcashMainNet_closure: function Bip49Conf_zcashMainNet_closure() {
    },
    Bip49Conf_zcashTestNet_closure: function Bip49Conf_zcashTestNet_closure() {
    },
    Bip49Conf_bitcoinMainNet_closure: function Bip49Conf_bitcoinMainNet_closure() {
    },
    Bip49Conf_bitcoinTestNet_closure: function Bip49Conf_bitcoinTestNet_closure() {
    },
    Bip49Conf_bitcoinSvMainNet_closure: function Bip49Conf_bitcoinSvMainNet_closure() {
    },
    Bip49Conf_bitcoinSvTestNet_closure: function Bip49Conf_bitcoinSvTestNet_closure() {
    },
    Bip49Conf_bitcoinCashMainNet_closure: function Bip49Conf_bitcoinCashMainNet_closure() {
    },
    Bip49Conf_bitcoinCashTestNet_closure: function Bip49Conf_bitcoinCashTestNet_closure() {
    },
    Bip49Conf_bitcoinCashSlpMainNet_closure: function Bip49Conf_bitcoinCashSlpMainNet_closure() {
    },
    Bip49Conf_bitcoinCashSlpTestNet_closure: function Bip49Conf_bitcoinCashSlpTestNet_closure() {
    },
    Bip49Conf_ecashMainNet_closure: function Bip49Conf_ecashMainNet_closure() {
    },
    Bip49Conf_ecashTestNet_closure: function Bip49Conf_ecashTestNet_closure() {
    },
    Bip49Conf_pepeMainnet_closure: function Bip49Conf_pepeMainnet_closure() {
    },
    Bip49Conf_pepeTestnet_closure: function Bip49Conf_pepeTestnet_closure() {
    },
    Bip84Coins_fromName($name) {
      var t1, exception;
      try {
        t1 = $.$get$Bip84Coins__coinToConf();
        t1 = new A.LinkedHashMapKeyIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapKeyIterable<1>")).firstWhere$1(0, new A.Bip84Coins_fromName_closure($name));
        return t1;
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.StateError)
          return null;
        else
          throw exception;
      }
    },
    Bip84Coins: function Bip84Coins(t0) {
      this.name = t0;
    },
    Bip84Coins_fromName_closure: function Bip84Coins_fromName_closure(t0) {
      this.name = t0;
    },
    Bip84Conf_bitcoinMainNet_closure: function Bip84Conf_bitcoinMainNet_closure() {
    },
    Bip84Conf_bitcoinTestNet_closure: function Bip84Conf_bitcoinTestNet_closure() {
    },
    Bip84Conf_litecoinMainNet_closure: function Bip84Conf_litecoinMainNet_closure() {
    },
    Bip84Conf_litecoinTestNet_closure: function Bip84Conf_litecoinTestNet_closure() {
    },
    Bip86Coins_fromName($name) {
      var t1, exception;
      try {
        t1 = $.$get$Bip86Coins__coinToConf();
        t1 = new A.LinkedHashMapKeyIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapKeyIterable<1>")).firstWhere$1(0, new A.Bip86Coins_fromName_closure($name));
        return t1;
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.StateError)
          return null;
        else
          throw exception;
      }
    },
    Bip86Coins: function Bip86Coins(t0) {
      this.name = t0;
    },
    Bip86Coins_fromName_closure: function Bip86Coins_fromName_closure(t0) {
      this.name = t0;
    },
    Bip86Conf_bitcoinMainNet_closure: function Bip86Conf_bitcoinMainNet_closure() {
    },
    Bip86Conf_bitcoinTestNet_closure: function Bip86Conf_bitcoinTestNet_closure() {
    },
    BipBitcoinCashConf$(addrParams, addressEncoder, coinIdx, coinNames, defPath, isTestnet, keyNetVer, type, wifNetVer) {
      return new A.BipBitcoinCashConf(type);
    },
    BipBitcoinCashConf: function BipBitcoinCashConf(t0) {
      this.type = t0;
    },
    BipCoinConfig$(addrParams, addressEncoder, coinIdx, coinNames, defPath, isTestnet, keyNetVer, type, wifNetVer) {
      return new A.BipCoinConfig(type);
    },
    BipCoinConfig: function BipCoinConfig(t0) {
      this.type = t0;
    },
    BipLitecoinConf$(addrParams, addressEncoder, altKeyNetVer, coinIdx, coinNames, defPath, isTestnet, keyNetVer, type, wifNetVer) {
      return new A.BipLitecoinConf(type);
    },
    BipLitecoinConf: function BipLitecoinConf(t0) {
      this.type = t0;
    },
    CryptoCoins_getCoin($name, proposal) {
      switch (proposal) {
        case B.BipProposal_bip44:
        case B.BipProposal_bip49:
        case B.BipProposal_bip84:
        case B.BipProposal_bip86:
          return A.BipCoins_fromName($name, type$.BipProposal._as(proposal));
        case B.C_CipProposal:
          return A.Cip1852Coins_fromName($name);
        case B.C_SubstratePropoosal:
          return A.SubstrateCoins_fromName($name);
        case B.C_MoneroProposal:
          return A.MoneroCoins_fromName($name);
        default:
          return null;
      }
    },
    CoinProposal_fromName($name) {
      switch ($name) {
        case "cip1852":
          return B.C_CipProposal;
        case "substrate":
          return B.C_SubstratePropoosal;
        case "monero":
          return B.C_MoneroProposal;
        default:
          return B.JSArray_methods.firstWhere$2$orElse(B.List_Tre, new A.CoinProposal_fromName_closure($name), new A.CoinProposal_fromName_closure0($name));
      }
    },
    CoinProposal_fromName_closure: function CoinProposal_fromName_closure(t0) {
      this.name = t0;
    },
    CoinProposal_fromName_closure0: function CoinProposal_fromName_closure0(t0) {
      this.name = t0;
    },
    Cip1852Coins_fromName($name) {
      var t1, exception;
      try {
        t1 = $.$get$Cip1852Coins__coinToConf();
        t1 = new A.LinkedHashMapKeyIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapKeyIterable<1>")).firstWhere$1(0, new A.Cip1852Coins_fromName_closure($name));
        return t1;
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.StateError)
          return null;
        else
          throw exception;
      }
    },
    Cip1852Coins: function Cip1852Coins(t0) {
      this.name = t0;
    },
    Cip1852Coins_fromName_closure: function Cip1852Coins_fromName_closure(t0) {
      this.name = t0;
    },
    CipProposal: function CipProposal() {
    },
    Cip1852Conf_cardanoIcarusMainNet_closure: function Cip1852Conf_cardanoIcarusMainNet_closure() {
    },
    Cip1852Conf_cardanoIcarusTestNet_closure: function Cip1852Conf_cardanoIcarusTestNet_closure() {
    },
    Cip1852Conf_cardanoLedgerMainNet_closure: function Cip1852Conf_cardanoLedgerMainNet_closure() {
    },
    Cip1852Conf_cardanoLedgerTestNet_closure: function Cip1852Conf_cardanoLedgerTestNet_closure() {
    },
    CoinConf: function CoinConf(t0, t1) {
      this.coinName = t0;
      this.params = t1;
    },
    CoinParams: function CoinParams(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21) {
      var _ = this;
      _.p2pkhNetVer = t0;
      _.p2shNetVer = t1;
      _.p2wpkhHrp = t2;
      _.p2trHrp = t3;
      _.wifNetVer = t4;
      _.addrSs58Format = t5;
      _.addrHrp = t6;
      _.addrPrefix = t7;
      _.p2pkhStdHrp = t8;
      _.p2pkhStdNetVer = t9;
      _.p2pkhLegacyNetVer = t10;
      _.p2shStdHrp = t11;
      _.p2shStdNetVer = t12;
      _.p2shLegacyNetVer = t13;
      _.stakingAddrHrp = t14;
      _.p2pkhDeprNetVer = t15;
      _.p2shDeprNetVer = t16;
      _.addrNetVer = t17;
      _.addrIntNetVer = t18;
      _.subaddrNetVer = t19;
      _.addrVer = t20;
      _.workchain = t21;
    },
    CoinNames: function CoinNames(t0) {
      this.name = t0;
    },
    EllipticCurveTypes_fromName($name) {
      return B.JSArray_methods.firstWhere$1(B.List_akr, new A.EllipticCurveTypes_fromName_closure($name));
    },
    EllipticCurveTypes: function EllipticCurveTypes(t0) {
      this.name = t0;
    },
    EllipticCurveTypes_fromName_closure: function EllipticCurveTypes_fromName_closure(t0) {
      this.name = t0;
    },
    Ed25519Blake2bPublicKey: function Ed25519Blake2bPublicKey(t0) {
      this._publicKey = t0;
    },
    Ed25519PublicKey: function Ed25519PublicKey(t0) {
      this._ed25519_keys$_publicKey = t0;
    },
    Ed25519KholawPublicKey: function Ed25519KholawPublicKey(t0) {
      this._ed25519_kholaw_keys$_publicKey = t0;
    },
    Ed25519MoneroPublicKey: function Ed25519MoneroPublicKey(t0) {
      this._ed25519_monero_keys$_publicKey = t0;
    },
    Nist256p1PublicKey: function Nist256p1PublicKey(t0) {
      this.publicKey = t0;
    },
    Secp256k1PublicKeyEcdsa_Secp256k1PublicKeyEcdsa$fromBytes(keyBytes) {
      var point = A.ProjectiveECCPoint_ProjectiveECCPoint$fromBytes($.$get$Curves_curveSecp256k1(), keyBytes, null);
      return new A.Secp256k1PublicKeyEcdsa(A.ECDSAPublicKey_ECDSAPublicKey($.$get$Curves_generatorSecp256k1(), point));
    },
    Secp256k1PublicKeyEcdsa_isValidBytes(keyBytes) {
      var exception;
      try {
        A.Secp256k1PublicKeyEcdsa_Secp256k1PublicKeyEcdsa$fromBytes(keyBytes);
        return true;
      } catch (exception) {
        return false;
      }
    },
    Secp256k1PublicKeyEcdsa: function Secp256k1PublicKeyEcdsa(t0) {
      this.publicKey = t0;
    },
    Sr25519PublicKey: function Sr25519PublicKey(t0) {
      this.publicKey = t0;
    },
    MoneroCoinConf_MoneroCoinConf$fromCoinConf(coinConf) {
      var t1 = coinConf.params;
      t1.addrNetVer.toString;
      t1.addrIntNetVer.toString;
      t1.subaddrNetVer.toString;
      return new A.MoneroCoinConf(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.List_int));
    },
    MoneroCoinConf: function MoneroCoinConf(t0) {
      this.addrParams = t0;
    },
    MoneroCoins_fromName($name) {
      var t1, exception;
      try {
        t1 = $.$get$MoneroCoins__coinToConf();
        t1 = new A.LinkedHashMapKeyIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapKeyIterable<1>")).firstWhere$1(0, new A.MoneroCoins_fromName_closure($name));
        return t1;
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.StateError)
          return null;
        else
          throw exception;
      }
    },
    MoneroCoins: function MoneroCoins(t0) {
      this.name = t0;
    },
    MoneroCoins_fromName_closure: function MoneroCoins_fromName_closure(t0) {
      this.name = t0;
    },
    MoneroProposal: function MoneroProposal() {
    },
    MoneroKeyError: function MoneroKeyError() {
    },
    MoneroPublicKey__keyFromBytes(keyBytes) {
      var t1, exception;
      try {
        t1 = $.$get$Curves_generatorED25519();
        t1 = A.EDDSAPublicKey_EDDSAPublicKey$fromPoint(t1, A.EDPoint_EDPoint$fromBytes(t1.curve, keyBytes));
        return new A.Ed25519MoneroPublicKey(t1);
      } catch (exception) {
        throw A.wrapException(B.C_MoneroKeyError);
      }
    },
    MoneroPublicKey: function MoneroPublicKey(t0) {
      this.pubKey = t0;
    },
    SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(addressEncode, coinConf, type) {
      coinConf.params.addrSs58Format.toString;
      return new A.SubstrateCoinConf(type);
    },
    SubstrateCoinConf: function SubstrateCoinConf(t0) {
      this.type = t0;
    },
    SubstrateCoins_fromName($name) {
      var t1, exception;
      try {
        t1 = B.JSArray_methods.firstWhere$1(B.List_2lW, new A.SubstrateCoins_fromName_closure($name));
        return t1;
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.StateError)
          return null;
        else
          throw exception;
      }
    },
    SubstrateCoins: function SubstrateCoins(t0) {
      this.name = t0;
    },
    SubstrateCoins_fromName_closure: function SubstrateCoins_fromName_closure(t0) {
      this.name = t0;
    },
    SubstratePropoosal: function SubstratePropoosal() {
    },
    SubstrateConf_acalaEd25519_closure: function SubstrateConf_acalaEd25519_closure() {
    },
    SubstrateConf_acalaSecp256k1_closure: function SubstrateConf_acalaSecp256k1_closure() {
    },
    SubstrateConf_acalaSr25519_closure: function SubstrateConf_acalaSr25519_closure() {
    },
    SubstrateConf_bifrostEd25519_closure: function SubstrateConf_bifrostEd25519_closure() {
    },
    SubstrateConf_bifrostSecp256k1_closure: function SubstrateConf_bifrostSecp256k1_closure() {
    },
    SubstrateConf_bifrostSr25519_closure: function SubstrateConf_bifrostSr25519_closure() {
    },
    SubstrateConf_chainXEd25519_closure: function SubstrateConf_chainXEd25519_closure() {
    },
    SubstrateConf_chainXSecp256k1_closure: function SubstrateConf_chainXSecp256k1_closure() {
    },
    SubstrateConf_chainXSr25519_closure: function SubstrateConf_chainXSr25519_closure() {
    },
    SubstrateConf_edgewareEd25519_closure: function SubstrateConf_edgewareEd25519_closure() {
    },
    SubstrateConf_edgewareSecp256k1_closure: function SubstrateConf_edgewareSecp256k1_closure() {
    },
    SubstrateConf_edgewareSr25519_closure: function SubstrateConf_edgewareSr25519_closure() {
    },
    SubstrateConf_genericEd25519_closure: function SubstrateConf_genericEd25519_closure() {
    },
    SubstrateConf_genericSecp256k1_closure: function SubstrateConf_genericSecp256k1_closure() {
    },
    SubstrateConf_genericSr25519_closure: function SubstrateConf_genericSr25519_closure() {
    },
    SubstrateConf_karuraEd25519_closure: function SubstrateConf_karuraEd25519_closure() {
    },
    SubstrateConf_karuraSecp256k1_closure: function SubstrateConf_karuraSecp256k1_closure() {
    },
    SubstrateConf_karuraSr25519_closure: function SubstrateConf_karuraSr25519_closure() {
    },
    SubstrateConf_kusamaEd25519_closure: function SubstrateConf_kusamaEd25519_closure() {
    },
    SubstrateConf_kusamaSecp256k1_closure: function SubstrateConf_kusamaSecp256k1_closure() {
    },
    SubstrateConf_kusamaSr25519_closure: function SubstrateConf_kusamaSr25519_closure() {
    },
    SubstrateConf_moonbeamEd25519_closure: function SubstrateConf_moonbeamEd25519_closure() {
    },
    SubstrateConf_moonbeamSecp256k1_closure: function SubstrateConf_moonbeamSecp256k1_closure() {
    },
    SubstrateConf_moonbeamSr25519_closure: function SubstrateConf_moonbeamSr25519_closure() {
    },
    SubstrateConf_moonriverEd25519_closure: function SubstrateConf_moonriverEd25519_closure() {
    },
    SubstrateConf_moonriverSecp256k1_closure: function SubstrateConf_moonriverSecp256k1_closure() {
    },
    SubstrateConf_moonriverSr25519_closure: function SubstrateConf_moonriverSr25519_closure() {
    },
    SubstrateConf_phalaEd25519_closure: function SubstrateConf_phalaEd25519_closure() {
    },
    SubstrateConf_phalaSecp256k1_closure: function SubstrateConf_phalaSecp256k1_closure() {
    },
    SubstrateConf_phalaSr25519_closure: function SubstrateConf_phalaSr25519_closure() {
    },
    SubstrateConf_plasmEd25519_closure: function SubstrateConf_plasmEd25519_closure() {
    },
    SubstrateConf_plasmSecp256k1_closure: function SubstrateConf_plasmSecp256k1_closure() {
    },
    SubstrateConf_plasmSr25519_closure: function SubstrateConf_plasmSr25519_closure() {
    },
    SubstrateConf_polkadotEd25519_closure: function SubstrateConf_polkadotEd25519_closure() {
    },
    SubstrateConf_polkadotSecp256k1_closure: function SubstrateConf_polkadotSecp256k1_closure() {
    },
    SubstrateConf_polkadotSr25519_closure: function SubstrateConf_polkadotSr25519_closure() {
    },
    SubstrateConf_soraEd25519_closure: function SubstrateConf_soraEd25519_closure() {
    },
    SubstrateConf_soraSecp256k1_closure: function SubstrateConf_soraSecp256k1_closure() {
    },
    SubstrateConf_soraSr25519_closure: function SubstrateConf_soraSr25519_closure() {
    },
    SubstrateConf_stafiEd25519_closure: function SubstrateConf_stafiEd25519_closure() {
    },
    SubstrateConf_stafiSecp256k1_closure: function SubstrateConf_stafiSecp256k1_closure() {
    },
    SubstrateConf_stafiSr25519_closure: function SubstrateConf_stafiSr25519_closure() {
    },
    CborObject_CborObject$fromDynamic(value) {
      var t1 = type$.CborObject;
      if (t1._is(value))
        return value;
      else if (value == null)
        return B.C_CborNullValue;
      else if (A._isBool(value))
        return new A.CborBoleanValue(value);
      else if (A._isInt(value))
        return new A.CborIntValue(value);
      else if (typeof value == "number")
        return new A.CborFloatValue(value);
      else if (value instanceof A._BigIntImpl)
        return new A.CborBigIntValue(value);
      else if (typeof value == "string")
        return new A.CborStringValue(value);
      else if (type$.List_String._is(value))
        return new A.CborIndefiniteStringValue(value);
      else if (type$.List_int._is(value))
        return new A.CborBytesValue(value);
      else if (type$.List_List_int._is(value))
        return new A.CborDynamicBytesValue(value);
      else if (type$.Map_dynamic_dynamic._is(value))
        return new A.CborMapValue(value, true, type$.CborMapValue_dynamic_dynamic);
      else if (type$.List_dynamic._is(value)) {
        t1 = J.map$1$1$ax(value, new A.CborObject_CborObject$fromDynamic_closure(), t1);
        return new A.CborListValue(A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E")), true, type$.CborListValue_CborObject);
      }
      throw A.wrapException(A.UnimplementedError$("does not supported"));
    },
    CborNumeric_getCborNumericValue(val) {
      if (val instanceof A.CborIntValue)
        return A._BigIntImpl__BigIntImpl$from(val.value);
      else if (val instanceof A.CborBigIntValue)
        return val.value;
      else if (val instanceof A.CborSafeIntValue)
        return val.value;
      throw A.wrapException(B.ArgumentException_e4a);
    },
    CborObject_CborObject$fromDynamic_closure: function CborObject_CborObject$fromDynamic_closure() {
    },
    CborBase64Types: function CborBase64Types(t0) {
      this.tag = t0;
    },
    CborBaseUrlValue: function CborBaseUrlValue(t0, t1) {
      this.value = t0;
      this.type = t1;
    },
    CborBigFloatValue: function CborBigFloatValue(t0, t1) {
      this.exponent = t0;
      this.mantissa = t1;
    },
    CborBigIntValue: function CborBigIntValue(t0) {
      this.value = t0;
    },
    CborBoleanValue: function CborBoleanValue(t0) {
      this.value = t0;
    },
    CborBytesValue: function CborBytesValue(t0) {
      this.value = t0;
    },
    CborDynamicBytesValue: function CborDynamicBytesValue(t0) {
      this.value = t0;
    },
    CborTagValue: function CborTagValue(t0, t1, t2) {
      this.tags = t0;
      this.value = t1;
      this.$ti = t2;
    },
    _CborDate: function _CborDate() {
    },
    CborStringDateValue: function CborStringDateValue(t0) {
      this.value = t0;
    },
    CborEpochFloatValue: function CborEpochFloatValue(t0) {
      this.value = t0;
    },
    CborEpochIntValue: function CborEpochIntValue(t0) {
      this.value = t0;
    },
    CborDecimalFracValue: function CborDecimalFracValue(t0, t1) {
      this.exponent = t0;
      this.mantissa = t1;
    },
    CborFloatValue: function CborFloatValue(t0) {
      this.value = t0;
      this.__CborFloatValue__decodFloat_FI = $;
    },
    CborIntValue: function CborIntValue(t0) {
      this.value = t0;
    },
    CborSafeIntValue: function CborSafeIntValue(t0) {
      this.value = t0;
    },
    CborListValue: function CborListValue(t0, t1, t2) {
      this.value = t0;
      this._isFixedLength = t1;
      this.$ti = t2;
    },
    CborMapValue: function CborMapValue(t0, t1, t2) {
      this.value = t0;
      this._map$_isFixedLength = t1;
      this.$ti = t2;
    },
    CborMimeValue: function CborMimeValue(t0) {
      this.value = t0;
    },
    CborNullValue: function CborNullValue() {
    },
    CborUndefinedValue: function CborUndefinedValue() {
    },
    CborRegxpValue: function CborRegxpValue(t0) {
      this.value = t0;
    },
    CborSetValue: function CborSetValue(t0, t1) {
      this.value = t0;
      this.$ti = t1;
    },
    CborString: function CborString() {
    },
    CborStringValue: function CborStringValue(t0) {
      this.value = t0;
    },
    CborIndefiniteStringValue: function CborIndefiniteStringValue(t0) {
      this.value = t0;
    },
    CborUriValue: function CborUriValue(t0) {
      this.value = t0;
    },
    CborUtils_parseRFC3339DateTime(dateTimeString) {
      var parts, t1;
      if (B.JSString_methods.contains$1(dateTimeString, "+")) {
        parts = dateTimeString.split("+");
        t1 = parts.length;
        if (t1 !== 2)
          throw A.wrapException(A.MessageException$("Invalid format: " + dateTimeString, null));
        if (0 >= t1)
          return A.ioore(parts, 0);
        return A.DateTime_parse(parts[0]);
      } else
        return A.DateTime_parse(dateTimeString).toUtc$0();
    },
    CborUtils__decode(cborBytes) {
      var t1, i, first, majorTag, info, data, t2,
        tags = A._setArrayType([], type$.JSArray_int);
      $label0$1:
        for (t1 = J.getInterceptor$asx(cborBytes), i = 0; i < t1.get$length(cborBytes);) {
          first = t1.$index(cborBytes, i);
          majorTag = B.JSInt_methods._shrOtherPositive$1(first, 5);
          info = first & 31;
          switch (majorTag) {
            case 5:
              if (info === 31)
                return A.CborUtils__decodeDynamicMap(cborBytes, i, info, tags);
              return A.CborUtils__decodeMap(cborBytes, i, info, tags);
            case 1:
            case 0:
              return A.CborUtils__parseInt(majorTag, info, i, cborBytes, tags);
            case 6:
              data = A.CborUtils__decodeLength(info, t1.sublist$1(cborBytes, i));
              B.JSArray_methods.add$1(tags, A._asInt(data.item1));
              t2 = data.item2;
              if (typeof t2 !== "number")
                return A.iae(t2);
              i += t2;
              continue $label0$1;
            case 2:
              return A.CborUtils__decodeBytesString(info, i, cborBytes, tags);
            case 3:
              return A.CborUtils__decodeUtf8String(info, i, cborBytes, tags);
            case 7:
              return A.CborUtils__parseSimpleValue(i, info, cborBytes, tags);
            case 4:
              if (info === 31)
                return A.CborUtils__decodeDynamicArray(cborBytes, i, info, tags);
              return A.CborUtils__decodeArray(cborBytes, i, info, tags);
            default:
              throw A.wrapException(A.ArgumentException$("invalid or unsuported cbor tag major: " + majorTag + " "));
          }
        }
      throw A.wrapException(B.ArgumentException_UNa);
    },
    CborUtils__parsBytes(info, cborBytes) {
      var end,
        len = A.CborUtils__decodeLength(info, cborBytes),
        t1 = len.item2,
        t2 = A._asNum(len.item1);
      if (typeof t1 !== "number")
        return t1.$add();
      end = A._asInt(t1 + t2);
      return new A.Tuple(J.sublist$2$ax(cborBytes, t1, end), end, type$.Tuple_of_List_int_and_int);
    },
    CborUtils__decodeLength(info, cborBytes) {
      var len, t1, bytes, decode;
      if (info < 24)
        return new A.Tuple(info, 1, type$.Tuple_dynamic_int);
      len = B.JSInt_methods.$shl(1, info - 24);
      t1 = len + 1;
      bytes = J.sublist$2$ax(cborBytes, 1, t1);
      if (len <= 4)
        return new A.Tuple(A.IntUtils_fromBytes(bytes), t1, type$.Tuple_dynamic_int);
      else if (len <= 8) {
        decode = A.BigintUtils_fromBytes(bytes, B.C_Endian, false);
        if (decode.get$isValidInt())
          return new A.Tuple(decode.toInt$0(0), t1, type$.Tuple_dynamic_int);
        return new A.Tuple(decode, t1, type$.Tuple_dynamic_int);
      } else
        throw A.wrapException(A.ArgumentException$("Invalid additional info for int: " + info));
    },
    CborUtils__decodeUtf8String(info, i, cborBytes, tags) {
      var toList, t1, stringList, bytes, t2;
      if (info === 31) {
        toList = A.CborUtils__decodeDynamicArray(cborBytes, i, info, tags);
        t1 = type$.WhereTypeIterable_CborStringValue;
        t1 = A.MappedIterable_MappedIterable(new A.WhereTypeIterable(type$.CborListValue_dynamic._as(toList.item1).value, t1), t1._eval$1("String(Iterable.E)")._as(new A.CborUtils__decodeUtf8String_closure()), t1._eval$1("Iterable.E"), type$.String);
        stringList = A.List_List$of(t1, true, A._instanceType(t1)._eval$1("Iterable.E"));
        if (tags.length !== 0)
          return new A.Tuple(new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), new A.CborIndefiniteStringValue(stringList), type$.CborTagValue_CborIndefiniteStringValue), toList.item2, type$.Tuple_CborObject_int);
        return new A.Tuple(new A.CborIndefiniteStringValue(stringList), toList.item2, type$.Tuple_CborObject_int);
      }
      bytes = A.CborUtils__parsBytes(info, J.sublist$1$ax(cborBytes, i));
      t1 = A.CborUtils__toStringObject(bytes.item1, tags);
      t2 = bytes.item2;
      if (typeof t2 !== "number")
        return t2.$add();
      return new A.Tuple(t1, t2 + i, type$.Tuple_CborObject_int);
    },
    CborUtils__toStringObject(utf8Bytes, tags) {
      var toObj, baseType,
        $toString = A.StringUtils_decode(utf8Bytes, false, B.StringEncoding_1);
      if (tags.length === 0)
        toObj = new A.CborStringValue($toString);
      else if (B.JSArray_methods.any$1(B.List_ww8, new A.CborUtils__toStringObject_closure(tags))) {
        baseType = B.JSArray_methods.firstWhere$1(B.List_ww8, new A.CborUtils__toStringObject_closure0(tags));
        B.JSArray_methods.clear$0(tags);
        toObj = new A.CborBaseUrlValue($toString, baseType);
      } else if (A.BytesUtils_bytesEqual(tags, B.List_36)) {
        B.JSArray_methods.clear$0(tags);
        toObj = new A.CborMimeValue($toString);
      } else if (A.BytesUtils_bytesEqual(tags, B.List_32)) {
        B.JSArray_methods.clear$0(tags);
        toObj = new A.CborUriValue($toString);
      } else if (A.BytesUtils_bytesEqual(tags, B.List_35)) {
        B.JSArray_methods.clear$0(tags);
        toObj = new A.CborRegxpValue($toString);
      } else if (A.BytesUtils_bytesEqual(tags, B.List_00)) {
        B.JSArray_methods.clear$0(tags);
        toObj = new A.CborStringDateValue(A.CborUtils_parseRFC3339DateTime($toString));
      } else
        toObj = null;
      if (toObj == null)
        toObj = new A.CborStringValue($toString);
      return tags.length === 0 ? toObj : new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), toObj, type$.CborTagValue_CborObject);
    },
    CborUtils__decodeBytesString(info, i, cborBytes, tags) {
      var toList, t1, bytesList, bytes, big, val, t2;
      if (info === 31) {
        toList = A.CborUtils__decodeDynamicArray(cborBytes, i, info, tags);
        t1 = type$.WhereTypeIterable_CborBytesValue;
        t1 = A.MappedIterable_MappedIterable(new A.WhereTypeIterable(type$.CborListValue_dynamic._as(toList.item1).value, t1), t1._eval$1("List<int>(Iterable.E)")._as(new A.CborUtils__decodeBytesString_closure()), t1._eval$1("Iterable.E"), type$.List_int);
        bytesList = A.List_List$of(t1, true, A._instanceType(t1)._eval$1("Iterable.E"));
        if (tags.length !== 0)
          return new A.Tuple(new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), new A.CborDynamicBytesValue(bytesList), type$.CborTagValue_CborDynamicBytesValue), toList.item2, type$.Tuple_CborObject_int);
        return new A.Tuple(new A.CborDynamicBytesValue(bytesList), toList.item2, type$.Tuple_CborObject_int);
      }
      bytes = A.CborUtils__parsBytes(info, J.sublist$1$ax(cborBytes, i));
      if (A.BytesUtils_bytesEqual(tags, B.List_3) || A.BytesUtils_bytesEqual(tags, B.List_2)) {
        big = A.BigintUtils_fromBytes(bytes.item1, B.C_Endian, false);
        if (A.BytesUtils_bytesEqual(tags, B.List_3))
          big = big.$not(0);
        B.JSArray_methods.clear$0(tags);
        val = new A.CborBigIntValue(big);
      } else
        val = null;
      if (val == null)
        val = new A.CborBytesValue(bytes.item1);
      t1 = tags.length === 0 ? val : new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), val, type$.CborTagValue_CborObject);
      t2 = bytes.item2;
      if (typeof t2 !== "number")
        return t2.$add();
      return new A.Tuple(t1, t2 + i, type$.Tuple_CborObject_int);
    },
    CborUtils__decodeMap(cborBytes, offset, info, tags) {
      var index, $length, objects, lI, decodeKey, t2, decodeValue, toMap,
        decodeLen = A.CborUtils__decodeLength(info, cborBytes),
        t1 = decodeLen.item2;
      if (typeof t1 !== "number")
        return A.iae(t1);
      index = offset + t1;
      $length = A._asInt(decodeLen.item1);
      t1 = type$.CborObject;
      objects = A.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
      for (t1 = J.getInterceptor$ax(cborBytes), lI = 0; lI < $length; ++lI) {
        decodeKey = A.CborUtils__decode(t1.sublist$1(cborBytes, index));
        t2 = decodeKey.item2;
        if (typeof t2 !== "number")
          return A.iae(t2);
        index += t2;
        decodeValue = A.CborUtils__decode(t1.sublist$1(cborBytes, index));
        objects.$indexSet(0, decodeKey.item1, decodeValue.item1);
        t2 = decodeValue.item2;
        if (typeof t2 !== "number")
          return A.iae(t2);
        index += t2;
      }
      toMap = new A.CborMapValue(objects, true, type$.CborMapValue_CborObject_CborObject);
      t1 = tags.length === 0 ? toMap : new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), toMap, type$.CborTagValue_CborMapValue_CborObject_CborObject);
      return new A.Tuple(t1, index, type$.Tuple_CborObject_int);
    },
    CborUtils__decodeDynamicMap(cborBytes, offset, info, tags) {
      var decodeKey, t2, decodeValue, toMap,
        index = offset + 1,
        t1 = type$.CborObject,
        objects = A.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
      for (t1 = J.getInterceptor$asx(cborBytes); !J.$eq$(t1.$index(cborBytes, index), 255);) {
        decodeKey = A.CborUtils__decode(t1.sublist$1(cborBytes, index));
        t2 = decodeKey.item2;
        if (typeof t2 !== "number")
          return A.iae(t2);
        index += t2;
        decodeValue = A.CborUtils__decode(t1.sublist$1(cborBytes, index));
        objects.$indexSet(0, decodeKey.item1, decodeValue.item1);
        t2 = decodeValue.item2;
        if (typeof t2 !== "number")
          return A.iae(t2);
        index += t2;
      }
      toMap = new A.CborMapValue(objects, false, type$.CborMapValue_CborObject_CborObject);
      t1 = tags.length === 0 ? toMap : new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), toMap, type$.CborTagValue_CborMapValue_CborObject_CborObject);
      return new A.Tuple(t1, index + 1, type$.Tuple_CborObject_int);
    },
    CborUtils__decodeArray(cborBytes, offset, info, tags) {
      var index, $length, objects, lI, decodeData, t2, toObj,
        decodeLen = A.CborUtils__decodeLength(info, cborBytes),
        t1 = decodeLen.item2;
      if (typeof t1 !== "number")
        return A.iae(t1);
      index = offset + t1;
      $length = A._asInt(decodeLen.item1);
      objects = A._setArrayType([], type$.JSArray_CborObject);
      for (t1 = J.getInterceptor$ax(cborBytes), lI = 0; lI < $length; ++lI) {
        decodeData = A.CborUtils__decode(t1.sublist$1(cborBytes, index));
        B.JSArray_methods.add$1(objects, decodeData.item1);
        t2 = decodeData.item2;
        if (typeof t2 !== "number")
          return A.iae(t2);
        index += t2;
        if (index === t1.get$length(cborBytes))
          break;
      }
      if (A.BytesUtils_bytesEqual(tags, B.List_5) || A.BytesUtils_bytesEqual(tags, B.List_4))
        return new A.Tuple(A.CborUtils__decodeCborBigfloatOrDecimal(objects, tags), index, type$.Tuple_CborObject_int);
      if (A.BytesUtils_bytesEqual(tags, B.List_258)) {
        B.JSArray_methods.clear$0(tags);
        toObj = new A.CborSetValue(A.LinkedHashSet_LinkedHashSet$from(objects, type$.CborObject), type$.CborSetValue_CborObject);
        t1 = tags.length === 0 ? toObj : new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), toObj, type$.CborTagValue_CborSetValue_CborObject);
        return new A.Tuple(t1, index, type$.Tuple_CborObject_int);
      }
      toObj = new A.CborListValue(objects, true, type$.CborListValue_CborObject);
      t1 = tags.length === 0 ? toObj : new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), toObj, type$.CborTagValue_CborListValue_CborObject);
      return new A.Tuple(t1, index, type$.Tuple_CborObject_int);
    },
    CborUtils__decodeDynamicArray(cborBytes, offset, info, tags) {
      var t1, decodeData, t2, toObj,
        index = offset + 1,
        objects = A._setArrayType([], type$.JSArray_CborObject);
      for (t1 = J.getInterceptor$asx(cborBytes); !J.$eq$(t1.$index(cborBytes, index), 255);) {
        decodeData = A.CborUtils__decode(t1.sublist$1(cborBytes, index));
        B.JSArray_methods.add$1(objects, decodeData.item1);
        t2 = decodeData.item2;
        if (typeof t2 !== "number")
          return A.iae(t2);
        index += t2;
      }
      toObj = new A.CborListValue(objects, false, type$.CborListValue_CborObject);
      t1 = tags.length === 0 ? toObj : new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), toObj, type$.CborTagValue_CborListValue_CborObject);
      return new A.Tuple(t1, index + 1, type$.Tuple_CborObject_int);
    },
    CborUtils__decodeCborBigfloatOrDecimal(objects, tags) {
      var t2, t3, toObj,
        t1 = type$.WhereTypeIterable_CborNumeric;
      objects = A.List_List$of(new A.WhereTypeIterable(objects, t1), true, t1._eval$1("Iterable.E"));
      t1 = objects.length;
      if (t1 !== 2)
        throw A.wrapException(B.MessageException_j3V);
      if (A.BytesUtils_bytesEqual(tags, B.List_4)) {
        B.JSArray_methods.clear$0(tags);
        if (0 >= t1)
          return A.ioore(objects, 0);
        t2 = type$.CborNumeric;
        t3 = t2._as(objects[0]);
        if (1 >= t1)
          return A.ioore(objects, 1);
        t2 = t2._as(objects[1]);
        toObj = new A.CborDecimalFracValue(A.CborNumeric_getCborNumericValue(t3), A.CborNumeric_getCborNumericValue(t2));
        return tags.length === 0 ? toObj : new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), toObj, type$.CborTagValue_CborDecimalFracValue);
      }
      B.JSArray_methods.clear$0(tags);
      if (0 >= t1)
        return A.ioore(objects, 0);
      t2 = type$.CborNumeric;
      t3 = t2._as(objects[0]);
      if (1 >= t1)
        return A.ioore(objects, 1);
      t2 = t2._as(objects[1]);
      toObj = new A.CborBigFloatValue(A.CborNumeric_getCborNumericValue(t3), A.CborNumeric_getCborNumericValue(t2));
      return tags.length === 0 ? toObj : new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), toObj, type$.CborTagValue_CborBigFloatValue);
    },
    CborUtils__parseSimpleValue(i, info, bytes, tags) {
      var obj, offset0, t1, elementSize, end, int16Bits, sign, exponent, fraction, value, val, dt, _null = null,
        offset = i + 1;
      switch (info) {
        case 20:
          obj = B.CborBoleanValue_false;
          break;
        case 21:
          obj = B.CborBoleanValue_true;
          break;
        case 22:
          obj = B.C_CborNullValue;
          break;
        case 23:
          obj = B.C_CborUndefinedValue;
          break;
        default:
          obj = _null;
      }
      if (obj != null) {
        if (tags.length === 0)
          return new A.Tuple(obj, offset, type$.Tuple_CborObject_int);
        return new A.Tuple(new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), obj, type$.CborTagValue_CborObject), offset, type$.Tuple_CborObject_int);
      }
      switch (info) {
        case 25:
          offset0 = offset + 2;
          t1 = J.sublist$2$ax(bytes, offset, offset0);
          if (t1.length !== 2)
            A.throwExpression(B.ArgumentException_hWj);
          t1 = new Uint8Array(A._ensureNativeList(t1));
          elementSize = t1.BYTES_PER_ELEMENT;
          end = A.RangeError_checkValidRange(0, _null, B.JSInt_methods.$tdiv(t1.byteLength, elementSize));
          int16Bits = B.NativeByteData_methods._getInt16$2(A.NativeByteData_NativeByteData$view(t1.buffer, t1.byteOffset + 0 * elementSize, (end - 0) * elementSize), 0, false);
          sign = B.JSInt_methods._shrOtherPositive$1(int16Bits, 15) & 1;
          exponent = B.JSInt_methods._shrOtherPositive$1(int16Bits, 10) & 31;
          fraction = int16Bits & 1023;
          if (exponent === 31)
            if (fraction === 0)
              value = sign === 0 ? 1 / 0 : -1 / 0;
            else
              value = 0 / 0;
          else if (exponent === 0 && fraction === 0)
            value = sign === 0 ? 0 : -0.0;
          else {
            value = sign === 0 ? 1 : -1;
            value *= (1 + fraction / 1024) * Math.pow(2, exponent - 15);
          }
          val = value;
          offset = offset0;
          break;
        case 26:
          offset0 = offset + 4;
          val = B.NativeByteData_methods._getFloat32$2(A.NativeByteData_NativeByteData$view(new Uint8Array(A._ensureNativeList(J.sublist$2$ax(bytes, offset, offset0))).buffer, 0, _null), 0, false);
          offset = offset0;
          break;
        case 27:
          offset0 = offset + 8;
          val = B.NativeByteData_methods._getFloat64$2(A.NativeByteData_NativeByteData$view(new Uint8Array(A._ensureNativeList(J.sublist$2$ax(bytes, offset, offset0))).buffer, 0, _null), 0, false);
          offset = offset0;
          break;
        default:
          throw A.wrapException(B.MessageException_O1c);
      }
      if (A.BytesUtils_bytesEqual(tags, B.List_1)) {
        dt = A.DateTime$fromMillisecondsSinceEpoch(B.JSNumber_methods.round$0(val * 1000), false);
        B.JSArray_methods.clear$0(tags);
        obj = new A.CborEpochFloatValue(dt);
      }
      if (obj == null)
        obj = new A.CborFloatValue(val);
      t1 = tags.length === 0 ? obj : new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), obj, type$.CborTagValue_CborObject);
      return new A.Tuple(t1, offset, type$.Tuple_CborObject_int);
    },
    CborUtils__parseInt(mt, info, i, cborBytes, tags) {
      var val, numericValue, index, dt, toObj,
        data = A.CborUtils__decodeLength(info, J.sublist$1$ax(cborBytes, i)),
        numb = data.item1,
        t1 = numb instanceof A._BigIntImpl;
      if (t1 || mt === 1) {
        val = t1 ? numb : A._BigIntImpl__BigIntImpl$from(A._asNum(numb));
        if (mt === 1)
          val = val.$not(0);
        numericValue = val.get$isValidInt() ? new A.CborIntValue(val.toInt$0(0)) : null;
        if (numericValue == null)
          numericValue = new A.CborSafeIntValue(val);
      } else
        numericValue = new A.CborIntValue(A._asInt(numb));
      t1 = data.item2;
      if (typeof t1 !== "number")
        return t1.$add();
      index = t1 + i;
      if (A.BytesUtils_bytesEqual(tags, B.List_1)) {
        dt = A.DateTime$fromMillisecondsSinceEpoch(numericValue.toInt$0(0) * 1000, false);
        B.JSArray_methods.clear$0(tags);
        toObj = new A.CborEpochIntValue(dt);
        t1 = tags.length === 0 ? toObj : new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), toObj, type$.CborTagValue_CborEpochIntValue);
        return new A.Tuple(t1, index, type$.Tuple_CborObject_int);
      }
      t1 = tags.length === 0 ? numericValue : new A.CborTagValue(A.List_List$unmodifiable(tags, type$.int), numericValue, type$.CborTagValue_CborNumeric);
      return new A.Tuple(t1, index, type$.Tuple_CborObject_int);
    },
    CborUtils__decodeUtf8String_closure: function CborUtils__decodeUtf8String_closure() {
    },
    CborUtils__toStringObject_closure: function CborUtils__toStringObject_closure(t0) {
      this.tags = t0;
    },
    CborUtils__toStringObject_closure0: function CborUtils__toStringObject_closure0(t0) {
      this.tags = t0;
    },
    CborUtils__decodeBytesString_closure: function CborUtils__decodeBytesString_closure() {
    },
    CborBytesTracker: function CborBytesTracker(t0) {
      this._dynamic_bytes$_buffer = t0;
    },
    FloatUtils__decodeBits(bits) {
      var mantissa, exponent,
        mantissaBits = (bits & -1) >>> 0,
        exponentBits = B.JSInt_methods._shrBothPositive$1(bits, 52) & 2047,
        t1 = B.JSInt_methods._shrBothPositive$1(bits, 63);
      if (exponentBits === 0) {
        mantissa = mantissaBits;
        exponent = -1074;
      } else {
        exponent = exponentBits - 1023 - 52;
        mantissa = (mantissaBits | 0) >>> 0;
      }
      if (t1 !== 0)
        mantissa = -mantissa;
      while (true) {
        if (!((mantissa & 1) === 0 && mantissa !== 0))
          break;
        mantissa = B.JSInt_methods._shrOtherPositive$1(mantissa, 1);
        ++exponent;
      }
      return new A.Tuple(mantissa, exponent, type$.Tuple_int_int);
    },
    FloatUtils__toBits(value, endian) {
      var t1, bits, _i, b,
        toBytes = A.NativeUint8List_NativeUint8List$view(new Float64Array(A._ensureNativeList(A._setArrayType([value], type$.JSArray_double))).buffer, 0, null);
      toBytes = A.List_List$from(new A.ReversedListIterable(toBytes, A.instanceType(toBytes)._eval$1("ReversedListIterable<ListBase.E>")), false, type$.int);
      for (t1 = toBytes.length, bits = 0, _i = 0; _i < t1; ++_i) {
        b = toBytes[_i];
        if (typeof b !== "number")
          return A.iae(b);
        bits = (bits << 8 | b) >>> 0;
      }
      return bits;
    },
    FloatUtils__isLessThan(value) {
      var bits;
      if (isNaN(value) || value == 1 / 0 || value == -1 / 0)
        return B.Tuple_true_true;
      bits = A.FloatUtils__toBits(value, null);
      if (A.FloatUtils__dobuleLessThan(bits, B.FloatLength_5_10))
        return B.Tuple_true_true;
      if (A.FloatUtils__dobuleLessThan(bits, B.FloatLength_8_23))
        return B.Tuple_false_true;
      return B.Tuple_false_false;
    },
    FloatUtils__dobuleLessThan(bits, type) {
      var t3, t4, exponent, subnormalMantissaLength,
        mantissaBitLength = type.mantissaBitLength,
        exponentBitLength = type.exponentBitLength,
        exponentBias = B.JSInt_methods.$shl(1, exponentBitLength - 1) - 1,
        de = A.FloatUtils__decodeBits(bits),
        t1 = de.item1,
        t2 = J.getInterceptor$(t1);
      if (t2.$eq(t1, 0))
        return true;
      t3 = mantissaBitLength + 1;
      if (t3 < t2.get$bitLength(t1))
        return false;
      t4 = de.item2;
      if (typeof t4 !== "number")
        return t4.$add();
      exponent = t4 + mantissaBitLength + exponentBias + (t2.get$bitLength(t1) - t3);
      if (exponent >= B.JSInt_methods._shlPositive$1(1, exponentBitLength) - 1)
        return false;
      if (exponent >= 1)
        return true;
      subnormalMantissaLength = t2.get$bitLength(t1) + t4 - -(exponentBias - 1 + mantissaBitLength);
      return subnormalMantissaLength > 0 && subnormalMantissaLength <= mantissaBitLength;
    },
    FloatLength: function FloatLength(t0, t1) {
      this.exponentBitLength = t0;
      this.mantissaBitLength = t1;
    },
    FloatUtils: function FloatUtils(t0) {
      this.value = t0;
      this.__FloatUtils__isLess_FI = $;
    },
    AES$(key) {
      var t2, t3,
        t1 = new A.AES();
      t1.__AES__keyLen_A = 32;
      type$.List_int._as(key);
      t2 = type$.int;
      t1.set$_encKey(A.List_List$filled(60, 0, false, t2));
      if (t1._decKey == null)
        t1.set$_decKey(A.List_List$filled(60, 0, false, t2));
      t2 = $.$get$AES__lib();
      t3 = t1._encKey;
      t3.toString;
      t2.expandKey$3(key, t3, t1._decKey);
      return t1;
    },
    AES: function AES() {
      this.__AES__keyLen_A = $;
      this._decKey = this._encKey = null;
    },
    AESLib: function AESLib(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _._powx = t0;
      _._sbox0 = t1;
      _._sbox1 = t2;
      _._te0 = t3;
      _._te1 = t4;
      _._te2 = t5;
      _._te3 = t6;
      _._td0 = t7;
      _._td1 = t8;
      _._td2 = t9;
      _._td3 = t10;
    },
    AESLib_initialize_mul: function AESLib_initialize_mul() {
    },
    AESLib_initialize__rot24: function AESLib_initialize__rot24() {
    },
    CurveFp$(a, b, h, p) {
      return new A.CurveFp(p, a, b, h);
    },
    CurveFp: function CurveFp(t0, t1, t2, t3) {
      var _ = this;
      _.p = t0;
      _.a = t1;
      _.b = t2;
      _.h = t3;
    },
    CurveED: function CurveED(t0, t1, t2, t3) {
      var _ = this;
      _.p = t0;
      _.a = t1;
      _.d = t2;
      _.h = t3;
    },
    Curve: function Curve() {
    },
    ECDSAPublicKey_ECDSAPublicKey(generator, point) {
      var t2, t3, leftSide,
        curve = generator.curve,
        n = generator.order,
        p = curve.p,
        t1 = $.$get$_BigIntImpl_zero();
      if (t1.compareTo$1(0, point.get$x()) <= 0 && point.get$x().compareTo$1(0, p) < 0)
        t2 = !(t1.compareTo$1(0, point.get$y()) <= 0 && point.get$y().compareTo$1(0, p) < 0);
      else
        t2 = true;
      if (t2)
        throw A.wrapException(B.ArgumentException_oyU);
      t2 = point.get$x();
      t3 = point.get$y();
      leftSide = t3.$mul(0, t3).$sub(0, t2.$mul(0, t2).$add(0, curve.a).$mul(0, t2).$add(0, curve.b)).$mod(0, p);
      t1 = leftSide.compareTo$1(0, t1);
      t1 = t1 !== 0;
      if (t1)
        throw A.wrapException(B.ArgumentException_bJa);
      if (n == null)
        throw A.wrapException(B.ArgumentException_GlQ);
      t1 = curve.h.compareTo$1(0, $.$get$_BigIntImpl_one());
      t1 = t1 !== 0 && !point.$mul(0, n).get$isInfinity();
      if (t1)
        throw A.wrapException(B.ArgumentException_ifn);
      return new A.ECDSAPublicKey(generator, point);
    },
    ECDSAPublicKey: function ECDSAPublicKey(t0, t1) {
      this.generator = t0;
      this.point = t1;
    },
    EDDSAPublicKey_EDDSAPublicKey$fromPoint(generator, publicPoint) {
      var baselen = B.JSInt_methods._tdivFast$1(generator.curve.p.get$bitLength(0) + 1 + 7, 8),
        pubkeyBytes = publicPoint.toBytes$0();
      if (pubkeyBytes.length !== baselen)
        throw A.wrapException(A.ArgumentException$("Incorrect size of the public key, expected: " + baselen + " bytes"));
      return new A.EDDSAPublicKey(generator, A.BytesUtils_toBytes(pubkeyBytes, true), publicPoint);
    },
    EDDSAPublicKey: function EDDSAPublicKey(t0, t1, t2) {
      this.generator = t0;
      this._encoded = t1;
      this._point = t2;
    },
    AbstractPoint_fromBytes(curve, data) {
      var p, expLen, t1, t2, y, x, keyLen, rawEncodingLength, encodeType, prefix, result;
      if (curve instanceof A.CurveED) {
        data = A.List_List$from(data, true, type$.int);
        p = curve.p;
        expLen = B.JSInt_methods._tdivFast$1(p.get$bitLength(0) + 1 + 7, 8);
        t1 = data.length;
        if (t1 !== expLen)
          A.throwExpression(B.ArgumentException_qkE);
        t2 = expLen - 1;
        if (!(t2 >= 0 && t2 < t1))
          return A.ioore(data, t2);
        t1 = data[t2];
        if (typeof t1 !== "number")
          return t1.$and();
        B.JSArray_methods.$indexSet(data, t2, t1 & 127);
        y = A.BigintUtils_fromBytes(data, B.C_Endian0, false);
        x = A.ECDSAUtils_modularSquareRootPrime(y.$mul(0, y).$sub(0, A._BigIntImpl__BigIntImpl$from(1)).$mul(0, A.BigintUtils_inverseMod(curve.d.$mul(0, y).$mul(0, y).$sub(0, curve.a), p)).$mod(0, p), p);
        if (!x.get$isEven(0) !== ((t1 >>> 7 & 1) === 1))
          x = x.$negate(0).$mod(0, p);
        return new A.Tuple(x, y, type$.Tuple_BigInt_BigInt);
      }
      t1 = J.getInterceptor$asx(data);
      keyLen = t1.get$length(data);
      rawEncodingLength = 2 * A.BigintUtils_orderLen(curve.get$p());
      if (keyLen === rawEncodingLength)
        encodeType = B.EncodeType_2;
      else if (keyLen === rawEncodingLength + 1) {
        prefix = t1.$index(data, 0);
        if (prefix === 4)
          encodeType = B.EncodeType_3;
        else {
          if (!(prefix === 6 || prefix === 7))
            throw A.wrapException(B.ArgumentException_aep);
          encodeType = B.EncodeType_1;
        }
      } else {
        if (keyLen !== B.JSInt_methods._tdivFast$1(rawEncodingLength, 2) + 1)
          throw A.wrapException(B.ArgumentException_aep);
        encodeType = B.EncodeType_0;
      }
      type$.CurveFp._as(curve);
      switch (encodeType) {
        case B.EncodeType_0:
          return A.AbstractPoint__fromCompressed(data, curve);
        case B.EncodeType_3:
          return A.AbstractPoint__fromRawEncoding(t1.sublist$1(data, 1), rawEncodingLength);
        case B.EncodeType_1:
          result = A.AbstractPoint__fromRawEncoding(t1.sublist$1(data, 1), rawEncodingLength);
          y = result.item2;
          t2 = $.$get$_BigIntImpl_one();
          prefix = y.$and(0, t2);
          t2 = prefix.compareTo$1(0, t2);
          if (!(t2 === 0 && !J.$eq$(t1.$index(data, 0), 7))) {
            t2 = prefix.compareTo$1(0, $.$get$_BigIntImpl_zero());
            t1 = t2 === 0 && !J.$eq$(t1.$index(data, 0), 6);
          } else
            t1 = true;
          if (t1)
            A.throwExpression(B.ArgumentException_GEX);
          return new A.Tuple(result.item1, y, type$.Tuple_BigInt_BigInt);
        default:
          return A.AbstractPoint__fromRawEncoding(data, rawEncodingLength);
      }
    },
    AbstractPoint__fromRawEncoding(data, rawEncodingLength) {
      var t1 = B.JSInt_methods._tdivFast$1(rawEncodingLength, 2),
        t2 = J.getInterceptor$ax(data),
        xs = t2.sublist$2(data, 0, t1),
        ys = t2.sublist$1(data, t1);
      return new A.Tuple(A.BigintUtils_fromBytes(xs, B.C_Endian, false), A.BigintUtils_fromBytes(ys, B.C_Endian, false), type$.Tuple_BigInt_BigInt);
    },
    AbstractPoint__fromCompressed(data, curve) {
      var isEven, x, p, beta, t2,
        t1 = J.getInterceptor$asx(data);
      if (!J.$eq$(t1.$index(data, 0), 2) && !J.$eq$(t1.$index(data, 0), 3))
        throw A.wrapException(B.ArgumentException_yPV);
      isEven = J.$eq$(t1.$index(data, 0), 2);
      x = A.BigintUtils_fromBytes(t1.sublist$1(data, 1), B.C_Endian, false);
      p = curve.p;
      beta = A.ECDSAUtils_modularSquareRootPrime(x.modPow$2(0, A._BigIntImpl__BigIntImpl$from(3), p).$add(0, curve.a.$mul(0, x)).$add(0, curve.b).$mod(0, p), p);
      t1 = beta.$and(0, $.$get$_BigIntImpl_one()).compareTo$1(0, $.$get$_BigIntImpl_zero());
      t2 = type$.Tuple_BigInt_BigInt;
      if (isEven === (t1 !== 0))
        return new A.Tuple(x, p.$sub(0, beta), t2);
      else
        return new A.Tuple(x, beta, t2);
    },
    EncodeType: function EncodeType(t0) {
      this._core$_name = t0;
    },
    AbstractPoint: function AbstractPoint() {
    },
    ProjectiveECCPoint_ProjectiveECCPoint(curve, generator, order, x, y, z) {
      return new A.ProjectiveECCPoint(curve, order, generator, B.List_empty3, A._setArrayType([x, y, z], type$.JSArray_BigInt));
    },
    ProjectiveECCPoint_ProjectiveECCPoint$fromBytes(curve, data, order) {
      var coords = A.AbstractPoint_fromBytes(curve, data);
      return new A.ProjectiveECCPoint(curve, order, false, B.List_empty3, A._setArrayType([coords.item1, coords.item2, $.$get$_BigIntImpl_one()], type$.JSArray_BigInt));
    },
    ProjectiveECCPoint: function ProjectiveECCPoint(t0, t1, t2, t3, t4) {
      var _ = this;
      _.curve = t0;
      _.order = t1;
      _.generator = t2;
      _._precompute = t3;
      _._ec_projective_point$_coords = t4;
    },
    EDPoint$(curve, generator, order, t, x, y, z) {
      return new A.EDPoint(curve, order, generator, A._setArrayType([x, y, z, t], type$.JSArray_BigInt));
    },
    EDPoint_EDPoint$fromBytes(curve, data) {
      var coords = A.AbstractPoint_fromBytes(curve, data),
        x = coords.item1,
        y = coords.item2,
        t = x.$mul(0, y);
      return new A.EDPoint(curve, null, false, A._setArrayType([x, y, $.$get$_BigIntImpl_one(), t], type$.JSArray_BigInt));
    },
    EDPoint: function EDPoint(t0, t1, t2, t3) {
      var _ = this;
      _.curve = t0;
      _.order = t1;
      _.generator = t2;
      _._coords = t3;
    },
    RistrettoPoint_RistrettoPoint$fromBytes(bytes) {
      var s2, u1, u2, u1_2, u2_2, v, invSqrt, t3, x2, y2, x, y, t, coords, t4, t5,
        c = $.$get$Curves_curveEd25519(),
        a = c.a,
        $P = c.p,
        s = A.BigintUtils_fromBytes(bytes, B.C_Endian0, false),
        t1 = A.positiveMod(s, $P),
        t2 = $.$get$_BigIntImpl_one();
      t1 = t1.$and(0, t2).compareTo$1(0, t2);
      if (t1 === 0)
        throw A.wrapException(B.ArgumentException_IJC);
      s2 = A.positiveMod(s.$mul(0, s), $P);
      u1 = A.positiveMod(t2.$add(0, a.$mul(0, s2)), $P);
      u2 = A.positiveMod(t2.$sub(0, a.$mul(0, s2)), $P);
      u1_2 = A.positiveMod(u1.$mul(0, u1), $P);
      u2_2 = A.positiveMod(u2.$mul(0, u2), $P);
      v = A.positiveMod(a.$mul(0, c.d).$mul(0, u1_2).$sub(0, u2_2), $P);
      invSqrt = A.sqrtUV(t2, A.positiveMod(v.$mul(0, u2_2), $P));
      t1 = invSqrt.item2;
      t3 = J.getInterceptor$ns(t1);
      x2 = A.positiveMod(t3.$mul(t1, u2), $P);
      y2 = A.positiveMod(t3.$mul(t1, x2).$mul(0, v), $P);
      x = A.positiveMod(s.$add(0, s).$mul(0, x2), $P);
      t1 = A.positiveMod(x, $P).$and(0, t2).compareTo$1(0, t2);
      if (t1 === 0)
        x = A.positiveMod(x.$negate(0), $P);
      y = A.positiveMod(u1.$mul(0, y2), $P);
      t = A.positiveMod(x.$mul(0, y), $P);
      if (A.boolConversionCheck(invSqrt.item1)) {
        t1 = A.positiveMod(t, $P).$and(0, t2).compareTo$1(0, t2);
        if (t1 !== 0)
          t1 = y.compareTo$1(0, $.$get$_BigIntImpl_zero()) === 0;
        else
          t1 = true;
      } else
        t1 = true;
      if (t1)
        throw A.wrapException(B.ArgumentException_IJC);
      t1 = type$.JSArray_BigInt;
      coords = A.List_List$from(A._setArrayType([x, y, t2, t], t1), true, type$.BigInt);
      t2 = coords.length;
      if (0 >= t2)
        return A.ioore(coords, 0);
      t3 = coords[0];
      if (1 >= t2)
        return A.ioore(coords, 1);
      t4 = coords[1];
      if (2 >= t2)
        return A.ioore(coords, 2);
      t5 = coords[2];
      if (3 >= t2)
        return A.ioore(coords, 3);
      return new A.RistrettoPoint(c, null, false, A._setArrayType([t3, t4, t5, coords[3]], t1));
    },
    RistrettoPoint: function RistrettoPoint(t0, t1, t2, t3) {
      var _ = this;
      _.curve = t0;
      _.order = t1;
      _.generator = t2;
      _._coords = t3;
    },
    SquareRootError: function SquareRootError(t0) {
      this.message = t0;
    },
    JacobiError: function JacobiError(t0) {
      this.message = t0;
    },
    ChaCha20Poly1305$(key) {
      var t1 = new A.ChaCha20Poly1305();
      if (key.length !== 32)
        A.throwExpression(B.ArgumentException_IVQ);
      t1.set$__ChaCha20Poly1305__key_A(type$.List_int._as(A.BytesUtils_toBytes(key, false)));
      return t1;
    },
    ChaCha20Poly1305: function ChaCha20Poly1305() {
      this.__ChaCha20Poly1305__key_A = $;
    },
    CTR$(cipher, iv) {
      var t1 = new A.CTR(),
        t2 = type$.int,
        t3 = type$.List_int;
      t1.set$__CTR__counter_F(t3._as(A.List_List$filled(16, 0, false, t2)));
      t2 = t3._as(A.List_List$filled(16, 0, false, t2));
      t1.__CTR__buffer_F !== $ && A.throwLateFieldAI("_buffer");
      t1.set$__CTR__buffer_F(t2);
      type$.nullable_List_int._as(iv);
      t1._cipher = null;
      t2 = t1.__CTR__counter_F;
      t2 === $ && A.throwLateFieldNI("_counter");
      if (16 !== t2.length)
        A.throwExpression(B.ArgumentException_oWp);
      t1._cipher = cipher;
      B.JSArray_methods.setAll$2(t2, 0, iv);
      t2 = t1.__CTR__buffer_F;
      t2 === $ && A.throwLateFieldNI("_buffer");
      t1._bufpos = t2.length;
      return t1;
    },
    _incrementCounter(counter) {
      var i, carry, t1;
      for (i = counter.length - 1, carry = 1; i >= 0; --i) {
        t1 = counter[i];
        if (typeof t1 !== "number")
          return t1.$and();
        carry += t1 & 255;
        B.JSArray_methods.$indexSet(counter, i, carry & 255);
        carry = carry >>> 8;
      }
      if (carry > 0)
        throw A.wrapException(B.ArgumentException_yDH);
    },
    CTR: function CTR() {
      var _ = this;
      _.__CTR__buffer_F = _.__CTR__counter_F = $;
      _._bufpos = 0;
      _._cipher = null;
    },
    Keccack_hash(data, digestLength) {
      var t2, out,
        t1 = type$.int,
        h = new A.Keccack(digestLength, A.List_List$filled(25, 0, false, t1), A.List_List$filled(25, 0, false, t1), A.List_List$filled(200, 0, false, t1));
      h._Keccack$1(digestLength * 2);
      t2 = type$.List_int;
      h.super$_Keccack$update(t2._as(data));
      out = A.List_List$filled(digestLength, 0, false, t1);
      t2._as(out);
      if (!h._hash$_finished)
        h._padAndPermute$1(1);
      else
        h._pos = 0;
      h._squeeze$1(out);
      h.reset$0();
      return out;
    },
    _keccakf(sh, sl, buf) {
      var i, t1, r, bch0, bch1, bch2, bch3, bch4, bcl0, bcl1, bcl2, bcl3, bcl4, th, tl, bch00, bcl00, t2;
      for (i = 0; i < 25; ++i) {
        t1 = i * 8;
        B.JSArray_methods.$indexSet(sl, i, A.readUint32LE(buf, t1));
        B.JSArray_methods.$indexSet(sh, i, A.readUint32LE(buf, t1 + 4));
      }
      for (r = 0; r < 24; ++r) {
        t1 = sh[0];
        bch0 = t1 ^ sh[5] ^ sh[10] ^ sh[15] ^ sh[20];
        bch1 = sh[1] ^ sh[6] ^ sh[11] ^ sh[16] ^ sh[21];
        bch2 = sh[2] ^ sh[7] ^ sh[12] ^ sh[17] ^ sh[22];
        bch3 = sh[3] ^ sh[8] ^ sh[13] ^ sh[18] ^ sh[23];
        bch4 = sh[4] ^ sh[9] ^ sh[14] ^ sh[19] ^ sh[24];
        bcl0 = sl[0] ^ sl[5] ^ sl[10] ^ sl[15] ^ sl[20];
        bcl1 = sl[1] ^ sl[6] ^ sl[11] ^ sl[16] ^ sl[21];
        bcl2 = sl[2] ^ sl[7] ^ sl[12] ^ sl[17] ^ sl[22];
        bcl3 = sl[3] ^ sl[8] ^ sl[13] ^ sl[18] ^ sl[23];
        bcl4 = sl[4] ^ sl[9] ^ sl[14] ^ sl[19] ^ sl[24];
        th = bch4 ^ (bch1 << 1 | bcl1 >>> 31);
        tl = bcl4 ^ (bcl1 << 1 | bch1 >>> 31);
        B.JSArray_methods.$indexSet(sh, 0, (t1 ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 5, (sh[5] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 10, (sh[10] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 15, (sh[15] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 20, (sh[20] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sl, 0, (sl[0] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 5, (sl[5] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 10, (sl[10] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 15, (sl[15] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 20, (sl[20] ^ tl) >>> 0);
        th = bch0 ^ (bch2 << 1 | bcl2 >>> 31);
        tl = bcl0 ^ (bcl2 << 1 | bch2 >>> 31);
        B.JSArray_methods.$indexSet(sh, 1, (sh[1] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 6, (sh[6] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 11, (sh[11] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 16, (sh[16] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 21, (sh[21] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sl, 1, (sl[1] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 6, (sl[6] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 11, (sl[11] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 16, (sl[16] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 21, (sl[21] ^ tl) >>> 0);
        th = bch1 ^ (bch3 << 1 | bcl3 >>> 31);
        tl = bcl1 ^ (bcl3 << 1 | bch3 >>> 31);
        B.JSArray_methods.$indexSet(sh, 2, (sh[2] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 7, (sh[7] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 12, (sh[12] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 17, (sh[17] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 22, (sh[22] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sl, 2, (sl[2] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 7, (sl[7] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 12, (sl[12] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 17, (sl[17] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 22, (sl[22] ^ tl) >>> 0);
        th = bch2 ^ (bch4 << 1 | bcl4 >>> 31);
        tl = bcl2 ^ (bcl4 << 1 | bch4 >>> 31);
        B.JSArray_methods.$indexSet(sh, 3, (sh[3] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sl, 3, (sl[3] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sh, 8, (sh[8] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sl, 8, (sl[8] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sh, 13, (sh[13] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sl, 13, (sl[13] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sh, 18, (sh[18] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sl, 18, (sl[18] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sh, 23, (sh[23] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sl, 23, (sl[23] ^ tl) >>> 0);
        th = bch3 ^ (bch0 << 1 | bcl0 >>> 31);
        tl = bcl3 ^ (bcl0 << 1 | bch0 >>> 31);
        B.JSArray_methods.$indexSet(sh, 4, (sh[4] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 9, (sh[9] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 14, (sh[14] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 19, (sh[19] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sh, 24, (sh[24] ^ th) >>> 0);
        B.JSArray_methods.$indexSet(sl, 4, (sl[4] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 9, (sl[9] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 14, (sl[14] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 19, (sl[19] ^ tl) >>> 0);
        B.JSArray_methods.$indexSet(sl, 24, (sl[24] ^ tl) >>> 0);
        th = sh[1];
        tl = sl[1];
        bch0 = sh[10];
        bcl0 = sl[10];
        B.JSArray_methods.$indexSet(sh, 10, (th << 1 | tl >>> 31) >>> 0);
        B.JSArray_methods.$indexSet(sl, 10, (tl << 1 | th >>> 31) >>> 0);
        bch00 = sh[7];
        bcl00 = sl[7];
        B.JSArray_methods.$indexSet(sh, 7, (bch0 << 3 | bcl0 >>> 29) >>> 0);
        B.JSArray_methods.$indexSet(sl, 7, (bcl0 << 3 | bch0 >>> 29) >>> 0);
        bch0 = sh[11];
        bcl0 = sl[11];
        B.JSArray_methods.$indexSet(sh, 11, (bch00 << 6 | bcl00 >>> 26) >>> 0);
        B.JSArray_methods.$indexSet(sl, 11, (bcl00 << 6 | bch00 >>> 26) >>> 0);
        bch00 = sh[17];
        bcl00 = sl[17];
        B.JSArray_methods.$indexSet(sh, 17, (bch0 << 10 | bcl0 >>> 22) >>> 0);
        B.JSArray_methods.$indexSet(sl, 17, (bcl0 << 10 | bch0 >>> 22) >>> 0);
        bch0 = sh[18];
        bcl0 = sl[18];
        B.JSArray_methods.$indexSet(sh, 18, (bch00 << 15 | bcl00 >>> 17) >>> 0);
        B.JSArray_methods.$indexSet(sl, 18, (bcl00 << 15 | bch00 >>> 17) >>> 0);
        bch00 = sh[3];
        bcl00 = sl[3];
        B.JSArray_methods.$indexSet(sh, 3, (bch0 << 21 | bcl0 >>> 11) >>> 0);
        B.JSArray_methods.$indexSet(sl, 3, (bcl0 << 21 | bch0 >>> 11) >>> 0);
        bch0 = sh[5];
        bcl0 = sl[5];
        B.JSArray_methods.$indexSet(sh, 5, (bch00 << 28 | bcl00 >>> 4) >>> 0);
        B.JSArray_methods.$indexSet(sl, 5, (bcl00 << 28 | bch00 >>> 4) >>> 0);
        bch00 = sh[16];
        bcl00 = sl[16];
        B.JSArray_methods.$indexSet(sh, 16, (bcl0 << 4 | bch0 >>> 28) >>> 0);
        B.JSArray_methods.$indexSet(sl, 16, (bch0 << 4 | bcl0 >>> 28) >>> 0);
        bch0 = sh[8];
        bcl0 = sl[8];
        B.JSArray_methods.$indexSet(sh, 8, (bcl00 << 13 | bch00 >>> 19) >>> 0);
        B.JSArray_methods.$indexSet(sl, 8, (bch00 << 13 | bcl00 >>> 19) >>> 0);
        bch00 = sh[21];
        bcl00 = sl[21];
        B.JSArray_methods.$indexSet(sh, 21, (bcl0 << 23 | bch0 >>> 9) >>> 0);
        B.JSArray_methods.$indexSet(sl, 21, (bch0 << 23 | bcl0 >>> 9) >>> 0);
        bch0 = sh[24];
        bcl0 = sl[24];
        B.JSArray_methods.$indexSet(sh, 24, (bch00 << 2 | bcl00 >>> 30) >>> 0);
        B.JSArray_methods.$indexSet(sl, 24, (bcl00 << 2 | bch00 >>> 30) >>> 0);
        bch00 = sh[4];
        bcl00 = sl[4];
        B.JSArray_methods.$indexSet(sh, 4, (bch0 << 14 | bcl0 >>> 18) >>> 0);
        B.JSArray_methods.$indexSet(sl, 4, (bcl0 << 14 | bch0 >>> 18) >>> 0);
        bch0 = sh[15];
        bcl0 = sl[15];
        B.JSArray_methods.$indexSet(sh, 15, (bch00 << 27 | bcl00 >>> 5) >>> 0);
        B.JSArray_methods.$indexSet(sl, 15, (bcl00 << 27 | bch00 >>> 5) >>> 0);
        bch00 = sh[23];
        bcl00 = sl[23];
        B.JSArray_methods.$indexSet(sh, 23, (bcl0 << 9 | bch0 >>> 23) >>> 0);
        B.JSArray_methods.$indexSet(sl, 23, (bch0 << 9 | bcl0 >>> 23) >>> 0);
        bch0 = sh[19];
        bcl0 = sl[19];
        B.JSArray_methods.$indexSet(sh, 19, (bcl00 << 24 | bch00 >>> 8) >>> 0);
        B.JSArray_methods.$indexSet(sl, 19, (bch00 << 24 | bcl00 >>> 8) >>> 0);
        bch00 = sh[13];
        bcl00 = sl[13];
        B.JSArray_methods.$indexSet(sh, 13, (bch0 << 8 | bcl0 >>> 24) >>> 0);
        B.JSArray_methods.$indexSet(sl, 13, (bcl0 << 8 | bch0 >>> 24) >>> 0);
        bch0 = sh[12];
        bcl0 = sl[12];
        B.JSArray_methods.$indexSet(sh, 12, (bch00 << 25 | bcl00 >>> 7) >>> 0);
        B.JSArray_methods.$indexSet(sl, 12, (bcl00 << 25 | bch00 >>> 7) >>> 0);
        bch00 = sh[2];
        bcl00 = sl[2];
        B.JSArray_methods.$indexSet(sh, 2, (bcl0 << 11 | bch0 >>> 21) >>> 0);
        B.JSArray_methods.$indexSet(sl, 2, (bch0 << 11 | bcl0 >>> 21) >>> 0);
        bch0 = sh[20];
        bcl0 = sl[20];
        B.JSArray_methods.$indexSet(sh, 20, (bcl00 << 30 | bch00 >>> 2) >>> 0);
        B.JSArray_methods.$indexSet(sl, 20, (bch00 << 30 | bcl00 >>> 2) >>> 0);
        bch00 = sh[14];
        bcl00 = sl[14];
        B.JSArray_methods.$indexSet(sh, 14, (bch0 << 18 | bcl0 >>> 14) >>> 0);
        B.JSArray_methods.$indexSet(sl, 14, (bcl0 << 18 | bch0 >>> 14) >>> 0);
        bch0 = sh[22];
        bcl0 = sl[22];
        B.JSArray_methods.$indexSet(sh, 22, (bcl00 << 7 | bch00 >>> 25) >>> 0);
        B.JSArray_methods.$indexSet(sl, 22, (bch00 << 7 | bcl00 >>> 25) >>> 0);
        bch00 = sh[9];
        bcl00 = sl[9];
        B.JSArray_methods.$indexSet(sh, 9, (bcl0 << 29 | bch0 >>> 3) >>> 0);
        B.JSArray_methods.$indexSet(sl, 9, (bch0 << 29 | bcl0 >>> 3) >>> 0);
        bch0 = sh[6];
        bcl0 = sl[6];
        B.JSArray_methods.$indexSet(sh, 6, (bch00 << 20 | bcl00 >>> 12) >>> 0);
        B.JSArray_methods.$indexSet(sl, 6, (bcl00 << 20 | bch00 >>> 12) >>> 0);
        B.JSArray_methods.$indexSet(sh, 1, (bcl0 << 12 | bch0 >>> 20) >>> 0);
        B.JSArray_methods.$indexSet(sl, 1, (bch0 << 12 | bcl0 >>> 20) >>> 0);
        bch0 = sh[0];
        bch1 = sh[1];
        bch2 = sh[2];
        bch3 = sh[3];
        bch4 = sh[4];
        B.JSArray_methods.$indexSet(sh, 0, (bch0 ^ ~bch1 & bch2) >>> 0);
        B.JSArray_methods.$indexSet(sh, 1, (sh[1] ^ ~bch2 & bch3) >>> 0);
        B.JSArray_methods.$indexSet(sh, 2, (sh[2] ^ ~bch3 & bch4) >>> 0);
        B.JSArray_methods.$indexSet(sh, 3, (sh[3] ^ ~bch4 & bch0) >>> 0);
        B.JSArray_methods.$indexSet(sh, 4, (sh[4] ^ ~bch0 & bch1) >>> 0);
        bcl0 = sl[0];
        bcl1 = sl[1];
        bcl2 = sl[2];
        bcl3 = sl[3];
        bcl4 = sl[4];
        B.JSArray_methods.$indexSet(sl, 0, (bcl0 ^ ~bcl1 & bcl2) >>> 0);
        B.JSArray_methods.$indexSet(sl, 1, (sl[1] ^ ~bcl2 & bcl3) >>> 0);
        B.JSArray_methods.$indexSet(sl, 2, (sl[2] ^ ~bcl3 & bcl4) >>> 0);
        B.JSArray_methods.$indexSet(sl, 3, (sl[3] ^ ~bcl4 & bcl0) >>> 0);
        B.JSArray_methods.$indexSet(sl, 4, (sl[4] ^ ~bcl0 & bcl1) >>> 0);
        bch0 = sh[5];
        bch1 = sh[6];
        bch2 = sh[7];
        bch3 = sh[8];
        bch4 = sh[9];
        B.JSArray_methods.$indexSet(sh, 5, (bch0 ^ ~bch1 & bch2) >>> 0);
        B.JSArray_methods.$indexSet(sh, 6, (sh[6] ^ ~bch2 & bch3) >>> 0);
        B.JSArray_methods.$indexSet(sh, 7, (sh[7] ^ ~bch3 & bch4) >>> 0);
        B.JSArray_methods.$indexSet(sh, 8, (sh[8] ^ ~bch4 & bch0) >>> 0);
        B.JSArray_methods.$indexSet(sh, 9, (sh[9] ^ ~bch0 & bch1) >>> 0);
        bcl0 = sl[5];
        bcl1 = sl[6];
        bcl2 = sl[7];
        bcl3 = sl[8];
        bcl4 = sl[9];
        B.JSArray_methods.$indexSet(sl, 5, (bcl0 ^ ~bcl1 & bcl2) >>> 0);
        B.JSArray_methods.$indexSet(sl, 6, (sl[6] ^ ~bcl2 & bcl3) >>> 0);
        B.JSArray_methods.$indexSet(sl, 7, (sl[7] ^ ~bcl3 & bcl4) >>> 0);
        B.JSArray_methods.$indexSet(sl, 8, (sl[8] ^ ~bcl4 & bcl0) >>> 0);
        B.JSArray_methods.$indexSet(sl, 9, (sl[9] ^ ~bcl0 & bcl1) >>> 0);
        bch0 = sh[10];
        bch1 = sh[11];
        bch2 = sh[12];
        bch3 = sh[13];
        bch4 = sh[14];
        B.JSArray_methods.$indexSet(sh, 10, (bch0 ^ ~bch1 & bch2) >>> 0);
        B.JSArray_methods.$indexSet(sh, 11, (sh[11] ^ ~bch2 & bch3) >>> 0);
        B.JSArray_methods.$indexSet(sh, 12, (sh[12] ^ ~bch3 & bch4) >>> 0);
        B.JSArray_methods.$indexSet(sh, 13, (sh[13] ^ ~bch4 & bch0) >>> 0);
        B.JSArray_methods.$indexSet(sh, 14, (sh[14] ^ ~bch0 & bch1) >>> 0);
        bcl0 = sl[10];
        bcl1 = sl[11];
        bcl2 = sl[12];
        bcl3 = sl[13];
        bcl4 = sl[14];
        B.JSArray_methods.$indexSet(sl, 10, (bcl0 ^ ~bcl1 & bcl2) >>> 0);
        B.JSArray_methods.$indexSet(sl, 11, (sl[11] ^ ~bcl2 & bcl3) >>> 0);
        B.JSArray_methods.$indexSet(sl, 12, (sl[12] ^ ~bcl3 & bcl4) >>> 0);
        B.JSArray_methods.$indexSet(sl, 13, (sl[13] ^ ~bcl4 & bcl0) >>> 0);
        B.JSArray_methods.$indexSet(sl, 14, (sl[14] ^ ~bcl0 & bcl1) >>> 0);
        bch0 = sh[15];
        bch1 = sh[16];
        bch2 = sh[17];
        bch3 = sh[18];
        bch4 = sh[19];
        B.JSArray_methods.$indexSet(sh, 15, (bch0 ^ ~bch1 & bch2) >>> 0);
        B.JSArray_methods.$indexSet(sh, 16, (sh[16] ^ ~bch2 & bch3) >>> 0);
        B.JSArray_methods.$indexSet(sh, 17, (sh[17] ^ ~bch3 & bch4) >>> 0);
        B.JSArray_methods.$indexSet(sh, 18, (sh[18] ^ ~bch4 & bch0) >>> 0);
        B.JSArray_methods.$indexSet(sh, 19, (sh[19] ^ ~bch0 & bch1) >>> 0);
        bcl0 = sl[15];
        bcl1 = sl[16];
        bcl2 = sl[17];
        bcl3 = sl[18];
        bcl4 = sl[19];
        B.JSArray_methods.$indexSet(sl, 15, (bcl0 ^ ~bcl1 & bcl2) >>> 0);
        B.JSArray_methods.$indexSet(sl, 16, (sl[16] ^ ~bcl2 & bcl3) >>> 0);
        B.JSArray_methods.$indexSet(sl, 17, (sl[17] ^ ~bcl3 & bcl4) >>> 0);
        B.JSArray_methods.$indexSet(sl, 18, (sl[18] ^ ~bcl4 & bcl0) >>> 0);
        B.JSArray_methods.$indexSet(sl, 19, (sl[19] ^ ~bcl0 & bcl1) >>> 0);
        bch0 = sh[20];
        bch1 = sh[21];
        bch2 = sh[22];
        bch3 = sh[23];
        bch4 = sh[24];
        B.JSArray_methods.$indexSet(sh, 20, (bch0 ^ ~bch1 & bch2) >>> 0);
        B.JSArray_methods.$indexSet(sh, 21, (sh[21] ^ ~bch2 & bch3) >>> 0);
        B.JSArray_methods.$indexSet(sh, 22, (sh[22] ^ ~bch3 & bch4) >>> 0);
        B.JSArray_methods.$indexSet(sh, 23, (sh[23] ^ ~bch4 & bch0) >>> 0);
        B.JSArray_methods.$indexSet(sh, 24, (sh[24] ^ ~bch0 & bch1) >>> 0);
        bcl0 = sl[20];
        bcl1 = sl[21];
        bcl2 = sl[22];
        bcl3 = sl[23];
        bcl4 = sl[24];
        B.JSArray_methods.$indexSet(sl, 20, (bcl0 ^ ~bcl1 & bcl2) >>> 0);
        B.JSArray_methods.$indexSet(sl, 21, (sl[21] ^ ~bcl2 & bcl3) >>> 0);
        B.JSArray_methods.$indexSet(sl, 22, (sl[22] ^ ~bcl3 & bcl4) >>> 0);
        B.JSArray_methods.$indexSet(sl, 23, (sl[23] ^ ~bcl4 & bcl0) >>> 0);
        B.JSArray_methods.$indexSet(sl, 24, (sl[24] ^ ~bcl0 & bcl1) >>> 0);
        t1 = sh[0];
        t2 = $.$get$_hi();
        if (!(r < t2.length))
          return A.ioore(t2, r);
        t2 = t2[r];
        if (typeof t2 !== "number")
          return A.iae(t2);
        B.JSArray_methods.$indexSet(sh, 0, (t1 ^ t2) >>> 0);
        t2 = sl[0];
        t1 = $.$get$_lo();
        if (!(r < t1.length))
          return A.ioore(t1, r);
        t1 = t1[r];
        if (typeof t1 !== "number")
          return A.iae(t1);
        B.JSArray_methods.$indexSet(sl, 0, (t2 ^ t1) >>> 0);
      }
      for (i = 0; i < 25; ++i) {
        t1 = i * 8;
        A.writeUint32LE(sl[i], buf, t1);
        A.writeUint32LE(sh[i], buf, t1 + 4);
      }
    },
    RIPEMD160_hash(data) {
      var out,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        t3 = A.List_List$filled(16, 0, false, t1),
        h = new A.RIPEMD160(t2, t3),
        t4 = type$.List_int;
      h.set$___RIPEMD__state_F(t4._as(A.List_List$filled(5, 0, false, t1)));
      h.reset$0();
      t4._as(data);
      if (h._hash$_finished)
        A.throwExpression(B.MessageException_NiJ);
      h._lengthInBytes = h._lengthInBytes + data.length;
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(data, false));
      h._iterate$0();
      t4 = h.___RIPEMD__state_F;
      t4 === $ && A.throwLateFieldNI("_state");
      out = A.List_List$filled(t4.length * 4, 0, false, t1);
      h.finish$1(out);
      A.zero(t4);
      A.zero(t3);
      B.JSArray_methods.clear$0(t2);
      h.reset$0();
      return out;
    },
    _RidempUtils_T(i, bl, cl, dl) {
      if (i < 16)
        return (bl ^ cl ^ dl) >>> 0;
      if (i < 32)
        return ((bl & cl | ~bl & dl) >>> 0) + 1518500249 >>> 0;
      if (i < 48)
        return (((bl | ~cl) ^ dl) >>> 0) + 1859775393 >>> 0;
      if (i < 64)
        return ((bl & dl | cl & ~dl) >>> 0) + 2400959708 >>> 0;
      return ((bl ^ (cl | ~dl)) >>> 0) + 2840853838 >>> 0;
    },
    _RidempUtils_t64(i, br, cr, dr) {
      if (i < 16)
        return ((br & dr | cr & ~dr) >>> 0) + 1352829926 >>> 0;
      if (i < 32)
        return (((br | ~cr) ^ dr) >>> 0) + 1548603684 >>> 0;
      if (i < 48)
        return ((br & cr | ~br & dr) >>> 0) + 1836072691 >>> 0;
      return (br ^ cr ^ dr) >>> 0;
    },
    _RidempUtils_t80(i, br, cr, dr) {
      if (i < 16)
        return ((br ^ (cr | ~dr)) >>> 0) + 1352829926 >>> 0;
      if (i < 32)
        return ((br & dr | cr & ~dr) >>> 0) + 1548603684 >>> 0;
      if (i < 48)
        return (((br | ~cr) ^ dr) >>> 0) + 1836072691 >>> 0;
      if (i < 64)
        return ((br & cr | ~br & dr) >>> 0) + 2053994217 >>> 0;
      return (br ^ cr ^ dr) >>> 0;
    },
    _RidempUtils_readState(lengthInBytes) {
      var _3285377520 = 3285377520, _1985229328 = 1985229328, _4275878552 = 4275878552, _2309737967 = 2309737967,
        state = A.List_List$filled(B.JSInt_methods._tdivFast$1(lengthInBytes, 4), 0, false, type$.int);
      B.JSArray_methods.$indexSet(state, 0, 1732584193);
      B.JSArray_methods.$indexSet(state, 1, 4023233417);
      B.JSArray_methods.$indexSet(state, 2, 2562383102);
      B.JSArray_methods.$indexSet(state, 3, 271733878);
      switch (lengthInBytes) {
        case 20:
          B.JSArray_methods.$indexSet(state, 4, _3285377520);
          break;
        case 32:
          B.JSArray_methods.$indexSet(state, 4, _1985229328);
          B.JSArray_methods.$indexSet(state, 5, _4275878552);
          B.JSArray_methods.$indexSet(state, 6, _2309737967);
          B.JSArray_methods.$indexSet(state, 7, 19088743);
          break;
        case 40:
          B.JSArray_methods.$indexSet(state, 4, _3285377520);
          B.JSArray_methods.$indexSet(state, 5, _1985229328);
          B.JSArray_methods.$indexSet(state, 6, _4275878552);
          B.JSArray_methods.$indexSet(state, 7, _2309737967);
          B.JSArray_methods.$indexSet(state, 8, 19088743);
          B.JSArray_methods.$indexSet(state, 9, 1009589775);
          break;
      }
      return state;
    },
    SHA256_hash(data) {
      var out,
        t1 = type$.int,
        t2 = A.List_List$filled(8, 0, false, t1),
        t3 = A.List_List$filled(64, 0, false, t1),
        t4 = A.List_List$filled(128, 0, false, t1),
        h = new A.SHA256(t2, t3, t4, A.List_List$unmodifiable(B.List_0, t1));
      h.reset$0();
      h.update$1(data);
      out = A.List_List$filled(32, 0, false, t1);
      h.finish$1(out);
      A.zero(t4);
      A.zero(t3);
      h.reset$0();
      return out;
    },
    BLAKE2b: function BLAKE2b(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._hash$_state = t0;
      _._hash$_buffer = t1;
      _._bufferLength = 0;
      _._ctr = t2;
      _._flag = t3;
      _._hash$_finished = _._lastNode = false;
      _._vtmp = t4;
      _._mtmp = t5;
      _._paddedKey = null;
      _.__BLAKE2b_getDigestLength_F = _.__BLAKE2b__initialState_A = $;
    },
    _Keccack: function _Keccack() {
    },
    Keccack: function Keccack(t0, t1, t2, t3) {
      var _ = this;
      _.digestLength = t0;
      _._sh = t1;
      _._sl = t2;
      _._hash$_state = t3;
      _._pos = 0;
      _._hash$_finished = false;
      _.___Keccack_blockSize_F = $;
    },
    SHA3: function SHA3() {
    },
    SHA3256: function SHA3256(t0, t1, t2, t3) {
      var _ = this;
      _.getDigestLength = t0;
      _._sh = t1;
      _._sl = t2;
      _._hash$_state = t3;
      _._pos = 0;
      _._hash$_finished = false;
      _.___Keccack_blockSize_F = $;
    },
    SHAKE: function SHAKE() {
    },
    SHAKE256: function SHAKE256(t0, t1, t2) {
      var _ = this;
      _._sh = t0;
      _._sl = t1;
      _._hash$_state = t2;
      _._pos = 0;
      _._hash$_finished = false;
      _.___Keccack_blockSize_F = $;
    },
    RIPEMD160: function RIPEMD160(t0, t1) {
      var _ = this;
      _._hash$_buffer = t0;
      _._lengthInBytes = 0;
      _.___RIPEMD__state_F = $;
      _._currentChunk = t1;
      _._hash$_finished = false;
    },
    _RIPEMD: function _RIPEMD() {
    },
    SHA256: function SHA256(t0, t1, t2, t3) {
      var _ = this;
      _._hash$_state = t0;
      _._temp = t1;
      _._hash$_buffer = t2;
      _._bytesHashed = _._bufferLength = 0;
      _._hash$_finished = false;
      _._k = t3;
    },
    Poly1305: function Poly1305(t0, t1, t2, t3) {
      var _ = this;
      _._buffer = t0;
      _._r = t1;
      _._h = t2;
      _._pad = t3;
      _._fin = _._leftover = 0;
      _._finished = false;
    },
    FortunaPRNG__generateSeed(digestLen) {
      var i,
        rand = $.$get$Random__secureRandom(),
        seed = A.List_List$filled(digestLen, 0, false, type$.int);
      for (i = 0; i < digestLen; ++i)
        B.JSArray_methods.$indexSet(seed, i, rand.nextInt$1(256));
      return seed;
    },
    FortunaPRNG: function FortunaPRNG(t0, t1) {
      var _ = this;
      _.__FortunaPRNG__counter_FI = _.__FortunaPRNG__key_FI = $;
      _._zeroBlock = t0;
      _._out = t1;
      _._c = 0;
    },
    SchnorrkelPublicKey: function SchnorrkelPublicKey(t0) {
      this._keys$_publicKey = t0;
    },
    QuickCrypto__blake2bHash(data, digestSize, key, salt) {
      var t8, out,
        t1 = type$.int,
        t2 = A.List_List$from($.$get$_iv(), false, t1),
        t3 = A.List_List$filled(128, 0, false, t1),
        t4 = A.List_List$filled(4, 0, false, t1),
        t5 = A.List_List$filled(4, 0, false, t1),
        t6 = A.List_List$filled(32, 0, false, t1),
        t7 = A.List_List$filled(32, 0, false, t1),
        h = new A.BLAKE2b(t2, t3, t4, t5, t6, t7);
      if (digestSize < 1 || digestSize > 64)
        A.throwExpression(B.ArgumentException_cKo);
      h.__BLAKE2b_getDigestLength_F = digestSize;
      if (0 >= t2.length)
        return A.ioore(t2, 0);
      t8 = t2[0];
      if (typeof t8 !== "number")
        return t8.$xor();
      B.JSArray_methods.$indexSet(t2, 0, (t8 ^ (digestSize | 16842752)) >>> 0);
      h.set$__BLAKE2b__initialState_A(type$.List_int._as(A.List_List$from(t2, false, t1)));
      h.update$1(data);
      out = A.List_List$filled(digestSize, 0, false, t1);
      h.finish$1(out);
      A.zero(t6);
      A.zero(t7);
      A.zero(t2);
      A.zero(t3);
      t1 = h.__BLAKE2b__initialState_A;
      t1 === $ && A.throwLateFieldNI("_initialState");
      A.zero(t1);
      t1 = h._paddedKey;
      if (t1 != null)
        A.zero(t1);
      h._bufferLength = 0;
      A.zero(t4);
      A.zero(t5);
      h._hash$_finished = h._lastNode = false;
      return out;
    },
    QuickCrypto_blake2b224Hash(data) {
      return A.QuickCrypto__blake2bHash(data, 28, null, null);
    },
    QuickCrypto__generateRandom_closure: function QuickCrypto__generateRandom_closure() {
    },
    ArgumentException$(message) {
      return new A.ArgumentException(message);
    },
    MessageException$(message, details) {
      return new A.MessageException(message, details);
    },
    BlockchainUtilsException: function BlockchainUtilsException() {
    },
    ArgumentException: function ArgumentException(t0) {
      this.message = t0;
    },
    MessageException: function MessageException(t0, t1) {
      this.message = t0;
      this.details = t1;
    },
    _Hex: function _Hex() {
    },
    SS58ChecksumError: function SS58ChecksumError(t0) {
      this.message = t0;
    },
    DynamicByteTracker: function DynamicByteTracker(t0) {
      this._bytes_tracker$_buffer = t0;
    },
    BytesUtils_toHexString(dataBytes, lowerCase, prefix) {
      var toHex = B.C__Hex.encode$2$lowerCase(dataBytes, true);
      return (prefix == null ? "" : prefix) + toHex;
    },
    BytesUtils_tryToHexString(dataBytes) {
      var t1, exception,
        lowerCase = true,
        prefix = null;
      if (dataBytes == null)
        return null;
      try {
        t1 = A.BytesUtils_toHexString(dataBytes, lowerCase, prefix);
        return t1;
      } catch (exception) {
        return null;
      }
    },
    BytesUtils_fromHexString(data) {
      var hexString, t1, exception,
        paddingZero = false;
      try {
        hexString = A.StringUtils_strip0x(data);
        if (J.get$length$asx(hexString) === 0) {
          t1 = A._setArrayType([], type$.JSArray_int);
          return t1;
        }
        if (A.boolConversionCheck(paddingZero) && (J.get$length$asx(hexString) & 1) === 1)
          hexString = "0" + A.S(hexString);
        t1 = B.C__Hex.decode$1(hexString);
        return t1;
      } catch (exception) {
        throw A.wrapException(B.ArgumentException_Qs0);
      }
    },
    BytesUtils_tryFromHexString(data) {
      var t1, exception;
      if (data == null)
        return null;
      try {
        t1 = A.BytesUtils_fromHexString(data);
        return t1;
      } catch (exception) {
        return null;
      }
    },
    BytesUtils_toBytes(bytes, unmodifiable) {
      var t1 = type$.int,
        t2 = J.map$1$1$ax(bytes, new A.BytesUtils_toBytes_closure(), t1),
        toBytes = A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      if (unmodifiable)
        return A.List_List$unmodifiable(toBytes, t1);
      return toBytes;
    },
    BytesUtils_tryToBytes(bytes, unmodifiable) {
      if (bytes == null)
        return null;
      return A.BytesUtils_toBytes(bytes, true);
    },
    BytesUtils_validateBytes(bytes, onError) {
      var t1, i, byte;
      for (t1 = J.getInterceptor$asx(bytes), i = 0; i < t1.get$length(bytes); ++i) {
        byte = t1.$index(bytes, i);
        if (byte < 0 || byte > 255)
          throw A.wrapException(A.ArgumentException$((onError == null ? "Invalid bytes" : onError) + " at index " + i + " " + A.S(byte)));
      }
    },
    BytesUtils_compareBytes(a, b) {
      var i, t2, t3,
        $length = a.length,
        length0 = b.length,
        t1 = $length < length0,
        length1 = t1 ? $length : length0;
      for (i = 0; i < length1; ++i) {
        if (!(i < $length))
          return A.ioore(a, i);
        t2 = a[i];
        if (!(i < length0))
          return A.ioore(b, i);
        t3 = b[i];
        if (typeof t2 !== "number")
          return t2.$lt();
        if (typeof t3 !== "number")
          return A.iae(t3);
        if (t2 < t3)
          return -1;
        else if (t2 > t3)
          return 1;
      }
      if (t1)
        return -1;
      else if ($length > length0)
        return 1;
      return 0;
    },
    BytesUtils_bytesEqual(a, b) {
      var t1, t2, t3, t4, index;
      if (a == null)
        return false;
      t1 = J.getInterceptor$asx(a);
      t2 = t1.get$length(a);
      t3 = J.getInterceptor$asx(b);
      t4 = t3.get$length(b);
      if (t2 !== t4)
        return false;
      if (a === b)
        return true;
      for (index = 0; index < t1.get$length(a); ++index)
        if (!J.$eq$(t1.$index(a, index), t3.$index(b, index)))
          return false;
      return true;
    },
    BytesUtils_toBytes_closure: function BytesUtils_toBytes_closure() {
    },
    BigRational_BigRational(numerator, denominator) {
      var t1, t2;
      if (denominator == null)
        return new A.BigRational(numerator, $.$get$BigRational__one());
      t1 = $.$get$BigRational__zero();
      t2 = denominator.compareTo$1(0, t1);
      if (t2 === 0)
        throw A.wrapException(B.ArgumentException_VXU);
      t2 = numerator.compareTo$1(0, t1);
      if (t2 === 0)
        return new A.BigRational(t1, $.$get$BigRational__one());
      return A.BigRational__reduce(numerator, denominator);
    },
    BigRational__gcd(a, b) {
      var t1, b0;
      while (true) {
        t1 = b.compareTo$1(0, $.$get$BigRational__zero());
        if (!(t1 !== 0))
          break;
        b0 = a.$mod(0, b);
        a = b;
        b = b0;
      }
      return a;
    },
    BigRational_tryParseDecimaal(decimal) {
      var t1, exception;
      try {
        t1 = A.BigRational_BigRational$parseDecimal(decimal);
        return t1;
      } catch (exception) {
        return null;
      }
    },
    BigRational_BigRational$parseDecimal(decimal) {
      var significand, t2, exponent, isNegative, intPart, $length, decPart, multiple, a, b, _null = null,
        parts = B.JSString_methods.split$1(decimal, A.RegExp_RegExp("e", false)),
        t1 = parts.length;
      if (t1 > 2)
        throw A.wrapException(B.ArgumentException_e2q);
      if (t1 > 1) {
        t1 = J.$index$asx(parts[1], 0) === "-";
        if (t1) {
          if (1 >= parts.length)
            return A.ioore(parts, 1);
          B.JSArray_methods.$indexSet(parts, 1, J.substring$1$s(parts[1], 1));
        }
        if (1 >= parts.length)
          return A.ioore(parts, 1);
        if (J.$index$asx(parts[1], 0) === "+") {
          if (1 >= parts.length)
            return A.ioore(parts, 1);
          B.JSArray_methods.$indexSet(parts, 1, J.substring$1$s(parts[1], 1));
        }
        if (0 >= parts.length)
          return A.ioore(parts, 0);
        significand = A.BigRational_BigRational$parseDecimal(parts[0]);
        t2 = $.$get$BigRational__ten();
        if (1 >= parts.length)
          return A.ioore(parts, 1);
        exponent = new A.BigRational(t2.pow$1(A.int_parse(parts[1], _null)), $.$get$BigRational__one());
        if (!t1)
          return significand.$mul(0, exponent);
        else
          return significand.$div(0, exponent);
      }
      parts = A._setArrayType(B.JSString_methods.trim$0(decimal).split("."), type$.JSArray_String);
      t1 = parts.length;
      if (t1 > 2)
        throw A.wrapException(B.ArgumentException_e2q0);
      if (t1 > 1) {
        t1 = parts[0];
        isNegative = J.$index$asx(t1, 0) === "-";
        if (isNegative)
          B.JSArray_methods.$indexSet(parts, 0, J.substring$1$s(t1, 1));
        if (0 >= parts.length)
          return A.ioore(parts, 0);
        intPart = new A.BigRational(A._BigIntImpl_parse(parts[0], _null), $.$get$BigRational__one());
        if (1 >= parts.length)
          return A.ioore(parts, 1);
        $length = J.get$length$asx(parts[1]);
        while (true) {
          if (1 >= parts.length)
            return A.ioore(parts, 1);
          if (J.get$length$asx(parts[1]) !== 0) {
            if (1 >= parts.length)
              return A.ioore(parts, 1);
            t1 = J.$index$asx(parts[1], 0) === "0";
          } else
            t1 = false;
          if (!t1)
            break;
          if (1 >= parts.length)
            return A.ioore(parts, 1);
          B.JSArray_methods.$indexSet(parts, 1, J.substring$1$s(parts[1], 1));
        }
        t1 = B.JSString_methods.$mul("0", $length);
        if (1 >= parts.length)
          return A.ioore(parts, 1);
        if (J.get$length$asx(parts[1]) === 0)
          t2 = $.$get$BigRational__zero();
        else {
          if (1 >= parts.length)
            return A.ioore(parts, 1);
          t2 = A._BigIntImpl_parse(parts[1], _null);
        }
        decPart = A.BigRational__reduce(t2, A._BigIntImpl_parse("1" + t1, _null));
        t1 = intPart.denominator;
        t2 = decPart.denominator;
        multiple = t1.$mul(0, t2).$tdiv(0, A.BigRational__gcd(t1, t2));
        a = multiple.$tdiv(0, t1);
        b = multiple.$tdiv(0, t2);
        intPart = A.BigRational__reduce(intPart.numerator.$mul(0, a).$add(0, decPart.numerator.$mul(0, b)), multiple);
        return isNegative ? intPart.$not(0) : intPart;
      }
      return new A.BigRational(A._BigIntImpl_parse(decimal, _null), $.$get$BigRational__one());
    },
    BigRational__reduce(n, d) {
      var divisor = A.BigRational__gcd(n, d),
        num = n.$tdiv(0, divisor),
        denom = d.$tdiv(0, divisor);
      if (denom._isNegative)
        return new A.BigRational(num.$negate(0), denom.$negate(0));
      return new A.BigRational(num, denom);
    },
    BigRational: function BigRational(t0, t1) {
      this.numerator = t0;
      this.denominator = t1;
      this._inDecimal = null;
    },
    StringUtils_toBytes(v) {
      var t1 = $.$get$StringUtils__hexBytesRegex();
      if (t1._nativeRegExp.test(v))
        return A.BytesUtils_fromHexString(v);
      else
        return A.StringUtils_encode(v, B.StringEncoding_1);
    },
    StringUtils_strip0x(value) {
      if (B.JSString_methods.startsWith$1(value.toLowerCase(), "0x"))
        return B.JSString_methods.substring$1(value, 2);
      return value;
    },
    StringUtils_encode(value, type) {
      switch (type) {
        case B.StringEncoding_1:
          return B.C_Utf8Encoder.convert$1(value);
        case B.StringEncoding_2:
        case B.StringEncoding_3:
          return B.C_Base64Decoder.convert$1(value);
        default:
          return B.AsciiEncoder_127.convert$1(value);
      }
    },
    StringUtils_decode(value, allowInvalidOrMalformed, type) {
      switch (type) {
        case B.StringEncoding_1:
          return B.C_Utf8Codec.decode$2$allowMalformed(value, false);
        case B.StringEncoding_2:
          type$.Base64Codec._eval$1("Codec.S")._as(value);
          return B.Base64Codec_Base64Encoder_false.get$encoder().convert$1(value);
        case B.StringEncoding_3:
          type$.Base64Codec._eval$1("Codec.S")._as(value);
          return B.Base64Codec_Base64Encoder_true.get$encoder().convert$1(value);
        default:
          return B.C_AsciiCodec.decode$2$allowInvalid(value, false);
      }
    },
    StringUtils_tryDecode(value) {
      var t1, exception,
        allowInvalidOrMalformed = false,
        type = B.StringEncoding_1;
      try {
        t1 = A.StringUtils_decode(value, allowInvalidOrMalformed, type);
        return t1;
      } catch (exception) {
        return null;
      }
    },
    StringUtils_toJson(data, $T) {
      var decode = B.C_JsonCodec.decode$2$reviver(data, null);
      if (!$T._is(decode))
        throw A.wrapException(A.ArgumentException$("Invalid json casting. excepted: " + A.createRuntimeType($T).toString$0(0) + " got: " + J.get$runtimeType$(decode).toString$0(0)));
      return $T._as(B.C_JsonCodec.decode$2$reviver(data, null));
    },
    StringUtils_tryToJson(data, $T) {
      var t1, exception;
      try {
        t1 = A.StringUtils_toJson(data, $T._eval$1("0?"));
        return t1;
      } catch (exception) {
        return null;
      }
    },
    StringEncoding: function StringEncoding(t0) {
      this._core$_name = t0;
    },
    Tuple: function Tuple(t0, t1, t2) {
      this.item1 = t0;
      this.item2 = t1;
      this.$ti = t2;
    },
    UUID_generateUUIDv4() {
      var t1, t2, hexBytes,
        bytes = A.List_List$generate(16, new A.UUID_generateUUIDv4_closure($.$get$Random__secureRandom()), type$.int);
      B.JSArray_methods.$indexSet(bytes, 6, bytes[6] & 15 | 64);
      B.JSArray_methods.$indexSet(bytes, 8, bytes[8] & 63 | 128);
      t1 = A._arrayInstanceType(bytes);
      t2 = t1._eval$1("MappedListIterable<1,String>");
      hexBytes = A.List_List$of(new A.MappedListIterable(bytes, t1._eval$1("String(1)")._as(new A.UUID_generateUUIDv4_closure0()), t2), true, t2._eval$1("ListIterable.E"));
      return B.JSArray_methods.join$1(B.JSArray_methods.sublist$2(hexBytes, 0, 4), "") + "-" + B.JSArray_methods.join$1(B.JSArray_methods.sublist$2(hexBytes, 4, 6), "") + "-" + B.JSArray_methods.join$1(B.JSArray_methods.sublist$2(hexBytes, 6, 8), "") + "-" + B.JSArray_methods.join$1(B.JSArray_methods.sublist$2(hexBytes, 8, 10), "") + "-" + B.JSArray_methods.join$1(B.JSArray_methods.sublist$1(hexBytes, 10), "");
    },
    UUID_generateUUIDv4_closure: function UUID_generateUUIDv4_closure(t0) {
      this.random = t0;
    },
    UUID_generateUUIDv4_closure0: function UUID_generateUUIDv4_closure0() {
    },
    CanonicalizedMap: function CanonicalizedMap() {
    },
    CanonicalizedMap_addAll_closure: function CanonicalizedMap_addAll_closure(t0) {
      this.$this = t0;
    },
    CanonicalizedMap_entries_closure: function CanonicalizedMap_entries_closure(t0) {
      this.$this = t0;
    },
    CanonicalizedMap_forEach_closure: function CanonicalizedMap_forEach_closure(t0, t1) {
      this.$this = t0;
      this.f = t1;
    },
    CanonicalizedMap_keys_closure: function CanonicalizedMap_keys_closure(t0) {
      this.$this = t0;
    },
    CosmosBaseAddress: function CosmosBaseAddress(t0) {
      this.address = t0;
    },
    BaseClient: function BaseClient() {
    },
    BaseRequest: function BaseRequest() {
    },
    BaseRequest_closure: function BaseRequest_closure() {
    },
    BaseRequest_closure0: function BaseRequest_closure0() {
    },
    BaseResponse: function BaseResponse() {
    },
    _extension_0_get_responseHeaders(_this) {
      var _i, header, t2, splitIdx, key, value,
        t1 = type$.String,
        headers = A.LinkedHashMap_LinkedHashMap$_empty(t1, t1),
        headersList = A._asString(_this.getAllResponseHeaders()).split("\r\n");
      for (t1 = headersList.length, _i = 0; _i < t1; ++_i) {
        header = headersList[_i];
        t2 = J.getInterceptor$asx(header);
        if (t2.get$length(header) === 0)
          continue;
        splitIdx = t2.indexOf$1(header, ": ");
        if (splitIdx === -1)
          continue;
        key = t2.substring$2(header, 0, splitIdx).toLowerCase();
        value = t2.substring$1(header, splitIdx + 2);
        if (headers.containsKey$1(key))
          headers.$indexSet(0, key, A.S(headers.$index(0, key)) + ", " + value);
        else
          headers.$indexSet(0, key, value);
      }
      return headers;
    },
    BrowserClient: function BrowserClient(t0) {
      this._xhrs = t0;
    },
    BrowserClient_send_closure: function BrowserClient_send_closure(t0, t1, t2) {
      this.xhr = t0;
      this.completer = t1;
      this.request = t2;
    },
    BrowserClient_send_closure0: function BrowserClient_send_closure0(t0, t1) {
      this.completer = t0;
      this.request = t1;
    },
    ByteStream: function ByteStream(t0) {
      this._stream = t0;
    },
    ByteStream_toBytes_closure: function ByteStream_toBytes_closure(t0) {
      this.completer = t0;
    },
    ClientException: function ClientException(t0, t1) {
      this.message = t0;
      this.uri = t1;
    },
    Request$(method, url) {
      var t1 = new Uint8Array(0),
        t2 = $.$get$BaseRequest__tokenRE();
      if (!t2._nativeRegExp.test(method))
        A.throwExpression(A.ArgumentError$value(method, "method", "Not a valid method"));
      t2 = type$.String;
      return new A.Request(B.C_Utf8Codec, t1, method, url, A.LinkedHashMap_LinkedHashMap(new A.BaseRequest_closure(), new A.BaseRequest_closure0(), t2, t2));
    },
    Request: function Request(t0, t1, t2, t3, t4) {
      var _ = this;
      _._defaultEncoding = t0;
      _._bodyBytes = t1;
      _.method = t2;
      _.url = t3;
      _.headers = t4;
      _._finalized = false;
    },
    Response_fromStream(response) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Response),
        $async$returnValue, body, t1, t2, t3, t4, t5, t6;
      var $async$Response_fromStream = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return A._asyncAwait(response.stream.toBytes$0(), $async$Response_fromStream);
            case 3:
              // returning from await.
              body = $async$result;
              t1 = response.statusCode;
              t2 = response.request;
              t3 = response.headers;
              t4 = response.reasonPhrase;
              t5 = A.toUint8List(body);
              t6 = body.length;
              t5 = new A.Response(t5, t2, t1, t4, t6, t3, false, true);
              t5.BaseResponse$7$contentLength$headers$isRedirect$persistentConnection$reasonPhrase$request(t1, t6, t3, false, true, t4, t2);
              $async$returnValue = t5;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$Response_fromStream, $async$completer);
    },
    _contentTypeForHeaders(headers) {
      var contentType = headers.$index(0, "content-type");
      if (contentType != null)
        return A.MediaType_MediaType$parse(contentType);
      return A.MediaType$("application", "octet-stream", null);
    },
    Response: function Response(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.bodyBytes = t0;
      _.request = t1;
      _.statusCode = t2;
      _.reasonPhrase = t3;
      _.contentLength = t4;
      _.headers = t5;
      _.isRedirect = t6;
      _.persistentConnection = t7;
    },
    StreamedResponse: function StreamedResponse() {
    },
    StreamedResponseV2: function StreamedResponseV2(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.stream = t0;
      _.request = t1;
      _.statusCode = t2;
      _.reasonPhrase = t3;
      _.contentLength = t4;
      _.headers = t5;
      _.isRedirect = t6;
      _.persistentConnection = t7;
    },
    CaseInsensitiveMap$from(other, $V) {
      var t1 = new A.CaseInsensitiveMap(new A.CaseInsensitiveMap$from_closure(), A.LinkedHashMap_LinkedHashMap$_empty(type$.String, $V._eval$1("MapEntry<String,0>")), $V._eval$1("CaseInsensitiveMap<0>"));
      t1.addAll$1(0, other);
      return t1;
    },
    CaseInsensitiveMap: function CaseInsensitiveMap(t0, t1, t2) {
      this._canonicalize = t0;
      this._base = t1;
      this.$ti = t2;
    },
    CaseInsensitiveMap$from_closure: function CaseInsensitiveMap$from_closure() {
    },
    MediaType_MediaType$parse(mediaType) {
      return A.wrapFormatException("media type", mediaType, new A.MediaType_MediaType$parse_closure(mediaType), type$.MediaType);
    },
    MediaType$(type, subtype, parameters) {
      var t1 = type$.String;
      t1 = parameters == null ? A.LinkedHashMap_LinkedHashMap$_empty(t1, t1) : A.CaseInsensitiveMap$from(parameters, t1);
      return new A.MediaType(type.toLowerCase(), subtype.toLowerCase(), new A.UnmodifiableMapView(t1, type$.UnmodifiableMapView_String_String));
    },
    MediaType: function MediaType(t0, t1, t2) {
      this.type = t0;
      this.subtype = t1;
      this.parameters = t2;
    },
    MediaType_MediaType$parse_closure: function MediaType_MediaType$parse_closure(t0) {
      this.mediaType = t0;
    },
    MediaType_toString_closure: function MediaType_toString_closure(t0) {
      this.buffer = t0;
    },
    MediaType_toString__closure: function MediaType_toString__closure() {
    },
    expectQuotedString(scanner) {
      var string;
      scanner.expect$2$name($.$get$_quotedString(), "quoted string");
      string = scanner.get$lastMatch().$index(0, 0);
      return A.stringReplaceAllFuncUnchecked(B.JSString_methods.substring$2(string, 1, string.length - 1), $.$get$_quotedPair(), type$.nullable_String_Function_Match._as(type$.String_Function_Match._as(new A.expectQuotedString_closure())), null);
    },
    expectQuotedString_closure: function expectQuotedString_closure() {
    },
    AppPlatform: function AppPlatform(t0) {
      this._core$_name = t0;
    },
    MrtPlatformInterface: function MrtPlatformInterface() {
    },
    JSWebSocket_constructor_create(url, protocols) {
      var t1 = A._arrayInstanceType(protocols),
        t2 = t1._eval$1("MappedListIterable<1,String>");
      return type$.JSObject._as(new self.WebSocket(url, A.List_List$of(new A.MappedListIterable(protocols, t1._eval$1("String(1)")._as(new A.JSWebSocket_constructor_create_closure()), t2), true, t2._eval$1("ListIterable.E"))));
    },
    JSWebSocket_constructor_create_closure: function JSWebSocket_constructor_create_closure() {
    },
    WebEventStream_stream(_this, type, $T) {
      var controller = A.StreamController_StreamController(false, $T),
        callback = type$.JavaScriptFunction._as(A.allowInterop(new A.WebEventStream_stream_closure(controller, $T), type$.Function));
      controller.set$onCancel(new A.WebEventStream_stream_closure0(_this, type, callback));
      _this.addEventListener(type, callback);
      return new A._ControllerStream(controller, A._instanceType(controller)._eval$1("_ControllerStream<1>"));
    },
    WebEventStream_stream_closure: function WebEventStream_stream_closure(t0, t1) {
      this.controller = t0;
      this.T = t1;
    },
    WebEventStream_stream_closure0: function WebEventStream_stream_closure0(t0, t1, t2) {
      this._this = t0;
      this.type = t1;
      this.callback = t2;
    },
    MrtNativeWeb: function MrtNativeWeb() {
    },
    ApiProviderException$(code, message, requestPayload, responseData, statusCode) {
      return new A.ApiProviderException(message, statusCode, responseData);
    },
    ApiProviderException: function ApiProviderException(t0, t1, t2) {
      this.message = t0;
      this.statusCode = t1;
      this.responseData = t2;
    },
    WalletException$invalidArgruments(_argruments) {
      return new A.WalletException("", _argruments);
    },
    WalletException$(message) {
      return new A.WalletException(message, null);
    },
    WalletExceptionConst_invalidArgruments(expected, got) {
      return new A.WalletException("", A._setArrayType([expected, got], type$.JSArray_String));
    },
    WalletException: function WalletException(t0, t1) {
      this.message = t0;
      this._argruments = t1;
    },
    Equatable: function Equatable() {
    },
    LiveListenable__addListener(listen) {
    },
    _Live: function _Live() {
    },
    Live: function Live(t0, t1, t2) {
      this._live$_value = t0;
      this._LiveListenable__noneIdsListeners = t1;
      this.$ti = t2;
    },
    _LiveListenable: function _LiveListenable() {
    },
    LiveListenable: function LiveListenable() {
    },
    _LiveListenable_Object__LiveListenable: function _LiveListenable_Object__LiveListenable() {
    },
    ContentType_fromValue(value) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_zvt, new A.ContentType_fromValue_closure(value), new A.ContentType_fromValue_closure0(null));
    },
    ContentType: function ContentType(t0, t1) {
      this.value = t0;
      this._core$_name = t1;
    },
    ContentType_fromValue_closure: function ContentType_fromValue_closure(t0) {
      this.value = t0;
    },
    ContentType_fromValue_closure0: function ContentType_fromValue_closure0(t0) {
      this.defaultValue = t0;
    },
    APPImage_APPImage$fromCborBytesOrObject(obj) {
      var cbor, exception, t1, bytes = null;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_50_1, type$.CborListValue_dynamic);
        A.ContentType_fromValue(A.ExtractCborList_elementAt(cbor, 0, type$.nullable_int));
        A.ExtractCborList_elementAt(cbor, 1, type$.String);
        return new A.APPImage();
      } catch (exception) {
        t1 = $.$get$WalletExceptionConst_dataVerificationFailed();
        throw A.wrapException(t1);
      }
    },
    APPImage: function APPImage() {
    },
    _APPImage_Object_CborSerializable: function _APPImage_Object_CborSerializable() {
    },
    CborSerializable_decodeCborTags(cborBytes, object, tags, $T) {
      var cbor;
      if (object == null) {
        cborBytes.toString;
        cbor = A.CborUtils__decode(cborBytes).item1;
      } else
        cbor = object;
      return A.CborSerializable_validateCbor(cbor, tags, $T);
    },
    CborSerializable_cborTagValue(cborBytes, hex, object, tags, $T) {
      if (object == null) {
        if (cborBytes == null)
          cborBytes = A.BytesUtils_tryFromHexString(hex);
        if (cborBytes == null)
          throw A.wrapException(A.WalletException$(string$.decodi));
        object = A.CborUtils__decode(cborBytes).item1;
      }
      return A.CborSerializable_validateCbor(object, tags, $T);
    },
    CborSerializable_validateCbor(cbor, tags, $T) {
      var t1;
      if (!(cbor instanceof A.CborTagValue) || !$T._is(cbor.value))
        throw A.wrapException($.$get$WalletExceptionConst_invalidSerializationData());
      t1 = A.BytesUtils_bytesEqual(cbor.tags, tags);
      if (!t1)
        throw A.wrapException($.$get$WalletExceptionConst_invalidSerializationData());
      return $T._as(cbor.value);
    },
    CborSerializable_decode(cborBytes, hex, object, $T) {
      var t1, exception;
      cborBytes = cborBytes;
      object = object;
      try {
        if (object == null) {
          if (cborBytes == null)
            cborBytes = A.BytesUtils_tryFromHexString(hex);
          if (cborBytes == null) {
            t1 = A.WalletException$(string$.decodi);
            throw A.wrapException(t1);
          }
          object = A.CborUtils__decode(cborBytes).item1;
        }
        if (!$T._is(object)) {
          t1 = A.WalletException$invalidArgruments(A._setArrayType([A.createRuntimeType($T).toString$0(0) + A.getRuntimeTypeOfDartObject(object).toString$0(0)], type$.JSArray_String));
          throw A.wrapException(t1);
        }
        t1 = object;
        return t1;
      } catch (exception) {
        t1 = $.$get$WalletExceptionConst_dataVerificationFailed();
        throw A.wrapException(t1);
      }
    },
    ExtractCborMap_toMap(_this, $K, $V) {
      var cborMap, entrries, e, t1, exception;
      try {
        t1 = type$.CborObject;
        cborMap = _this.value.cast$2$0(0, t1, t1);
        entrries = cborMap.get$entries().map$1$1(0, new A.ExtractCborMap_toMap_closure($K, $V), $K._eval$1("@<0>")._bind$1($V)._eval$1("MapEntry<1,2>"));
        t1 = A.Map_Map$fromEntries(entrries, $K, $V);
        return t1;
      } catch (exception) {
        e = A.unwrapException(exception);
        A.print("error " + A.S(e));
        throw exception;
      }
    },
    ExtractCborList_elementAt(_this, index, $T) {
      var cborValue, v,
        t1 = _this.value;
      if (index > t1.length - 1) {
        $T._as(null);
        return null;
      }
      cborValue = t1[index];
      if (A.createRuntimeType($T) === B.Type_CborMapValue_ezS) {
        if (cborValue instanceof A.CborMapValue)
          return $T._as(cborValue);
        $T._as(null);
        return null;
      }
      v = type$.CborObject._is(cborValue) ? cborValue.get$value() : cborValue;
      if (!$T._is(v)) {
        $T._as(null);
        return null;
      }
      return v;
    },
    ExtractCborList_cast(_this, $T) {
      var t2, i,
        t1 = A._setArrayType([], $T._eval$1("JSArray<0>"));
      for (t2 = _this.value, i = 0; i < t2.length; ++i)
        t1.push(A.ExtractCborList_elementAt(_this, i, $T));
      return t1;
    },
    ExtractCborList_getCborTag(_this, index) {
      var cborValue,
        t1 = _this.value;
      if (index > t1.length - 1)
        return null;
      cborValue = t1[index];
      if (!type$.CborObject._is(cborValue))
        return null;
      if (cborValue instanceof A.CborTagValue)
        return cborValue;
      if (cborValue.get$value() instanceof A.CborTagValue)
        return type$.nullable_CborTagValue_dynamic._as(cborValue.get$value());
      return null;
    },
    ExtractCborList_getInt(_this, index) {
      var cborValue, v,
        t1 = _this.value;
      if (index > t1.length - 1)
        return null;
      cborValue = t1[index];
      if (cborValue instanceof A.CborIntValue)
        v = cborValue.value;
      else
        v = A._isInt(cborValue) ? cborValue : null;
      return v;
    },
    ExtractCborList_getString(_this, index) {
      var cborValue, v,
        t1 = _this.value;
      if (index > t1.length - 1)
        return null;
      cborValue = t1[index];
      if (cborValue instanceof A.CborStringValue)
        v = cborValue.value;
      else
        v = typeof cborValue == "string" ? cborValue : null;
      return v;
    },
    ExtractCborList_getElement(_this, index, $T) {
      var obj,
        t1 = _this.value;
      if (index >= t1.length) {
        if ($T._is(null)) {
          $T._as(null);
          return null;
        }
        throw A.wrapException($.$get$WalletExceptionConst_invalidSerializationData());
      }
      obj = type$.CborObject._as(t1[index]);
      if ($T._is(null) && obj.$eq(0, B.C_CborNullValue)) {
        $T._as(null);
        return null;
      }
      if ($T._is(obj))
        return $T._as(obj);
      if (!$T._is(obj.get$value()))
        throw A.wrapException($.$get$WalletExceptionConst_invalidSerializationData());
      return $T._as(obj.get$value());
    },
    QuickCbor_to(_this, toe, $E, $T) {
      if ($T._is(_this))
        return toe.call$1($T._as(_this));
      if (!$T._is(_this.get$value()))
        throw A.wrapException($.$get$WalletExceptionConst_invalidSerializationData());
      return toe.call$1($T._as(_this.get$value()));
    },
    QuickCborTag_get_getList(_this) {
      var t1 = _this.value;
      if (!(t1 instanceof A.CborListValue))
        throw A.wrapException($.$get$WalletExceptionConst_invalidSerializationData());
      return t1;
    },
    CborSerializable: function CborSerializable() {
    },
    ExtractCborMap_toMap_closure: function ExtractCborMap_toMap_closure(t0, t1) {
      this.K = t0;
      this.V = t1;
    },
    JsonSerialization: function JsonSerialization() {
    },
    SynchronizedLock: function SynchronizedLock() {
      this.last = null;
    },
    SynchronizedLock_synchronized_complete: function SynchronizedLock_synchronized_complete(t0, t1) {
      this.$this = t0;
      this.completer = t1;
    },
    SynchronizedLock_synchronized_closure: function SynchronizedLock_synchronized_closure(t0) {
      this.complete = t0;
    },
    MethodUtils_call(t, $T) {
      var cancelable = null, delay = null;
      return A.MethodUtils_call$body(t, $T, $T._eval$1("MethodResult<0>"));
    },
    MethodUtils_call$body(t, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$currentError, r, completer, e, stackTrace, t1, exception, cancelable, delay, $async$exception;
      var $async$MethodUtils_call = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              cancelable = null;
              delay = null;
              $async$handler = 4;
              $async$goto = delay != null ? 7 : 8;
              break;
            case 7:
              // then
              $async$goto = 9;
              return A._asyncAwait(A.Future_Future$delayed(delay, type$.dynamic), $async$MethodUtils_call);
            case 9:
              // returning from await.
            case 8:
              // join
              r = null;
              if (cancelable == null)
                r = t.call$0();
              else {
                completer = new A._AsyncCompleter(new A._Future($.Zone__current, $T._eval$1("_Future<0>")), $T._eval$1("_AsyncCompleter<0>"));
                cancelable.setup$1(A.instantiate1(new A.MethodUtils_call_closure(completer, $T), type$.dynamic));
                cancelable.success$1(t);
                r = completer.future;
              }
              $async$goto = 10;
              return A._asyncAwait(r, $async$MethodUtils_call);
            case 10:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = new A.MethodResult(t1, null, $T._eval$1("MethodResult<0>"));
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              e = A.unwrapException($async$exception);
              stackTrace = A.getTraceFromException($async$exception);
              $async$returnValue = new A.MethodResult($, e, $T._eval$1("MethodResult<0>"));
              // goto return
              $async$goto = 1;
              break;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return A._asyncStartSync($async$MethodUtils_call, $async$completer);
    },
    MethodUtils_nullOnException(t, $T) {
      var t1, exception, defaultValue = null;
      try {
        t1 = t.call$0();
        return t1;
      } catch (exception) {
        return defaultValue;
      }
    },
    MethodUtils_call_closure: function MethodUtils_call_closure(t0, t1) {
      this.completer = t0;
      this.T = t1;
    },
    MethodResult: function MethodResult(t0, t1, t2) {
      this.__MethodResult__result_F = t0;
      this.exception = t1;
      this.$ti = t2;
    },
    StrUtils_to3Digits(number, separator) {
      var parts, t1, integerPart, fractionalPart, negative, groups, i, i0, result;
      if (B.JSString_methods.contains$1(number, ".")) {
        parts = number.split(".");
        t1 = parts.length;
        if (0 >= t1)
          return A.ioore(parts, 0);
        integerPart = parts[0];
        if (1 >= t1)
          return A.ioore(parts, 1);
        fractionalPart = parts[1];
      } else {
        integerPart = number;
        fractionalPart = "";
      }
      negative = B.JSString_methods.startsWith$1(integerPart, "-");
      if (negative)
        integerPart = B.JSString_methods.substring$1(integerPart, 1);
      groups = A._setArrayType([], type$.JSArray_String);
      i = integerPart.length;
      for (; i > 0; i = i0) {
        i0 = i - 3;
        B.JSArray_methods.insert$2(groups, 0, B.JSString_methods.substring$2(integerPart, Math.max(0, i0), i));
      }
      t1 = B.JSArray_methods.join$1(groups, separator);
      result = t1 + (fractionalPart.length === 0 ? "" : "." + fractionalPart);
      if (negative)
        return "-" + result;
      return result;
    },
    StrUtils_substring(value, $length) {
      var t1 = value.length;
      if (t1 > $length)
        return B.JSString_methods.replaceRange$3(value, $length - 1, t1, "");
      return value;
    },
    StrUtils_removeLastSlash(v) {
      if (B.JSString_methods.endsWith$1(v, "/"))
        return B.JSString_methods.substring$1(v, v.length - 1);
      return v;
    },
    StrUtils_toSnakeCase(input) {
      var t1,
        snakeCase = A.stringReplaceAllFuncUnchecked(input, A.RegExp_RegExp("[A-Z]", true), type$.nullable_String_Function_Match._as(type$.String_Function_Match._as(new A.StrUtils_toSnakeCase_closure())), null);
      if (B.JSString_methods.startsWith$1(snakeCase, "_"))
        snakeCase = B.JSString_methods.substring$1(snakeCase, 1);
      t1 = A.RegExp_RegExp("\\s+|[^a-zA-Z0-9]+", true);
      return A.stringReplaceAllUnchecked(snakeCase, t1, "_");
    },
    StrUtils_toSnakeCase_closure: function StrUtils_toSnakeCase_closure() {
    },
    connectSoc(url, protocols) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.PlatformWebScoket),
        $async$returnValue;
      var $async$connectSoc = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return A._asyncAwait(A.WebsocketWeb_connect(url), $async$connectSoc);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$connectSoc, $async$completer);
    },
    WebsocketWeb$_(_socket) {
      var t1 = new A.WebsocketWeb(_socket, A.StreamController_StreamController(false, type$.dynamic), new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_void), type$._AsyncCompleter_void));
      t1.WebsocketWeb$_$1(_socket);
      return t1;
    },
    WebsocketWeb_connect(url) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.WebsocketWeb),
        $async$returnValue, t1, exception, completer, socket;
      var $async$WebsocketWeb_connect = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              completer = new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_WebsocketWeb), type$._AsyncCompleter_WebsocketWeb);
              socket = A.JSWebSocket_constructor_create(url, B.List_empty1);
              try {
                A.WebsocketWeb$_(socket)._connectedCompleter.future.then$1$1(new A.WebsocketWeb_connect_closure(completer, socket), type$.Null);
                t1 = completer.future;
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
              } catch (exception) {
                socket.close();
                throw exception;
              }
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$WebsocketWeb_connect, $async$completer);
    },
    WebsocketWeb: function WebsocketWeb(t0, t1, t2) {
      var _ = this;
      _._web$_socket = t0;
      _._streamController = t1;
      _._connectedCompleter = t2;
      _._onMessage = _._web$_onClose = _._onOpen = null;
    },
    WebsocketWeb$__closure: function WebsocketWeb$__closure(t0) {
      this.$this = t0;
    },
    WebsocketWeb$__closure0: function WebsocketWeb$__closure0(t0) {
      this.$this = t0;
    },
    WebsocketWeb$__closure1: function WebsocketWeb$__closure1(t0) {
      this.$this = t0;
    },
    WebsocketWeb_connect_closure: function WebsocketWeb_connect_closure(t0, t1) {
      this.completer = t0;
      this.socket = t1;
    },
    BaseRepository: function BaseRepository() {
    },
    NodeClientStatus: function NodeClientStatus(t0) {
      this._core$_name = t0;
    },
    NetworkClient: function NetworkClient() {
    },
    _NetworkClient_Object_BaseRepository: function _NetworkClient_Object_BaseRepository() {
    },
    BitcoinElectrumClient: function BitcoinElectrumClient(t0, t1, t2) {
      this.network = t0;
      this._status = t1;
      this._lock = t2;
    },
    BitcoinExplorerApiProvider: function BitcoinExplorerApiProvider(t0, t1, t2) {
      this.network = t0;
      this._status = t1;
      this._lock = t2;
    },
    BitcoinClient: function BitcoinClient() {
    },
    CardanoClient: function CardanoClient(t0, t1, t2) {
      this.network = t0;
      this._status = t1;
      this._lock = t2;
    },
    CosmosClient: function CosmosClient(t0, t1, t2) {
      this.network = t0;
      this._status = t1;
      this._lock = t2;
    },
    EthereumClient$(network, provider) {
      return new A.EthereumClient(network, new A.Live(B.NodeClientStatus_1, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_NodeClientStatus), new A.SynchronizedLock());
    },
    EthereumClient: function EthereumClient(t0, t1, t2) {
      this.network = t0;
      this._status = t1;
      this._lock = t2;
    },
    RippleClient: function RippleClient(t0, t1, t2) {
      this.network = t0;
      this._status = t1;
      this._lock = t2;
    },
    SolanaClient: function SolanaClient(t0, t1, t2) {
      this.network = t0;
      this._status = t1;
      this._lock = t2;
    },
    SubstrateClient: function SubstrateClient(t0, t1, t2) {
      this.network = t0;
      this._status = t1;
      this._lock = t2;
    },
    _SubstrateClient_NetworkClient_SubstrateRepository: function _SubstrateClient_NetworkClient_SubstrateRepository() {
    },
    SubstrateRepository: function SubstrateRepository() {
    },
    TonClient: function TonClient(t0, t1, t2) {
      this.network = t0;
      this._status = t1;
      this._lock = t2;
    },
    TronClient: function TronClient(t0, t1, t2) {
      this.network = t0;
      this._status = t1;
      this._lock = t2;
    },
    ProvidersConst_getDefaultService(network, service) {
      var networkServices,
        t1 = $.$get$ProvidersConst__providers();
      if (!t1.containsKey$1(network.get$value()))
        return null;
      t1 = t1.$index(0, network.get$value());
      t1.toString;
      t1 = J.where$1$ax(t1, new A.ProvidersConst_getDefaultService_closure());
      networkServices = A.List_List$of(t1, true, t1.$ti._eval$1("Iterable.E"));
      if (networkServices.length === 0)
        return null;
      if (service == null)
        return B.JSArray_methods.get$first(networkServices);
      return B.JSArray_methods.firstWhere$2$orElse(networkServices, new A.ProvidersConst_getDefaultService_closure0(service), new A.ProvidersConst_getDefaultService_closure1(networkServices));
    },
    ProvidersConst_getDefaultService_closure: function ProvidersConst_getDefaultService_closure() {
    },
    ProvidersConst_getDefaultService_closure0: function ProvidersConst_getDefaultService_closure0(t0) {
      this.service = t0;
    },
    ProvidersConst_getDefaultService_closure1: function ProvidersConst_getDefaultService_closure1(t0) {
      this.networkServices = t0;
    },
    APIProvider_APIProvider$fromCborBytesOrObject(network, obj) {
      var _null = null;
      switch (network.get$type()) {
        case B.NetworkType_iDZ:
          return A.EthereumAPIProvider_EthereumAPIProvider$fromCborBytesOrObject(_null, obj);
        case B.NetworkType_SkF:
          return A.TronAPIProvider_TronAPIProvider$fromCborBytesOrObject(_null, obj);
        case B.NetworkType_4QF:
          return A.SolanaAPIProvider_SolanaAPIProvider$fromCborBytesOrObject(_null, obj);
        case B.NetworkType_8eb:
        case B.NetworkType_8eb0:
          return A.BaseBitcoinAPIProvider_BaseBitcoinAPIProvider$fromCborBytesOrObject(_null, obj);
        case B.NetworkType_4ei:
          return A.CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject(_null, obj);
        case B.NetworkType_QJm:
          return A.CosmosAPIProvider_CosmosAPIProvider$fromCborBytesOrObject(_null, obj);
        case B.NetworkType_Oh2:
          return A.RippleAPIProvider_RippleAPIProvider$fromCborBytesOrObject(_null, obj);
        case B.NetworkType_66M:
          return A.TonAPIProvider_TonAPIProvider$fromCborBytesOrObject(_null, obj);
        case B.NetworkType_GRA:
        case B.NetworkType_0:
          return A.SubstrateAPIProvider_SubstrateAPIProvider$fromCborBytesOrObject(_null, obj);
        default:
          throw A.wrapException(A.UnimplementedError$("Network does not exists " + network.get$type().name));
      }
    },
    APIProvider: function APIProvider() {
    },
    _APIProvider_Object_Equatable: function _APIProvider_Object_Equatable() {
    },
    _APIProvider_Object_Equatable_CborSerializable: function _APIProvider_Object_Equatable_CborSerializable() {
    },
    BitcoinExplorerProviderType_fromName($name) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_swi, new A.BitcoinExplorerProviderType_fromName_closure($name), new A.BitcoinExplorerProviderType_fromName_closure0());
    },
    BitcoinExplorerProviderType: function BitcoinExplorerProviderType(t0) {
      this._core$_name = t0;
    },
    BitcoinExplorerProviderType_fromName_closure: function BitcoinExplorerProviderType_fromName_closure(t0) {
      this.name = t0;
    },
    BitcoinExplorerProviderType_fromName_closure0: function BitcoinExplorerProviderType_fromName_closure0() {
    },
    _BitcoinExplorerAPIProviderUtils_getDefaultConfing(network, type) {
      if (type === B.APIType_0)
        return A.APIConfig_APIConfig$mempool(network);
      return A.APIConfig_APIConfig$fromBlockCypher(network);
    },
    _BitcoinExplorerAPIProviderUtils_createConfig(network, type, url) {
      if (url == null)
        return A._BitcoinExplorerAPIProviderUtils_getDefaultConfing(network, type);
      A.StrUtils_removeLastSlash(url);
      if (type === B.APIType_0)
        return new A.APIConfig();
      return new A.APIConfig();
    },
    BitcoinExplorerAPIProvider_BitcoinExplorerAPIProvider$fromCborBytesOrObject(obj) {
      var t3, t4, t5,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_90_2, type$.CborListValue_dynamic),
        t1 = type$.String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t3 = type$.nullable_String;
      t4 = A.ExtractCborList_elementAt(cbor, 2, t3);
      t5 = A.ExtractCborList_getCborTag(cbor, 3);
      if (t5 != null)
        A.QuickCbor_to(t5, new A.BitcoinExplorerAPIProvider_BitcoinExplorerAPIProvider$fromCborBytesOrObject_closure(), type$.ProviderAuth, type$.CborTagValue_dynamic);
      return new A.BitcoinExplorerAPIProvider(t4, A.BitcoinExplorerProviderType_fromName(A.ExtractCborList_elementAt(cbor, 4, t3)), B.ServiceProtocol_HTTP_0_http, t2, t1);
    },
    BitcoinExplorerAPIProvider: function BitcoinExplorerAPIProvider(t0, t1, t2, t3, t4) {
      var _ = this;
      _.uri = t0;
      _.explorerType = t1;
      _.protocol = t2;
      _.serviceName = t3;
      _.websiteUri = t4;
    },
    BitcoinExplorerAPIProvider_BitcoinExplorerAPIProvider$fromCborBytesOrObject_closure: function BitcoinExplorerAPIProvider_BitcoinExplorerAPIProvider$fromCborBytesOrObject_closure() {
    },
    ElectrumAPIProvider_ElectrumAPIProvider(protocol, serviceName, url, websiteUri) {
      var _null = null;
      switch (protocol) {
        case B.ServiceProtocol_TCP_2_tcp:
          return new A.ElectrumAPIProvider(_null, url, _null, protocol, serviceName, websiteUri);
        case B.ServiceProtocol_SSL_1_ssl:
          return new A.ElectrumAPIProvider(_null, _null, url, protocol, serviceName, websiteUri);
        default:
          return new A.ElectrumAPIProvider(url, _null, _null, protocol, serviceName, websiteUri);
      }
    },
    ElectrumAPIProvider_ElectrumAPIProvider$fromCborBytesOrObject(obj) {
      var protocol, t2, t3,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_90_0, type$.CborListValue_dynamic),
        t1 = type$.dynamic,
        websocket = A.ExtractCborList_elementAt(cbor, 2, t1),
        tcp = A.ExtractCborList_elementAt(cbor, 3, t1),
        ssl = A.ExtractCborList_elementAt(cbor, 4, t1);
      if (websocket != null)
        protocol = B.ServiceProtocol_WebSocket_3_websocket;
      else
        protocol = tcp != null ? B.ServiceProtocol_TCP_2_tcp : B.ServiceProtocol_SSL_1_ssl;
      t1 = type$.String;
      t2 = A.ExtractCborList_elementAt(cbor, 0, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 1, t1);
      A._asStringQ(websocket);
      A._asStringQ(tcp);
      A._asStringQ(ssl);
      t3 = A.ExtractCborList_getCborTag(cbor, 5);
      if (t3 != null)
        A.QuickCbor_to(t3, new A.ElectrumAPIProvider_ElectrumAPIProvider$fromCborBytesOrObject_closure(), type$.ProviderAuth, type$.CborTagValue_dynamic);
      return new A.ElectrumAPIProvider(websocket, tcp, ssl, protocol, t2, t1);
    },
    ElectrumAPIProvider: function ElectrumAPIProvider(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.websocket = t0;
      _.tcp = t1;
      _.ssl = t2;
      _.protocol = t3;
      _.serviceName = t4;
      _.websiteUri = t5;
    },
    ElectrumAPIProvider_ElectrumAPIProvider$fromCborBytesOrObject_closure: function ElectrumAPIProvider_ElectrumAPIProvider$fromCborBytesOrObject_closure() {
    },
    BaseBitcoinAPIProvider_BaseBitcoinAPIProvider$fromCborBytesOrObject(bytes, obj) {
      var t1;
      if (obj == null) {
        bytes.toString;
        t1 = A.CborUtils__decode(bytes).item1;
      } else
        t1 = obj;
      type$.CborTagValue_dynamic._as(t1);
      if (A.BytesUtils_bytesEqual(t1.tags, B.List_90_0))
        return A.ElectrumAPIProvider_ElectrumAPIProvider$fromCborBytesOrObject(t1);
      return A.BitcoinExplorerAPIProvider_BitcoinExplorerAPIProvider$fromCborBytesOrObject(obj);
    },
    BaseBitcoinAPIProvider: function BaseBitcoinAPIProvider() {
    },
    CardanoAPIProvider_CardanoAPIProvider(auth, serviceName, uri, websiteUri) {
      return new A.CardanoAPIProvider(uri, A.ServiceProtocol_fromURI(uri), serviceName, websiteUri);
    },
    CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject(bytes, obj) {
      var cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_90_6, type$.CborListValue_dynamic),
        protocolId = A.ExtractCborList_elementAt(cbor, 3, type$.nullable_int),
        t1 = type$.String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1),
        t3 = A.ExtractCborList_elementAt(cbor, 1, t1),
        t4 = A.ExtractCborList_elementAt(cbor, 2, t1),
        t5 = A.ServiceProtocol_fromID(protocolId == null ? 0 : protocolId),
        t6 = A.ExtractCborList_getCborTag(cbor, 5);
      if ((t6 == null ? null : A.QuickCbor_to(t6, new A.CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject_closure(), type$.ProviderAuth, type$.CborTagValue_dynamic)) == null) {
        t6 = A.ExtractCborList_elementAt(cbor, 4, type$.nullable_CborObject);
        if (t6 != null)
          A.QuickCbor_to(t6, new A.CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject_closure0(), type$.ProviderAuth, t1);
      }
      return new A.CardanoAPIProvider(t4, t5, t2, t3);
    },
    CardanoAPIProvider: function CardanoAPIProvider(t0, t1, t2, t3) {
      var _ = this;
      _.uri = t0;
      _.protocol = t1;
      _.serviceName = t2;
      _.websiteUri = t3;
    },
    CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject_closure: function CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject_closure() {
    },
    CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject_closure0: function CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject_closure0() {
    },
    CosmosAPIProvider_CosmosAPIProvider(nodeUri, serviceName, uri, websiteUri) {
      return new A.CosmosAPIProvider(uri, nodeUri, A.ServiceProtocol_fromURI(uri), serviceName, websiteUri);
    },
    CosmosAPIProvider_CosmosAPIProvider$fromCborBytesOrObject(bytes, obj) {
      var t4, t5, t6,
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_90_7, type$.CborListValue_dynamic),
        protocolId = A.ExtractCborList_elementAt(cbor, 3, type$.nullable_int),
        t1 = type$.String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1),
        t3 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 2, t1);
      t4 = A.ServiceProtocol_fromID(protocolId == null ? 0 : protocolId);
      t5 = A.ExtractCborList_elementAt(cbor, 4, type$.nullable_String);
      t6 = A.ExtractCborList_getCborTag(cbor, 5);
      if (t6 != null)
        A.QuickCbor_to(t6, new A.CosmosAPIProvider_CosmosAPIProvider$fromCborBytesOrObject_closure(), type$.ProviderAuth, type$.CborTagValue_dynamic);
      return new A.CosmosAPIProvider(t1, t5, t4, t2, t3);
    },
    CosmosAPIProvider: function CosmosAPIProvider(t0, t1, t2, t3, t4) {
      var _ = this;
      _.uri = t0;
      _.nodeUri = t1;
      _.protocol = t2;
      _.serviceName = t3;
      _.websiteUri = t4;
    },
    CosmosAPIProvider_CosmosAPIProvider$fromCborBytesOrObject_closure: function CosmosAPIProvider_CosmosAPIProvider$fromCborBytesOrObject_closure() {
    },
    EthereumAPIProvider_EthereumAPIProvider(serviceName, uri, websiteUri) {
      return new A.EthereumAPIProvider(uri, A.ServiceProtocol_fromURI(uri), serviceName, websiteUri);
    },
    EthereumAPIProvider_EthereumAPIProvider$fromCborBytesOrObject(bytes, obj) {
      var t4, t5,
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_90_3, type$.CborListValue_dynamic),
        protocolId = A.ExtractCborList_elementAt(cbor, 3, type$.nullable_int),
        t1 = type$.String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1),
        t3 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 2, t1);
      t4 = A.ServiceProtocol_fromID(protocolId == null ? 0 : protocolId);
      t5 = A.ExtractCborList_getCborTag(cbor, 4);
      if (t5 != null)
        A.QuickCbor_to(t5, new A.EthereumAPIProvider_EthereumAPIProvider$fromCborBytesOrObject_closure(), type$.ProviderAuth, type$.CborTagValue_dynamic);
      return new A.EthereumAPIProvider(t1, t4, t2, t3);
    },
    EthereumAPIProvider: function EthereumAPIProvider(t0, t1, t2, t3) {
      var _ = this;
      _.uri = t0;
      _.protocol = t1;
      _.serviceName = t2;
      _.websiteUri = t3;
    },
    EthereumAPIProvider_EthereumAPIProvider$fromCborBytesOrObject_closure: function EthereumAPIProvider_EthereumAPIProvider$fromCborBytesOrObject_closure() {
    },
    RippleAPIProvider_RippleAPIProvider(serviceName, uri, websiteUri) {
      return new A.RippleAPIProvider(uri, A.ServiceProtocol_fromURI(uri), serviceName, websiteUri);
    },
    RippleAPIProvider_RippleAPIProvider$fromCborBytesOrObject(bytes, obj) {
      var t4, t5,
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_90_9, type$.CborListValue_dynamic),
        protocolId = A.ExtractCborList_elementAt(cbor, 3, type$.nullable_int),
        t1 = type$.String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1),
        t3 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 2, t1);
      t4 = A.ServiceProtocol_fromID(protocolId == null ? 0 : protocolId);
      t5 = A.ExtractCborList_getCborTag(cbor, 4);
      if (t5 != null)
        A.QuickCbor_to(t5, new A.RippleAPIProvider_RippleAPIProvider$fromCborBytesOrObject_closure(), type$.ProviderAuth, type$.CborTagValue_dynamic);
      return new A.RippleAPIProvider(t1, t4, t2, t3);
    },
    RippleAPIProvider: function RippleAPIProvider(t0, t1, t2, t3) {
      var _ = this;
      _.uri = t0;
      _.protocol = t1;
      _.serviceName = t2;
      _.websiteUri = t3;
    },
    RippleAPIProvider_RippleAPIProvider$fromCborBytesOrObject_closure: function RippleAPIProvider_RippleAPIProvider$fromCborBytesOrObject_closure() {
    },
    SolanaAPIProvider_SolanaAPIProvider$fromCborBytesOrObject(bytes, obj) {
      var t4,
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_90_5, type$.CborListValue_dynamic),
        t1 = type$.String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1),
        t3 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 2, t1);
      t4 = A.ExtractCborList_getCborTag(cbor, 3);
      if (t4 != null)
        A.QuickCbor_to(t4, new A.SolanaAPIProvider_SolanaAPIProvider$fromCborBytesOrObject_closure(), type$.ProviderAuth, type$.CborTagValue_dynamic);
      return new A.SolanaAPIProvider(t1, B.ServiceProtocol_HTTP_0_http, t2, t3);
    },
    SolanaAPIProvider: function SolanaAPIProvider(t0, t1, t2, t3) {
      var _ = this;
      _.httpNodeUri = t0;
      _.protocol = t1;
      _.serviceName = t2;
      _.websiteUri = t3;
    },
    SolanaAPIProvider_SolanaAPIProvider$fromCborBytesOrObject_closure: function SolanaAPIProvider_SolanaAPIProvider$fromCborBytesOrObject_closure() {
    },
    SubstrateAPIProvider_SubstrateAPIProvider(serviceName, uri, websiteUri) {
      return new A.SubstrateAPIProvider(uri, A.ServiceProtocol_fromURI(uri), serviceName, websiteUri);
    },
    SubstrateAPIProvider_SubstrateAPIProvider$fromCborBytesOrObject(bytes, obj) {
      var t4, t5,
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_90_10, type$.CborListValue_dynamic),
        protocolId = A.ExtractCborList_elementAt(cbor, 3, type$.nullable_int),
        t1 = type$.String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1),
        t3 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 2, t1);
      t4 = A.ServiceProtocol_fromID(protocolId == null ? 0 : protocolId);
      A.ExtractCborList_elementAt(cbor, 4, type$.nullable_String);
      t5 = A.ExtractCborList_getCborTag(cbor, 5);
      if (t5 != null)
        A.QuickCbor_to(t5, new A.SubstrateAPIProvider_SubstrateAPIProvider$fromCborBytesOrObject_closure(), type$.ProviderAuth, type$.CborTagValue_dynamic);
      return new A.SubstrateAPIProvider(t1, t4, t2, t3);
    },
    SubstrateAPIProvider: function SubstrateAPIProvider(t0, t1, t2, t3) {
      var _ = this;
      _.uri = t0;
      _.protocol = t1;
      _.serviceName = t2;
      _.websiteUri = t3;
    },
    SubstrateAPIProvider_SubstrateAPIProvider$fromCborBytesOrObject_closure: function SubstrateAPIProvider_SubstrateAPIProvider$fromCborBytesOrObject_closure() {
    },
    TonAPIProvider_TonAPIProvider(apiType, auth, serviceName, uri, websiteUri) {
      return new A.TonAPIProvider(uri, A.ServiceProtocol_fromURI(uri), serviceName, websiteUri);
    },
    TonAPIProvider_TonAPIProvider$fromCborBytesOrObject(bytes, obj) {
      var t2, t3, t4, t5,
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_90_8, type$.CborListValue_dynamic),
        protocolId = A.ExtractCborList_elementAt(cbor, 3, type$.nullable_int),
        t1 = type$.String;
      A.TonApiType_TonApiType$fromValue(A.ExtractCborList_elementAt(cbor, 4, t1));
      t2 = A.ExtractCborList_elementAt(cbor, 0, t1);
      t3 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 2, t1);
      t4 = A.ServiceProtocol_fromID(protocolId == null ? 0 : protocolId);
      t5 = A.ExtractCborList_getCborTag(cbor, 5);
      if (t5 != null)
        A.QuickCbor_to(t5, new A.TonAPIProvider_TonAPIProvider$fromCborBytesOrObject_closure(), type$.ProviderAuth, type$.CborTagValue_dynamic);
      return new A.TonAPIProvider(t1, t4, t2, t3);
    },
    TonAPIProvider: function TonAPIProvider(t0, t1, t2, t3) {
      var _ = this;
      _.uri = t0;
      _.protocol = t1;
      _.serviceName = t2;
      _.websiteUri = t3;
    },
    TonAPIProvider_TonAPIProvider$fromCborBytesOrObject_closure: function TonAPIProvider_TonAPIProvider$fromCborBytesOrObject_closure() {
    },
    TronAPIProvider$(auth, httpNodeUri, serviceName, solidityProvider, websiteUri) {
      return new A.TronAPIProvider(httpNodeUri, solidityProvider, B.ServiceProtocol_HTTP_0_http, serviceName, websiteUri);
    },
    TronAPIProvider_TronAPIProvider$fromCborBytesOrObject(bytes, obj) {
      var t4,
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_90_4, type$.CborListValue_dynamic),
        t1 = type$.String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1),
        t3 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 2, t1);
      t4 = A.ExtractCborList_getCborTag(cbor, 3);
      if (t4 != null)
        A.QuickCbor_to(t4, new A.TronAPIProvider_TronAPIProvider$fromCborBytesOrObject_closure(), type$.ProviderAuth, type$.CborTagValue_dynamic);
      return new A.TronAPIProvider(t1, A.EthereumAPIProvider_EthereumAPIProvider$fromCborBytesOrObject(null, A.ExtractCborList_getCborTag(cbor, 4)), B.ServiceProtocol_HTTP_0_http, t2, t3);
    },
    TronAPIProvider: function TronAPIProvider(t0, t1, t2, t3, t4) {
      var _ = this;
      _.httpNodeUri = t0;
      _.solidityProvider = t1;
      _.protocol = t2;
      _.serviceName = t3;
      _.websiteUri = t4;
    },
    TronAPIProvider_TronAPIProvider$fromCborBytesOrObject_closure: function TronAPIProvider_TronAPIProvider$fromCborBytesOrObject_closure() {
    },
    APIServiceTracker: function APIServiceTracker(t0, t1) {
      var _ = this;
      _._tracker$_status = t0;
      _._requests = t1;
      _._totalError = _._totalSuccess = 0;
    },
    APIServiceTracker__checkStatus_closure: function APIServiceTracker__checkStatus_closure() {
    },
    HTTPService: function HTTPService() {
    },
    HTTPService_providerPOST_closure: function HTTPService_providerPOST_closure(t0, t1, t2, t3, t4) {
      var _ = this;
      _.$this = t0;
      _.url = t1;
      _.headers = t2;
      _.params = t3;
      _.timeout = t4;
    },
    BaseSocketService: function BaseSocketService() {
    },
    SSLService: function SSLService() {
    },
    SSLService_connect_closure: function SSLService_connect_closure(t0) {
      this.$this = t0;
    },
    SSLService_connect__closure: function SSLService_connect__closure(t0) {
      this.$this = t0;
    },
    SSLService_connect___closure: function SSLService_connect___closure() {
    },
    SSLService_post_closure: function SSLService_post_closure(t0, t1, t2) {
      this.$this = t0;
      this.message = t1;
      this.timeout = t2;
    },
    TCPService: function TCPService() {
    },
    TCPService_connect_closure: function TCPService_connect_closure(t0) {
      this.$this = t0;
    },
    TCPService_connect__closure: function TCPService_connect__closure(t0) {
      this.$this = t0;
    },
    TCPService_post_closure: function TCPService_post_closure(t0, t1, t2) {
      this.$this = t0;
      this.message = t1;
      this.timeout = t2;
    },
    WebSocketService: function WebSocketService() {
    },
    WebSocketService__onClose_closure: function WebSocketService__onClose_closure() {
    },
    WebSocketService_connect_closure: function WebSocketService_connect_closure(t0) {
      this.$this = t0;
    },
    WebSocketService_connect__closure: function WebSocketService_connect__closure(t0) {
      this.$this = t0;
    },
    WebSocketService_addMessage_closure: function WebSocketService_addMessage_closure(t0, t1, t2) {
      this.$this = t0;
      this.message = t1;
      this.timeout = t2;
    },
    ProviderAuthType_fromName($name) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_XC3, new A.ProviderAuthType_fromName_closure($name), new A.ProviderAuthType_fromName_closure0());
    },
    ProviderAuth_ProviderAuth$fromCborBytesOrObject(obj) {
      var t1,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_90_1, type$.CborListValue_dynamic);
      A.ProviderAuthType_fromName(A.ExtractCborList_elementAt(cbor, 0, type$.nullable_String));
      t1 = type$.String;
      A.ExtractCborList_elementAt(cbor, 1, t1);
      return new A.ProviderAuth(A.ExtractCborList_elementAt(cbor, 2, t1));
    },
    ProviderAuthType: function ProviderAuthType(t0) {
      this._core$_name = t0;
    },
    ProviderAuthType_fromName_closure: function ProviderAuthType_fromName_closure(t0) {
      this.name = t0;
    },
    ProviderAuthType_fromName_closure0: function ProviderAuthType_fromName_closure0() {
    },
    ProviderAuth: function ProviderAuth(t0) {
      this.value = t0;
    },
    _ProviderAuth_Object_CborSerializable: function _ProviderAuth_Object_CborSerializable() {
    },
    ServiceProtocol_fromID(id) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_yX5, new A.ServiceProtocol_fromID_closure(id), null);
    },
    ServiceProtocol_fromURI(url) {
      var lower = url.toLowerCase();
      if (B.JSString_methods.startsWith$1(lower, "http"))
        return B.ServiceProtocol_HTTP_0_http;
      else if (B.JSString_methods.startsWith$1(lower, "ws"))
        return B.ServiceProtocol_WebSocket_3_websocket;
      else
        throw A.wrapException(A.WalletException$("Invalid URL. The ServiceProtocol.fromURI function is designed to work exclusively with http and websocket URIs."));
    },
    ServiceProtocol: function ServiceProtocol(t0, t1, t2) {
      this.value = t0;
      this.id = t1;
      this._core$_name = t2;
    },
    ServiceProtocol_fromID_closure: function ServiceProtocol_fromID_closure(t0) {
      this.id = t0;
    },
    ApiRequest: function ApiRequest(t0) {
      this.error = t0;
    },
    SocketRequestCompeleter: function SocketRequestCompeleter(t0, t1, t2) {
      this.completer = t0;
      this.params = t1;
      this.id = t2;
    },
    SocketStatus: function SocketStatus(t0) {
      this._core$_name = t0;
    },
    APIServiceStatus: function APIServiceStatus(t0) {
      this._core$_name = t0;
    },
    ElectrumSSLSocketService: function ElectrumSSLSocketService(t0, t1, t2, t3, t4) {
      var _ = this;
      _.tracker = t0;
      _.url = t1;
      _._ssl$_lock = t2;
      _._ssl$_socket = null;
      _._ssl$_status = t3;
      _._ssl$_subscription = null;
      _._ssl$_requests = t4;
    },
    ElectrumSocketService: function ElectrumSocketService(t0, t1, t2, t3, t4) {
      var _ = this;
      _.tracker = t0;
      _.url = t1;
      _._tcp$_lock = t2;
      _._tcp$_socket = null;
      _._tcp$_status = t3;
      _._tcp$_subscription = null;
      _._tcp$_requests = t4;
    },
    ElectrumWebsocketService: function ElectrumWebsocketService(t0, t1, t2, t3, t4) {
      var _ = this;
      _.tracker = t0;
      _.url = t1;
      _._websocket$_lock = t2;
      _._socket = null;
      _._websocket$_status = t3;
      _._websocket$_subscription = null;
      _._websocket$_requests = t4;
    },
    RippleHTTPService: function RippleHTTPService(t0, t1) {
      this.url = t0;
      this.tracker = t1;
    },
    RippleWebsocketService: function RippleWebsocketService(t0, t1, t2, t3, t4) {
      var _ = this;
      _.tracker = t0;
      _.url = t1;
      _._websocket$_lock = t2;
      _._socket = null;
      _._websocket$_status = t3;
      _._websocket$_subscription = null;
      _._websocket$_requests = t4;
    },
    Chain_Chain$fromCborBytesOrObject(bytes, obj, PROVIDER, NETWORKPARAMS, NETWORKADDRESS, CHAINTOKEN, ADDRESS, NETWORK, CLIENT, WEB3REQUEST) {
      var networkObject, networkId, network, provider, accountData, _null = null, t1 = {},
        cbor = A.CborSerializable_decode(bytes, _null, obj, type$.CborTagValue_dynamic),
        values = A.QuickCborTag_get_getList(cbor),
        t2 = cbor.tags;
      if (A.BytesUtils_bytesEqual(t2, B.List_80)) {
        t2 = A.ExtractCborList_getCborTag(values, 0);
        networkObject = t2 == null ? _null : A.QuickCborTag_get_getList(t2);
        networkId = networkObject == null ? _null : A.ExtractCborList_elementAt(networkObject, 0, type$.nullable_int);
        network = A.MethodUtils_nullOnException(new A.Chain_Chain$fromCborBytesOrObject_closure(values), type$.WalletNetwork_NetworkCoinParams_APIProvider);
        t1.network = network;
        t1.network = A.ChainConst_updateNetwork(network, networkId);
        provider = A.MethodUtils_nullOnException(new A.Chain_Chain$fromCborBytesOrObject_closure0(t1, values), type$.APIProvider);
        t2 = A.ExtractCborList_getCborTag(values, 2);
        accountData = t2 == null ? _null : A.QuickCborTag_get_getList(t2);
        if (accountData == null)
          throw A.wrapException($.$get$WalletExceptionConst_dataVerificationFailed());
        return A.Chain_Chain$_fromNetwork(t1.network, provider, accountData, PROVIDER, NETWORKPARAMS, NETWORKADDRESS, CHAINTOKEN, ADDRESS, NETWORK, CLIENT, WEB3REQUEST);
      }
      if (!A.BytesUtils_bytesEqual(t2, B.List_200))
        throw A.wrapException($.$get$WalletExceptionConst_dataVerificationFailed());
      networkId = A.ExtractCborList_elementAt(values, 0, type$.int);
      network = A.MethodUtils_nullOnException(new A.Chain_Chain$fromCborBytesOrObject_closure1(values), type$.WalletNetwork_NetworkCoinParams_APIProvider);
      t1.network = network;
      t1.network = A.ChainConst_updateNetwork(network, networkId);
      provider = A.MethodUtils_nullOnException(new A.Chain_Chain$fromCborBytesOrObject_closure2(t1, values), type$.APIProvider);
      return A.Chain_Chain$_fromNetwork(t1.network, provider, values, PROVIDER, NETWORKPARAMS, NETWORKADDRESS, CHAINTOKEN, ADDRESS, NETWORK, CLIENT, WEB3REQUEST);
    },
    Chain_setup(network) {
      var t1, t2, t3, _null = null;
      switch (network.get$type()) {
        case B.NetworkType_iDZ:
          t1 = network.toNetwork$1$0(type$.WalletEthereumNetwork);
          t2 = A.APIUtils_createApiClient(network, _null, type$.EthereumClient);
          t3 = t1.coinParam.token.decimal;
          t3.toString;
          return A.EthereumChain$_(0, B.List_empty13, t2, B.List_empty14, t1, B.List_empty15, new A.Live(A.IntegerBalance_IntegerBalance($.$get$_BigIntImpl_zero(), t3, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
        case B.NetworkType_SkF:
          t1 = network.toNetwork$1$0(type$.WalletTronNetwork);
          t2 = A.APIUtils_createApiClient(network, _null, type$.TronClient);
          t3 = t1.coinParam.token.decimal;
          t3.toString;
          return A.TronChain$_(0, B.List_empty13, t2, B.List_empty14, t1, B.List_empty15, new A.Live(A.IntegerBalance_IntegerBalance($.$get$_BigIntImpl_zero(), t3, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
        case B.NetworkType_Oh2:
          t1 = network.toNetwork$1$0(type$.WalletXRPNetwork);
          t2 = A.APIUtils_createApiClient(network, _null, type$.RippleClient);
          t3 = t1.coinParam.token.decimal;
          t3.toString;
          return A.RippleChain$_(0, B.List_empty13, t2, B.List_empty14, t1, B.List_empty15, new A.Live(A.IntegerBalance_IntegerBalance($.$get$_BigIntImpl_zero(), t3, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
        case B.NetworkType_4QF:
          t1 = network.toNetwork$1$0(type$.WalletSolanaNetwork);
          t2 = A.APIUtils_createApiClient(network, _null, type$.SolanaClient);
          t3 = t1.coinParam.token.decimal;
          t3.toString;
          return A.SolanaChain$_(0, B.List_empty13, t2, B.List_empty14, t1, B.List_empty15, new A.Live(A.IntegerBalance_IntegerBalance($.$get$_BigIntImpl_zero(), t3, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
        case B.NetworkType_4ei:
          t1 = network.toNetwork$1$0(type$.WalletCardanoNetwork);
          t2 = A.APIUtils_createApiClient(network, _null, type$.CardanoClient);
          t3 = t1.coinParam.token.decimal;
          t3.toString;
          return A.ADAChain$_(0, B.List_empty13, t2, B.List_empty14, t1, B.List_empty15, new A.Live(A.IntegerBalance_IntegerBalance($.$get$_BigIntImpl_zero(), t3, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
        case B.NetworkType_QJm:
          t1 = network.toNetwork$1$0(type$.WalletCosmosNetwork);
          t2 = A.APIUtils_createApiClient(network, _null, type$.CosmosClient);
          t3 = t1.coinParam.token.decimal;
          t3.toString;
          return A.CosmosChain$_(0, B.List_empty13, t2, B.List_empty14, t1, B.List_empty15, new A.Live(A.IntegerBalance_IntegerBalance($.$get$_BigIntImpl_zero(), t3, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
        case B.NetworkType_66M:
          t1 = network.toNetwork$1$0(type$.WalletTonNetwork);
          t2 = A.APIUtils_createApiClient(network, _null, type$.TonClient);
          t3 = t1.coinParam.token.decimal;
          t3.toString;
          return A.TonChain$_(0, B.List_empty13, t2, B.List_empty14, t1, B.List_empty15, new A.Live(A.IntegerBalance_IntegerBalance($.$get$_BigIntImpl_zero(), t3, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
        case B.NetworkType_GRA:
        case B.NetworkType_0:
          t1 = network.toNetwork$1$0(type$.WalletPolkadotNetwork);
          t2 = A.APIUtils_createApiClient(network, _null, type$.SubstrateClient);
          t3 = t1.coinParam.token.decimal;
          t3.toString;
          return A.SubstrateChain$_(0, B.List_empty13, t2, B.List_empty14, t1, B.List_empty15, new A.Live(A.IntegerBalance_IntegerBalance($.$get$_BigIntImpl_zero(), t3, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
        case B.NetworkType_8eb:
        case B.NetworkType_8eb0:
          t1 = network.toNetwork$1$0(type$.WalletBitcoinNetwork);
          t2 = A.APIUtils_createApiClient(network, _null, type$.BitcoinClient_IBitcoinAddress);
          t3 = t1.coinParam.token.decimal;
          t3.toString;
          return A.BitcoinChain$_(0, B.List_empty13, t2, B.List_empty14, t1, B.List_empty15, new A.Live(A.IntegerBalance_IntegerBalance($.$get$_BigIntImpl_zero(), t3, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
        default:
          throw A.wrapException(A.UnimplementedError$("network does not eixst. "));
      }
    },
    Chain_Chain$_fromNetwork(network, provider, values, PROVIDER, NETWORKPARAMS, NETWORKADDRESS, CHAINTOKEN, ADDRESS, NETWORK, CLIENT, WEB3REQUEST) {
      var t1, chain;
      switch (network.get$type()) {
        case B.NetworkType_8eb0:
        case B.NetworkType_8eb:
          t1 = network.toNetwork$1$0(type$.WalletBitcoinNetwork);
          chain = A.BitcoinChain_BitcoinChain$deserialize(values, A.APIUtils_createApiClient(network, provider, type$.BitcoinClient_IBitcoinAddress), t1);
          break;
        case B.NetworkType_GRA:
        case B.NetworkType_0:
          t1 = network.toNetwork$1$0(type$.WalletPolkadotNetwork);
          chain = A.SubstrateChain_SubstrateChain$deserialize(values, A.APIUtils_createApiClient(network, provider, type$.SubstrateClient), t1);
          break;
        case B.NetworkType_iDZ:
          t1 = network.toNetwork$1$0(type$.WalletEthereumNetwork);
          chain = A.EthereumChain_EthereumChain$deserialize(values, A.APIUtils_createApiClient(network, provider, type$.EthereumClient), t1);
          break;
        case B.NetworkType_QJm:
          t1 = network.toNetwork$1$0(type$.WalletCosmosNetwork);
          chain = A.CosmosChain_CosmosChain$deserialize(values, A.APIUtils_createApiClient(network, provider, type$.CosmosClient), t1);
          break;
        case B.NetworkType_66M:
          t1 = network.toNetwork$1$0(type$.WalletTonNetwork);
          chain = A.TonChain_TonChain$deserialize(values, A.APIUtils_createApiClient(network, provider, type$.TonClient), t1);
          break;
        case B.NetworkType_SkF:
          t1 = network.toNetwork$1$0(type$.WalletTronNetwork);
          chain = A.TronChain_TronChain$deserialize(values, A.APIUtils_createApiClient(network, provider, type$.TronClient), t1);
          break;
        case B.NetworkType_Oh2:
          t1 = network.toNetwork$1$0(type$.WalletXRPNetwork);
          chain = A.RippleChain_RippleChain$deserialize(values, A.APIUtils_createApiClient(network, provider, type$.RippleClient), t1);
          break;
        case B.NetworkType_4QF:
          t1 = network.toNetwork$1$0(type$.WalletSolanaNetwork);
          chain = A.SolanaChain_SolanaChain$deserialize(values, A.APIUtils_createApiClient(network, provider, type$.SolanaClient), t1);
          break;
        case B.NetworkType_4ei:
          t1 = network.toNetwork$1$0(type$.WalletCardanoNetwork);
          chain = A.ADAChain_ADAChain$deserialize(values, A.APIUtils_createApiClient(network, provider, type$.CardanoClient), t1);
          break;
        default:
          throw A.wrapException(A.UnimplementedError$("Network does not exist"));
      }
      t1 = PROVIDER._eval$1("@<0>")._bind$1(NETWORKPARAMS)._bind$1(NETWORKADDRESS)._bind$1(CHAINTOKEN)._bind$1(ADDRESS)._bind$1(NETWORK)._bind$1(CLIENT)._bind$1(WEB3REQUEST)._eval$1("Chain<1,2,3,4,5,6,7,8>");
      A.checkTypeBound(t1, type$.BaseChain_of_dynamic_and_ChainAccount_of_dynamic_and_TokenCore_dynamic_and_dynamic_and_dynamic_and_dynamic, "T", "cast");
      if (!t1._is(chain))
        A.throwExpression(A.WalletExceptionConst_invalidArgruments(A.getRuntimeTypeOfDartObject(chain).toString$0(0), A.createRuntimeType(t1).toString$0(0)));
      return t1._as(chain);
    },
    ADAChain$_(addressIndex, addresses, client, contacts, network, permissions, totalBalance) {
      A.List_List$unmodifiable(addresses, type$.ICardanoAddress);
      A.List_List$unmodifiable(contacts, type$.ContactCore_ADAAddress);
      A.List_List$unmodifiable(permissions, type$.Web3Permission_ADAAddress);
      return new A.ADAChain(network);
    },
    ADAChain_ADAChain$deserialize(cbor, client, network) {
      var accounts, toAccounts, t1, t2, acc, addressIndex, contacts, cborContacts, totalBalance, permissions, t3;
      if (A.ExtractCborList_elementAt(cbor, 0, type$.int) !== network.value)
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      accounts = A.ExtractCborList_elementAt(cbor, 1, type$.nullable_List_CborObject);
      if (accounts == null)
        accounts = A._setArrayType([], type$.JSArray_CborObject);
      toAccounts = A._setArrayType([], type$.JSArray_ICardanoAddress);
      for (t1 = J.get$iterator$ax(accounts), t2 = type$.ICardanoAddress; t1.moveNext$0();) {
        acc = A.MethodUtils_nullOnException(new A.ADAChain_ADAChain$deserialize_closure(network, t1.get$current()), t2);
        if (acc != null)
          B.JSArray_methods.add$1(toAccounts, acc);
      }
      addressIndex = A.ExtractCborList_elementAt(cbor, 5, type$.nullable_int);
      if (addressIndex == null)
        addressIndex = 0;
      if (addressIndex >= toAccounts.length)
        addressIndex = 0;
      contacts = A._setArrayType([], type$.JSArray_ContactCore_ADAAddress);
      t1 = type$.nullable_List_dynamic;
      cborContacts = A.ExtractCborList_elementAt(cbor, 3, t1);
      if (cborContacts != null) {
        t2 = J.map$1$1$ax(cborContacts, new A.ADAChain_ADAChain$deserialize_closure0(network), type$.ContactCore_ADAAddress);
        contacts = A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      }
      totalBalance = A.ExtractCborList_elementAt(cbor, 4, type$.nullable_BigInt);
      t1 = A.ExtractCborList_elementAt(cbor, 8, t1);
      if (t1 == null)
        permissions = null;
      else {
        t1 = J.map$1$1$ax(t1, new A.ADAChain_ADAChain$deserialize_closure1(), type$.Web3Permission_ADAAddress);
        permissions = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      }
      t1 = addressIndex < 0 ? 0 : addressIndex;
      t2 = totalBalance == null ? $.$get$_BigIntImpl_zero() : totalBalance;
      t3 = network.coinParam.token.decimal;
      t3.toString;
      t3 = A.IntegerBalance_IntegerBalance(t2, t3, false);
      t2 = permissions == null ? B.List_empty2 : permissions;
      return A.ADAChain$_(t1, toAccounts, client, contacts, network, t2, new A.Live(t3, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
    },
    BitcoinChain$_(addressIndex, addresses, client, contacts, network, permissions, totalBalance) {
      A.List_List$unmodifiable(addresses, type$.IBitcoinAddress);
      A.List_List$unmodifiable(contacts, type$.ContactCore_BitcoinBaseAddress);
      A.List_List$unmodifiable(permissions, type$.Web3Permission_BitcoinBaseAddress);
      return new A.BitcoinChain(network);
    },
    BitcoinChain_BitcoinChain$deserialize(cbor, client, network) {
      var accounts, toAccounts, t1, t2, acc, addressIndex, contacts, cborContacts, totalBalance, permissions, t3;
      if (A.ExtractCborList_elementAt(cbor, 0, type$.int) !== network.value)
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      accounts = A.ExtractCborList_elementAt(cbor, 1, type$.nullable_List_CborObject);
      if (accounts == null)
        accounts = A._setArrayType([], type$.JSArray_CborObject);
      toAccounts = A._setArrayType([], type$.JSArray_IBitcoinAddress);
      for (t1 = J.get$iterator$ax(accounts), t2 = type$.IBitcoinAddress; t1.moveNext$0();) {
        acc = A.MethodUtils_nullOnException(new A.BitcoinChain_BitcoinChain$deserialize_closure(network, t1.get$current()), t2);
        if (acc != null)
          B.JSArray_methods.add$1(toAccounts, acc);
      }
      addressIndex = A.ExtractCborList_elementAt(cbor, 5, type$.nullable_int);
      if (addressIndex == null)
        addressIndex = 0;
      if (addressIndex >= toAccounts.length)
        addressIndex = 0;
      contacts = A._setArrayType([], type$.JSArray_ContactCore_BitcoinBaseAddress);
      t1 = type$.nullable_List_dynamic;
      cborContacts = A.ExtractCborList_elementAt(cbor, 3, t1);
      if (cborContacts != null) {
        t2 = J.map$1$1$ax(cborContacts, new A.BitcoinChain_BitcoinChain$deserialize_closure0(network), type$.ContactCore_BitcoinBaseAddress);
        contacts = A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      }
      totalBalance = A.ExtractCborList_elementAt(cbor, 4, type$.nullable_BigInt);
      t1 = A.ExtractCborList_elementAt(cbor, 8, t1);
      if (t1 == null)
        permissions = null;
      else {
        t1 = J.map$1$1$ax(t1, new A.BitcoinChain_BitcoinChain$deserialize_closure1(), type$.Web3Permission_BitcoinBaseAddress);
        permissions = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      }
      t1 = addressIndex < 0 ? 0 : addressIndex;
      t2 = totalBalance == null ? $.$get$_BigIntImpl_zero() : totalBalance;
      t3 = network.coinParam.token.decimal;
      t3.toString;
      t3 = A.IntegerBalance_IntegerBalance(t2, t3, false);
      t2 = permissions == null ? B.List_empty12 : permissions;
      return A.BitcoinChain$_(t1, toAccounts, client, contacts, network, t2, new A.Live(t3, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
    },
    CosmosChain$_(addressIndex, addresses, client, contacts, network, permissions, totalBalance) {
      A.List_List$unmodifiable(addresses, type$.ICosmosAddress);
      A.List_List$unmodifiable(contacts, type$.ContactCore_CosmosBaseAddress);
      A.List_List$unmodifiable(permissions, type$.Web3Permission_CosmosBaseAddress);
      return new A.CosmosChain(network);
    },
    CosmosChain_CosmosChain$deserialize(cbor, client, network) {
      var accounts, toAccounts, t1, t2, acc, addressIndex, contacts, cborContacts, totalBalance, permissions, t3;
      if (A.ExtractCborList_elementAt(cbor, 0, type$.int) !== network.value)
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      accounts = A.ExtractCborList_elementAt(cbor, 1, type$.nullable_List_CborObject);
      if (accounts == null)
        accounts = A._setArrayType([], type$.JSArray_CborObject);
      toAccounts = A._setArrayType([], type$.JSArray_ICosmosAddress);
      for (t1 = J.get$iterator$ax(accounts), t2 = type$.ICosmosAddress; t1.moveNext$0();) {
        acc = A.MethodUtils_nullOnException(new A.CosmosChain_CosmosChain$deserialize_closure(network, t1.get$current()), t2);
        if (acc != null)
          B.JSArray_methods.add$1(toAccounts, acc);
      }
      addressIndex = A.ExtractCborList_elementAt(cbor, 5, type$.nullable_int);
      if (addressIndex == null)
        addressIndex = 0;
      if (addressIndex >= toAccounts.length)
        addressIndex = 0;
      contacts = A._setArrayType([], type$.JSArray_ContactCore_CosmosBaseAddress);
      t1 = type$.nullable_List_dynamic;
      cborContacts = A.ExtractCborList_elementAt(cbor, 3, t1);
      if (cborContacts != null) {
        t2 = J.map$1$1$ax(cborContacts, new A.CosmosChain_CosmosChain$deserialize_closure0(network), type$.ContactCore_CosmosBaseAddress);
        contacts = A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      }
      totalBalance = A.ExtractCborList_elementAt(cbor, 4, type$.nullable_BigInt);
      t1 = A.ExtractCborList_elementAt(cbor, 8, t1);
      if (t1 == null)
        permissions = null;
      else {
        t1 = J.map$1$1$ax(t1, new A.CosmosChain_CosmosChain$deserialize_closure1(), type$.Web3Permission_CosmosBaseAddress);
        permissions = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      }
      t1 = addressIndex < 0 ? 0 : addressIndex;
      t2 = totalBalance == null ? $.$get$_BigIntImpl_zero() : totalBalance;
      t3 = network.coinParam.token.decimal;
      t3.toString;
      t3 = A.IntegerBalance_IntegerBalance(t2, t3, false);
      t2 = permissions == null ? B.List_empty9 : permissions;
      return A.CosmosChain$_(t1, toAccounts, client, contacts, network, t2, new A.Live(t3, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
    },
    EthereumChain$_(addressIndex, addresses, client, contacts, network, permissions, totalBalance) {
      A.List_List$unmodifiable(addresses, type$.IEthAddress);
      A.List_List$unmodifiable(contacts, type$.ContactCore_ETHAddress);
      A.List_List$unmodifiable(permissions, type$.Web3Permission_ETHAddress);
      return new A.EthereumChain(network);
    },
    EthereumChain_EthereumChain$deserialize(cbor, client, network) {
      var accounts, toAccounts, t1, t2, acc, addressIndex, contacts, cborContacts, totalBalance, permissions, t3;
      if (A.ExtractCborList_elementAt(cbor, 0, type$.int) !== network.value)
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      accounts = A.ExtractCborList_elementAt(cbor, 1, type$.nullable_List_CborObject);
      if (accounts == null)
        accounts = A._setArrayType([], type$.JSArray_CborObject);
      toAccounts = A._setArrayType([], type$.JSArray_IEthAddress);
      for (t1 = J.get$iterator$ax(accounts), t2 = type$.IEthAddress; t1.moveNext$0();) {
        acc = A.MethodUtils_nullOnException(new A.EthereumChain_EthereumChain$deserialize_closure(network, t1.get$current()), t2);
        if (acc != null)
          B.JSArray_methods.add$1(toAccounts, acc);
      }
      addressIndex = A.ExtractCborList_elementAt(cbor, 5, type$.nullable_int);
      if (addressIndex == null)
        addressIndex = 0;
      if (addressIndex >= toAccounts.length)
        addressIndex = 0;
      contacts = A._setArrayType([], type$.JSArray_ContactCore_ETHAddress);
      t1 = type$.nullable_List_dynamic;
      cborContacts = A.ExtractCborList_elementAt(cbor, 3, t1);
      if (cborContacts != null) {
        t2 = J.map$1$1$ax(cborContacts, new A.EthereumChain_EthereumChain$deserialize_closure0(network), type$.ContactCore_ETHAddress);
        contacts = A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      }
      totalBalance = A.ExtractCborList_elementAt(cbor, 4, type$.nullable_BigInt);
      t1 = A.ExtractCborList_elementAt(cbor, 8, t1);
      if (t1 == null)
        permissions = null;
      else {
        t1 = J.map$1$1$ax(t1, new A.EthereumChain_EthereumChain$deserialize_closure1(), type$.Web3Permission_ETHAddress);
        permissions = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      }
      t1 = addressIndex < 0 ? 0 : addressIndex;
      t2 = totalBalance == null ? $.$get$_BigIntImpl_zero() : totalBalance;
      t3 = network.coinParam.token.decimal;
      t3.toString;
      t3 = A.IntegerBalance_IntegerBalance(t2, t3, false);
      t2 = permissions == null ? B.List_empty10 : permissions;
      return A.EthereumChain$_(t1, toAccounts, client, contacts, network, t2, new A.Live(t3, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
    },
    SolanaChain$_(addressIndex, addresses, client, contacts, network, permissions, totalBalance) {
      A.List_List$unmodifiable(addresses, type$.ISolanaAddress);
      A.List_List$unmodifiable(contacts, type$.ContactCore_SolAddress);
      A.List_List$unmodifiable(permissions, type$.Web3Permission_SolAddress);
      return new A.SolanaChain(network);
    },
    SolanaChain_SolanaChain$deserialize(cbor, client, network) {
      var accounts, toAccounts, t1, t2, acc, addressIndex, contacts, cborContacts, totalBalance, permissions, t3;
      if (A.ExtractCborList_elementAt(cbor, 0, type$.int) !== network.value)
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      accounts = A.ExtractCborList_elementAt(cbor, 1, type$.nullable_List_CborObject);
      if (accounts == null)
        accounts = A._setArrayType([], type$.JSArray_CborObject);
      toAccounts = A._setArrayType([], type$.JSArray_ISolanaAddress);
      for (t1 = J.get$iterator$ax(accounts), t2 = type$.ISolanaAddress; t1.moveNext$0();) {
        acc = A.MethodUtils_nullOnException(new A.SolanaChain_SolanaChain$deserialize_closure(network, t1.get$current()), t2);
        if (acc != null)
          B.JSArray_methods.add$1(toAccounts, acc);
      }
      addressIndex = A.ExtractCborList_elementAt(cbor, 5, type$.nullable_int);
      if (addressIndex == null)
        addressIndex = 0;
      if (addressIndex >= toAccounts.length)
        addressIndex = 0;
      contacts = A._setArrayType([], type$.JSArray_ContactCore_SolAddress);
      t1 = type$.nullable_List_dynamic;
      cborContacts = A.ExtractCborList_elementAt(cbor, 3, t1);
      if (cborContacts != null) {
        t2 = J.map$1$1$ax(cborContacts, new A.SolanaChain_SolanaChain$deserialize_closure0(network), type$.ContactCore_SolAddress);
        contacts = A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      }
      totalBalance = A.ExtractCborList_elementAt(cbor, 4, type$.nullable_BigInt);
      t1 = A.ExtractCborList_elementAt(cbor, 8, t1);
      if (t1 == null)
        permissions = null;
      else {
        t1 = J.map$1$1$ax(t1, new A.SolanaChain_SolanaChain$deserialize_closure1(), type$.Web3Permission_SolAddress);
        permissions = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      }
      t1 = addressIndex < 0 ? 0 : addressIndex;
      t2 = totalBalance == null ? $.$get$_BigIntImpl_zero() : totalBalance;
      t3 = network.coinParam.token.decimal;
      t3.toString;
      t3 = A.IntegerBalance_IntegerBalance(t2, t3, false);
      t2 = permissions == null ? B.List_empty5 : permissions;
      return A.SolanaChain$_(t1, toAccounts, client, contacts, network, t2, new A.Live(t3, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
    },
    SubstrateChain$_(addressIndex, addresses, client, contacts, network, permissions, totalBalance) {
      A.List_List$unmodifiable(addresses, type$.ISubstrateAddress);
      A.List_List$unmodifiable(contacts, type$.ContactCore_SubstrateAddress);
      A.List_List$unmodifiable(permissions, type$.Web3Permission_SubstrateAddress);
      return new A.SubstrateChain(network);
    },
    SubstrateChain_SubstrateChain$deserialize(cbor, client, network) {
      var accounts, toAccounts, t1, t2, acc, addressIndex, contacts, cborContacts, totalBalance, permissions, t3;
      if (A.ExtractCborList_elementAt(cbor, 0, type$.int) !== network.value)
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      accounts = A.ExtractCborList_elementAt(cbor, 1, type$.nullable_List_CborObject);
      if (accounts == null)
        accounts = A._setArrayType([], type$.JSArray_CborObject);
      toAccounts = A._setArrayType([], type$.JSArray_ISubstrateAddress);
      for (t1 = J.get$iterator$ax(accounts), t2 = type$.ISubstrateAddress; t1.moveNext$0();) {
        acc = A.MethodUtils_nullOnException(new A.SubstrateChain_SubstrateChain$deserialize_closure(network, t1.get$current()), t2);
        if (acc != null)
          B.JSArray_methods.add$1(toAccounts, acc);
      }
      addressIndex = A.ExtractCborList_elementAt(cbor, 5, type$.nullable_int);
      if (addressIndex == null)
        addressIndex = 0;
      if (addressIndex >= toAccounts.length)
        addressIndex = 0;
      contacts = A._setArrayType([], type$.JSArray_ContactCore_SubstrateAddress);
      t1 = type$.nullable_List_dynamic;
      cborContacts = A.ExtractCborList_elementAt(cbor, 3, t1);
      if (cborContacts != null) {
        t2 = J.map$1$1$ax(cborContacts, new A.SubstrateChain_SubstrateChain$deserialize_closure0(network), type$.ContactCore_SubstrateAddress);
        contacts = A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      }
      totalBalance = A.ExtractCborList_elementAt(cbor, 4, type$.nullable_BigInt);
      t1 = A.ExtractCborList_elementAt(cbor, 8, t1);
      if (t1 == null)
        permissions = null;
      else {
        t1 = J.map$1$1$ax(t1, new A.SubstrateChain_SubstrateChain$deserialize_closure1(), type$.Web3Permission_SubstrateAddress);
        permissions = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      }
      t1 = addressIndex < 0 ? 0 : addressIndex;
      t2 = totalBalance == null ? $.$get$_BigIntImpl_zero() : totalBalance;
      t3 = network.coinParam.token.decimal;
      t3.toString;
      t3 = A.IntegerBalance_IntegerBalance(t2, t3, false);
      t2 = permissions == null ? B.List_empty11 : permissions;
      return A.SubstrateChain$_(t1, toAccounts, client, contacts, network, t2, new A.Live(t3, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
    },
    TonChain$_(addressIndex, addresses, client, contacts, network, permissions, totalBalance) {
      A.List_List$unmodifiable(addresses, type$.ITonAddress);
      A.List_List$unmodifiable(contacts, type$.ContactCore_TonAddress);
      A.List_List$unmodifiable(permissions, type$.Web3Permission_TonAddress);
      return new A.TonChain(network);
    },
    TonChain_TonChain$deserialize(cbor, client, network) {
      var accounts, toAccounts, t1, t2, acc, addressIndex, contacts, cborContacts, totalBalance, permissions, t3;
      if (A.ExtractCborList_elementAt(cbor, 0, type$.int) !== network.value)
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      accounts = A.ExtractCborList_elementAt(cbor, 1, type$.nullable_List_CborObject);
      if (accounts == null)
        accounts = A._setArrayType([], type$.JSArray_CborObject);
      toAccounts = A._setArrayType([], type$.JSArray_ITonAddress);
      for (t1 = J.get$iterator$ax(accounts), t2 = type$.ITonAddress; t1.moveNext$0();) {
        acc = A.MethodUtils_nullOnException(new A.TonChain_TonChain$deserialize_closure(network, t1.get$current()), t2);
        if (acc != null)
          B.JSArray_methods.add$1(toAccounts, acc);
      }
      addressIndex = A.ExtractCborList_elementAt(cbor, 5, type$.nullable_int);
      if (addressIndex == null)
        addressIndex = 0;
      if (addressIndex >= toAccounts.length)
        addressIndex = 0;
      contacts = A._setArrayType([], type$.JSArray_ContactCore_TonAddress);
      t1 = type$.nullable_List_dynamic;
      cborContacts = A.ExtractCborList_elementAt(cbor, 3, t1);
      if (cborContacts != null) {
        t2 = J.map$1$1$ax(cborContacts, new A.TonChain_TonChain$deserialize_closure0(network), type$.ContactCore_TonAddress);
        contacts = A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      }
      totalBalance = A.ExtractCborList_elementAt(cbor, 4, type$.nullable_BigInt);
      t1 = A.ExtractCborList_elementAt(cbor, 8, t1);
      if (t1 == null)
        permissions = null;
      else {
        t1 = J.map$1$1$ax(t1, new A.TonChain_TonChain$deserialize_closure1(), type$.Web3Permission_TonAddress);
        permissions = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      }
      t1 = addressIndex < 0 ? 0 : addressIndex;
      t2 = totalBalance == null ? $.$get$_BigIntImpl_zero() : totalBalance;
      t3 = network.coinParam.token.decimal;
      t3.toString;
      t3 = A.IntegerBalance_IntegerBalance(t2, t3, false);
      t2 = permissions == null ? B.List_empty8 : permissions;
      return A.TonChain$_(t1, toAccounts, client, contacts, network, t2, new A.Live(t3, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
    },
    TronChain$_(addressIndex, addresses, client, contacts, network, permissions, totalBalance) {
      A.List_List$unmodifiable(addresses, type$.ITronAddress);
      A.List_List$unmodifiable(contacts, type$.ContactCore_TronAddress);
      A.List_List$unmodifiable(permissions, type$.Web3Permission_TronAddress);
      return new A.TronChain(network);
    },
    TronChain_TronChain$deserialize(cbor, client, network) {
      var accounts, toAccounts, t1, t2, acc, addressIndex, contacts, cborContacts, totalBalance, permissions, t3;
      if (A.ExtractCborList_elementAt(cbor, 0, type$.int) !== network.value)
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      accounts = A.ExtractCborList_elementAt(cbor, 1, type$.nullable_List_CborObject);
      if (accounts == null)
        accounts = A._setArrayType([], type$.JSArray_CborObject);
      toAccounts = A._setArrayType([], type$.JSArray_ITronAddress);
      for (t1 = J.get$iterator$ax(accounts), t2 = type$.ITronAddress; t1.moveNext$0();) {
        acc = A.MethodUtils_nullOnException(new A.TronChain_TronChain$deserialize_closure(network, t1.get$current()), t2);
        if (acc != null)
          B.JSArray_methods.add$1(toAccounts, acc);
      }
      addressIndex = A.ExtractCborList_elementAt(cbor, 5, type$.nullable_int);
      if (addressIndex == null)
        addressIndex = 0;
      if (addressIndex >= toAccounts.length)
        addressIndex = 0;
      contacts = A._setArrayType([], type$.JSArray_ContactCore_TronAddress);
      t1 = type$.nullable_List_dynamic;
      cborContacts = A.ExtractCborList_elementAt(cbor, 3, t1);
      if (cborContacts != null) {
        t2 = J.map$1$1$ax(cborContacts, new A.TronChain_TronChain$deserialize_closure0(network), type$.ContactCore_TronAddress);
        contacts = A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      }
      totalBalance = A.ExtractCborList_elementAt(cbor, 4, type$.nullable_BigInt);
      t1 = A.ExtractCborList_elementAt(cbor, 8, t1);
      if (t1 == null)
        permissions = null;
      else {
        t1 = J.map$1$1$ax(t1, new A.TronChain_TronChain$deserialize_closure1(), type$.Web3Permission_TronAddress);
        permissions = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      }
      t1 = addressIndex < 0 ? 0 : addressIndex;
      t2 = totalBalance == null ? $.$get$_BigIntImpl_zero() : totalBalance;
      t3 = network.coinParam.token.decimal;
      t3.toString;
      t3 = A.IntegerBalance_IntegerBalance(t2, t3, false);
      t2 = permissions == null ? B.List_empty7 : permissions;
      return A.TronChain$_(t1, toAccounts, client, contacts, network, t2, new A.Live(t3, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
    },
    RippleChain$_(addressIndex, addresses, client, contacts, network, permissions, totalBalance) {
      A.List_List$unmodifiable(addresses, type$.IXRPAddress);
      A.List_List$unmodifiable(contacts, type$.ContactCore_XRPAddress);
      A.List_List$unmodifiable(permissions, type$.Web3Permission_XRPAddress);
      return new A.RippleChain(network);
    },
    RippleChain_RippleChain$deserialize(cbor, client, network) {
      var accounts, toAccounts, t1, t2, acc, addressIndex, contacts, cborContacts, totalBalance, permissions, t3;
      if (A.ExtractCborList_elementAt(cbor, 0, type$.int) !== network.value)
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      accounts = A.ExtractCborList_elementAt(cbor, 1, type$.nullable_List_CborObject);
      if (accounts == null)
        accounts = A._setArrayType([], type$.JSArray_CborObject);
      toAccounts = A._setArrayType([], type$.JSArray_IXRPAddress);
      for (t1 = J.get$iterator$ax(accounts), t2 = type$.IXRPAddress; t1.moveNext$0();) {
        acc = A.MethodUtils_nullOnException(new A.RippleChain_RippleChain$deserialize_closure(network, t1.get$current()), t2);
        if (acc != null)
          B.JSArray_methods.add$1(toAccounts, acc);
      }
      addressIndex = A.ExtractCborList_elementAt(cbor, 5, type$.nullable_int);
      if (addressIndex == null)
        addressIndex = 0;
      if (addressIndex >= toAccounts.length)
        addressIndex = 0;
      contacts = A._setArrayType([], type$.JSArray_ContactCore_XRPAddress);
      t1 = type$.nullable_List_dynamic;
      cborContacts = A.ExtractCborList_elementAt(cbor, 3, t1);
      if (cborContacts != null) {
        t2 = J.map$1$1$ax(cborContacts, new A.RippleChain_RippleChain$deserialize_closure0(network), type$.ContactCore_XRPAddress);
        contacts = A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      }
      totalBalance = A.ExtractCborList_elementAt(cbor, 4, type$.nullable_BigInt);
      t1 = A.ExtractCborList_elementAt(cbor, 8, t1);
      if (t1 == null)
        permissions = null;
      else {
        t1 = J.map$1$1$ax(t1, new A.RippleChain_RippleChain$deserialize_closure1(), type$.Web3Permission_XRPAddress);
        permissions = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      }
      t1 = addressIndex < 0 ? 0 : addressIndex;
      t2 = totalBalance == null ? $.$get$_BigIntImpl_zero() : totalBalance;
      t3 = network.coinParam.token.decimal;
      t3.toString;
      t3 = A.IntegerBalance_IntegerBalance(t2, t3, false);
      t2 = permissions == null ? B.List_empty6 : permissions;
      return A.RippleChain$_(t1, toAccounts, client, contacts, network, t2, new A.Live(t3, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance));
    },
    Chain: function Chain() {
    },
    Chain_Chain$fromCborBytesOrObject_closure: function Chain_Chain$fromCborBytesOrObject_closure(t0) {
      this.values = t0;
    },
    Chain_Chain$fromCborBytesOrObject_closure0: function Chain_Chain$fromCborBytesOrObject_closure0(t0, t1) {
      this._box_0 = t0;
      this.values = t1;
    },
    Chain_Chain$fromCborBytesOrObject_closure1: function Chain_Chain$fromCborBytesOrObject_closure1(t0) {
      this.values = t0;
    },
    Chain_Chain$fromCborBytesOrObject_closure2: function Chain_Chain$fromCborBytesOrObject_closure2(t0, t1) {
      this._box_0 = t0;
      this.values = t1;
    },
    ADAChain: function ADAChain(t0) {
      this.network = t0;
    },
    ADAChain_ADAChain$deserialize_closure: function ADAChain_ADAChain$deserialize_closure(t0, t1) {
      this.network = t0;
      this.i = t1;
    },
    ADAChain_ADAChain$deserialize_closure0: function ADAChain_ADAChain$deserialize_closure0(t0) {
      this.network = t0;
    },
    ADAChain_ADAChain$deserialize_closure1: function ADAChain_ADAChain$deserialize_closure1() {
    },
    BitcoinChain: function BitcoinChain(t0) {
      this.network = t0;
    },
    BitcoinChain_BitcoinChain$deserialize_closure: function BitcoinChain_BitcoinChain$deserialize_closure(t0, t1) {
      this.network = t0;
      this.i = t1;
    },
    BitcoinChain_BitcoinChain$deserialize_closure0: function BitcoinChain_BitcoinChain$deserialize_closure0(t0) {
      this.network = t0;
    },
    BitcoinChain_BitcoinChain$deserialize_closure1: function BitcoinChain_BitcoinChain$deserialize_closure1() {
    },
    CosmosChain: function CosmosChain(t0) {
      this.network = t0;
    },
    CosmosChain_CosmosChain$deserialize_closure: function CosmosChain_CosmosChain$deserialize_closure(t0, t1) {
      this.network = t0;
      this.i = t1;
    },
    CosmosChain_CosmosChain$deserialize_closure0: function CosmosChain_CosmosChain$deserialize_closure0(t0) {
      this.network = t0;
    },
    CosmosChain_CosmosChain$deserialize_closure1: function CosmosChain_CosmosChain$deserialize_closure1() {
    },
    EthereumChain: function EthereumChain(t0) {
      this.network = t0;
    },
    EthereumChain_EthereumChain$deserialize_closure: function EthereumChain_EthereumChain$deserialize_closure(t0, t1) {
      this.network = t0;
      this.i = t1;
    },
    EthereumChain_EthereumChain$deserialize_closure0: function EthereumChain_EthereumChain$deserialize_closure0(t0) {
      this.network = t0;
    },
    EthereumChain_EthereumChain$deserialize_closure1: function EthereumChain_EthereumChain$deserialize_closure1() {
    },
    SolanaChain: function SolanaChain(t0) {
      this.network = t0;
    },
    SolanaChain_SolanaChain$deserialize_closure: function SolanaChain_SolanaChain$deserialize_closure(t0, t1) {
      this.network = t0;
      this.i = t1;
    },
    SolanaChain_SolanaChain$deserialize_closure0: function SolanaChain_SolanaChain$deserialize_closure0(t0) {
      this.network = t0;
    },
    SolanaChain_SolanaChain$deserialize_closure1: function SolanaChain_SolanaChain$deserialize_closure1() {
    },
    SubstrateChain: function SubstrateChain(t0) {
      this.network = t0;
    },
    SubstrateChain_SubstrateChain$deserialize_closure: function SubstrateChain_SubstrateChain$deserialize_closure(t0, t1) {
      this.network = t0;
      this.i = t1;
    },
    SubstrateChain_SubstrateChain$deserialize_closure0: function SubstrateChain_SubstrateChain$deserialize_closure0(t0) {
      this.network = t0;
    },
    SubstrateChain_SubstrateChain$deserialize_closure1: function SubstrateChain_SubstrateChain$deserialize_closure1() {
    },
    TonChain: function TonChain(t0) {
      this.network = t0;
    },
    TonChain_TonChain$deserialize_closure: function TonChain_TonChain$deserialize_closure(t0, t1) {
      this.network = t0;
      this.i = t1;
    },
    TonChain_TonChain$deserialize_closure0: function TonChain_TonChain$deserialize_closure0(t0) {
      this.network = t0;
    },
    TonChain_TonChain$deserialize_closure1: function TonChain_TonChain$deserialize_closure1() {
    },
    TronChain: function TronChain(t0) {
      this.network = t0;
    },
    TronChain_TronChain$deserialize_closure: function TronChain_TronChain$deserialize_closure(t0, t1) {
      this.network = t0;
      this.i = t1;
    },
    TronChain_TronChain$deserialize_closure0: function TronChain_TronChain$deserialize_closure0(t0) {
      this.network = t0;
    },
    TronChain_TronChain$deserialize_closure1: function TronChain_TronChain$deserialize_closure1() {
    },
    RippleChain: function RippleChain(t0) {
      this.network = t0;
    },
    RippleChain_RippleChain$deserialize_closure: function RippleChain_RippleChain$deserialize_closure(t0, t1) {
      this.network = t0;
      this.i = t1;
    },
    RippleChain_RippleChain$deserialize_closure0: function RippleChain_RippleChain$deserialize_closure0(t0) {
      this.network = t0;
    },
    RippleChain_RippleChain$deserialize_closure1: function RippleChain_RippleChain$deserialize_closure1() {
    },
    _Chain_Object_CborSerializable: function _Chain_Object_CborSerializable() {
    },
    IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(currencyDecimal, obj) {
      var cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_80, type$.CborListValue_dynamic),
        address = A.ExtractCborList_elementAt(cbor, 0, type$.String),
        balance = A.ExtractCborList_elementAt(cbor, 1, type$.BigInt);
      A.ExtractCborList_elementAt(cbor, 2, type$.DateTime);
      A.IntegerBalance_IntegerBalance(balance, currencyDecimal, false);
      return new A.AccountBalance(address);
    },
    AccountBalance: function AccountBalance(t0) {
      this.address = t0;
    },
    CryptoAddress_fromCbor(network, cbor) {
      var address, t1, t2, coin, keyIndex, networkId, t3, adaAddress, cbor0, t4, t5, t6, t7, addrDetails, rewardIndexCbor, rewardIndex, proposal, publicKey, hrp, ss58Format, _null = null;
      if (!(cbor instanceof A.CborTagValue))
        throw A.wrapException($.$get$WalletExceptionConst_invalidAccountDetails());
      switch (network.get$type()) {
        case B.NetworkType_8eb:
          address = A.IBitcoinAddress_IBitcoinAddress$fromCborBytesOrObject(network, cbor);
          break;
        case B.NetworkType_8eb0:
          address = A.IBitcoinCashAddress_IBitcoinCashAddress$fromCborBytesOrObject(network, cbor);
          break;
        case B.NetworkType_Oh2:
          address = A.IXRPAddress_IXRPAddress$fromCborBytesOrObject(network, cbor);
          break;
        case B.NetworkType_iDZ:
          address = A.IEthAddress_IEthAddress$fromCborBytesOrObject(network, cbor);
          break;
        case B.NetworkType_SkF:
          address = A.ITronAddress_ITronAddress$fromCborBytesOrObject(network, cbor);
          break;
        case B.NetworkType_4QF:
          address = A.ISolanaAddress_ISolanaAddress$fromCborBytesOrObject(network, cbor);
          break;
        case B.NetworkType_4ei:
          t1 = type$.CborListValue_dynamic;
          cbor = A.CborSerializable_decodeCborTags(_null, cbor, B.List_200_197, t1);
          t2 = type$.String;
          coin = A.CustomCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t2), A.ExtractCborList_elementAt(cbor, 0, t2), type$.CryptoCoins_CoinConfig);
          keyIndex = A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
          networkId = A.ExtractCborList_elementAt(cbor, 6, type$.dynamic);
          if (!J.$eq$(networkId, network.get$value()))
            A.throwExpression($.$get$WalletExceptionConst_incorrectNetwork());
          t3 = network.get$coinParam().token.decimal;
          t3.toString;
          A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t3, A.ExtractCborList_getCborTag(cbor, 4));
          adaAddress = A.ADAAddress_fromAddress(A.ExtractCborList_elementAt(cbor, 5, t2), type$.ADAAddress);
          cbor0 = A.CborSerializable_decodeCborTags(_null, A.ExtractCborList_getCborTag(cbor, 7), B.List_200_197_100, t1);
          t1 = A.ExtractCborList_elementAt(cbor0, 0, type$.List_int);
          t2 = A.ADAAddressType_fromHeader(A.ExtractCborList_elementAt(cbor0, 1, type$.nullable_int));
          t3 = type$.nullable_List_int;
          t4 = A.ExtractCborList_elementAt(cbor0, 2, t3);
          t5 = A.ExtractCborList_elementAt(cbor0, 3, t3);
          t3 = A.ExtractCborList_elementAt(cbor0, 4, t3);
          t6 = type$.nullable_String;
          t7 = A.ExtractCborList_elementAt(cbor0, 5, t6);
          addrDetails = new A.CardanoAddrDetails(A.BytesUtils_toBytes(t1, true), A.BytesUtils_tryToBytes(t4, true), A.BytesUtils_tryToBytes(t5, true), A.BytesUtils_tryToBytes(t3, true), t7, t2);
          if (addrDetails.toAddress$2(coin, !network.get$coinParam().get$mainnet()).get$address() !== adaAddress.get$address())
            A.throwExpression(A.WalletException$("Incorrect ADA addresss."));
          A.ExtractCborList_elementAt(cbor, 10, t6);
          rewardIndexCbor = A.ExtractCborList_getCborTag(cbor, 11);
          rewardIndex = rewardIndexCbor == null ? _null : A.Bip32AddressIndex_Bip32AddressIndex$fromCborBytesOrObject(rewardIndexCbor);
          if (adaAddress.get$addressType() === B.ADAAddressType_0_Base && rewardIndex == null)
            A.throwExpression($.$get$WalletExceptionConst_invalidAccountDetails());
          A._asInt(networkId);
          t1 = A._setArrayType([], type$.JSArray_TokenCore_dynamic);
          t2 = A._setArrayType([], type$.JSArray_NFTCore);
          A.List_List$unmodifiable(t1, type$.TokenCore_BigInt);
          A.List_List$unmodifiable(t2, type$.NFTCore);
          A.CardanoUtils_extractRewardAddress(adaAddress);
          address = new A.ICardanoAddress(keyIndex, networkId, addrDetails, adaAddress);
          break;
        case B.NetworkType_QJm:
          cbor = A.CborSerializable_decodeCborTags(_null, cbor, B.List_200_198, type$.CborListValue_dynamic);
          t1 = type$.String;
          proposal = A.CoinProposal_fromName(A.ExtractCborList_elementAt(cbor, 0, t1));
          A.CryptoCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), proposal).toString;
          keyIndex = A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
          publicKey = A.ExtractCborList_elementAt(cbor, 3, type$.List_int);
          networkId = A.ExtractCborList_elementAt(cbor, 6, type$.dynamic);
          if (!J.$eq$(networkId, network.get$value()))
            A.throwExpression($.$get$WalletExceptionConst_incorrectNetwork());
          t2 = network.get$coinParam().token.decimal;
          t2.toString;
          A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t2, A.ExtractCborList_getCborTag(cbor, 4));
          hrp = A.ExtractCborList_elementAt(cbor, 10, t1);
          A.CosmosAddrUtils_decodeBytes(A.ExtractCborList_elementAt(cbor, 5, t1), hrp);
          A.ExtractCborList_elementAt(cbor, 9, type$.nullable_String);
          A._asInt(networkId);
          t1 = A._setArrayType([], type$.JSArray_TokenCore_BigInt);
          t2 = A._setArrayType([], type$.JSArray_NFTCore);
          A.List_List$unmodifiable(publicKey, type$.int);
          A.List_List$unmodifiable(t1, type$.TokenCore_BigInt);
          A.List_List$unmodifiable(t2, type$.NFTCore);
          address = new A.ICosmosAddress(keyIndex, networkId);
          break;
        case B.NetworkType_66M:
          address = A.ITonAddress_ITonAddress$fromCborBytesOrObject(network, cbor);
          break;
        case B.NetworkType_GRA:
        case B.NetworkType_0:
          cbor = A.CborSerializable_decodeCborTags(_null, cbor, B.List_200_200, type$.CborListValue_dynamic);
          t1 = type$.String;
          A.CustomCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), A.ExtractCborList_elementAt(cbor, 0, t1), type$.CryptoCoins_CoinConfig);
          keyIndex = A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
          publicKey = A.ExtractCborList_elementAt(cbor, 3, type$.List_int);
          t2 = network.get$coinParam().token.decimal;
          t2.toString;
          A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t2, A.ExtractCborList_getCborTag(cbor, 4));
          t2 = type$.int;
          ss58Format = A.ExtractCborList_elementAt(cbor, 10, t2);
          A.SubstrateAddress_SubstrateAddress(A.ExtractCborList_elementAt(cbor, 5, t1), ss58Format);
          networkId = A.ExtractCborList_elementAt(cbor, 6, type$.dynamic);
          if (!J.$eq$(networkId, network.get$value()))
            A.throwExpression($.$get$WalletExceptionConst_incorrectNetwork());
          A.ExtractCborList_elementAt(cbor, 9, type$.nullable_String);
          A._asInt(networkId);
          t1 = A._setArrayType([], type$.JSArray_TokenCore_dynamic);
          t3 = A._setArrayType([], type$.JSArray_NFTCore);
          A.List_List$unmodifiable(publicKey, t2);
          A.List_List$unmodifiable(t1, type$.TokenCore_dynamic);
          A.List_List$unmodifiable(t3, type$.NFTCore);
          address = new A.ISubstrateAddress(keyIndex, networkId);
          break;
        default:
          throw A.wrapException(A.UnimplementedError$("Network does not exists. "));
      }
      return address;
    },
    ChainAccount: function ChainAccount() {
    },
    CryptoAddress: function CryptoAddress() {
    },
    _CryptoAddress_Object_CborSerializable: function _CryptoAddress_Object_CborSerializable() {
    },
    IBitcoinCashAddress$_(accountName, address, addressType, coin, keyIndex, network, networkAddress, publicKey) {
      A.List_List$unmodifiable(publicKey, type$.int);
      return new A.IBitcoinCashAddress(addressType, keyIndex, network);
    },
    IBitcoinCashAddress_IBitcoinCashAddress$fromCborBytesOrObject(network, obj) {
      var cbor, t1, proposal, multiSignatureAddress, t2, t3, t4, t5, address, bitcoinAddressType, keyIndex, publicKey, bitcoinAddress;
      type$.WalletBitcoinCashNetwork._as(network);
      if (A.BytesUtils_bytesEqual(obj.tags, B.List_200_191_1)) {
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_191_1, type$.CborListValue_dynamic);
        t1 = type$.String;
        proposal = A.CoinProposal_fromName(A.ExtractCborList_elementAt(cbor, 0, t1));
        A.CryptoCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), proposal).toString;
        multiSignatureAddress = A.BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
        t2 = type$.int;
        t3 = network.value;
        if (A.ExtractCborList_elementAt(cbor, 5, t2) !== t3)
          A.throwExpression($.$get$WalletExceptionConst_incorrectNetwork());
        t4 = network.coinParam;
        t5 = t4.token.decimal;
        t5.toString;
        address = A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t5, A.ExtractCborList_getCborTag(cbor, 3));
        bitcoinAddressType = A.BitcoinAddressType_fromValue(A.ExtractCborList_elementAt(cbor, 4, t1));
        keyIndex = A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 6));
        if (bitcoinAddressType !== A.BlockchainAddressUtils_toBitcoinAddress(address.address, t4.transacationNetwork, bitcoinAddressType).get$type())
          A.throwExpression($.$get$WalletExceptionConst_invalidAccountDetails());
        A.ExtractCborList_elementAt(cbor, 7, type$.nullable_String);
        A.List_List$unmodifiable(B.List_empty4, t2);
        return new A.IBitcoinCashMultiSigAddress(multiSignatureAddress, bitcoinAddressType, keyIndex, t3);
      }
      cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_191, type$.CborListValue_dynamic);
      t1 = type$.String;
      proposal = A.CoinProposal_fromName(A.ExtractCborList_elementAt(cbor, 0, t1));
      t2 = A.CryptoCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), proposal);
      t2.toString;
      keyIndex = A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      publicKey = A.ExtractCborList_elementAt(cbor, 3, type$.List_int);
      t3 = network.value;
      if (!J.$eq$(A.ExtractCborList_elementAt(cbor, 6, type$.dynamic), t3))
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      t4 = network.coinParam;
      t5 = t4.token.decimal;
      t5.toString;
      address = A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t5, A.ExtractCborList_getCborTag(cbor, 4));
      bitcoinAddressType = A.BitcoinAddressType_fromValue(A.ExtractCborList_elementAt(cbor, 5, t1));
      bitcoinAddress = A.BlockchainAddressUtils_publicKeyToBitcoinAddress(publicKey, t2, bitcoinAddressType);
      if (bitcoinAddress.toAddress$1(t4.transacationNetwork) !== address.address)
        throw A.wrapException($.$get$WalletExceptionConst_invalidAccountDetails());
      return A.IBitcoinCashAddress$_(A.ExtractCborList_elementAt(cbor, 7, type$.nullable_String), address, bitcoinAddressType, t2, keyIndex, t3, bitcoinAddress, publicKey);
    },
    IBitcoinCashAddress: function IBitcoinCashAddress(t0, t1, t2) {
      this.addressType = t0;
      this.keyIndex = t1;
      this.network = t2;
    },
    IBitcoinCashMultiSigAddress: function IBitcoinCashMultiSigAddress(t0, t1, t2, t3) {
      var _ = this;
      _.multiSignatureAddress = t0;
      _.addressType = t1;
      _.keyIndex = t2;
      _.network = t3;
    },
    _IBitcoinCashMultiSigAddress_IBitcoinCashAddress_BitcoinMultiSigBase: function _IBitcoinCashMultiSigAddress_IBitcoinCashAddress_BitcoinMultiSigBase() {
    },
    IBitcoinAddress_IBitcoinAddress$fromCborBytesOrObject(network, obj) {
      var cbor, t1, proposal, multiSignatureAddress, t2, t3, bitcoinAddressType, keyIndex, publicKey, address, bitcoinAddress;
      if (A.BytesUtils_bytesEqual(obj.tags, B.List_200_192_1)) {
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_192_1, type$.CborListValue_dynamic);
        t1 = type$.String;
        proposal = A.CoinProposal_fromName(A.ExtractCborList_elementAt(cbor, 0, t1));
        A.CryptoCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), proposal).toString;
        multiSignatureAddress = A.BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
        t2 = type$.int;
        if (A.ExtractCborList_elementAt(cbor, 5, t2) !== network.get$value())
          A.throwExpression($.$get$WalletExceptionConst_incorrectNetwork());
        t3 = network.get$coinParam().token.decimal;
        t3.toString;
        A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t3, A.ExtractCborList_getCborTag(cbor, 3));
        bitcoinAddressType = A.BitcoinAddressType_fromValue(A.ExtractCborList_elementAt(cbor, 4, t1));
        keyIndex = A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 6));
        A.ExtractCborList_elementAt(cbor, 7, type$.nullable_String);
        multiSignatureAddress.fromType$2$addressType$network(bitcoinAddressType, network.toNetwork$1$0(type$.WalletBitcoinNetwork).coinParam.transacationNetwork);
        t1 = network.get$value();
        A.List_List$unmodifiable(B.List_empty4, t2);
        return new A.IBitcoinMultiSigAddress(multiSignatureAddress, bitcoinAddressType, keyIndex, t1);
      }
      cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_192, type$.CborListValue_dynamic);
      t1 = type$.String;
      proposal = A.CoinProposal_fromName(A.ExtractCborList_elementAt(cbor, 0, t1));
      t2 = A.CryptoCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), proposal);
      t2.toString;
      keyIndex = A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      publicKey = A.ExtractCborList_elementAt(cbor, 3, type$.List_int);
      if (!J.$eq$(A.ExtractCborList_elementAt(cbor, 6, type$.dynamic), network.get$value()))
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      t3 = network.get$coinParam().token.decimal;
      t3.toString;
      address = A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t3, A.ExtractCborList_getCborTag(cbor, 4));
      bitcoinAddressType = A.BitcoinAddressType_fromValue(A.ExtractCborList_elementAt(cbor, 5, t1));
      bitcoinAddress = A.BlockchainAddressUtils_publicKeyToBitcoinAddress(publicKey, t2, bitcoinAddressType);
      type$.WalletBitcoinNetwork._as(network);
      if (bitcoinAddress.toAddress$1(network.coinParam.transacationNetwork) !== address.address)
        throw A.wrapException($.$get$WalletExceptionConst_invalidAccountDetails());
      A.ExtractCborList_elementAt(cbor, 7, type$.nullable_String);
      A.List_List$unmodifiable(publicKey, type$.int);
      return new A.IBitcoinAddress(bitcoinAddressType, keyIndex, network.value);
    },
    IBitcoinAddress: function IBitcoinAddress(t0, t1, t2) {
      this.addressType = t0;
      this.keyIndex = t1;
      this.network = t2;
    },
    IBitcoinMultiSigAddress: function IBitcoinMultiSigAddress(t0, t1, t2, t3) {
      var _ = this;
      _.multiSignatureAddress = t0;
      _.addressType = t1;
      _.keyIndex = t2;
      _.network = t3;
    },
    _IBitcoinAddress_ChainAccount_Equatable: function _IBitcoinAddress_ChainAccount_Equatable() {
    },
    _IBitcoinMultiSigAddress_IBitcoinAddress_BitcoinMultiSigBase: function _IBitcoinMultiSigAddress_IBitcoinAddress_BitcoinMultiSigBase() {
    },
    BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject(obj) {
      var cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_192_1_0, type$.CborListValue_dynamic),
        t1 = type$.List_dynamic,
        t2 = J.map$1$1$ax(A.ExtractCborList_elementAt(cbor, 0, t1), new A.BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject_closure(), type$.BitcoinMultiSigSignerDetais);
      A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      A.ExtractCborList_elementAt(cbor, 1, type$.int);
      t1 = J.map$1$1$ax(A.ExtractCborList_elementAt(cbor, 2, t1), new A.BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject_closure0(), type$.String);
      return new A.BitcoinMultiSignatureAddress(new A.Script(A.List_List$unmodifiable(A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E")), type$.dynamic)));
    },
    BitcoinMultiSigBase: function BitcoinMultiSigBase() {
    },
    BitcoinMultiSigSignerDetais: function BitcoinMultiSigSignerDetais(t0, t1, t2) {
      this.publicKey = t0;
      this._wieght = t1;
      this.keyIndex = t2;
    },
    BitcoinMultiSignatureAddress: function BitcoinMultiSignatureAddress(t0) {
      this.multiSigScript = t0;
    },
    BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject_closure: function BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject_closure() {
    },
    BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject_closure0: function BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject_closure0() {
    },
    BitcoinMultiSignatureAddress_toP2shAddress_closure: function BitcoinMultiSignatureAddress_toP2shAddress_closure() {
    },
    _BitcoinMultiSigSignerDetais_Object_Equatable: function _BitcoinMultiSigSignerDetais_Object_Equatable() {
    },
    _BitcoinMultiSigSignerDetais_Object_Equatable_CborSerializable: function _BitcoinMultiSigSignerDetais_Object_Equatable_CborSerializable() {
    },
    _BitcoinMultiSignatureAddress_Object_CborSerializable: function _BitcoinMultiSignatureAddress_Object_CborSerializable() {
    },
    ICardanoAddress: function ICardanoAddress(t0, t1, t2, t3) {
      var _ = this;
      _.keyIndex = t0;
      _.network = t1;
      _.addressDetails = t2;
      _.networkAddress = t3;
    },
    _ICardanoAddress_ChainAccount_Equatable: function _ICardanoAddress_ChainAccount_Equatable() {
    },
    ICosmosAddress: function ICosmosAddress(t0, t1) {
      this.keyIndex = t0;
      this.network = t1;
    },
    _ICosmosAddress_ChainAccount_Equatable: function _ICosmosAddress_ChainAccount_Equatable() {
    },
    IEthAddress_IEthAddress$fromCborBytesOrObject(network, obj) {
      var keyIndex, networkId, t2, erc20Tokens, tokens,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_194, type$.CborListValue_dynamic),
        t1 = type$.String,
        proposal = A.CoinProposal_fromName(A.ExtractCborList_elementAt(cbor, 0, t1));
      A.CryptoCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), proposal).toString;
      keyIndex = A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      networkId = A.ExtractCborList_elementAt(cbor, 6, type$.dynamic);
      if (!J.$eq$(networkId, network.get$value()))
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      t2 = network.get$coinParam().token.decimal;
      t2.toString;
      A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t2, A.ExtractCborList_getCborTag(cbor, 4));
      A.ETHAddress_ETHAddress(A.ExtractCborList_elementAt(cbor, 5, t1));
      erc20Tokens = A._setArrayType([], type$.JSArray_ETHERC20Token);
      tokens = A.ExtractCborList_elementAt(cbor, 7, type$.nullable_List_dynamic);
      if (tokens != null)
        for (t1 = J.get$iterator$ax(tokens), t2 = type$.nullable_CborObject; t1.moveNext$0();)
          B.JSArray_methods.add$1(erc20Tokens, A.ETHERC20Token_ETHERC20Token$fromCborBytesOrObject(t2._as(t1.get$current())));
      A.ExtractCborList_elementAt(cbor, 9, type$.nullable_String);
      A._asInt(networkId);
      t1 = A._setArrayType([], type$.JSArray_RippleNFToken);
      A.List_List$unmodifiable(erc20Tokens, type$.ETHERC20Token);
      A.List_List$unmodifiable(t1, type$.NFTCore);
      return new A.IEthAddress(keyIndex, networkId);
    },
    IEthAddress: function IEthAddress(t0, t1) {
      this.keyIndex = t0;
      this.network = t1;
    },
    _IEthAddress_ChainAccount_Equatable: function _IEthAddress_ChainAccount_Equatable() {
    },
    ISolanaAddress_ISolanaAddress$fromCborBytesOrObject(network, obj) {
      var keyIndex, networkId, t2, splTokens, tokens,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_196, type$.CborListValue_dynamic),
        t1 = type$.String,
        proposal = A.CoinProposal_fromName(A.ExtractCborList_elementAt(cbor, 0, t1));
      A.CryptoCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), proposal).toString;
      keyIndex = A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      networkId = A.ExtractCborList_elementAt(cbor, 6, type$.dynamic);
      if (!J.$eq$(networkId, network.get$value()))
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      t2 = network.get$coinParam().token.decimal;
      t2.toString;
      A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t2, A.ExtractCborList_getCborTag(cbor, 4));
      new A.SolAddrDecoder().decodeAddr$1(A.ExtractCborList_elementAt(cbor, 5, t1));
      splTokens = A._setArrayType([], type$.JSArray_SolanaSPLToken);
      tokens = A.ExtractCborList_elementAt(cbor, 7, type$.nullable_List_dynamic);
      if (tokens != null)
        for (t1 = J.get$iterator$ax(tokens), t2 = type$.nullable_CborObject; t1.moveNext$0();)
          B.JSArray_methods.add$1(splTokens, A.SolanaSPLToken_SolanaSPLToken$fromCborBytesOrObject(t2._as(t1.get$current())));
      A.ExtractCborList_elementAt(cbor, 9, type$.nullable_String);
      A._asInt(networkId);
      t1 = A._setArrayType([], type$.JSArray_NFTCore);
      A.List_List$unmodifiable(splTokens, type$.SolanaSPLToken);
      A.List_List$unmodifiable(t1, type$.NFTCore);
      return new A.ISolanaAddress(keyIndex, networkId);
    },
    ISolanaAddress: function ISolanaAddress(t0, t1) {
      this.keyIndex = t0;
      this.network = t1;
    },
    _ISolanaAddress_ChainAccount_Equatable: function _ISolanaAddress_ChainAccount_Equatable() {
    },
    ISubstrateAddress: function ISubstrateAddress(t0, t1) {
      this.keyIndex = t0;
      this.network = t1;
    },
    _ISubstrateAddress_ChainAccount_Equatable: function _ISubstrateAddress_ChainAccount_Equatable() {
    },
    ITonAddress_ITonAddress$fromCborBytesOrObject(network, obj) {
      var keyIndex, publicKey, t2, networkId, t3, t4, tokens,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_199, type$.CborListValue_dynamic),
        t1 = type$.String,
        proposal = A.CoinProposal_fromName(A.ExtractCborList_elementAt(cbor, 0, t1));
      A.CryptoCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), proposal).toString;
      keyIndex = A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      publicKey = A.ExtractCborList_elementAt(cbor, 3, type$.List_int);
      t2 = network.get$coinParam().token.decimal;
      t2.toString;
      A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t2, A.ExtractCborList_getCborTag(cbor, 4));
      A.TonAddress_TonAddress(A.ExtractCborList_elementAt(cbor, 5, t1));
      t1 = type$.int;
      networkId = A.ExtractCborList_elementAt(cbor, 6, t1);
      if (networkId !== network.get$value())
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      t2 = type$.nullable_String;
      A.WalletVersion_WalletVersion$fromValue(A.ExtractCborList_elementAt(cbor, 7, t2));
      A.ExtractCborList_elementAt(cbor, 8, type$.nullable_int);
      t3 = type$.TonJettonToken;
      t4 = J.map$1$1$ax(A.ExtractCborList_elementAt(cbor, 9, type$.List_dynamic), new A.ITonAddress_ITonAddress$fromCborBytesOrObject_closure(), t3);
      tokens = A.List_List$of(t4, true, t4.$ti._eval$1("ListIterable.E"));
      A.ExtractCborList_elementAt(cbor, 11, t2);
      t2 = A._setArrayType([], type$.JSArray_NFTCore);
      A.ExtractCborList_elementAt(cbor, 12, type$.bool);
      A.List_List$unmodifiable(publicKey, t1);
      A.List_List$unmodifiable(tokens, t3);
      A.List_List$unmodifiable(t2, type$.NFTCore);
      return new A.ITonAddress(keyIndex, networkId);
    },
    ITonAddress: function ITonAddress(t0, t1) {
      this.keyIndex = t0;
      this.network = t1;
    },
    ITonAddress_ITonAddress$fromCborBytesOrObject_closure: function ITonAddress_ITonAddress$fromCborBytesOrObject_closure() {
    },
    _ITonAddress_ChainAccount_Equatable: function _ITonAddress_ChainAccount_Equatable() {
    },
    TronMultiSignatureAddress_TronMultiSignatureAddress$fromCborBytesOrObject(obj) {
      var cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_195_1_0, type$.CborListValue_dynamic),
        t1 = J.map$1$1$ax(A.ExtractCborList_elementAt(cbor, 0, type$.List_dynamic), new A.TronMultiSignatureAddress_TronMultiSignatureAddress$fromCborBytesOrObject_closure(), type$.TronMultiSigSignerDetais);
      return new A.TronMultiSignatureAddress(A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E")), A.ExtractCborList_elementAt(cbor, 1, type$.BigInt), A.ExtractCborList_elementAt(cbor, 2, type$.nullable_int));
    },
    TronMultiSigSignerDetais: function TronMultiSigSignerDetais(t0, t1, t2) {
      this.publicKey = t0;
      this.weight = t1;
      this.keyIndex = t2;
    },
    TronMultiSignatureAddress: function TronMultiSignatureAddress(t0, t1, t2) {
      this.signers = t0;
      this.threshold = t1;
      this.permissionID = t2;
    },
    TronMultiSignatureAddress_TronMultiSignatureAddress$fromCborBytesOrObject_closure: function TronMultiSignatureAddress_TronMultiSignatureAddress$fromCborBytesOrObject_closure() {
    },
    _TronMultiSigSignerDetais_Object_Equatable: function _TronMultiSigSignerDetais_Object_Equatable() {
    },
    _TronMultiSigSignerDetais_Object_Equatable_CborSerializable: function _TronMultiSigSignerDetais_Object_Equatable_CborSerializable() {
    },
    _TronMultiSignatureAddress_Object_Equatable: function _TronMultiSignatureAddress_Object_Equatable() {
    },
    _TronMultiSignatureAddress_Object_Equatable_CborSerializable: function _TronMultiSignatureAddress_Object_Equatable_CborSerializable() {
    },
    ITronAddress$_(accountInfo, accountName, address, coin, keyIndex, network, networkAddress, nfts, publicKey, resource, trc10Token, trc20Token) {
      A.List_List$unmodifiable(publicKey, type$.int);
      A.List_List$unmodifiable(trc10Token, type$.TronTRC10Token);
      A.List_List$unmodifiable(trc20Token, type$.TronTRC20Token);
      A.List_List$unmodifiable(nfts, type$.NFTCore);
      return new A.ITronAddress(keyIndex, network);
    },
    ITronAddress_ITronAddress$fromCborBytesOrObject(network, obj) {
      var cbor, t1, proposal, t2, keyIndex, publicKey, t3, networkId, t4, address, ethAddress, trc20Tokens, trc10Tokens, accountName, account, resource, _null = null;
      if (A.BytesUtils_bytesEqual(obj.tags, B.List_200_195_1))
        return A.ITronMultisigAddress_ITronMultisigAddress$fromCborBytesOrObject(network, obj);
      cbor = A.CborSerializable_decodeCborTags(_null, obj, B.List_200_195, type$.CborListValue_dynamic);
      t1 = type$.String;
      proposal = A.CoinProposal_fromName(A.ExtractCborList_elementAt(cbor, 0, t1));
      t2 = A.CryptoCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), proposal);
      t2.toString;
      keyIndex = A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      publicKey = A.ExtractCborList_elementAt(cbor, 3, type$.List_int);
      t3 = type$.dynamic;
      networkId = A.ExtractCborList_elementAt(cbor, 6, t3);
      if (!J.$eq$(networkId, network.get$value()))
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      t4 = network.get$coinParam().token.decimal;
      t4.toString;
      address = A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t4, A.ExtractCborList_getCborTag(cbor, 4));
      ethAddress = A.TronAddress_TronAddress(A.ExtractCborList_elementAt(cbor, 5, t1));
      t1 = type$.nullable_List_dynamic;
      t4 = t1._as(A.ExtractCborList_elementAt(cbor, 7, t3));
      if (t4 == null)
        trc20Tokens = _null;
      else {
        t4 = J.map$1$1$ax(t4, new A.ITronAddress_ITronAddress$fromCborBytesOrObject_closure(), type$.TronTRC20Token);
        t4 = A.List_List$of(t4, true, t4.$ti._eval$1("ListIterable.E"));
        trc20Tokens = t4;
      }
      if (trc20Tokens == null)
        trc20Tokens = A._setArrayType([], type$.JSArray_TronTRC20Token);
      t1 = t1._as(A.ExtractCborList_elementAt(cbor, 8, t3));
      if (t1 == null)
        trc10Tokens = _null;
      else {
        t1 = J.map$1$1$ax(t1, new A.ITronAddress_ITronAddress$fromCborBytesOrObject_closure0(), type$.TronTRC10Token);
        t1 = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
        trc10Tokens = t1;
      }
      if (trc10Tokens == null)
        trc10Tokens = A._setArrayType([], type$.JSArray_TronTRC10Token);
      accountName = A.ExtractCborList_elementAt(cbor, 10, type$.nullable_String);
      account = A.ExtractCborList_getCborTag(cbor, 11);
      resource = A.ExtractCborList_getCborTag(cbor, 12);
      A._asInt(networkId);
      t1 = A._setArrayType([], type$.JSArray_NFTCore);
      t3 = account == null ? _null : A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject(account);
      return A.ITronAddress$_(t3, accountName, address, t2, keyIndex, networkId, ethAddress, t1, publicKey, resource == null ? _null : A.TronAccountResourceInfo_TronAccountResourceInfo$fromCborBytesOrObject(resource), trc10Tokens, trc20Tokens);
    },
    ITronMultisigAddress_ITronMultisigAddress$fromCborBytesOrObject(network, obj) {
      var multiSignatureAddress, t2, networkId, t3, trc20Tokens, trc10Tokens, account, resource,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_195_1, type$.CborListValue_dynamic),
        t1 = type$.String,
        proposal = A.CoinProposal_fromName(A.ExtractCborList_elementAt(cbor, 0, t1));
      A.CryptoCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), proposal).toString;
      multiSignatureAddress = A.TronMultiSignatureAddress_TronMultiSignatureAddress$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 3));
      t2 = type$.dynamic;
      networkId = A.ExtractCborList_elementAt(cbor, 6, t2);
      if (!J.$eq$(networkId, network.get$value()))
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      t3 = network.get$coinParam().token.decimal;
      t3.toString;
      A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t3, A.ExtractCborList_getCborTag(cbor, 4));
      A.TronAddress_TronAddress(A.ExtractCborList_elementAt(cbor, 5, t1));
      t1 = type$.nullable_List_dynamic;
      t3 = t1._as(A.ExtractCborList_elementAt(cbor, 7, t2));
      if (t3 == null)
        trc20Tokens = null;
      else {
        t3 = J.map$1$1$ax(t3, new A.ITronMultisigAddress_ITronMultisigAddress$fromCborBytesOrObject_closure(), type$.TronTRC20Token);
        t3 = A.List_List$of(t3, true, t3.$ti._eval$1("ListIterable.E"));
        trc20Tokens = t3;
      }
      if (trc20Tokens == null)
        trc20Tokens = A._setArrayType([], type$.JSArray_TronTRC20Token);
      t1 = t1._as(A.ExtractCborList_elementAt(cbor, 8, t2));
      if (t1 == null)
        trc10Tokens = null;
      else {
        t1 = J.map$1$1$ax(t1, new A.ITronMultisigAddress_ITronMultisigAddress$fromCborBytesOrObject_closure0(), type$.TronTRC10Token);
        t1 = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
        trc10Tokens = t1;
      }
      if (trc10Tokens == null)
        trc10Tokens = A._setArrayType([], type$.JSArray_TronTRC10Token);
      A.ExtractCborList_elementAt(cbor, 10, type$.nullable_String);
      account = A.ExtractCborList_getCborTag(cbor, 11);
      resource = A.ExtractCborList_getCborTag(cbor, 12);
      A._asInt(networkId);
      t1 = A._setArrayType([], type$.JSArray_NFTCore);
      if (account != null)
        A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject(account);
      if (resource != null)
        A.TronAccountResourceInfo_TronAccountResourceInfo$fromCborBytesOrObject(resource);
      A.List_List$unmodifiable(B.List_empty4, type$.int);
      A.List_List$unmodifiable(trc10Tokens, type$.TronTRC10Token);
      A.List_List$unmodifiable(trc20Tokens, type$.TronTRC20Token);
      A.List_List$unmodifiable(t1, type$.NFTCore);
      return new A.ITronMultisigAddress(multiSignatureAddress, B.C_MultiSigAddressIndex, networkId);
    },
    ITronAddress: function ITronAddress(t0, t1) {
      this.keyIndex = t0;
      this.network = t1;
    },
    ITronAddress_ITronAddress$fromCborBytesOrObject_closure: function ITronAddress_ITronAddress$fromCborBytesOrObject_closure() {
    },
    ITronAddress_ITronAddress$fromCborBytesOrObject_closure0: function ITronAddress_ITronAddress$fromCborBytesOrObject_closure0() {
    },
    ITronMultisigAddress: function ITronMultisigAddress(t0, t1, t2) {
      this.multiSignatureAccount = t0;
      this.keyIndex = t1;
      this.network = t2;
    },
    ITronMultisigAddress_ITronMultisigAddress$fromCborBytesOrObject_closure: function ITronMultisigAddress_ITronMultisigAddress$fromCborBytesOrObject_closure() {
    },
    ITronMultisigAddress_ITronMultisigAddress$fromCborBytesOrObject_closure0: function ITronMultisigAddress_ITronMultisigAddress$fromCborBytesOrObject_closure0() {
    },
    _ITronAddress_ChainAccount_Equatable: function _ITronAddress_ChainAccount_Equatable() {
    },
    RippleMultiSignatureAddress_RippleMultiSignatureAddress$fromCborBytesOrObject(obj) {
      var cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_193_1_0, type$.CborListValue_dynamic),
        t1 = J.map$1$1$ax(A.ExtractCborList_elementAt(cbor, 0, type$.List_dynamic), new A.RippleMultiSignatureAddress_RippleMultiSignatureAddress$fromCborBytesOrObject_closure(), type$.RippleMultiSigSignerDetais),
        signers = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E")),
        threshHold = A.ExtractCborList_elementAt(cbor, 1, type$.int);
      A.ExtractCborList_elementAt(cbor, 2, type$.bool);
      return new A.RippleMultiSignatureAddress(signers, threshHold);
    },
    RippleMultiSigSignerDetais: function RippleMultiSigSignerDetais(t0, t1, t2) {
      this.publicKey = t0;
      this.weight = t1;
      this.keyIndex = t2;
    },
    RippleMultiSignatureAddress: function RippleMultiSignatureAddress(t0, t1) {
      this.signers = t0;
      this.threshold = t1;
    },
    RippleMultiSignatureAddress_RippleMultiSignatureAddress$fromCborBytesOrObject_closure: function RippleMultiSignatureAddress_RippleMultiSignatureAddress$fromCborBytesOrObject_closure() {
    },
    _RippleMultiSigSignerDetais_Object_Equatable: function _RippleMultiSigSignerDetais_Object_Equatable() {
    },
    _RippleMultiSigSignerDetais_Object_Equatable_CborSerializable: function _RippleMultiSigSignerDetais_Object_Equatable_CborSerializable() {
    },
    _RippleMultiSignatureAddress_Object_Equatable: function _RippleMultiSignatureAddress_Object_Equatable() {
    },
    _RippleMultiSignatureAddress_Object_Equatable_CborSerializable: function _RippleMultiSignatureAddress_Object_Equatable_CborSerializable() {
    },
    IXRPAddress$_(accountName, address, coin, curveType, keyIndex, network, networkAddress, nfts, publicKey, tag, tokens) {
      A.List_List$unmodifiable(publicKey, type$.int);
      A.List_List$unmodifiable(tokens, type$.RippleIssueToken);
      A.List_List$unmodifiable(nfts, type$.RippleNFToken);
      return new A.IXRPAddress(keyIndex, network, tag);
    },
    IXRPAddress_IXRPAddress$fromCborBytesOrObject(network, obj) {
      var cbor, t1, proposal, t2, keyIndex, publicKey, networkId, t3, address, rippleAddress, tag, issueTokens, nfts, curveName, curveType, accountName;
      if (A.BytesUtils_bytesEqual(obj.tags, B.List_200_193_1))
        return A.IXRPMultisigAddress_IXRPMultisigAddress$fromCborBytesOrObject(network, obj);
      cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_193, type$.CborListValue_dynamic);
      t1 = type$.String;
      proposal = A.CoinProposal_fromName(A.ExtractCborList_elementAt(cbor, 0, t1));
      t2 = A.CryptoCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), proposal);
      t2.toString;
      keyIndex = A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      publicKey = A.ExtractCborList_elementAt(cbor, 3, type$.List_int);
      networkId = A.ExtractCborList_elementAt(cbor, 7, type$.dynamic);
      if (!J.$eq$(networkId, network.get$value()))
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      t3 = network.get$coinParam().token.decimal;
      t3.toString;
      address = A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t3, A.ExtractCborList_getCborTag(cbor, 4));
      rippleAddress = A.XRPAddress_XRPAddress(A.ExtractCborList_elementAt(cbor, 5, t1));
      tag = A.ExtractCborList_elementAt(cbor, 6, type$.nullable_int);
      t1 = type$.nullable_List_dynamic;
      t3 = A.ExtractCborList_elementAt(cbor, 8, t1);
      if (t3 == null)
        issueTokens = null;
      else {
        t3 = J.map$1$1$ax(t3, new A.IXRPAddress_IXRPAddress$fromCborBytesOrObject_closure(), type$.RippleIssueToken);
        issueTokens = A.List_List$of(t3, true, t3.$ti._eval$1("ListIterable.E"));
      }
      t1 = A.ExtractCborList_elementAt(cbor, 9, t1);
      if (t1 == null)
        nfts = null;
      else {
        t1 = J.map$1$1$ax(t1, new A.IXRPAddress_IXRPAddress$fromCborBytesOrObject_closure0(), type$.RippleNFToken);
        nfts = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      }
      t1 = type$.nullable_String;
      curveName = A.ExtractCborList_elementAt(cbor, 10, t1);
      curveType = curveName == null ? B.EllipticCurveTypes_secp256k1 : A.EllipticCurveTypes_fromName(curveName);
      accountName = A.ExtractCborList_elementAt(cbor, 11, t1);
      A._asInt(networkId);
      t1 = issueTokens == null ? A._setArrayType([], type$.JSArray_RippleIssueToken) : issueTokens;
      return A.IXRPAddress$_(accountName, address, t2, curveType, keyIndex, networkId, rippleAddress, nfts == null ? A._setArrayType([], type$.JSArray_RippleNFToken) : nfts, publicKey, tag, t1);
    },
    IXRPMultisigAddress_IXRPMultisigAddress$fromCborBytesOrObject(network, obj) {
      var proposal, t2, networkId, t3, t4, tag, issueTokens, tokens, accountNfts, nfts, multiSigAccount,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_193_1, type$.CborListValue_dynamic),
        t1 = cbor.value;
      if (0 >= t1.length)
        return A.ioore(t1, 0);
      proposal = A.CoinProposal_fromName(A._asString(t1[0].get$value()));
      if (1 >= t1.length)
        return A.ioore(t1, 1);
      A.CryptoCoins_getCoin(A._asString(t1[1].get$value()), proposal).toString;
      t2 = type$.int;
      networkId = A.ExtractCborList_elementAt(cbor, 7, t2);
      if (networkId !== network.get$value())
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      t3 = network.get$coinParam().token.decimal;
      t3.toString;
      if (4 >= t1.length)
        return A.ioore(t1, 4);
      t4 = type$.nullable_CborObject;
      A.IntegerAddressBalance_IntegerAddressBalance$fromCborBytesOrObject(t3, t4._as(t1[4]));
      if (5 >= t1.length)
        return A.ioore(t1, 5);
      A.XRPAddress_XRPAddress(A._asString(t1[5].get$value()));
      if (6 >= t1.length)
        return A.ioore(t1, 6);
      t1 = t1[6];
      tag = t1 instanceof A.CborIntValue ? t1.value : null;
      issueTokens = A._setArrayType([], type$.JSArray_RippleIssueToken);
      t1 = type$.nullable_List_dynamic;
      tokens = A.ExtractCborList_elementAt(cbor, 8, t1);
      if (tokens != null)
        for (t3 = J.get$iterator$ax(tokens); t3.moveNext$0();)
          B.JSArray_methods.add$1(issueTokens, A.RippleIssueToken_RippleIssueToken$fromCborBytesOrObject(t4._as(t3.get$current())));
      accountNfts = A._setArrayType([], type$.JSArray_RippleNFToken);
      nfts = A.ExtractCborList_elementAt(cbor, 9, t1);
      if (nfts != null)
        for (t1 = J.get$iterator$ax(nfts); t1.moveNext$0();)
          B.JSArray_methods.add$1(accountNfts, A.RippleNFToken_RippleNFToken$fromCborBytesOrObject(t4._as(t1.get$current())));
      multiSigAccount = A.RippleMultiSignatureAddress_RippleMultiSignatureAddress$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 11));
      A.ExtractCborList_elementAt(cbor, 12, type$.nullable_String);
      A.List_List$unmodifiable(B.List_empty4, t2);
      A.List_List$unmodifiable(issueTokens, type$.RippleIssueToken);
      A.List_List$unmodifiable(accountNfts, type$.RippleNFToken);
      return new A.IXRPMultisigAddress(multiSigAccount, B.C_MultiSigAddressIndex, networkId, tag);
    },
    IXRPAddress: function IXRPAddress(t0, t1, t2) {
      this.keyIndex = t0;
      this.network = t1;
      this.tag = t2;
    },
    IXRPAddress_IXRPAddress$fromCborBytesOrObject_closure: function IXRPAddress_IXRPAddress$fromCborBytesOrObject_closure() {
    },
    IXRPAddress_IXRPAddress$fromCborBytesOrObject_closure0: function IXRPAddress_IXRPAddress$fromCborBytesOrObject_closure0() {
    },
    IXRPMultisigAddress: function IXRPMultisigAddress(t0, t1, t2, t3) {
      var _ = this;
      _.multiSignatureAccount = t0;
      _.keyIndex = t1;
      _.network = t2;
      _.tag = t3;
    },
    _IXRPAddress_ChainAccount_Equatable: function _IXRPAddress_ChainAccount_Equatable() {
    },
    Web3AccountPermission_Web3AccountPermission$deserialize(object, NETWORKADDRESS) {
      var values, permission, _null = null,
        cbor = A.CborSerializable_decode(_null, _null, object, type$.CborTagValue_dynamic);
      switch (A.NetworkType_fromTag(cbor.tags)) {
        case B.NetworkType_iDZ:
          values = A.CborSerializable_cborTagValue(_null, _null, cbor, B.List_80_0_3, type$.CborListValue_dynamic);
          permission = new A.Web3EthereumPermission(A.AddressDerivationIndex_fromCborBytesOrObject(A.ExtractCborList_getCborTag(values, 0)), A.ETHAddress_ETHAddress(A.ExtractCborList_elementAt(values, 1, type$.String)));
          break;
        default:
          throw A.wrapException($.$get$WalletExceptionConst_dataVerificationFailed());
      }
      if (!NETWORKADDRESS._eval$1("Web3AccountPermission<0>")._is(permission))
        throw A.wrapException($.$get$WalletExceptionConst_dataVerificationFailed());
      return permission;
    },
    Web3Permission_Web3Permission$deserialize(object, NETWORKADDRESS) {
      var t4,
        values = A.CborSerializable_cborTagValue(null, null, object, B.List_0_0_0_1, type$.CborListValue_dynamic),
        t1 = type$.List_dynamic,
        t2 = NETWORKADDRESS._eval$1("Web3AccountPermission<0>"),
        t3 = J.map$1$1$ax(A.ExtractCborList_elementAt(values, 0, t1), new A.Web3Permission_Web3Permission$deserialize_closure(NETWORKADDRESS), t2);
      t3 = A.List_List$of(t3, true, t3.$ti._eval$1("ListIterable.E"));
      t4 = type$.String;
      A.ExtractCborList_elementAt(values, 1, t4);
      A.ExtractCborList_elementAt(values, 2, t4);
      t4 = A.ExtractCborList_getCborTag(values, 3);
      if (t4 != null)
        A.QuickCbor_to(t4, new A.Web3Permission_Web3Permission$deserialize_closure0(), type$.APPImage, type$.CborTagValue_dynamic);
      t4 = type$.Web3PermissionActivities;
      t1 = J.map$1$1$ax(A.ExtractCborList_elementAt(values, 4, t1), new A.Web3Permission_Web3Permission$deserialize_closure1(), t4);
      t1 = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      A.List_List$unmodifiable(t3, t2);
      A.List_List$unmodifiable(t1, t4);
      return new A.Web3Permission(NETWORKADDRESS._eval$1("Web3Permission<0>"));
    },
    Web3PermissionActivities: function Web3PermissionActivities() {
    },
    Web3AccountPermission: function Web3AccountPermission() {
    },
    Web3Permission: function Web3Permission(t0) {
      this.$ti = t0;
    },
    Web3Permission_Web3Permission$deserialize_closure: function Web3Permission_Web3Permission$deserialize_closure(t0) {
      this.NETWORKADDRESS = t0;
    },
    Web3Permission_Web3Permission$deserialize_closure0: function Web3Permission_Web3Permission$deserialize_closure0() {
    },
    Web3Permission_Web3Permission$deserialize_closure1: function Web3Permission_Web3Permission$deserialize_closure1() {
    },
    _Web3AccountPermission_Object_CborSerializable: function _Web3AccountPermission_Object_CborSerializable() {
    },
    _Web3AccountPermission_Object_CborSerializable_Equatable: function _Web3AccountPermission_Object_CborSerializable_Equatable() {
    },
    _Web3Permission_Object_CborSerializable: function _Web3Permission_Object_CborSerializable() {
    },
    _Web3PermissionActivities_Object_CborSerializable: function _Web3PermissionActivities_Object_CborSerializable() {
    },
    Web3EthereumPermission: function Web3EthereumPermission(t0, t1) {
      this.addressIndex = t0;
      this.address = t1;
    },
    DecimalBalance: function DecimalBalance(t0) {
      this.__DecimalBalance__price_A = t0;
    },
    IntegerBalance_IntegerBalance(balance, currencyDecimal, imutable) {
      var showDecimal = currencyDecimal > 8 ? 8 : currencyDecimal,
        currency = new A.IntegerBalance($.$get$_BigIntImpl_zero(), currencyDecimal, showDecimal),
        t1 = A.BigRational_BigRational(balance, null).$div(0, A.RetionalConst_fromDecimalNumber(currencyDecimal)).toDecimal$1$digits(showDecimal);
      currency.__IntegerBalance__price_A = t1;
      currency._balance = balance;
      A.StrUtils_to3Digits(t1, ",");
      return currency;
    },
    IntegerBalance: function IntegerBalance(t0, t1, t2) {
      var _ = this;
      _._balance = t0;
      _.__IntegerBalance__price_A = $;
      _.currencyDecimal = t1;
      _.__IntegerBalance_showDecimal_F = t2;
    },
    BitcoinContact_BitcoinContact$fromCborBytesOrObject(network, bytes, obj) {
      var cbor, address, type, created, $name, bitcoinAddress, t1, exception;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_100_0, type$.CborListValue_dynamic);
        t1 = type$.String;
        address = A.ExtractCborList_elementAt(cbor, 0, t1);
        type = A.BitcoinAddressType_fromValue(A.ExtractCborList_elementAt(cbor, 1, t1));
        created = A.ExtractCborList_elementAt(cbor, 2, type$.DateTime);
        $name = A.ExtractCborList_elementAt(cbor, 3, t1);
        bitcoinAddress = A.BlockchainAddressUtils_toBitcoinAddressFromType(type, address, network);
        if (bitcoinAddress.toAddress$1(network.coinParam.transacationNetwork) !== address) {
          t1 = $.$get$WalletExceptionConst_invalidContactDetails();
          throw A.wrapException(t1);
        }
        return new A.BitcoinContact(address, $name);
      } catch (exception) {
        t1 = $.$get$WalletExceptionConst_invalidContactDetails();
        throw A.wrapException(t1);
      }
    },
    BitcoinContact: function BitcoinContact(t0, t1) {
      this.address = t0;
      this.name = t1;
    },
    _BitcoinContact_Object_Equatable: function _BitcoinContact_Object_Equatable() {
    },
    CardanoContact_CardanoContact$fromCborBytesOrObject(bytes, obj) {
      var cbor, address, created, $name, cardanoAddr, t1, exception;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_100_5, type$.CborListValue_dynamic);
        t1 = type$.String;
        address = A.ExtractCborList_elementAt(cbor, 0, t1);
        created = A.ExtractCborList_elementAt(cbor, 1, type$.DateTime);
        $name = A.ExtractCborList_elementAt(cbor, 2, t1);
        cardanoAddr = A.ADAAddress_fromAddress(address, type$.ADAAddress);
        return new A.CardanoContact(cardanoAddr, $name);
      } catch (exception) {
        t1 = $.$get$WalletExceptionConst_invalidContactDetails();
        throw A.wrapException(t1);
      }
    },
    CardanoContact: function CardanoContact(t0, t1) {
      this.addressObject = t0;
      this.name = t1;
    },
    _CardanoContact_Object_Equatable: function _CardanoContact_Object_Equatable() {
    },
    CosmosContact_CosmosContact$fromCborBytesOrObject(bytes, obj) {
      var cbor, address, created, $name, cardanoAddr, t1, exception;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_100_6, type$.CborListValue_dynamic);
        t1 = type$.String;
        address = A.ExtractCborList_elementAt(cbor, 0, t1);
        created = A.ExtractCborList_elementAt(cbor, 1, type$.DateTime);
        $name = A.ExtractCborList_elementAt(cbor, 2, t1);
        t1 = address;
        A.CosmosAddrUtils_decodeBytes(t1, null);
        cardanoAddr = new A.CosmosBaseAddress(t1);
        return new A.CosmosContact(cardanoAddr, $name);
      } catch (exception) {
        t1 = $.$get$WalletExceptionConst_invalidContactDetails();
        throw A.wrapException(t1);
      }
    },
    CosmosContact: function CosmosContact(t0, t1) {
      this.addressObject = t0;
      this.name = t1;
    },
    _CosmosContact_Object_Equatable: function _CosmosContact_Object_Equatable() {
    },
    EthereumContract_EthereumContract$fromCborBytesOrObject(bytes, obj) {
      var cbor, address, created, $name, ethAddress, t1, exception;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_100_2, type$.CborListValue_dynamic);
        t1 = type$.String;
        address = A.ExtractCborList_elementAt(cbor, 0, t1);
        created = A.ExtractCborList_elementAt(cbor, 1, type$.DateTime);
        $name = A.ExtractCborList_elementAt(cbor, 2, t1);
        ethAddress = A.ETHAddress_ETHAddress(address);
        return new A.EthereumContract(ethAddress, $name);
      } catch (exception) {
        t1 = $.$get$WalletExceptionConst_invalidContactDetails();
        throw A.wrapException(t1);
      }
    },
    EthereumContract: function EthereumContract(t0, t1) {
      this.addressObject = t0;
      this.name = t1;
    },
    _EthereumContract_Object_Equatable: function _EthereumContract_Object_Equatable() {
    },
    SolanaContact_SolanaContact$fromCborBytesOrObject(bytes, obj) {
      var cbor, address, created, $name, solanaAddress, t1, exception;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_100_4, type$.CborListValue_dynamic);
        t1 = type$.String;
        address = A.ExtractCborList_elementAt(cbor, 0, t1);
        created = A.ExtractCborList_elementAt(cbor, 1, type$.DateTime);
        $name = A.ExtractCborList_elementAt(cbor, 2, t1);
        t1 = address;
        new A.SolAddrDecoder().decodeAddr$1(t1);
        solanaAddress = new A.SolAddress(t1);
        return new A.SolanaContact(solanaAddress, $name);
      } catch (exception) {
        t1 = $.$get$WalletExceptionConst_invalidContactDetails();
        throw A.wrapException(t1);
      }
    },
    SolanaContact: function SolanaContact(t0, t1) {
      this.addressObject = t0;
      this.name = t1;
    },
    _SolanaContact_Object_Equatable: function _SolanaContact_Object_Equatable() {
    },
    SubstrateContact: function SubstrateContact(t0, t1) {
      this.addressObject = t0;
      this.name = t1;
    },
    _SubstrateContact_Object_Equatable: function _SubstrateContact_Object_Equatable() {
    },
    TonContact_TonContact$fromCborBytesOrObject(bytes, obj) {
      var cbor, address, created, $name, solanaAddress, t1, exception;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_100_7, type$.CborListValue_dynamic);
        t1 = type$.String;
        address = A.ExtractCborList_elementAt(cbor, 0, t1);
        created = A.ExtractCborList_elementAt(cbor, 1, type$.DateTime);
        $name = A.ExtractCborList_elementAt(cbor, 2, t1);
        solanaAddress = A.TonAddress_TonAddress(address);
        return new A.TonContact(solanaAddress, $name);
      } catch (exception) {
        t1 = $.$get$WalletExceptionConst_invalidContactDetails();
        throw A.wrapException(t1);
      }
    },
    TonContact: function TonContact(t0, t1) {
      this.addressObject = t0;
      this.name = t1;
    },
    _TonContact_Object_Equatable: function _TonContact_Object_Equatable() {
    },
    TronContact_TronContact$fromCborBytesOrObject(bytes, obj) {
      var cbor, address, created, $name, ethAddress, t1, exception;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_100_3, type$.CborListValue_dynamic);
        t1 = type$.String;
        address = A.ExtractCborList_elementAt(cbor, 0, t1);
        created = A.ExtractCborList_elementAt(cbor, 1, type$.DateTime);
        $name = A.ExtractCborList_elementAt(cbor, 2, t1);
        ethAddress = A.TronAddress_TronAddress(address);
        return new A.TronContact(ethAddress, $name);
      } catch (exception) {
        t1 = $.$get$WalletExceptionConst_invalidContactDetails();
        throw A.wrapException(t1);
      }
    },
    TronContact: function TronContact(t0, t1) {
      this.addressObject = t0;
      this.name = t1;
    },
    _TronContact_Object_Equatable: function _TronContact_Object_Equatable() {
    },
    RippleContact_RippleContact$fromCborBytesOrObject(bytes, obj) {
      var cbor, address, tag, created, $name, rippleAddress, t1, t2, exception;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_100_1, type$.CborListValue_dynamic);
        t1 = type$.String;
        address = A.ExtractCborList_elementAt(cbor, 0, t1);
        tag = A.ExtractCborList_elementAt(cbor, 1, type$.nullable_int);
        created = A.ExtractCborList_elementAt(cbor, 2, type$.DateTime);
        $name = A.ExtractCborList_elementAt(cbor, 3, t1);
        rippleAddress = A.XRPAddress_XRPAddress(address);
        t1 = rippleAddress.tag;
        t2 = tag;
        if (t1 == null ? t2 != null : t1 !== t2) {
          t1 = $.$get$WalletExceptionConst_invalidContactDetails();
          throw A.wrapException(t1);
        }
        return new A.RippleContact(address, $name);
      } catch (exception) {
        t1 = $.$get$WalletExceptionConst_invalidContactDetails();
        throw A.wrapException(t1);
      }
    },
    RippleContact: function RippleContact(t0, t1) {
      this.address = t0;
      this.name = t1;
    },
    _RippleContact_Object_Equatable: function _RippleContact_Object_Equatable() {
    },
    WalletNetwork_fromCborBytesOrObject(obj) {
      var t1, cbor, _null = null;
      if (obj == null) {
        null.toString;
        t1 = A.CborUtils__decode(null).item1;
      } else
        t1 = obj;
      type$.CborTagValue_dynamic._as(t1);
      switch (A.NetworkType_fromTag(t1.tags)) {
        case B.NetworkType_8eb:
          cbor = A.CborSerializable_decodeCborTags(_null, t1, B.List_80_0_1, type$.CborListValue_dynamic);
          return new A.WalletBitcoinNetwork(A.ExtractCborList_elementAt(cbor, 0, type$.int), A.BitcoinParams_BitcoinParams$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 1)));
        case B.NetworkType_8eb0:
          cbor = A.CborSerializable_decodeCborTags(_null, t1, B.List_80_0_10, type$.CborListValue_dynamic);
          return new A.WalletBitcoinCashNetwork(A.ExtractCborList_elementAt(cbor, 0, type$.int), A.BitcoinParams_BitcoinParams$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 1)));
        case B.NetworkType_Oh2:
          cbor = A.CborSerializable_decodeCborTags(_null, t1, B.List_80_0_2, type$.CborListValue_dynamic);
          return new A.WalletXRPNetwork(A.ExtractCborList_elementAt(cbor, 0, type$.int), A.RippleNetworkParams_RippleNetworkParams$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 1)));
        case B.NetworkType_iDZ:
          cbor = A.CborSerializable_decodeCborTags(_null, t1, B.List_80_0_3, type$.CborListValue_dynamic);
          return new A.WalletEthereumNetwork(A.ExtractCborList_elementAt(cbor, 0, type$.int), A.EthereumNetworkParams_EthereumNetworkParams$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 1)), A.ExtractCborList_elementAt(cbor, 2, type$.nullable_int));
        case B.NetworkType_4QF:
          cbor = A.CborSerializable_decodeCborTags(_null, t1, B.List_80_0_5, type$.CborListValue_dynamic);
          return new A.WalletSolanaNetwork(A.ExtractCborList_elementAt(cbor, 0, type$.int), A.SolanaNetworkParams_SolanaNetworkParams$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 1)));
        case B.NetworkType_4ei:
          cbor = A.CborSerializable_decodeCborTags(_null, t1, B.List_80_0_6, type$.CborListValue_dynamic);
          return new A.WalletCardanoNetwork(A.ExtractCborList_elementAt(cbor, 0, type$.int), A.CardanoNetworkParams_CardanoNetworkParams$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 1)));
        case B.NetworkType_QJm:
          cbor = A.CborSerializable_decodeCborTags(_null, t1, B.List_80_0_7, type$.CborListValue_dynamic);
          return new A.WalletCosmosNetwork(A.ExtractCborList_elementAt(cbor, 0, type$.int), A.CosmosNetworkParams_CosmosNetworkParams$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 1)));
        case B.NetworkType_66M:
          cbor = A.CborSerializable_decodeCborTags(_null, t1, B.List_80_0_11, type$.CborListValue_dynamic);
          return new A.WalletTonNetwork(A.ExtractCborList_elementAt(cbor, 0, type$.int), A.TonNetworkParams_TonNetworkParams$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 1)));
        case B.NetworkType_SkF:
          cbor = A.CborSerializable_decodeCborTags(_null, t1, B.List_80_0_4, type$.CborListValue_dynamic);
          return new A.WalletTronNetwork(A.ExtractCborList_elementAt(cbor, 0, type$.int), A.TronNetworkParams_TronNetworkParams$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 1)));
        case B.NetworkType_GRA:
          cbor = A.CborSerializable_decodeCborTags(_null, t1, B.List_80_0_12, type$.CborListValue_dynamic);
          return new A.WalletPolkadotNetwork(A.ExtractCborList_elementAt(cbor, 0, type$.int), A.SubstrateNetworkParams_SubstrateNetworkParams$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 1)));
        case B.NetworkType_0:
          cbor = A.CborSerializable_decodeCborTags(_null, t1, B.List_80_0_13, type$.CborListValue_dynamic);
          return new A.WalletKusamaNetwork(A.ExtractCborList_elementAt(cbor, 0, type$.int), A.SubstrateNetworkParams_SubstrateNetworkParams$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 1)));
        default:
          throw A.wrapException(A.UnimplementedError$("network does not exist."));
      }
    },
    WalletBitcoinNetwork$(value, coinParam) {
      return new A.WalletBitcoinNetwork(value, coinParam);
    },
    WalletBitcoinCashNetwork$(value, coinParam) {
      return new A.WalletBitcoinCashNetwork(value, coinParam);
    },
    WalletXRPNetwork$(value, coinParam) {
      return new A.WalletXRPNetwork(value, coinParam);
    },
    WalletEthereumNetwork$(value, coinParam, slip44) {
      return new A.WalletEthereumNetwork(value, coinParam, slip44);
    },
    WalletTronNetwork$(value, coinParam) {
      return new A.WalletTronNetwork(value, coinParam);
    },
    WalletSolanaNetwork$(value, coinParam) {
      return new A.WalletSolanaNetwork(value, coinParam);
    },
    WalletCardanoNetwork$(value, coinParam) {
      return new A.WalletCardanoNetwork(value, coinParam);
    },
    WalletCosmosNetwork$(value, coinParam) {
      return new A.WalletCosmosNetwork(value, coinParam);
    },
    WalletTonNetwork$(value, coinParam) {
      return new A.WalletTonNetwork(value, coinParam);
    },
    WalletPolkadotNetwork$(value, coinParam) {
      return new A.WalletPolkadotNetwork(value, coinParam);
    },
    WalletKusamaNetwork$(value, coinParam) {
      return new A.WalletKusamaNetwork(value, coinParam);
    },
    WalletNetwork: function WalletNetwork() {
    },
    WalletNetwork_getProvider_closure: function WalletNetwork_getProvider_closure(t0) {
      this.T = t0;
    },
    WalletNetwork_getProvider_closure0: function WalletNetwork_getProvider_closure0(t0, t1, t2) {
      this.$this = t0;
      this.selectProvider = t1;
      this.T = t2;
    },
    WalletNetwork_getProvider__closure: function WalletNetwork_getProvider__closure(t0, t1) {
      this.selectProvider = t0;
      this.T = t1;
    },
    WalletBitcoinNetwork: function WalletBitcoinNetwork(t0, t1) {
      this.value = t0;
      this.coinParam = t1;
    },
    WalletBitcoinCashNetwork: function WalletBitcoinCashNetwork(t0, t1) {
      this.value = t0;
      this.coinParam = t1;
    },
    WalletXRPNetwork: function WalletXRPNetwork(t0, t1) {
      this.value = t0;
      this.coinParam = t1;
    },
    WalletEthereumNetwork: function WalletEthereumNetwork(t0, t1, t2) {
      this.value = t0;
      this.coinParam = t1;
      this.slip44 = t2;
    },
    WalletTronNetwork: function WalletTronNetwork(t0, t1) {
      this.value = t0;
      this.coinParam = t1;
    },
    WalletSolanaNetwork: function WalletSolanaNetwork(t0, t1) {
      this.value = t0;
      this.coinParam = t1;
    },
    WalletCardanoNetwork: function WalletCardanoNetwork(t0, t1) {
      this.value = t0;
      this.coinParam = t1;
    },
    WalletCosmosNetwork: function WalletCosmosNetwork(t0, t1) {
      this.value = t0;
      this.coinParam = t1;
    },
    WalletTonNetwork: function WalletTonNetwork(t0, t1) {
      this.value = t0;
      this.coinParam = t1;
    },
    WalletPolkadotNetwork: function WalletPolkadotNetwork(t0, t1) {
      this.value = t0;
      this.coinParam = t1;
    },
    WalletKusamaNetwork: function WalletKusamaNetwork(t0, t1) {
      this.value = t0;
      this.coinParam = t1;
    },
    _WalletNetwork_Object_Equatable: function _WalletNetwork_Object_Equatable() {
    },
    _WalletNetwork_Object_Equatable_CborSerializable: function _WalletNetwork_Object_Equatable_CborSerializable() {
    },
    NetworkCoinParams: function NetworkCoinParams() {
    },
    _NetworkCoinParams_Object_CborSerializable: function _NetworkCoinParams_Object_CborSerializable() {
    },
    BitcoinParams_BitcoinParams$fromCborBytesOrObject(obj) {
      var t3, t4, t5, t6,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_80_1_1, type$.CborListValue_dynamic),
        t1 = type$.nullable_String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t3 = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      t4 = type$.String;
      t5 = A.BasedUtxoNetwork_fromName(A.ExtractCborList_elementAt(cbor, 3, t4));
      t6 = J.map$1$1$ax(type$.List_dynamic._as(A.ExtractCborList_elementAt(cbor, 4, type$.dynamic)), new A.BitcoinParams_BitcoinParams$fromCborBytesOrObject_closure(), type$.BaseBitcoinAPIProvider);
      t6 = A.List_List$of(t6, true, t6.$ti._eval$1("ListIterable.E"));
      return A.BitcoinParams$(t1, A.ExtractCborList_elementAt(cbor, 5, t4), t6, t3, t5, t2);
    },
    BitcoinParams$(addressExplorer, genesis, providers, token, transacationNetwork, transactionExplorer) {
      var t1 = transacationNetwork.get$isMainnet();
      return new A.BitcoinParams(transacationNetwork, genesis, transactionExplorer, addressExplorer, token, A.List_List$unmodifiable(providers, type$.BaseBitcoinAPIProvider), t1, null);
    },
    BitcoinParams: function BitcoinParams(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.transacationNetwork = t0;
      _.genesis = t1;
      _.transactionExplorer = t2;
      _.addressExplorer = t3;
      _.token = t4;
      _.providers = t5;
      _.mainnet = t6;
      _.bip32CoinType = t7;
    },
    BitcoinParams_BitcoinParams$fromCborBytesOrObject_closure: function BitcoinParams_BitcoinParams$fromCborBytesOrObject_closure() {
    },
    CardanoNetworkParams_CardanoNetworkParams$fromCborBytesOrObject(obj) {
      var t3, t4,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_80_1_5, type$.CborListValue_dynamic),
        t1 = type$.nullable_String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t3 = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      t4 = J.map$1$1$ax(type$.List_dynamic._as(A.ExtractCborList_elementAt(cbor, 3, type$.dynamic)), new A.CardanoNetworkParams_CardanoNetworkParams$fromCborBytesOrObject_closure(), type$.CardanoAPIProvider);
      t4 = A.List_List$of(t4, true, t4.$ti._eval$1("ListIterable.E"));
      return A.CardanoNetworkParams$(t1, A.ExtractCborList_elementAt(cbor, 4, type$.bool), t4, t3, t2);
    },
    CardanoNetworkParams$(addressExplorer, mainnet, providers, token, transactionExplorer) {
      return new A.CardanoNetworkParams(transactionExplorer, addressExplorer, token, A.List_List$unmodifiable(providers, type$.CardanoAPIProvider), mainnet, null);
    },
    CardanoNetworkParams: function CardanoNetworkParams(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.transactionExplorer = t0;
      _.addressExplorer = t1;
      _.token = t2;
      _.providers = t3;
      _.mainnet = t4;
      _.bip32CoinType = t5;
    },
    CardanoNetworkParams_CardanoNetworkParams$fromCborBytesOrObject_closure: function CardanoNetworkParams_CardanoNetworkParams$fromCborBytesOrObject_closure() {
    },
    CosmosNetworkParams_CosmosNetworkParams$fromCborBytesOrObject(obj) {
      var t3, t4, t5, t6, t7, t8, t9,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_80_1_6, type$.CborListValue_dynamic),
        t1 = type$.nullable_String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t3 = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      t4 = type$.dynamic;
      t5 = type$.List_dynamic;
      t6 = J.map$1$1$ax(t5._as(A.ExtractCborList_elementAt(cbor, 3, t4)), new A.CosmosNetworkParams_CosmosNetworkParams$fromCborBytesOrObject_closure(), type$.CosmosAPIProvider);
      t6 = A.List_List$of(t6, true, t6.$ti._eval$1("ListIterable.E"));
      t7 = A.ExtractCborList_elementAt(cbor, 4, type$.bool);
      t8 = A.ExtractCborList_elementAt(cbor, 5, type$.String);
      t4 = J.map$1$1$ax(t5._as(A.ExtractCborList_elementAt(cbor, 6, t4)), new A.CosmosNetworkParams_CosmosNetworkParams$fromCborBytesOrObject_closure0(), type$.CosmosNativeCoin);
      t4 = A.List_List$of(t4, true, t4.$ti._eval$1("ListIterable.E"));
      t5 = A.CosmosNativeCoin_CosmosNativeCoin$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 7));
      t9 = A.CosmosNetworkTypes_CosmosNetworkTypes$fromValue(A.ExtractCborList_elementAt(cbor, 8, type$.int));
      return A.CosmosNetworkParams$(t1, A.ExtractCborList_elementAt(cbor, 9, type$.nullable_int), t4, t8, t5, t7, t9, t6, t3, t2);
    },
    CosmosNetworkParams$(addressExplorer, bip32CoinType, coins, hrp, mainCoin, mainnet, networkType, providers, token, transactionExplorer) {
      return new A.CosmosNetworkParams(hrp, A.List_List$unmodifiable(coins, type$.CosmosNativeCoin), mainCoin, networkType, transactionExplorer, addressExplorer, token, A.List_List$unmodifiable(providers, type$.CosmosAPIProvider), mainnet, bip32CoinType);
    },
    CosmosNetworkParams: function CosmosNetworkParams(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.hrp = t0;
      _.nativeCoins = t1;
      _.mainCoin = t2;
      _.networkType = t3;
      _.transactionExplorer = t4;
      _.addressExplorer = t5;
      _.token = t6;
      _.providers = t7;
      _.mainnet = t8;
      _.bip32CoinType = t9;
    },
    CosmosNetworkParams_CosmosNetworkParams$fromCborBytesOrObject_closure: function CosmosNetworkParams_CosmosNetworkParams$fromCborBytesOrObject_closure() {
    },
    CosmosNetworkParams_CosmosNetworkParams$fromCborBytesOrObject_closure0: function CosmosNetworkParams_CosmosNetworkParams$fromCborBytesOrObject_closure0() {
    },
    EthereumNetworkParams$(addressExplorer, bip32CoinType, chainId, defaultNetwork, mainnet, providers, supportEIP1559, token, transactionExplorer) {
      return new A.EthereumNetworkParams(chainId, supportEIP1559, defaultNetwork, transactionExplorer, addressExplorer, token, A.List_List$unmodifiable(providers, type$.EthereumAPIProvider), mainnet, bip32CoinType);
    },
    EthereumNetworkParams_EthereumNetworkParams$fromCborBytesOrObject(obj) {
      var t4, t5, t6, t7,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_80_1_3, type$.CborListValue_dynamic),
        defaultNetwork = A.ExtractCborList_elementAt(cbor, 7, type$.nullable_bool),
        t1 = A.ExtractCborList_elementAt(cbor, 0, type$.BigInt),
        t2 = type$.bool,
        t3 = A.ExtractCborList_elementAt(cbor, 1, t2);
      t2 = A.ExtractCborList_elementAt(cbor, 2, t2);
      t4 = type$.nullable_String;
      t5 = A.ExtractCborList_elementAt(cbor, 3, t4);
      t4 = A.ExtractCborList_elementAt(cbor, 4, t4);
      t6 = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 5));
      t7 = J.map$1$1$ax(type$.List_dynamic._as(A.ExtractCborList_elementAt(cbor, 6, type$.dynamic)), new A.EthereumNetworkParams_EthereumNetworkParams$fromCborBytesOrObject_closure(), type$.EthereumAPIProvider);
      t7 = A.List_List$of(t7, true, t7.$ti._eval$1("ListIterable.E"));
      return A.EthereumNetworkParams$(t4, A.ExtractCborList_elementAt(cbor, 8, type$.nullable_int), t1, defaultNetwork !== false, t2, t7, t3, t6, t5);
    },
    EthereumNetworkParams: function EthereumNetworkParams(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.chainId = t0;
      _.supportEIP1559 = t1;
      _.defaultNetwork = t2;
      _.transactionExplorer = t3;
      _.addressExplorer = t4;
      _.token = t5;
      _.providers = t6;
      _.mainnet = t7;
      _.bip32CoinType = t8;
    },
    EthereumNetworkParams_EthereumNetworkParams$fromCborBytesOrObject_closure: function EthereumNetworkParams_EthereumNetworkParams$fromCborBytesOrObject_closure() {
    },
    RippleNetworkParams_RippleNetworkParams$fromCborBytesOrObject(obj) {
      var t3, t4, t5,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_80_1_2, type$.CborListValue_dynamic),
        token = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2)),
        t1 = type$.nullable_String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t3 = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      t4 = J.map$1$1$ax(type$.List_dynamic._as(A.ExtractCborList_elementAt(cbor, 3, type$.dynamic)), new A.RippleNetworkParams_RippleNetworkParams$fromCborBytesOrObject_closure(), type$.RippleAPIProvider);
      t4 = A.List_List$of(t4, true, t4.$ti._eval$1("ListIterable.E"));
      t5 = A.ExtractCborList_elementAt(cbor, 4, type$.nullable_bool);
      return A.RippleNetworkParams$(t1, t5 == null ? token.symbol === "XRP" : t5, t4, t3, t2);
    },
    RippleNetworkParams$(addressExplorer, mainnet, providers, token, transactionExplorer) {
      return new A.RippleNetworkParams(transactionExplorer, addressExplorer, token, A.List_List$unmodifiable(providers, type$.RippleAPIProvider), mainnet, null);
    },
    RippleNetworkParams: function RippleNetworkParams(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.transactionExplorer = t0;
      _.addressExplorer = t1;
      _.token = t2;
      _.providers = t3;
      _.mainnet = t4;
      _.bip32CoinType = t5;
    },
    RippleNetworkParams_RippleNetworkParams$fromCborBytesOrObject_closure: function RippleNetworkParams_RippleNetworkParams$fromCborBytesOrObject_closure() {
    },
    SolanaNetworkParams_SolanaNetworkParams$fromCborBytesOrObject(obj) {
      var t3, t4, t5,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_80_1_7, type$.CborListValue_dynamic),
        t1 = type$.nullable_String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t3 = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      t4 = J.map$1$1$ax(type$.List_dynamic._as(A.ExtractCborList_elementAt(cbor, 3, type$.dynamic)), new A.SolanaNetworkParams_SolanaNetworkParams$fromCborBytesOrObject_closure(), type$.SolanaAPIProvider);
      t4 = A.List_List$of(t4, true, t4.$ti._eval$1("ListIterable.E"));
      t5 = A.ExtractCborList_elementAt(cbor, 4, type$.bool);
      return A.SolanaNetworkParams$(t1, A.ExtractCborList_elementAt(cbor, 5, type$.String), t5, t4, t3, t2);
    },
    SolanaNetworkParams$(addressExplorer, genesis, mainnet, providers, token, transactionExplorer) {
      return new A.SolanaNetworkParams(genesis, transactionExplorer, addressExplorer, token, A.List_List$unmodifiable(providers, type$.SolanaAPIProvider), mainnet, null);
    },
    SolanaNetworkParams: function SolanaNetworkParams(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.genesis = t0;
      _.transactionExplorer = t1;
      _.addressExplorer = t2;
      _.token = t3;
      _.providers = t4;
      _.mainnet = t5;
      _.bip32CoinType = t6;
    },
    SolanaNetworkParams_SolanaNetworkParams$fromCborBytesOrObject_closure: function SolanaNetworkParams_SolanaNetworkParams$fromCborBytesOrObject_closure() {
    },
    SubstrateNetworkParams_SubstrateNetworkParams$fromCborBytesOrObject(obj) {
      var t3, t4, t5, t6, t7,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_80_1_9, type$.CborListValue_dynamic),
        t1 = type$.nullable_String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t3 = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      t4 = J.map$1$1$ax(type$.List_dynamic._as(A.ExtractCborList_elementAt(cbor, 3, type$.dynamic)), new A.SubstrateNetworkParams_SubstrateNetworkParams$fromCborBytesOrObject_closure(), type$.SubstrateAPIProvider);
      t4 = A.List_List$of(t4, true, t4.$ti._eval$1("ListIterable.E"));
      t5 = A.ExtractCborList_elementAt(cbor, 4, type$.bool);
      t6 = type$.int;
      t7 = A.ExtractCborList_elementAt(cbor, 5, t6);
      return A.SubstrateNetworkParams$(t1, t5, t4, A.ExtractCborList_elementAt(cbor, 6, t6), t7, t3, t2);
    },
    SubstrateNetworkParams$(addressExplorer, mainnet, providers, specVersion, ss58Format, token, transactionExplorer) {
      return new A.SubstrateNetworkParams(ss58Format, specVersion, transactionExplorer, addressExplorer, token, A.List_List$unmodifiable(providers, type$.SubstrateAPIProvider), mainnet, null);
    },
    SubstrateNetworkParams: function SubstrateNetworkParams(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.ss58Format = t0;
      _.specVersion = t1;
      _.transactionExplorer = t2;
      _.addressExplorer = t3;
      _.token = t4;
      _.providers = t5;
      _.mainnet = t6;
      _.bip32CoinType = t7;
    },
    SubstrateNetworkParams_SubstrateNetworkParams$fromCborBytesOrObject_closure: function SubstrateNetworkParams_SubstrateNetworkParams$fromCborBytesOrObject_closure() {
    },
    TonNetworkParams$(addressExplorer, mainnet, providers, token, transactionExplorer, workchain) {
      return new A.TonNetworkParams(workchain, transactionExplorer, addressExplorer, token, A.List_List$unmodifiable(providers, type$.TonAPIProvider), mainnet, null);
    },
    TonNetworkParams_TonNetworkParams$fromCborBytesOrObject(obj) {
      var t5, t6,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_80_1_8, type$.CborListValue_dynamic),
        t1 = A.ExtractCborList_elementAt(cbor, 0, type$.int),
        t2 = A.ExtractCborList_elementAt(cbor, 1, type$.bool),
        t3 = type$.nullable_String,
        t4 = A.ExtractCborList_elementAt(cbor, 2, t3);
      t3 = A.ExtractCborList_elementAt(cbor, 3, t3);
      t5 = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 4));
      t6 = J.map$1$1$ax(type$.List_dynamic._as(A.ExtractCborList_elementAt(cbor, 5, type$.dynamic)), new A.TonNetworkParams_TonNetworkParams$fromCborBytesOrObject_closure(), type$.TonAPIProvider);
      return A.TonNetworkParams$(t3, t2, A.List_List$of(t6, true, t6.$ti._eval$1("ListIterable.E")), t5, t4, t1);
    },
    TonNetworkParams: function TonNetworkParams(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.workchain = t0;
      _.transactionExplorer = t1;
      _.addressExplorer = t2;
      _.token = t3;
      _.providers = t4;
      _.mainnet = t5;
      _.bip32CoinType = t6;
    },
    TonNetworkParams_TonNetworkParams$fromCborBytesOrObject_closure: function TonNetworkParams_TonNetworkParams$fromCborBytesOrObject_closure() {
    },
    TronNetworkParams_TronNetworkParams$fromCborBytesOrObject(obj) {
      var t3, t4, t5, t6,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_80_1_4, type$.CborListValue_dynamic),
        t1 = type$.nullable_String,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t3 = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      t4 = type$.dynamic;
      t5 = type$.List_dynamic;
      t6 = J.map$1$1$ax(t5._as(A.ExtractCborList_elementAt(cbor, 3, t4)), new A.TronNetworkParams_TronNetworkParams$fromCborBytesOrObject_closure(), type$.TronAPIProvider);
      t6 = A.List_List$of(t6, true, t6.$ti._eval$1("ListIterable.E"));
      t4 = J.map$1$1$ax(t5._as(A.ExtractCborList_elementAt(cbor, 4, t4)), new A.TronNetworkParams_TronNetworkParams$fromCborBytesOrObject_closure0(), type$.EthereumAPIProvider);
      t4 = A.List_List$of(t4, true, t4.$ti._eval$1("ListIterable.E"));
      t5 = A.ExtractCborList_elementAt(cbor, 5, type$.bool);
      return A.TronNetworkParams$(t1, t4, A.ExtractCborList_elementAt(cbor, 6, type$.String), t5, t6, t3, t2);
    },
    TronNetworkParams$(addressExplorer, ethereumProviders, genesis, mainnet, providers, token, transactionExplorer) {
      return new A.TronNetworkParams(ethereumProviders, genesis, transactionExplorer, addressExplorer, token, A.List_List$unmodifiable(providers, type$.TronAPIProvider), mainnet, null);
    },
    TronNetworkParams: function TronNetworkParams(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.ethereumProviders = t0;
      _.genesis = t1;
      _.transactionExplorer = t2;
      _.addressExplorer = t3;
      _.token = t4;
      _.providers = t5;
      _.mainnet = t6;
      _.bip32CoinType = t7;
    },
    TronNetworkParams_TronNetworkParams$fromCborBytesOrObject_closure: function TronNetworkParams_TronNetworkParams$fromCborBytesOrObject_closure() {
    },
    TronNetworkParams_TronNetworkParams$fromCborBytesOrObject_closure0: function TronNetworkParams_TronNetworkParams$fromCborBytesOrObject_closure0() {
    },
    CardanoAddrDetails: function CardanoAddrDetails(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.publicKey = t0;
      _.stakePubkey = t1;
      _.chainCode = t2;
      _.hdPathKey = t3;
      _.hdPath = t4;
      _.__CardanoAddrDetails_hdPathKeyHex_FI = $;
      _.addressType = t5;
    },
    _CardanoAddrDetails_Object_Equatable: function _CardanoAddrDetails_Object_Equatable() {
    },
    _CardanoAddrDetails_Object_Equatable_CborSerializable: function _CardanoAddrDetails_Object_Equatable_CborSerializable() {
    },
    CosmosNativeCoin_CosmosNativeCoin$fromCborBytesOrObject(obj) {
      var cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_110_1, type$.CborListValue_dynamic);
      A.ExtractCborList_getElement(cbor, 0, type$.int);
      A.ExtractCborList_getElement(cbor, 1, type$.String);
      return new A.CosmosNativeCoin();
    },
    CosmosNativeCoin: function CosmosNativeCoin() {
    },
    _CosmosNativeCoin_Object_CborSerializable: function _CosmosNativeCoin_Object_CborSerializable() {
    },
    CosmosNetworkTypes_CosmosNetworkTypes$fromValue(value) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_R2g, new A.CosmosNetworkTypes_CosmosNetworkTypes$fromValue_closure(value), new A.CosmosNetworkTypes_CosmosNetworkTypes$fromValue_closure0());
    },
    CosmosNetworkTypes: function CosmosNetworkTypes(t0) {
      this.value = t0;
    },
    CosmosNetworkTypes_CosmosNetworkTypes$fromValue_closure: function CosmosNetworkTypes_CosmosNetworkTypes$fromValue_closure(t0) {
      this.value = t0;
    },
    CosmosNetworkTypes_CosmosNetworkTypes$fromValue_closure0: function CosmosNetworkTypes_CosmosNetworkTypes$fromValue_closure0() {
    },
    TronAccountResourceInfo_TronAccountResourceInfo$fromCborBytesOrObject(obj) {
      var t7, t8,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_195_101, type$.CborListValue_dynamic),
        t1 = type$.BigInt,
        t2 = A.ExtractCborList_elementAt(cbor, 0, t1),
        t3 = A.ExtractCborList_elementAt(cbor, 1, t1),
        t4 = A.ExtractCborList_elementAt(cbor, 2, t1),
        t5 = A.ExtractCborList_elementAt(cbor, 3, t1),
        t6 = A.ExtractCborList_elementAt(cbor, 4, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 5, t1);
      t7 = type$.int;
      t8 = A.ExtractCborList_elementAt(cbor, 6, t7);
      t8 = new A.TronAccountResourceInfo(t2, t3, t4, t5, t6, t1, A.ExtractCborList_elementAt(cbor, 7, t7), t8);
      t8.__TronAccountResourceInfo_totalBandWith_F = t3.$add(0, t4);
      t8.__TronAccountResourceInfo_totalBandWithUsed_F = t5.$add(0, t2);
      t1 = t8.__TronAccountResourceInfo_howManyEnergy_F = t6.$sub(0, t1);
      t2 = $.$get$_BigIntImpl_zero();
      if (t1.compareTo$1(0, t2) < 0) {
        t1 !== $ && A.throwLateFieldAI("howManyEnergy");
        t8.__TronAccountResourceInfo_howManyEnergy_F = t2;
      }
      return t8;
    },
    TronAccountResourceInfo: function TronAccountResourceInfo(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.freeNetUsed = t0;
      _.freeNetLimit = t1;
      _.netLimit = t2;
      _.netUsed = t3;
      _.energyLimit = t4;
      _.energyUsed = t5;
      _.tronPowerUsed = t6;
      _.tronPowerLimit = t7;
      _.__TronAccountResourceInfo_totalBandWithUsed_F = _.__TronAccountResourceInfo_howManyEnergy_F = _.__TronAccountResourceInfo_totalBandWith_F = $;
    },
    _TronAccountResourceInfo_Object_CborSerializable: function _TronAccountResourceInfo_Object_CborSerializable() {
    },
    TronAccountInfo_TronAccountInfo$fromCborBytesOrObject(obj) {
      var t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, cbor0, t19, t20, t21, t22, t23,
        t1 = type$.CborListValue_dynamic,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_195_100, t1),
        t2 = type$.dynamic,
        witness = A.ExtractCborList_elementAt(cbor, 14, t2),
        t3 = type$.nullable_String,
        t4 = A.ExtractCborList_elementAt(cbor, 0, t3),
        t5 = A.ExtractCborList_elementAt(cbor, 1, type$.String),
        t6 = type$.BigInt,
        t7 = A.ExtractCborList_elementAt(cbor, 2, t6);
      t6 = A.ExtractCborList_elementAt(cbor, 3, t6);
      t8 = type$.nullable_BigInt;
      t9 = A.ExtractCborList_elementAt(cbor, 4, t8);
      t10 = type$.List_dynamic;
      t11 = J.map$1$1$ax(t10._as(A.ExtractCborList_elementAt(cbor, 5, t2)), new A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure(), type$.FrozenSupply);
      t11 = A.List_List$of(t11, true, t11.$ti._eval$1("ListIterable.E"));
      t12 = A.ExtractCborList_elementAt(cbor, 6, t3);
      t13 = A.ExtractCborList_elementAt(cbor, 7, type$.nullable_int);
      t14 = A.ExtractCborList_elementAt(cbor, 8, t8);
      t15 = type$.int;
      t16 = A.ExtractCborList_elementAt(cbor, 9, t15);
      t17 = type$.bool;
      t18 = A.ExtractCborList_elementAt(cbor, 10, t17);
      cbor0 = A.CborSerializable_decodeCborTags(null, A.ExtractCborList_getCborTag(cbor, 11), B.List_200_195_100_1, t1);
      t15 = A.ExtractCborList_elementAt(cbor0, 0, t15);
      t8 = A.ExtractCborList_elementAt(cbor0, 1, t8);
      t1 = A.ExtractCborList_elementAt(cbor0, 2, t17);
      t19 = A.AccountPermission_AccountPermission$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 12));
      t20 = J.map$1$1$ax(t10._as(A.ExtractCborList_elementAt(cbor, 13, t2)), new A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure0(), type$.AccountPermission);
      t20 = A.List_List$of(t20, true, t20.$ti._eval$1("ListIterable.E"));
      if (witness != null)
        A.AccountPermission_AccountPermission$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 14));
      t21 = J.map$1$1$ax(t10._as(A.ExtractCborList_elementAt(cbor, 15, t2)), new A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure1(), type$.FrozenV2);
      t21 = A.List_List$of(t21, true, t21.$ti._eval$1("ListIterable.E"));
      t22 = J.map$1$1$ax(t10._as(A.ExtractCborList_elementAt(cbor, 16, t2)), new A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure2(), type$.UnfrozenV2);
      t22 = A.List_List$of(t22, true, t22.$ti._eval$1("ListIterable.E"));
      t23 = J.map$1$1$ax(t10._as(A.ExtractCborList_elementAt(cbor, 17, t2)), new A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure3(), type$.AssetV2);
      t23 = A.List_List$of(t23, true, t23.$ti._eval$1("ListIterable.E"));
      t3 = A.ExtractCborList_elementAt(cbor, 18, t3);
      t2 = J.map$1$1$ax(t10._as(A.ExtractCborList_elementAt(cbor, 19, t2)), new A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure4(), type$.FreeAssetNetUsageV2);
      return new A.TronAccountInfo(t4, t5, t7, t6, t9, t11, t12, t13, t14, t16, t18, new A.TronAccountResource(t15, t8, t1), t19, t20, t21, t22, t23, t3, A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E")), A.ExtractCborList_elementAt(cbor, 20, t17));
    },
    AccountPermission_AccountPermission$fromCborBytesOrObject(obj) {
      var cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_195_100_8, type$.CborListValue_dynamic),
        t1 = J.map$1$1$ax(type$.List_dynamic._as(A.ExtractCborList_elementAt(cbor, 5, type$.dynamic)), new A.AccountPermission_AccountPermission$fromCborBytesOrObject_closure(), type$.PermissionKeys),
        keys = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      t1 = type$.nullable_String;
      return new A.AccountPermission(A.PermissionType_fromName(A.ExtractCborList_elementAt(cbor, 0, t1), B.PermissionType_Owner_0), A.ExtractCborList_elementAt(cbor, 1, type$.nullable_int), A.ExtractCborList_elementAt(cbor, 2, t1), A.ExtractCborList_elementAt(cbor, 3, type$.BigInt), A.ExtractCborList_elementAt(cbor, 4, t1), keys);
    },
    TronAccountInfo: function TronAccountInfo(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19) {
      var _ = this;
      _.accountName = t0;
      _.address = t1;
      _.balance = t2;
      _.createTime = t3;
      _.latestOperationTime = t4;
      _.frozenSupply = t5;
      _.assetIssuedName = t6;
      _.freeNetUsage = t7;
      _.latestConsumeFreeTime = t8;
      _.netWindowSize = t9;
      _.netWindowOptimized = t10;
      _.accountResource = t11;
      _.ownerPermission = t12;
      _.activePermissions = t13;
      _.frozenV2 = t14;
      _.unfrozenV2 = t15;
      _.assetV2 = t16;
      _.assetIssuedID = t17;
      _.freeAssetNetUsageV2 = t18;
      _.assetOptimized = t19;
    },
    TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure: function TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure() {
    },
    TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure0: function TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure0() {
    },
    TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure1: function TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure1() {
    },
    TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure2: function TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure2() {
    },
    TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure3: function TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure3() {
    },
    TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure4: function TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure4() {
    },
    AccountPermission: function AccountPermission(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.type = t0;
      _.id = t1;
      _.permissionName = t2;
      _.threshold = t3;
      _.operations = t4;
      _.keys = t5;
    },
    AccountPermission_AccountPermission$fromCborBytesOrObject_closure: function AccountPermission_AccountPermission$fromCborBytesOrObject_closure() {
    },
    PermissionKeys: function PermissionKeys(t0, t1) {
      this.address = t0;
      this.weight = t1;
    },
    FrozenSupply: function FrozenSupply(t0, t1) {
      this.frozenBalance = t0;
      this.expireTime = t1;
    },
    FrozenV2: function FrozenV2(t0, t1) {
      this.amount = t0;
      this.type = t1;
    },
    UnfrozenV2: function UnfrozenV2(t0, t1, t2) {
      this.type = t0;
      this.unfreezeAmount = t1;
      this.unfreezeExpireTime = t2;
    },
    AssetV2: function AssetV2(t0, t1) {
      this.key = t0;
      this.value = t1;
    },
    FreeAssetNetUsageV2: function FreeAssetNetUsageV2(t0, t1) {
      this.key = t0;
      this.value = t1;
    },
    TronAccountResource: function TronAccountResource(t0, t1, t2) {
      this.energyWindowSize = t0;
      this.delegatedFrozenV2BalanceForEnergy = t1;
      this.energyWindowOptimized = t2;
    },
    _AccountPermission_Object_CborSerializable: function _AccountPermission_Object_CborSerializable() {
    },
    _AssetV2_Object_CborSerializable: function _AssetV2_Object_CborSerializable() {
    },
    _FreeAssetNetUsageV2_Object_CborSerializable: function _FreeAssetNetUsageV2_Object_CborSerializable() {
    },
    _FrozenSupply_Object_CborSerializable: function _FrozenSupply_Object_CborSerializable() {
    },
    _FrozenV2_Object_CborSerializable: function _FrozenV2_Object_CborSerializable() {
    },
    _PermissionKeys_Object_CborSerializable: function _PermissionKeys_Object_CborSerializable() {
    },
    _PermissionKeys_Object_CborSerializable_Equatable: function _PermissionKeys_Object_CborSerializable_Equatable() {
    },
    _TronAccountInfo_Object_CborSerializable: function _TronAccountInfo_Object_CborSerializable() {
    },
    _TronAccountResource_Object_CborSerializable: function _TronAccountResource_Object_CborSerializable() {
    },
    _UnfrozenV2_Object_CborSerializable: function _UnfrozenV2_Object_CborSerializable() {
    },
    RippleNFToken_RippleNFToken$fromCborBytesOrObject(obj) {
      var cbor, flags, nftokenId, nftokenTaxon, issuer, serial, uri, t1, exception, bytes = null;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_120_10, type$.CborListValue_dynamic);
        t1 = A.ExtractCborList_getInt(cbor, 0);
        t1.toString;
        flags = t1;
        t1 = A.ExtractCborList_getString(cbor, 1);
        t1.toString;
        nftokenId = t1;
        t1 = A.ExtractCborList_getInt(cbor, 2);
        t1.toString;
        nftokenTaxon = t1;
        t1 = A.ExtractCborList_getString(cbor, 3);
        t1.toString;
        issuer = t1;
        t1 = A.ExtractCborList_getInt(cbor, 4);
        t1.toString;
        serial = t1;
        uri = A.ExtractCborList_getString(cbor, 5);
        return new A.RippleNFToken(uri, nftokenId, flags, issuer, serial, nftokenTaxon);
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.WalletException)
          throw exception;
        else {
          t1 = $.$get$WalletExceptionConst_invalidNftInfromaation();
          throw A.wrapException(t1);
        }
      }
    },
    RippleNFToken: function RippleNFToken(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.uri = t0;
      _.nftokenId = t1;
      _.flags = t2;
      _.issuer = t3;
      _.serial = t4;
      _.nftokenTaxon = t5;
    },
    _RippleNFToken_Object_Equatable: function _RippleNFToken_Object_Equatable() {
    },
    CoingeckoCoin: function CoingeckoCoin(t0, t1, t2) {
      this.apiId = t0;
      this.coinName = t1;
      this.symbol = t2;
    },
    _CoingeckoCoin_Object_CborSerializable: function _CoingeckoCoin_Object_CborSerializable() {
    },
    _CoingeckoCoin_Object_CborSerializable_JsonSerialization: function _CoingeckoCoin_Object_CborSerializable_JsonSerialization() {
    },
    Token_Token$fromCborBytesOrObject(obj) {
      var cbor, $name, symbol, decimal, logo, market, logoCbor, image, t1, exception, bytes = null;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_110, type$.CborListValue_dynamic);
        t1 = type$.String;
        $name = A.ExtractCborList_elementAt(cbor, 0, t1);
        symbol = A.ExtractCborList_elementAt(cbor, 1, t1);
        decimal = A.ExtractCborList_elementAt(cbor, 2, type$.nullable_int);
        logo = A.ExtractCborList_elementAt(cbor, 3, type$.nullable_String);
        t1 = A.ExtractCborList_getCborTag(cbor, 4);
        market = t1 == null ? null : A.QuickCbor_to(t1, new A.Token_Token$fromCborBytesOrObject_closure(), type$.CoingeckoCoin, type$.CborObject);
        logoCbor = A.ExtractCborList_getCborTag(cbor, 3);
        image = null;
        if (logo != null)
          image = new A.APPImage();
        else if (logoCbor != null)
          image = A.APPImage_APPImage$fromCborBytesOrObject(logoCbor);
        t1 = A.Token_Token(image, decimal, market, $name, symbol);
        return t1;
      } catch (exception) {
        t1 = $.$get$WalletExceptionConst_invalidTokenInformation();
        throw A.wrapException(t1);
      }
    },
    Token_Token(assetLogo, decimal, market, $name, symbol) {
      if (decimal != null)
        if (decimal < 0 || decimal > 255)
          throw A.wrapException($.$get$WalletExceptionConst_invalidTokenInformation());
      A.StrUtils_substring($name, 20);
      A.StrUtils_substring(symbol, 5);
      return new A.Token($name, symbol, decimal);
    },
    Token: function Token(t0, t1, t2) {
      this.name = t0;
      this.symbol = t1;
      this.decimal = t2;
    },
    Token_Token$fromCborBytesOrObject_closure: function Token_Token$fromCborBytesOrObject_closure() {
    },
    _Token_Object_CborSerializable: function _Token_Object_CborSerializable() {
    },
    _Token_Object_CborSerializable_Equatable: function _Token_Object_CborSerializable_Equatable() {
    },
    ETHERC20Token_ETHERC20Token$fromCborBytesOrObject(obj) {
      var cbor, token, contractAddress, balance, updated, t1, t2, exception, bytes = null;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_110_20, type$.CborListValue_dynamic);
        token = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 0));
        contractAddress = A.ETHAddress_ETHAddress(A.ExtractCborList_elementAt(cbor, 1, type$.String));
        t1 = A.ExtractCborList_elementAt(cbor, 2, type$.BigInt);
        t2 = token.decimal;
        t2.toString;
        balance = new A.Live(A.IntegerBalance_IntegerBalance(t1, t2, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance);
        updated = A.ExtractCborList_elementAt(cbor, 3, type$.DateTime);
        return new A.ETHERC20Token(contractAddress, token);
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.WalletException)
          throw exception;
        else {
          t1 = $.$get$WalletExceptionConst_invalidTokenInformation();
          throw A.wrapException(t1);
        }
      }
    },
    ETHERC20Token: function ETHERC20Token(t0, t1) {
      this.contractAddress = t0;
      this.token = t1;
    },
    _ETHERC20Token_Object_Equatable: function _ETHERC20Token_Object_Equatable() {
    },
    RippleIssueToken_RippleIssueToken$fromCborBytesOrObject(obj) {
      var cbor, token, issuer, balance, updated, t1, inRetional, $toString, exception, bytes = null;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_110_10, type$.CborListValue_dynamic);
        token = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 0));
        t1 = type$.String;
        issuer = A.ExtractCborList_elementAt(cbor, 1, t1);
        inRetional = A.BigRational_tryParseDecimaal(A.ExtractCborList_elementAt(cbor, 2, t1));
        if (inRetional == null)
          A.throwExpression($.$get$WalletExceptionConst_invalidBalance());
        $toString = inRetional.toDecimal$1$digits(4);
        t1 = inRetional.toDecimal$1$digits(4);
        A.StrUtils_to3Digits($toString, ",");
        balance = new A.Live(new A.DecimalBalance(t1), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_DecimalBalance);
        updated = A.ExtractCborList_elementAt(cbor, 3, type$.DateTime);
        return new A.RippleIssueToken(issuer, token);
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.WalletException)
          throw exception;
        else {
          t1 = $.$get$WalletExceptionConst_invalidTokenInformation();
          throw A.wrapException(t1);
        }
      }
    },
    RippleIssueToken: function RippleIssueToken(t0, t1) {
      this.issuer = t0;
      this.token = t1;
    },
    _RippleIssueToken_Object_Equatable: function _RippleIssueToken_Object_Equatable() {
    },
    TonJettonToken_TonJettonToken$fromCborBytesOrObject(obj) {
      var cbor, token, minterAddress, walletAddress, balance, updated, t1, t2, t3, exception, bytes = null;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_110_33, type$.CborListValue_dynamic);
        token = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 0));
        t1 = type$.String;
        minterAddress = A.ExtractCborList_elementAt(cbor, 1, t1);
        walletAddress = A.ExtractCborList_elementAt(cbor, 2, t1);
        t1 = A.ExtractCborList_elementAt(cbor, 3, type$.BigInt);
        t2 = token.decimal;
        t2.toString;
        balance = new A.Live(A.IntegerBalance_IntegerBalance(t1, t2, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance);
        updated = A.ExtractCborList_elementAt(cbor, 4, type$.DateTime);
        t2 = A.TonAddress_TonAddress(minterAddress);
        t1 = A.TonAddress_TonAddress(walletAddress);
        t3 = type$.nullable_String;
        A.ExtractCborList_elementAt(cbor, 5, t3);
        A.ExtractCborList_elementAt(cbor, 6, t3);
        A.ExtractCborList_elementAt(cbor, 7, type$.bool);
        return new A.TonJettonToken(t2, t1, token);
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.WalletException)
          throw exception;
        else {
          t1 = $.$get$WalletExceptionConst_invalidTokenInformation();
          throw A.wrapException(t1);
        }
      }
    },
    TonJettonToken: function TonJettonToken(t0, t1, t2) {
      this.minterAddress = t0;
      this.walletAddress = t1;
      this.token = t2;
    },
    _TonJettonToken_Object_Equatable: function _TonJettonToken_Object_Equatable() {
    },
    SolanaSPLToken_SolanaSPLToken$fromCborBytesOrObject(obj) {
      var cbor, token, mint, balance, updated, tokenAccount, tokenOwner, t1, t2, t3, exception, bytes = null;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_110_32, type$.CborListValue_dynamic);
        token = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 0));
        t1 = type$.String;
        mint = A.ExtractCborList_elementAt(cbor, 1, t1);
        t2 = A.ExtractCborList_elementAt(cbor, 2, type$.BigInt);
        t3 = token.decimal;
        t3.toString;
        balance = new A.Live(A.IntegerBalance_IntegerBalance(t2, t3, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance);
        updated = A.ExtractCborList_elementAt(cbor, 3, type$.DateTime);
        tokenAccount = A.ExtractCborList_elementAt(cbor, 4, t1);
        tokenOwner = A.ExtractCborList_elementAt(cbor, 5, t1);
        t1 = mint;
        new A.SolAddrDecoder().decodeAddr$1(t1);
        t3 = tokenAccount;
        new A.SolAddrDecoder().decodeAddr$1(t3);
        new A.SolAddrDecoder().decodeAddr$1(tokenOwner);
        return new A.SolanaSPLToken(new A.SolAddress(t1), new A.SolAddress(t3), token);
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.WalletException)
          throw exception;
        else {
          t1 = $.$get$WalletExceptionConst_invalidTokenInformation();
          throw A.wrapException(t1);
        }
      }
    },
    SolanaSPLToken: function SolanaSPLToken(t0, t1, t2) {
      this.mint = t0;
      this.tokenAccount = t1;
      this.token = t2;
    },
    _SolanaSPLToken_Object_Equatable: function _SolanaSPLToken_Object_Equatable() {
    },
    TronTRC10Token_TronTRC10Token$fromCborBytesOrObject(obj) {
      var cbor, token, tokenID, balance, updated, t1, t2, exception, bytes = null;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_110_31, type$.CborListValue_dynamic);
        token = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 0));
        tokenID = A.ExtractCborList_elementAt(cbor, 1, type$.String);
        t1 = A.ExtractCborList_elementAt(cbor, 2, type$.BigInt);
        t2 = token.decimal;
        t2.toString;
        balance = new A.Live(A.IntegerBalance_IntegerBalance(t1, t2, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance);
        updated = A.ExtractCborList_elementAt(cbor, 3, type$.DateTime);
        return new A.TronTRC10Token(tokenID, token);
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.WalletException)
          throw exception;
        else {
          t1 = $.$get$WalletExceptionConst_invalidTokenInformation();
          throw A.wrapException(t1);
        }
      }
    },
    TronTRC10Token: function TronTRC10Token(t0, t1) {
      this.tokenID = t0;
      this.token = t1;
    },
    _TronTRC10Token_Object_Equatable: function _TronTRC10Token_Object_Equatable() {
    },
    TronTRC20Token_TronTRC20Token$fromCborBytesOrObject(obj) {
      var cbor, token, contractAddress, balance, updated, t1, t2, exception, bytes = null;
      try {
        cbor = A.CborSerializable_decodeCborTags(bytes, obj, B.List_110_30, type$.CborListValue_dynamic);
        token = A.Token_Token$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 0));
        contractAddress = A.TronAddress_TronAddress(A.ExtractCborList_elementAt(cbor, 1, type$.String));
        t1 = A.ExtractCborList_elementAt(cbor, 2, type$.BigInt);
        t2 = token.decimal;
        t2.toString;
        balance = new A.Live(A.IntegerBalance_IntegerBalance(t1, t2, false), A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_IntegerBalance);
        updated = A.ExtractCborList_elementAt(cbor, 3, type$.DateTime);
        return new A.TronTRC20Token(contractAddress, token);
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.WalletException)
          throw exception;
        else {
          t1 = $.$get$WalletExceptionConst_invalidTokenInformation();
          throw A.wrapException(t1);
        }
      }
    },
    TronTRC20Token: function TronTRC20Token(t0, t1) {
      this.contractAddress = t0;
      this.token = t1;
    },
    _TronTRC20Token_Object_Equatable: function _TronTRC20Token_Object_Equatable() {
    },
    ChainsHandler_ChainsHandler$deserialize(bytes) {
      var values = A.CborSerializable_cborTagValue(bytes, null, null, B.List_60_3, type$.CborListValue_dynamic),
        t1 = J.map$1$1$ax(A.ExtractCborList_elementAt(values, 0, type$.List_dynamic), new A.ChainsHandler_ChainsHandler$deserialize_closure(), type$.Chain_of_APIProvider_and_NetworkCoinParams_APIProvider_and_dynamic_and_TokenCore_dynamic_and_ChainAccount_of_nullable_Object_and_TokenCore_dynamic_and_WalletNetwork_NetworkCoinParams_APIProvider_and_NetworkClient_of_ChainAccount_of_nullable_Object_and_TokenCore_dynamic_and_APIProvider_and_Web3BaseRequestParams_dynamic_dynamic_dynamic);
      return A.ChainsHandler_ChainsHandler(A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E")), A.ExtractCborList_elementAt(values, 1, type$.nullable_int));
    },
    ChainsHandler_ChainsHandler(chains, currentNetwork) {
      var t4, _i, i, t5, chain,
        t1 = type$.int,
        t2 = type$.Chain_of_APIProvider_and_NetworkCoinParams_APIProvider_and_dynamic_and_TokenCore_dynamic_and_ChainAccount_of_dynamic_and_TokenCore_dynamic_and_WalletNetwork_NetworkCoinParams_APIProvider_and_NetworkClient_of_ChainAccount_of_dynamic_and_TokenCore_dynamic_and_APIProvider_and_Web3BaseRequestParams_dynamic_dynamic_dynamic,
        t3 = A.LinkedHashMap_LinkedHashMap$_empty(t1, t2);
      for (t4 = chains.length, _i = 0; _i < chains.length; chains.length === t4 || (0, A.throwConcurrentModificationError)(chains), ++_i) {
        i = chains[_i];
        t3.$indexSet(0, i.network.get$value(), i);
      }
      for (t4 = $.$get$ChainConst_defaultCoins().get$keys(), t4 = t4.get$iterator(t4); t4.moveNext$0();) {
        t5 = t4.get$current();
        if (t3.containsKey$1(t5))
          continue;
        t5 = $.$get$ChainConst_defaultCoins().$index(0, t5);
        t5.toString;
        chain = A.Chain_setup(t5);
        t3.addAll$1(0, A.LinkedHashMap_LinkedHashMap$_literal([chain.network.get$value(), chain], t1, t2));
      }
      t3.containsKey$1(currentNetwork);
      return new A.ChainsHandler(t3);
    },
    ChainsHandler: function ChainsHandler(t0) {
      this._networks = t0;
    },
    ChainsHandler_ChainsHandler$deserialize_closure: function ChainsHandler_ChainsHandler$deserialize_closure() {
    },
    _ChainsHandler_Object_CborSerializable: function _ChainsHandler_Object_CborSerializable() {
    },
    Web3RequestMethods_fromTag(tag) {
      switch (A.NetworkType_fromTag(tag)) {
        case B.NetworkType_iDZ:
          tag.toString;
          return A.Web3EthereumRequestMethods_fromId(J.get$last$ax(tag));
        default:
          throw A.wrapException(B.Web3InternalException_86y);
      }
    },
    Web3RequestMethods: function Web3RequestMethods() {
    },
    Web3RequestParams_Web3RequestParams$deserialize(object, RESULT, RESPONSE, NETWORKADDRESS) {
      var t1, param, _null = null;
      A.Web3RequestMethods_fromTag(A.ExtractCborList_elementAt(A.CborSerializable_cborTagValue(_null, _null, object, B.List_0_10_100_2, type$.CborListValue_dynamic), 0, type$.nullable_List_int));
      switch (B.NetworkType_iDZ) {
        case B.NetworkType_iDZ:
          t1 = type$.dynamic;
          param = A.Web3EthereumRequestParam_Web3EthereumRequestParam$deserialize(_null, _null, object, t1, t1);
          break;
        default:
          throw A.wrapException(A.Web3InternalException_internalError("message_" + A.S(A.BytesUtils_tryToHexString(_null))));
      }
      if (!RESULT._eval$1("@<0>")._bind$1(RESPONSE)._bind$1(NETWORKADDRESS)._eval$1("Web3RequestParams<1,2,3>")._is(param))
        throw A.wrapException(A.Web3InternalException_internalError("message"));
      return param;
    },
    Web3RequestParams: function Web3RequestParams() {
    },
    _Web3RequestParams_Web3MessageCore_JsonSerialization: function _Web3RequestParams_Web3MessageCore_JsonSerialization() {
    },
    Web3EthereumRequestException: function Web3EthereumRequestException() {
    },
    Web3EthereumRequestMethods_fromId(id) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_EUu, new A.Web3EthereumRequestMethods_fromId_closure(id), new A.Web3EthereumRequestMethods_fromId_closure0());
    },
    Web3EthereumRequestMethods_fromName($name) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_EUu, new A.Web3EthereumRequestMethods_fromName_closure($name), new A.Web3EthereumRequestMethods_fromName_closure0());
    },
    Web3EthereumRequestMethods: function Web3EthereumRequestMethods(t0, t1, t2) {
      this.id = t0;
      this.name = t1;
      this.methodsName = t2;
    },
    Web3EthereumRequestMethods_fromId_closure: function Web3EthereumRequestMethods_fromId_closure(t0) {
      this.id = t0;
    },
    Web3EthereumRequestMethods_fromId_closure0: function Web3EthereumRequestMethods_fromId_closure0() {
    },
    Web3EthereumRequestMethods_fromName_closure: function Web3EthereumRequestMethods_fromName_closure(t0) {
      this.name = t0;
    },
    Web3EthereumRequestMethods_fromName_closure0: function Web3EthereumRequestMethods_fromName_closure0() {
    },
    Web3EthereumRequestParam_Web3EthereumRequestParam$deserialize(bytes, hex, object, RESULT, RESPONSE) {
      var values, t2, t3, t4, t5, t6, t7, t8, t9, param, challeng, _null = null,
        t1 = type$.CborListValue_dynamic;
      switch (A.Web3RequestMethods_fromTag(A.ExtractCborList_elementAt(A.CborSerializable_cborTagValue(bytes, hex, object, B.List_0_10_100_2, t1), 0, type$.nullable_List_int))) {
        case B.Web3EthereumRequestMethods_7xV:
          values = A.CborSerializable_cborTagValue(bytes, hex, object, B.List_0_10_100_2, t1);
          t2 = A.ExtractCborList_elementAt(values, 1, type$.BigInt);
          t3 = type$.String;
          t4 = A.ExtractCborList_elementAt(values, 2, t3);
          t5 = A.ExtractCborList_elementAt(values, 3, t3);
          t6 = A.ExtractCborList_elementAt(values, 4, t3);
          t1 = A.ExtractCborList_cast(A.ExtractCborList_elementAt(values, 5, t1), t3);
          t7 = type$.nullable_CborListValue_dynamic;
          t8 = A.ExtractCborList_elementAt(values, 6, t7);
          t8 = t8 == null ? _null : A.ExtractCborList_cast(t8, t3);
          t7 = A.ExtractCborList_elementAt(values, 7, t7);
          t7 = t7 == null ? _null : A.ExtractCborList_cast(t7, t3);
          t9 = A.ExtractCborList_elementAt(values, 8, type$.int);
          t1 = A.List_List$unmodifiable(t1, t3);
          if (t8 == null)
            t8 = _null;
          else
            t8 = t8.length === 0 ? _null : A.List_List$unmodifiable(t8, t3);
          if (t7 == null)
            t3 = _null;
          else
            t3 = t7.length === 0 ? _null : A.List_List$unmodifiable(t7, t3);
          param = new A.Web3EthreumAddChain(t2, t4, t5, t6, t1, t8, t3, t9, new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_dynamic), type$._AsyncCompleter_dynamic));
          break;
        case B.Web3EthereumRequestMethods_1_personal_sign_List_empty:
          values = A.CborSerializable_cborTagValue(bytes, hex, object, B.List_0_10_100_2, t1);
          challeng = A.ExtractCborList_elementAt(values, 2, type$.List_int);
          t1 = A.ETHAddress_ETHAddress(A.ExtractCborList_elementAt(values, 1, type$.String));
          t2 = A.BytesUtils_toHexString(challeng, true, "0x");
          A.StringUtils_tryDecode(challeng);
          param = new A.Web3EthreumPersonalSign(t1, t2, new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_dynamic), type$._AsyncCompleter_dynamic));
          break;
        case B.Web3EthereumRequestMethods_5_eth_requestAccounts_List_empty:
          param = new A.Web3EthreumRequestAccounts(A.ExtractCborList_elementAt(A.CborSerializable_cborTagValue(bytes, hex, object, B.List_0_10_100_2, t1), 1, type$.BigInt), new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_List_Web3AccountPermission_ETHAddress), type$._AsyncCompleter_List_Web3AccountPermission_ETHAddress));
          break;
        case B.Web3EthereumRequestMethods_0_eth_sendTransaction_List_empty:
          values = A.CborSerializable_cborTagValue(bytes, hex, object, B.Web3EthereumRequestMethods_0_eth_sendTransaction_List_empty.get$tag(), t1);
          t1 = type$.String;
          t2 = type$.nullable_BigInt;
          param = new A.Web3EthreumSendTransaction(A.ETHAddress_ETHAddress(A.ExtractCborList_elementAt(values, 0, t1)), A.ETHAddress_ETHAddress(A.ExtractCborList_elementAt(values, 1, t1)), A.ExtractCborList_elementAt(values, 2, type$.nullable_int), A.ExtractCborList_elementAt(values, 3, t2), A.ExtractCborList_elementAt(values, 4, t2), A.ExtractCborList_elementAt(values, 5, t2), A.ExtractCborList_elementAt(values, 6, type$.BigInt), A.ExtractCborList_elementAt(values, 7, type$.List_int), new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_dynamic), type$._AsyncCompleter_dynamic));
          break;
        case B.Web3EthereumRequestMethods_MEg:
          values = A.CborSerializable_cborTagValue(bytes, hex, object, B.List_0_10_100_2, t1);
          t1 = type$.String;
          t2 = A.ETHAddress_ETHAddress(A.ExtractCborList_elementAt(values, 1, t1));
          t1 = A.EIP712Base_EIP712Base$fromJson(A.StringUtils_toJson(A.ExtractCborList_elementAt(values, 2, t1), type$.Map_String_dynamic));
          param = A.Web3EthreumTypdedData$(t2, A.ExtractCborList_elementAt(values, 3, type$.BigInt), t1);
          break;
        case B.Web3EthereumRequestMethods_EuK:
          param = new A.Web3EthreumSwitchChain(A.ExtractCborList_elementAt(A.CborSerializable_cborTagValue(bytes, hex, object, B.List_0_10_100_2, t1), 1, type$.BigInt), new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_dynamic), type$._AsyncCompleter_dynamic));
          break;
        default:
          throw A.wrapException(A.Web3InternalException_internalError("request_" + A.S(A.BytesUtils_tryToHexString(bytes))));
      }
      if (!RESULT._eval$1("@<0>")._bind$1(RESPONSE)._eval$1("Web3EthereumRequestParam<1,2>")._is(param))
        throw A.wrapException(A.Web3InternalException_internalError("request"));
      return param;
    },
    Web3EthereumPermissionRequestParam: function Web3EthereumPermissionRequestParam() {
    },
    Web3EthereumRequestParam: function Web3EthereumRequestParam() {
    },
    Web3EthreumAddChain: function Web3EthreumAddChain(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.chainId = t0;
      _.chainName = t1;
      _.name = t2;
      _.symbol = t3;
      _.rpcUrls = t4;
      _.blockExplorerUrls = t5;
      _.iconUrls = t6;
      _.decimals = t7;
      _._completer = t8;
    },
    Web3EthreumPersonalSign_Web3EthreumPersonalSign$fromJson(json) {
      var _s8_ = "challeng",
        t1 = A.Web3ValidatorUtils_parseAddress(json, "address", B.Web3EthereumRequestMethods_0_eth_sendTransaction_List_empty, new A.Web3EthreumPersonalSign_Web3EthreumPersonalSign$fromJson_closure(), type$.ETHAddress),
        t2 = A.Web3ValidatorUtils_parseHex(json, _s8_, B.Web3EthereumRequestMethods_0_eth_sendTransaction_List_empty, type$.String);
      A.StringUtils_tryDecode(A.BytesUtils_fromHexString(A._asString(json.$index(0, _s8_))));
      return new A.Web3EthreumPersonalSign(t1, t2, new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_dynamic), type$._AsyncCompleter_dynamic));
    },
    Web3EthreumPersonalSign: function Web3EthreumPersonalSign(t0, t1, t2) {
      this.address = t0;
      this.challeng = t1;
      this._completer = t2;
    },
    Web3EthreumPersonalSign_Web3EthreumPersonalSign$fromJson_closure: function Web3EthreumPersonalSign_Web3EthreumPersonalSign$fromJson_closure() {
    },
    Web3EthreumRequestAccounts: function Web3EthreumRequestAccounts(t0, t1) {
      this.chainId = t0;
      this._completer = t1;
    },
    Web3EthreumSendTransaction: function Web3EthreumSendTransaction(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.from = t0;
      _.to = t1;
      _.gas = t2;
      _.gasPrice = t3;
      _.maxFeePerGas = t4;
      _.maxPriorityFeePerGas = t5;
      _.value = t6;
      _.data = t7;
      _._completer = t8;
    },
    Web3EthreumTypdedData$(address, chainId, typedData) {
      return new A.Web3EthreumTypdedData(address, typedData, chainId, new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_dynamic), type$._AsyncCompleter_dynamic));
    },
    Web3EthreumTypdedData_Web3EthreumTypdedData$fromJson(json) {
      var t1 = A.Web3ValidatorUtils_parseAddress(json, "address", B.Web3EthereumRequestMethods_MEg, new A.Web3EthreumTypdedData_Web3EthreumTypdedData$fromJson_closure(), type$.ETHAddress),
        t2 = A.Web3EthereumValidator_parseTypedData(A._asString(json.$index(0, "typedData")), B.Web3EthereumRequestMethods_MEg);
      return A.Web3EthreumTypdedData$(t1, A.Web3ValidatorUtils_parseBigInt("chainId", B.Web3EthereumRequestMethods_MEg, type$.BigInt), t2);
    },
    Web3EthreumTypdedData: function Web3EthreumTypdedData(t0, t1, t2, t3) {
      var _ = this;
      _.address = t0;
      _.typedData = t1;
      _.chainId = t2;
      _._completer = t3;
    },
    Web3EthreumTypdedData_Web3EthreumTypdedData$fromJson_closure: function Web3EthreumTypdedData_Web3EthreumTypdedData$fromJson_closure() {
    },
    Web3EthreumSwitchChain: function Web3EthreumSwitchChain(t0, t1) {
      this.chainId = t0;
      this._completer = t1;
    },
    Web3EthereumValidator_parseTypedData(data, method) {
      var e, exception, t1, _null = null,
        _s63_ = "Invalid typedata parameter: the provided typeddata is not valid",
        parse = A.MethodUtils_nullOnException(new A.Web3EthereumValidator_parseTypedData_closure(data), type$.EIP712Base);
      if (parse == null)
        throw A.wrapException(A.Web3ArgrumentException$(false, _null, _s63_, method, B.Web3ArgsTypes_6, _null));
      try {
        parse.encode$0();
      } catch (exception) {
        t1 = A.unwrapException(exception);
        if (t1 instanceof A.SolidityAbiException) {
          e = t1;
          throw A.wrapException(A.Web3ArgrumentException$(false, _null, "Invalid typedata parameter: " + e.message, method, B.Web3ArgsTypes_6, _null));
        } else {
          t1 = A.Web3ArgrumentException$(false, _null, _s63_, method, B.Web3ArgsTypes_6, _null);
          throw A.wrapException(t1);
        }
      }
      return parse;
    },
    Web3EthereumValidator_parseTypedData_closure: function Web3EthereumValidator_parseTypedData_closure(t0) {
      this.data = t0;
    },
    Web3InternalException_internalError(message) {
      var t1 = type$.String;
      return new A.Web3InternalException(null, -2, A.LinkedHashMap_LinkedHashMap$_literal(["targetOrError", message], t1, t1), "internal_request_error_desc");
    },
    Web3ArgrumentException$(isOptional, key, message, method, type, value) {
      return new A.Web3ArgrumentException(value, message);
    },
    Web3ArgsTypes: function Web3ArgsTypes(t0) {
      this._core$_name = t0;
    },
    Web3RequestException: function Web3RequestException() {
    },
    Web3InternalException: function Web3InternalException(t0, t1, t2, t3) {
      var _ = this;
      _.request = t0;
      _.code = t1;
      _.info = t2;
      _.message = t3;
    },
    Web3ArgrumentException: function Web3ArgrumentException(t0, t1) {
      this.value = t0;
      this.message = t1;
    },
    Web3ArgsException: function Web3ArgsException(t0) {
      this.message = t0;
    },
    Web3MessageTypes_fromTag(tags) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_HjA, new A.Web3MessageTypes_fromTag_closure(tags), new A.Web3MessageTypes_fromTag_closure0());
    },
    Web3MessageCore_Web3MessageCore$deserialize(bytes) {
      var cbor, type, t1, tag, values, t2, t3, exception, _null = null, hex = null, object = null;
      try {
        t1 = type$.CborTagValue_dynamic;
        cbor = A.CborSerializable_decode(bytes, hex, object, t1);
        type = A.Web3MessageTypes_fromTag(cbor.tags);
        switch (type) {
          case B.Web3MessageTypes_eYh:
          case B.Web3MessageTypes_n9E:
            tag = A.CborSerializable_decode(_null, _null, cbor, t1);
            type = A.Web3MessageTypes_fromTag(tag.tags);
            t1 = A.BytesUtils_toBytes(A.ExtractCborList_elementAt(A.QuickCborTag_get_getList(tag), 0, type$.List_int), true);
            return new A.Web3ChainMessage(t1, type);
          case B.Web3MessageTypes_fvN:
            t1 = A.Web3ResponseMessage_Web3ResponseMessage(A.ExtractCborList_elementAt(A.CborSerializable_cborTagValue(_null, _null, cbor, B.List_0_10_100_3, type$.CborListValue_dynamic), 0, type$.nullable_Object));
            return t1;
          case B.Web3MessageTypes_359:
            t1 = type$.dynamic;
            t1 = A.Web3RequestParams_Web3RequestParams$deserialize(cbor, t1, t1, t1);
            return t1;
          case B.Web3MessageTypes_L6o:
            values = A.CborSerializable_cborTagValue(_null, _null, cbor, B.List_0_10_100_4, type$.CborListValue_dynamic);
            t1 = type$.String;
            t2 = A.ExtractCborList_elementAt(values, 0, t1);
            t3 = type$.nullable_String;
            t3 = A.Web3ExceptionMessage$(A.ExtractCborList_elementAt(values, 1, type$.nullable_int), A.ExtractCborMap_toMap(A.ExtractCborList_elementAt(values, 2, type$.CborMapValue_dynamic_dynamic), t1, t1), t2, A.ExtractCborList_elementAt(values, 3, t3), A.ExtractCborList_elementAt(values, 4, t3));
            return t3;
          default:
            t1 = A.Web3InternalException_internalError("Message _" + A.S(A.BytesUtils_tryToHexString(bytes)));
            throw A.wrapException(t1);
        }
      } catch (exception) {
        t1 = A.Web3InternalException_internalError("Message _" + A.S(A.BytesUtils_tryToHexString(bytes)));
        throw A.wrapException(t1);
      }
    },
    Web3EncryptedMessage_Web3EncryptedMessage$deserialize(bytes) {
      var values, t1, t2, exception, hex = null, object = null;
      try {
        values = A.CborSerializable_cborTagValue(bytes, hex, object, B.List_0_10_200_0, type$.CborListValue_dynamic);
        t1 = type$.List_int;
        t2 = A.ExtractCborList_elementAt(values, 0, t1);
        t1 = A.BytesUtils_toBytes(A.ExtractCborList_elementAt(values, 1, t1), true);
        return new A.Web3EncryptedMessage(t2, t1);
      } catch (exception) {
        t1 = A.Web3InternalException_internalError("encrypted_message");
        throw A.wrapException(t1);
      }
    },
    Web3ResponseMessage_Web3ResponseMessage(result) {
      if (result == null)
        return B.Web3ResponseMessage_null;
      if (typeof result == "string")
        return new A.Web3ResponseMessage(result);
      return new A.Web3ResponseMessage(B.C_JsonCodec.encode$2$toEncodable(result, null));
    },
    Web3ExceptionMessage$(code, info, message, request, requestId) {
      var t1;
      if (info == null)
        t1 = null;
      else {
        t1 = type$.String;
        t1 = info.__js_helper$_length === 0 ? null : A.ConstantMap_ConstantMap$from(info, t1, t1);
      }
      return new A.Web3ExceptionMessage(message, code, t1, request, requestId);
    },
    Web3MessageTypes: function Web3MessageTypes(t0, t1) {
      this.tag = t0;
      this._core$_name = t1;
    },
    Web3MessageTypes_fromTag_closure: function Web3MessageTypes_fromTag_closure(t0) {
      this.tags = t0;
    },
    Web3MessageTypes_fromTag_closure0: function Web3MessageTypes_fromTag_closure0() {
    },
    Web3MessageCore: function Web3MessageCore() {
    },
    Web3ChainMessage: function Web3ChainMessage(t0, t1) {
      this.message = t0;
      this.type = t1;
    },
    Web3EncryptedMessage: function Web3EncryptedMessage(t0, t1) {
      this.message = t0;
      this.nonce = t1;
    },
    Web3ResponseMessage: function Web3ResponseMessage(t0) {
      this.value = t0;
    },
    Web3ExceptionMessage: function Web3ExceptionMessage(t0, t1, t2, t3, t4) {
      var _ = this;
      _.message = t0;
      _.code = t1;
      _.info = t2;
      _.request = t3;
      _.requestId = t4;
    },
    _Web3EncryptedMessage_Object_CborSerializable: function _Web3EncryptedMessage_Object_CborSerializable() {
    },
    _Web3MessageCore_Object_CborSerializable: function _Web3MessageCore_Object_CborSerializable() {
    },
    Web3ValidatorUtils_parseAddress(json, key, method, onParse, $T) {
      var value, addr,
        t1 = json.$index(0, key);
      if (t1 == null)
        t1 = json.$index(0, A.StrUtils_toSnakeCase(key));
      value = t1 == null ? null : J.toString$0$(t1);
      if (value == null && $T._is(null)) {
        $T._as(null);
        return null;
      }
      if (typeof value != "string")
        throw A.wrapException(A.Web3ArgrumentException$(false, key, null, method, B.Web3ArgsTypes_1, value));
      addr = A.MethodUtils_nullOnException(new A.Web3ValidatorUtils_parseAddress_closure(onParse, value, $T), $T);
      if (addr != null)
        return addr;
      throw A.wrapException(A.Web3ArgrumentException$($T._is(null), key, null, method, B.Web3ArgsTypes_5, value));
    },
    Web3ValidatorUtils_parseHex(json, key, method, $T) {
      var value, t2, toBytes, _null = null,
        t1 = json.$index(0, key);
      if (t1 == null) {
        t1 = json.$index(0, A.StrUtils_toSnakeCase(key));
        value = t1;
      } else
        value = t1;
      if (value == null)
        value = _null;
      t1 = $T._is(null);
      if (t1 && value == null) {
        $T._as(null);
        return null;
      }
      t2 = value == null ? _null : B.JSString_methods.startsWith$1(value, "0x");
      toBytes = t2 === true ? A.BytesUtils_tryFromHexString(value) : _null;
      if (toBytes != null) {
        A.createRuntimeType($T);
        return $T._as(toBytes);
      }
      throw A.wrapException(A.Web3ArgrumentException$(t1, key, _null, method, B.Web3ArgsTypes_4, value));
    },
    Web3ValidatorUtils_parseBigInt(key, method, $T) {
      var toBigInt;
      if ($T._is(null)) {
        $T._as(null);
        return null;
      }
      toBigInt = A.BigintUtils_tryParse(null);
      if (toBigInt != null)
        return $T._as(toBigInt);
      throw A.wrapException(A.Web3ArgrumentException$(false, key, null, method, B.Web3ArgsTypes_0, null));
    },
    Web3ValidatorUtils_parseAddress_closure: function Web3ValidatorUtils_parseAddress_closure(t0, t1, t2) {
      this.onParse = t0;
      this.value = t1;
      this.T = t2;
    },
    CustomCoins$_($name, conf) {
      return new A.CustomCoins($name, conf);
    },
    CustomCoins_getCoin($name, proposal, $T) {
      var coin;
      switch (proposal) {
        case "CIP-0019":
          coin = A.CustomCoins_fromName($name);
          break;
        default:
          coin = A.CryptoCoins_getCoin($name, A.CustomProposal_fromName(proposal));
          break;
      }
      if (coin == null)
        throw A.wrapException($.$get$WalletExceptionConst_coinNotFound());
      if (!$T._is(coin))
        throw A.wrapException($.$get$WalletExceptionConst_invalidCoin());
      return coin;
    },
    CustomCoins_fromName($name) {
      var t1, exception;
      try {
        t1 = B.JSArray_methods.firstWhere$1($.$get$CustomCoins_values(), new A.CustomCoins_fromName_closure($name));
        return t1;
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.StateError)
          return null;
        else
          throw exception;
      }
    },
    CustomProposal_fromName($name) {
      if ($name === "CIP-0019")
        return B.C_CustomProposal;
      return A.CoinProposal_fromName($name);
    },
    CustomCoins: function CustomCoins(t0, t1) {
      this.name = t0;
      this.conf = t1;
    },
    CustomCoins_fromName_closure: function CustomCoins_fromName_closure(t0) {
      this.name = t0;
    },
    CustomProposal: function CustomProposal() {
    },
    CustomCurrencyConf_byronLegacy_closure: function CustomCurrencyConf_byronLegacy_closure() {
    },
    CustomCurrencyConf_byronLegacyTestnet_closure: function CustomCurrencyConf_byronLegacyTestnet_closure() {
    },
    AddressDerivationType_fromTag(tag) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_gQW, new A.AddressDerivationType_fromTag_closure(tag), new A.AddressDerivationType_fromTag_closure0());
    },
    AddressDerivationIndex_fromCborBytesOrObject(obj) {
      var t1, cbor, t2, t3, t4;
      if (obj == null) {
        null.toString;
        t1 = A.CborUtils__decode(null).item1;
      } else
        t1 = obj;
      type$.CborTagValue_dynamic._as(t1);
      switch (A.AddressDerivationType_fromTag(t1.tags)) {
        case B.AddressDerivationType_List_200_81_bip32:
          return A.Bip32AddressIndex_Bip32AddressIndex$fromCborBytesOrObject(t1);
        case B.AddressDerivationType_List_200_84_substrate:
          cbor = A.CborSerializable_decodeCborTags(null, t1, B.List_200_84, type$.CborListValue_dynamic);
          t1 = type$.String;
          t1 = A.CustomCoins_getCoin(A.ExtractCborList_elementAt(cbor, 1, t1), A.ExtractCborList_elementAt(cbor, 0, t1), type$.SubstrateCoins);
          t2 = type$.nullable_String;
          t3 = A.ExtractCborList_elementAt(cbor, 2, t2);
          t4 = A.ExtractCborList_elementAt(cbor, 3, t2);
          A.ExtractCborList_elementAt(cbor, 4, t2);
          return new A.SubstrateAddressIndex(t4, t3, t1);
        case B.AddressDerivationType_List_200_83_multisig:
          return B.C_MultiSigAddressIndex;
        default:
          throw A.wrapException(A.UnimplementedError$("Unsuported key index."));
      }
    },
    AddressDerivationType: function AddressDerivationType(t0, t1) {
      this.tag = t0;
      this._core$_name = t1;
    },
    AddressDerivationType_fromTag_closure: function AddressDerivationType_fromTag_closure(t0) {
      this.tag = t0;
    },
    AddressDerivationType_fromTag_closure0: function AddressDerivationType_fromTag_closure0() {
    },
    AddressDerivationIndex: function AddressDerivationIndex() {
    },
    _AddressDerivationIndex_Object_CborSerializable: function _AddressDerivationIndex_Object_CborSerializable() {
    },
    _AddressDerivationIndex_Object_CborSerializable_Equatable: function _AddressDerivationIndex_Object_CborSerializable_Equatable() {
    },
    Bip32AddressIndex_Bip32AddressIndex$fromCborBytesOrObject(obj) {
      var t6, t7, t8, t9,
        cbor = A.CborSerializable_decodeCborTags(null, obj, B.List_200_81, type$.CborListValue_dynamic),
        t1 = type$.nullable_int,
        t2 = A.ExtractCborList_elementAt(cbor, 2, t1),
        t3 = A.ExtractCborList_elementAt(cbor, 4, t1),
        t4 = A.ExtractCborList_elementAt(cbor, 3, t1),
        t5 = A.ExtractCborList_elementAt(cbor, 0, t1);
      t1 = A.ExtractCborList_elementAt(cbor, 1, t1);
      t6 = type$.String;
      t6 = A.CustomCoins_getCoin(A.ExtractCborList_elementAt(cbor, 6, t6), A.ExtractCborList_elementAt(cbor, 5, t6), type$.CryptoCoins_CoinConfig);
      t7 = type$.nullable_String;
      t8 = A.SeedTypes_fromName(A.ExtractCborList_elementAt(cbor, 7, t7));
      t9 = A.ExtractCborList_elementAt(cbor, 8, t7);
      A.ExtractCborList_elementAt(cbor, 9, t7);
      return new A.Bip32AddressIndex(t5, t1, t2, t4, t3, t9, A.Bip32AddressIndex__toPath(A._setArrayType([t5, t1, t2, t4, t3], type$.JSArray_nullable_int), t9), t8, t6);
    },
    Bip32AddressIndex__toPath(indexses, importedKeyId) {
      var pathStr, _i,
        t1 = A._arrayInstanceType(indexses),
        t2 = t1._eval$1("MappedIterable<1,Bip32KeyIndex>"),
        bipIndexes = A.List_List$of(new A.MappedIterable(new A.WhereIterable(indexses, t1._eval$1("bool(1)")._as(new A.Bip32AddressIndex__toPath_closure()), t1._eval$1("WhereIterable<1>")), t1._eval$1("Bip32KeyIndex(1)")._as(new A.Bip32AddressIndex__toPath_closure0()), t2), true, t2._eval$1("Iterable.E"));
      t1 = bipIndexes.length;
      if (t1 === 0)
        return null;
      for (pathStr = "m/", _i = 0; _i < t1; ++_i) {
        t2 = bipIndexes[_i].index;
        if ((t2 & 2147483648) >>> 0 === 0)
          pathStr += "" + t2 + "/";
        else
          pathStr += "" + (t2 & 2147483647) + "'/";
      }
      return B.JSString_methods.substring$2(pathStr, 0, pathStr.length - 1);
    },
    Bip32AddressIndex: function Bip32AddressIndex(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.purpose = t0;
      _.coin = t1;
      _.accountLevel = t2;
      _.changeLevel = t3;
      _.addressIndex = t4;
      _.importedKeyId = t5;
      _.hdPath = t6;
      _.seedGeneration = t7;
      _.currencyCoin = t8;
    },
    Bip32AddressIndex__toPath_closure: function Bip32AddressIndex__toPath_closure() {
    },
    Bip32AddressIndex__toPath_closure0: function Bip32AddressIndex__toPath_closure0() {
    },
    MultiSigAddressIndex: function MultiSigAddressIndex() {
    },
    SubstrateAddressIndex: function SubstrateAddressIndex(t0, t1, t2) {
      this.importedKeyId = t0;
      this.substratePath = t1;
      this.currencyCoin = t2;
    },
    SeedTypes_fromName($name) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_jnD, new A.SeedTypes_fromName_closure($name), new A.SeedTypes_fromName_closure0());
    },
    SeedTypes: function SeedTypes(t0, t1) {
      this.name = t0;
      this._core$_name = t1;
    },
    SeedTypes_fromName_closure: function SeedTypes_fromName_closure(t0) {
      this.name = t0;
    },
    SeedTypes_fromName_closure0: function SeedTypes_fromName_closure0() {
    },
    NetworkType_fromTag(tag) {
      var t1 = {};
      t1.tag = tag;
      if (tag != null && J.get$length$asx(tag) > 3)
        t1.tag = J.sublist$2$ax(tag, 0, 3);
      return B.JSArray_methods.firstWhere$2$orElse(B.List_sAO, new A.NetworkType_fromTag_closure(t1), new A.NetworkType_fromTag_closure0());
    },
    NetworkType: function NetworkType(t0, t1) {
      this.name = t0;
      this.tag = t1;
    },
    NetworkType_fromTag_closure: function NetworkType_fromTag_closure(t0) {
      this._box_0 = t0;
    },
    NetworkType_fromTag_closure0: function NetworkType_fromTag_closure0() {
    },
    ADAByronAddress_ADAByronAddress$fromPublicKey(chaincode, hdPath, hdPathKey, network, publicKey) {
      var t1, t2, netTag, chainCodeBytes, hdPathKeyBytes, pubKeyBytes, t3, chainCode,
        _s10_ = "chain_code",
        _s7_ = "hd_path",
        _s11_ = "hd_path_key";
      if (hdPath != null && hdPathKey != null) {
        t1 = A.LinkedHashMap_LinkedHashMap$_literal(["net_tag", network, "chain_code", chaincode, "hd_path", hdPath, "hd_path_key", hdPathKey], type$.String, type$.dynamic);
        t2 = type$.List_int;
        t2._as(publicKey);
        type$.Map_String_dynamic._as(t1);
        netTag = t1.$index(0, "net_tag");
        if (netTag == null)
          netTag = B.ADANetwork_1_764824073_mainnet;
        if (!(netTag instanceof A.ADANetwork))
          A.throwExpression(B.AddressConverterException_QWm);
        if (typeof t1.$index(0, _s7_) == "string")
          hdPath = A.Bip32PathParser_parse(A._asString(t1.$index(0, _s7_)));
        else {
          t1.$index(0, _s7_);
          A.throwExpression(B.AddressConverterException_AZs);
          hdPath = type$.Bip32Path._as(t1.$index(0, _s7_));
        }
        if (t2._is(t1.$index(0, _s10_)))
          chainCodeBytes = t2._as(t1.$index(0, _s10_));
        else {
          t1.$index(0, _s10_);
          A.throwExpression(B.AddressConverterException_kZb);
          chainCodeBytes = type$.Bip32ChainCode._as(t1.$index(0, _s10_)).toBytes$0();
        }
        if (!t2._is(t1.$index(0, _s11_)))
          A.throwExpression(B.AddressConverterException_MPa);
        hdPathKeyBytes = t2._as(t1.$index(0, _s11_));
        if (hdPathKeyBytes.length !== 32)
          A.throwExpression(B.AddressConverterException_MQy);
        pubKeyBytes = A.IPublicKey_IPublicKey$fromBytes(publicKey, B.EllipticCurveTypes_ed25519).get$compressed();
        t1 = $.$get$ADAByronAddrConst_chacha20Poly1305Nonce();
        t2 = $.$get$ADAByronAddrConst_chacha20Poly1305AssocData();
        t3 = new A.CborListValue(hdPath.toList$0(0), false, type$.CborListValue_int).encode$0();
        return new A.ADAByronAddress(A.Base58Encoder_encode(A._AdaByronAddrUtils_encodeKey(pubKeyBytes, chainCodeBytes, B.ADAByronAddrTypes_0_publicKey, A.ChaCha20Poly1305$(hdPathKeyBytes).encrypt$3$associatedData(t1, t3, t2), netTag.protocolMagic).toCbor$0().encode$0(), B.Base58Alphabets_0), network);
      }
      t1 = A.LinkedHashMap_LinkedHashMap$_literal(["net_tag", network, "chain_code", chaincode], type$.String, type$.dynamic);
      t2 = type$.List_int;
      t2._as(publicKey);
      type$.Map_String_dynamic._as(t1);
      netTag = t1.$index(0, "net_tag");
      if (netTag == null)
        netTag = B.ADANetwork_1_764824073_mainnet;
      if (!(netTag instanceof A.ADANetwork))
        A.throwExpression(B.AddressConverterException_QWm);
      chainCode = t1.$index(0, _s10_);
      if (t2._is(chainCode))
        chainCodeBytes = chainCode;
      else {
        A.throwExpression(B.AddressConverterException_Cpp);
        chainCodeBytes = null;
      }
      return new A.ADAByronAddress(A.Base58Encoder_encode(A._AdaByronAddrUtils_encodeKey(A.IPublicKey_IPublicKey$fromBytes(publicKey, B.EllipticCurveTypes_ed25519).get$compressed(), chainCodeBytes, B.ADAByronAddrTypes_0_publicKey, null, netTag.protocolMagic).toCbor$0().encode$0(), B.Base58Alphabets_0), network);
    },
    ADAByronAddress: function ADAByronAddress(t0, t1) {
      this.address = t0;
      this.network = t1;
    },
    ADAAddress_fromAddress(address, $T) {
      var decode, t1, addr, _null = null;
      switch (new A.AdaGenericAddrDecoder().decode$1(address).type) {
        case B.ADAAddressType_0_Base:
          decode = A.AdaAddressUtils_decodeAddres(address, B.ADAAddressType_0_Base, _null);
          t1 = decode.baseHashBytes;
          t1.toString;
          A.AdaAddressUtils_toCerdential(t1);
          t1 = decode.stakeHashBytes;
          t1.toString;
          addr = new A.ADABaseAddress(A.AdaAddressUtils_toCerdential(t1), address, decode.network);
          break;
        case B.ADAAddressType_4_Pointer:
          decode = A.AdaAddressUtils_decodeAddres(address, B.ADAAddressType_4_Pointer, _null);
          t1 = decode.baseHashBytes;
          t1.toString;
          A.AdaAddressUtils_toCerdential(t1);
          decode.pointer.toString;
          addr = new A.ADAPointerAddress(address, decode.network);
          break;
        case B.ADAAddressType_14_Reward:
          decode = A.AdaAddressUtils_decodeAddres(address, B.ADAAddressType_14_Reward, _null);
          t1 = decode.baseHashBytes;
          t1.toString;
          A.AdaAddressUtils_toCerdential(t1);
          addr = new A.ADARewardAddress(address, decode.network);
          break;
        case B.ADAAddressType_6_Enterprise:
          decode = A.AdaAddressUtils_decodeAddres(address, B.ADAAddressType_6_Enterprise, _null);
          t1 = decode.baseHashBytes;
          t1.toString;
          A.AdaAddressUtils_toCerdential(t1);
          addr = new A.ADAEnterpriseAddress(address, decode.network);
          break;
        default:
          decode = A.AdaAddressUtils_decodeAddres(address, B.ADAAddressType_8_Byron, _null);
          addr = new A.ADAByronAddress(A.Base58Encoder_encode(decode.byronAddrPayload.toCbor$0().encode$0(), B.Base58Alphabets_0), decode.network);
          break;
      }
      if (!$T._is(addr))
        throw A.wrapException(A.MessageException$("Invalid address type.", A.LinkedHashMap_LinkedHashMap$_literal(["Excepted", A.createRuntimeType($T).toString$0(0), "Type", A.getRuntimeTypeOfDartObject(addr), "address", addr.get$address()], type$.String, type$.dynamic)));
      return addr;
    },
    ADAAddress: function ADAAddress() {
    },
    _ADAAddress_Object_ADASerialization: function _ADAAddress_Object_ADASerialization() {
    },
    ADAPointerAddress: function ADAPointerAddress(t0, t1) {
      this.address = t0;
      this.network = t1;
    },
    ADARewardAddress: function ADARewardAddress(t0, t1) {
      this.address = t0;
      this.network = t1;
    },
    ADABaseAddress: function ADABaseAddress(t0, t1, t2) {
      this.stakeCredential = t0;
      this.address = t1;
      this.network = t2;
    },
    ADAShellyAddress: function ADAShellyAddress() {
    },
    ADAEnterpriseAddress: function ADAEnterpriseAddress(t0, t1) {
      this.address = t0;
      this.network = t1;
    },
    StakeCred: function StakeCred() {
    },
    StakeCredType: function StakeCredType(t0, t1) {
      this.name = t0;
      this.value = t1;
    },
    _StakeCredType_Object_ADASerialization: function _StakeCredType_Object_ADASerialization() {
    },
    StakeCredKey: function StakeCredKey(t0) {
      this.data = t0;
    },
    StakeCredScript: function StakeCredScript(t0) {
      this.data = t0;
    },
    FixedBytes: function FixedBytes() {
    },
    FixedBytes_hashCode_closure: function FixedBytes_hashCode_closure() {
    },
    _FixedBytes_Object_ADASerialization: function _FixedBytes_Object_ADASerialization() {
    },
    QuickCborObject_getValue(_this, $T) {
      var cborObject,
        t1 = type$.CborObject;
      if (t1._is(_this.get$value())) {
        cborObject = t1._as(_this.get$value());
        if ($T._is(cborObject.get$value()))
          return $T._as(cborObject.get$value());
        if ($T._is(null) && cborObject instanceof A.CborNullValue) {
          $T._as(null);
          return null;
        }
      }
      if ($T._is(null) && _this.get$value() instanceof A.CborNullValue) {
        $T._as(null);
        return null;
      }
      if (!$T._is(_this.get$value()))
        throw A.wrapException(A.MessageException$("Failed to cast value.", A.LinkedHashMap_LinkedHashMap$_literal(["Value", J.get$runtimeType$(_this.get$value()), "Type", A.createRuntimeType($T).toString$0(0)], type$.String, type$.dynamic)));
      return $T._as(_this.get$value());
    },
    ADASerialization: function ADASerialization() {
    },
    ETHAddress_ETHAddress(address) {
      var wihtoutPrefix, t1, exception,
        skipChecksum = true;
      try {
        new A.EthAddrDecoder().decodeAddr$2(address, A.LinkedHashMap_LinkedHashMap$_literal(["skip_chksum_enc", skipChecksum], type$.String, type$.dynamic));
        wihtoutPrefix = A.StringUtils_strip0x(address);
        A.AddrDecUtils_validateLength(wihtoutPrefix, 40);
        t1 = A.EthAddrUtils__checksumEncode(wihtoutPrefix);
        return new A.ETHAddress("0x" + t1);
      } catch (exception) {
        t1 = A.MessageException$("invalid ethereum address", A.LinkedHashMap_LinkedHashMap$_literal(["input", address], type$.String, type$.dynamic));
        throw A.wrapException(t1);
      }
    },
    ETHAddress: function ETHAddress(t0) {
      this.address = t0;
    },
    EVMRPC: function EVMRPC() {
    },
    SolAddress: function SolAddress(t0) {
      this.address = t0;
    },
    ABICoder_ABICoder$fromType(type, $T) {
      var correctType, t1;
      if (B.JSString_methods.endsWith$1(type, "]"))
        correctType = "array";
      else if (B.JSString_methods.startsWith$1(type, "bytes"))
        correctType = "bytes";
      else
        correctType = B.JSString_methods.startsWith$1(type, "uint") || B.JSString_methods.startsWith$1(type, "int") ? "number" : null;
      if (correctType == null)
        correctType = type;
      if (!B.Map_zPayp.containsKey$1(correctType))
        throw A.wrapException(A.SolidityAbiException$("Unsuported ABI type. codec not found", A.LinkedHashMap_LinkedHashMap$_literal(["type", type], type$.String, type$.dynamic)));
      t1 = B.Map_zPayp.$index(0, correctType);
      t1.toString;
      return $T._eval$1("ABICoder<0>")._as(t1);
    },
    AbiParameter$(components, $name, tronTypes, type) {
      return new A.AbiParameter(type, false, components);
    },
    EIP712Version_fromVersion(version) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_Gbr, new A.EIP712Version_fromVersion_closure(version), new A.EIP712Version_fromVersion_closure0(version));
    },
    EIP712Base_EIP712Base$fromJson(json) {
      var version = A.EIP712Version_fromVersion(A._asIntQ(json.$index(0, "version")));
      switch (version) {
        case B.EIP712Version_1:
          return A.EIP712Legacy_EIP712Legacy$fromJson(type$.List_Map_String_dynamic._as(json.$index(0, "types")));
        default:
          return A.Eip712TypedData_Eip712TypedData$fromJson(json, version);
      }
    },
    Eip712TypedData_Eip712TypedData$fromJson(json, version) {
      var jsonTypes, types, i, values, eip712Types, t1, t2, t3, exception;
      try {
        t1 = type$.String;
        jsonTypes = A.LinkedHashMap_LinkedHashMap$from(type$.Map_dynamic_dynamic._as(json.$index(0, "types")), t1, type$.List_dynamic);
        types = A.LinkedHashMap_LinkedHashMap$_empty(t1, type$.List_Eip712TypeDetails);
        for (t1 = jsonTypes.get$entries(), t1 = t1.get$iterator(t1), t2 = type$.Eip712TypeDetails; t1.moveNext$0();) {
          i = t1.get$current();
          values = i.value;
          t3 = J.map$1$1$ax(values, new A.Eip712TypedData_Eip712TypedData$fromJson_closure(), t2);
          eip712Types = A.List_List$of(t3, true, t3.$ti._eval$1("ListIterable.E"));
          J.$indexSet$ax(types, i.key, eip712Types);
        }
        t1 = A._asString(json.$index(0, "primaryType"));
        t2 = type$.Map_String_dynamic;
        t3 = t2._as(json.$index(0, "domain"));
        t2 = t2._as(json.$index(0, "message"));
        return new A.Eip712TypedData(types, t1, t3, t2, version);
      } catch (exception) {
        throw A.wrapException(B.SolidityAbiException_knt);
      }
    },
    EIP712Legacy_EIP712Legacy$fromJson(messages) {
      var t1 = J.map$1$1$ax(messages, new A.EIP712Legacy_EIP712Legacy$fromJson_closure(), type$.Eip712TypedDataV1);
      return new A.EIP712Legacy(A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E")));
    },
    _EIP712Utils_ensureBytes(type, value) {
      if (!B.JSString_methods.startsWith$1(type, "bytes"))
        throw A.wrapException(B.SolidityAbiException_mOy);
      if (typeof value != "string" && !type$.List_int._is(value))
        throw A.wrapException(B.SolidityAbiException_mOy);
      if (type$.List_int._is(value))
        return A.BytesUtils_toBytes(value, false);
      return A.StringUtils_toBytes(A._asString(value));
    },
    _EIP712Utils_ensureCorrectValues(type, value) {
      var childType, t2,
        match = $.$get$_EIP712Utils_arrayRegex().firstMatch$1(type),
        t1 = match == null;
      if (t1)
        childType = null;
      else {
        t2 = match._match;
        if (1 >= t2.length)
          return A.ioore(t2, 1);
        childType = t2[1];
      }
      if (!t1) {
        if (!type$.List_dynamic._is(value))
          throw A.wrapException(A.SolidityAbiException$("Invalid data provided for array codec.", A.LinkedHashMap_LinkedHashMap$_literal(["type", type, "value", value], type$.String, type$.dynamic)));
        t1 = J.map$1$1$ax(value, new A._EIP712Utils_ensureCorrectValues_closure(childType), type$.dynamic);
        return A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      }
      if (B.JSString_methods.startsWith$1(type, "uint") || B.JSString_methods.startsWith$1(type, "int"))
        return A.BigintUtils_parse(value);
      switch (type) {
        case "address":
          return A._EIP712Utils_ensureIsAddress(value);
        case "bool":
          if (!A._isBool(value))
            A.throwExpression(A.SolidityAbiException$("Invalid data provided for boolean codec.", A.LinkedHashMap_LinkedHashMap$_literal(["input", value], type$.String, type$.dynamic)));
          return value;
        case "string":
          if (typeof value != "string")
            A.throwExpression(A.SolidityAbiException$("invalid data provided for string codec.", A.LinkedHashMap_LinkedHashMap$_literal(["input", value], type$.String, type$.dynamic)));
          return value;
        default:
          if (B.JSString_methods.startsWith$1(type, "bytes"))
            return A._EIP712Utils_ensureBytes(type, value);
          throw A.wrapException(A.SolidityAbiException$("Unsuported type. codec not found.", A.LinkedHashMap_LinkedHashMap$_literal(["type", type], type$.String, type$.dynamic)));
      }
    },
    _EIP712Utils_eip712TypedDataV1ValueToJson(type, value) {
      var childType, t2,
        match = $.$get$_EIP712Utils_arrayRegex().firstMatch$1(type),
        t1 = match == null;
      if (t1)
        childType = null;
      else {
        t2 = match._match;
        if (1 >= t2.length)
          return A.ioore(t2, 1);
        childType = t2[1];
      }
      if (!t1) {
        if (!type$.List_dynamic._is(value))
          throw A.wrapException(A.SolidityAbiException$("Invalid data provided for array codec.", A.LinkedHashMap_LinkedHashMap$_literal(["type", type, "value", value], type$.String, type$.dynamic)));
        t1 = J.map$1$1$ax(value, new A._EIP712Utils_eip712TypedDataV1ValueToJson_closure(childType), type$.dynamic);
        return A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      }
      if (B.JSString_methods.startsWith$1(type, "uint") || B.JSString_methods.startsWith$1(type, "int"))
        return J.toString$0$(value);
      switch (type) {
        case "address":
          if (value instanceof A.TronAddress)
            return value.toAddress$0();
          else
            return type$.ETHAddress._as(value).address;
        case "bool":
        case "string":
          return value;
        default:
          return A.BytesUtils_toHexString(type$.List_int._as(value), true, "0x");
      }
    },
    _EIP712Utils_ensureIsAddress(value) {
      var t1, exception;
      if (value instanceof A.ETHAddress)
        return value;
      if (type$.List_int._is(value)) {
        if (J.get$length$asx(value) === 21)
          return new A.TronAddress(A.TrxAddressUtils_fromHexBytes(value), A.BytesUtils_toHexString(value, true, null));
        return A.ETHAddress_ETHAddress(A.BytesUtils_toHexString(value, true, "0x"));
      } else if (typeof value == "string")
        try {
          t1 = A.ETHAddress_ETHAddress(value);
          return t1;
        } catch (exception) {
          t1 = A.TronAddress_TronAddress(value);
          return t1;
        }
      throw A.wrapException(A.SolidityAbiException$("Invalid data provided for address codec.", A.LinkedHashMap_LinkedHashMap$_literal(["input", value], type$.String, type$.dynamic)));
    },
    _EIP712Utils_encodeStruct(typedData, type, data) {
      var t2, t3, t4, value, encodedValue,
        types = A._setArrayType(["bytes32"], type$.JSArray_String),
        inputBytes = [A._EIP712Utils_getMethodSigature(typedData, type)],
        t1 = typedData.types.$index(0, type);
      t1.toString;
      t1 = J.get$iterator$ax(t1);
      t2 = typedData.version === B.EIP712Version_3;
      for (; t1.moveNext$0();) {
        t3 = t1.get$current();
        t4 = t3.name;
        if (data.$index(0, t4) == null) {
          if (t2)
            continue;
          throw A.wrapException(A.SolidityAbiException$("Invalid Eip712TypedData data. data mising for field " + t4, A.LinkedHashMap_LinkedHashMap$_literal(["data", data, "field", t3], type$.String, type$.dynamic)));
        }
        value = data.$index(0, t4);
        encodedValue = A._EIP712Utils_encodeValue(typedData, t3.type, value);
        B.JSArray_methods.add$1(types, encodedValue.item1);
        inputBytes.push(encodedValue.item2);
      }
      return A._EIP712Utils_abiEncode(types, inputBytes);
    },
    _EIP712Utils_getDependencies(typedData, type, dependencies) {
      var t1, actualType, t2, t3,
        match = $.$get$_EIP712Utils_typeRegex().firstMatch$1(type);
      if (match != null) {
        t1 = match._match;
        if (0 >= t1.length)
          return A.ioore(t1, 0);
        t1 = t1[0];
        t1.toString;
        actualType = t1;
      } else
        actualType = type;
      if (J.contains$1$asx(dependencies, actualType))
        return dependencies;
      t1 = typedData.types;
      if (t1.$index(0, actualType) == null)
        return dependencies;
      t2 = type$.JSArray_String;
      t3 = A._setArrayType([actualType], t2);
      t1 = t1.$index(0, actualType);
      t1.toString;
      B.JSArray_methods.addAll$1(t3, J.fold$1$2$ax(t1, A._setArrayType([], t2), new A._EIP712Utils_getDependencies_closure(typedData), type$.List_String));
      return t3;
    },
    _EIP712Utils_extractArrayType(typeName) {
      var t1, t2, t3,
        match = $.$get$_EIP712Utils_arrayRegex().firstMatch$1(typeName);
      if (match == null)
        return null;
      t1 = match._match;
      t2 = t1.length;
      if (1 >= t2)
        return A.ioore(t1, 1);
      t3 = t1[1];
      t3.toString;
      if (2 >= t2)
        return A.ioore(t1, 2);
      t1 = t1[2];
      return new A.Tuple(t3, A.int_parse(t1 == null ? "0" : t1, null), type$.Tuple_String_int);
    },
    _EIP712Utils_encodeValue(typedData, type, data) {
      var t1, t2, encodedData, t3, t4,
        _s7_ = "bytes32",
        isArray = A._EIP712Utils_extractArrayType(type);
      if (isArray != null) {
        if (!type$.List_dynamic._is(data))
          throw A.wrapException(A.SolidityAbiException$("Invalid data provided for array codec.", A.LinkedHashMap_LinkedHashMap$_literal(["input", data], type$.String, type$.dynamic)));
        t1 = isArray.item2;
        if (typeof t1 !== "number")
          return t1.$gt();
        if (t1 > 0 && J.get$length$asx(data) !== t1)
          throw A.wrapException(A.SolidityAbiException$("Invalid array length: expected " + A.S(t1) + ", but got " + J.get$length$asx(data), A.LinkedHashMap_LinkedHashMap$_literal(["input", data], type$.String, type$.dynamic)));
        t1 = type$.Tuple_String_dynamic;
        t2 = J.map$1$1$ax(data, new A._EIP712Utils_encodeValue_closure(typedData, isArray), t1);
        encodedData = A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
        t2 = A._arrayInstanceType(encodedData);
        t3 = t2._eval$1("MappedListIterable<1,String>");
        t4 = t2._eval$1("MappedListIterable<1,@>");
        return new A.Tuple(_s7_, A.Keccack_hash(A._EIP712Utils_abiEncode(A.List_List$of(new A.MappedListIterable(encodedData, t2._eval$1("String(1)")._as(new A._EIP712Utils_encodeValue_closure0()), t3), true, t3._eval$1("ListIterable.E")), A.List_List$of(new A.MappedListIterable(encodedData, t2._eval$1("@(1)")._as(new A._EIP712Utils_encodeValue_closure1()), t4), true, t4._eval$1("ListIterable.E"))), 32), t1);
      }
      if (typedData.types.$index(0, type) != null)
        return new A.Tuple(_s7_, A.Keccack_hash(A._EIP712Utils_encodeStruct(typedData, type, type$.Map_String_dynamic._as(data)), 32), type$.Tuple_String_dynamic);
      t1 = type === "string";
      if (t1 || type === "bytes") {
        t1 = t1 ? A.StringUtils_encode(A._asString(data), B.StringEncoding_1) : data;
        return new A.Tuple(_s7_, A.Keccack_hash(type$.List_int._as(t1), 32), type$.Tuple_String_dynamic);
      }
      return new A.Tuple(type, data, type$.Tuple_String_dynamic);
    },
    _EIP712Utils_abiEncode(types, inputs) {
      var i, t2, t3, t1 = [];
      for (i = 0; i < types.length; ++i) {
        t2 = types[i];
        if (!(i < inputs.length))
          return A.ioore(inputs, i);
        t1.push(A._EIP712Utils_ensureCorrectValues(t2, inputs[i]));
      }
      t2 = A._arrayInstanceType(types);
      t3 = t2._eval$1("MappedListIterable<1,AbiParameter>");
      return A.AbiParameter$(A.List_List$of(new A.MappedListIterable(types, t2._eval$1("AbiParameter(1)")._as(new A._EIP712Utils_abiEncode_closure()), t3), true, t3._eval$1("ListIterable.E")), "", false, "tuple").abiEncode$1(t1).encoded;
    },
    _EIP712Utils_legacyV1encode(types, inputs) {
      var t1 = A._arrayInstanceType(types),
        t2 = t1._eval$1("MappedListIterable<1,AbiParameter>");
      return A.AbiParameter$(A.List_List$of(new A.MappedListIterable(types, t1._eval$1("AbiParameter(1)")._as(new A._EIP712Utils_legacyV1encode_closure()), t2), true, t2._eval$1("ListIterable.E")), "", false, "tuple").legacyEip712Encode$2(inputs, false).encoded;
    },
    _EIP712Utils_getMethodSigature(typedData, type) {
      var t1,
        dependencies = A.List_List$from(A._EIP712Utils_getDependencies(typedData, type, B.List_empty1), true, type$.String);
      B.JSArray_methods.sort$0(dependencies);
      t1 = A._arrayInstanceType(dependencies);
      return A.Keccack_hash(A.StringUtils_encode(new A.MappedListIterable(dependencies, t1._eval$1("String(1)")._as(new A._EIP712Utils_getMethodSigature_closure(typedData)), t1._eval$1("MappedListIterable<1,String>")).join$1(0, ""), B.StringEncoding_1), 32);
    },
    SolidityAbiException$(message, details) {
      return new A.SolidityAbiException(message);
    },
    _ABIUtils_bytesSize($name) {
      var t1, size, _null = null;
      A._ABIValidator_validateBytes($name, _null, _null, _null);
      t1 = $.$get$_ABIValidator_sizeDetectRegex().firstMatch$1($name);
      if (t1 == null)
        size = _null;
      else {
        t1 = t1._match;
        if (0 >= t1.length)
          return A.ioore(t1, 0);
        size = t1[0];
      }
      if (size == null)
        return _null;
      return A.int_parse(size, _null);
    },
    _ABIUtils_numericSize($name) {
      var size, bitSize,
        t1 = $.$get$_ABIValidator_sizeDetectRegex().firstMatch$1($name);
      if (t1 == null)
        size = null;
      else {
        t1 = t1._match;
        if (0 >= t1.length)
          return A.ioore(t1, 0);
        size = t1[0];
      }
      if (size == null)
        return null;
      bitSize = A.int_parse(size, null);
      return B.JSInt_methods._tdivFast$1(bitSize, 8);
    },
    _ABIUtils_encodeDynamicParams(encodedParams) {
      var staticSize, _i, t2, encodedParam, dynamicSize, t3, t4, t5,
        t1 = type$.JSArray_EncoderResult,
        staticParams = A._setArrayType([], t1),
        dynamicParams = A._setArrayType([], t1);
      for (t1 = encodedParams.length, staticSize = 0, _i = 0; t2 = encodedParams.length, _i < t2; encodedParams.length === t1 || (0, A.throwConcurrentModificationError)(encodedParams), ++_i) {
        encodedParam = encodedParams[_i];
        staticSize = encodedParam.isDynamic ? staticSize + 32 : staticSize + J.get$length$asx(encodedParam.encoded);
      }
      for (dynamicSize = 0, _i = 0; _i < encodedParams.length; encodedParams.length === t2 || (0, A.throwConcurrentModificationError)(encodedParams), ++_i) {
        encodedParam = encodedParams[_i];
        if (encodedParam.isDynamic) {
          t1 = A._BigIntImpl__BigIntImpl$from(staticSize + dynamicSize);
          A._ABIValidator_isValidNumber("uint256", t1);
          B.JSArray_methods.add$1(staticParams, new A.EncoderResult(false, A.BigintUtils_toBytes(t1, 32, B.C_Endian)));
          B.JSArray_methods.add$1(dynamicParams, encodedParam);
          dynamicSize += J.get$length$asx(encodedParam.encoded);
        } else
          B.JSArray_methods.add$1(staticParams, encodedParam);
      }
      t1 = type$.List_int_Function_EncoderResult;
      t2 = type$.MappedListIterable_of_EncoderResult_and_List_int;
      t3 = t2._eval$1("Iterable<int>(Iterable.E)");
      t4 = t2._eval$1("ExpandIterable<Iterable.E,int>");
      t5 = A.List_List$of(new A.ExpandIterable(new A.MappedListIterable(staticParams, t1._as(new A._ABIUtils_encodeDynamicParams_closure()), t2), t3._as(new A._ABIUtils_encodeDynamicParams_closure0()), t4), true, type$.int);
      B.JSArray_methods.addAll$1(t5, new A.ExpandIterable(new A.MappedListIterable(dynamicParams, t1._as(new A._ABIUtils_encodeDynamicParams_closure1()), t2), t3._as(new A._ABIUtils_encodeDynamicParams_closure2()), t4));
      return t5;
    },
    _ABIUtils_toArrayType(abi) {
      var t1 = abi.type,
        arrayParenthesisStart = B.JSString_methods.lastIndexOf$1(t1, "["),
        arrayParamType = B.JSString_methods.substring$2(t1, 0, arrayParenthesisStart),
        sizeString = B.JSString_methods.substring$1(t1, arrayParenthesisStart);
      if (sizeString !== "[]")
        if (A.Primitives_parseInt(B.JSString_methods.substring$2(sizeString, 1, sizeString.length - 1), null) == null)
          throw A.wrapException(B.SolidityAbiException_Jx8);
      return new A.Tuple(A.AbiParameter$(abi.components, "", false, arrayParamType), -1, type$.Tuple_AbiParameter_int);
    },
    _ABIValidator_validateBytes(typeName, bytes, maxLength, minLength) {
      if (B.JSString_methods.contains$1(typeName, "bytes")) {
        if (bytes != null) {
          if (maxLength != null)
            if (J.get$length$asx(bytes) > maxLength)
              throw A.wrapException(B.SolidityAbiException_1lF);
          if (minLength != null)
            if (J.get$length$asx(bytes) < minLength)
              throw A.wrapException(B.SolidityAbiException_1lF);
        }
      } else
        throw A.wrapException(B.SolidityAbiException_mOy);
    },
    _ABIValidator_isValidNumber(type, value) {
      var spl, spl0, e, t1, t2, exception, bitLength = null, sign = null;
      try {
        if (B.JSString_methods.startsWith$1(type, "int")) {
          spl = A._setArrayType(type.split("int"), type$.JSArray_String);
          bitLength = A.int_parse(J.$index$asx(spl, 1), null);
          sign = true;
        } else if (B.JSString_methods.startsWith$1(type, "uint")) {
          spl0 = A._setArrayType(type.split("uint"), type$.JSArray_String);
          bitLength = A.int_parse(J.$index$asx(spl0, 1), null);
          sign = true;
        } else {
          t1 = A.SolidityAbiException$("Invalid type name provided for number codec.", A.LinkedHashMap_LinkedHashMap$_literal(["type", type, "value", value], type$.String, type$.dynamic));
          throw A.wrapException(t1);
        }
        if (A.boolConversionCheck(sign)) {
          if (value.toSigned$1(0, bitLength).$eq(0, value))
            return;
        } else {
          t1 = A._asInt(bitLength);
          t2 = $.$get$_BigIntImpl_one();
          if (value.$and(0, t2.$shl(0, t1).$sub(0, t2)).$eq(0, value))
            return;
        }
      } catch (exception) {
        e = A.unwrapException(exception);
        if (e instanceof A.SolidityAbiException)
          throw exception;
      }
      throw A.wrapException(A.SolidityAbiException$("Invalid data provided for number codec.", A.LinkedHashMap_LinkedHashMap$_literal(["type", type, "value", value], type$.String, type$.dynamic)));
    },
    AbiParameter: function AbiParameter(t0, t1, t2) {
      this.type = t0;
      this.tronTypes = t1;
      this.components = t2;
    },
    AbiParameter_isDynamic_closure: function AbiParameter_isDynamic_closure() {
    },
    EncoderResult: function EncoderResult(t0, t1) {
      this.isDynamic = t0;
      this.encoded = t1;
    },
    EIP712Version: function EIP712Version(t0) {
      this.version = t0;
    },
    EIP712Version_fromVersion_closure: function EIP712Version_fromVersion_closure(t0) {
      this.version = t0;
    },
    EIP712Version_fromVersion_closure0: function EIP712Version_fromVersion_closure0(t0) {
      this.version = t0;
    },
    EIP712Version_fromVersion__closure: function EIP712Version_fromVersion__closure() {
    },
    Eip712TypeDetails: function Eip712TypeDetails(t0, t1) {
      this.name = t0;
      this.type = t1;
    },
    Eip712TypedData: function Eip712TypedData(t0, t1, t2, t3, t4) {
      var _ = this;
      _.types = t0;
      _.primaryType = t1;
      _.domain = t2;
      _.message = t3;
      _.version = t4;
    },
    Eip712TypedData_Eip712TypedData$fromJson_closure: function Eip712TypedData_Eip712TypedData$fromJson_closure() {
    },
    Eip712TypedData_toJson_closure: function Eip712TypedData_toJson_closure() {
    },
    Eip712TypedData_toJson__closure: function Eip712TypedData_toJson__closure() {
    },
    Eip712TypedDataV1: function Eip712TypedDataV1(t0, t1, t2) {
      this.name = t0;
      this.type = t1;
      this.value = t2;
    },
    EIP712Legacy: function EIP712Legacy(t0) {
      this.typesData = t0;
    },
    EIP712Legacy_EIP712Legacy$fromJson_closure: function EIP712Legacy_EIP712Legacy$fromJson_closure() {
    },
    EIP712Legacy_encode_closure: function EIP712Legacy_encode_closure() {
    },
    EIP712Legacy_encode_closure0: function EIP712Legacy_encode_closure0() {
    },
    EIP712Legacy_encode_closure1: function EIP712Legacy_encode_closure1() {
    },
    EIP712Legacy_toJson_closure: function EIP712Legacy_toJson_closure() {
    },
    _EIP712Utils_ensureCorrectValues_closure: function _EIP712Utils_ensureCorrectValues_closure(t0) {
      this.childType = t0;
    },
    _EIP712Utils_eip712TypedDataV1ValueToJson_closure: function _EIP712Utils_eip712TypedDataV1ValueToJson_closure(t0) {
      this.childType = t0;
    },
    _EIP712Utils_getDependencies_closure: function _EIP712Utils_getDependencies_closure(t0) {
      this.typedData = t0;
    },
    _EIP712Utils_getDependencies__closure: function _EIP712Utils_getDependencies__closure(t0) {
      this.previous = t0;
    },
    _EIP712Utils_encodeValue_closure: function _EIP712Utils_encodeValue_closure(t0, t1) {
      this.typedData = t0;
      this.isArray = t1;
    },
    _EIP712Utils_encodeValue_closure0: function _EIP712Utils_encodeValue_closure0() {
    },
    _EIP712Utils_encodeValue_closure1: function _EIP712Utils_encodeValue_closure1() {
    },
    _EIP712Utils_abiEncode_closure: function _EIP712Utils_abiEncode_closure() {
    },
    _EIP712Utils_legacyV1encode_closure: function _EIP712Utils_legacyV1encode_closure() {
    },
    _EIP712Utils_getMethodSigature_closure: function _EIP712Utils_getMethodSigature_closure(t0) {
      this.typedData = t0;
    },
    _EIP712Utils_getMethodSigature__closure: function _EIP712Utils_getMethodSigature__closure() {
    },
    SolidityAbiException: function SolidityAbiException(t0) {
      this.message = t0;
    },
    AddressCoder: function AddressCoder() {
    },
    ArrayCoder: function ArrayCoder() {
    },
    ArrayCoder_abiEncode_closure: function ArrayCoder_abiEncode_closure(t0) {
      this.param = t0;
    },
    ArrayCoder_abiEncode_closure0: function ArrayCoder_abiEncode_closure0() {
    },
    ArrayCoder_legacyEip712Encode_closure: function ArrayCoder_legacyEip712Encode_closure(t0) {
      this.param = t0;
    },
    ArrayCoder_legacyEip712Encode_closure0: function ArrayCoder_legacyEip712Encode_closure0() {
    },
    BooleanCoder: function BooleanCoder() {
    },
    BytesCoder: function BytesCoder() {
    },
    FunctionCoder: function FunctionCoder() {
    },
    NumbersCoder: function NumbersCoder() {
    },
    StringCoder: function StringCoder() {
    },
    TupleCoder: function TupleCoder() {
    },
    TupleCoder_abiEncode_closure: function TupleCoder_abiEncode_closure() {
    },
    TupleCoder_legacyEip712Encode_closure: function TupleCoder_legacyEip712Encode_closure() {
    },
    _ABIUtils_encodeDynamicParams_closure: function _ABIUtils_encodeDynamicParams_closure() {
    },
    _ABIUtils_encodeDynamicParams_closure0: function _ABIUtils_encodeDynamicParams_closure0() {
    },
    _ABIUtils_encodeDynamicParams_closure1: function _ABIUtils_encodeDynamicParams_closure1() {
    },
    _ABIUtils_encodeDynamicParams_closure2: function _ABIUtils_encodeDynamicParams_closure2() {
    },
    TronAddress_TronAddress(address) {
      var decode, t1, decode0, t2, addr, exception, _null = null, visible = null;
      try {
        if (visible == null) {
          t2 = $.$get$StringUtils__hexBytesRegex();
          if (t2._nativeRegExp.test(address)) {
            t1 = A.BytesUtils_fromHexString(address);
            addr = A.TrxAddressUtils_fromHexBytes(t1);
            t1 = A.BytesUtils_toHexString(t1, true, _null);
            return new A.TronAddress(addr, t1);
          }
          decode = new A.TrxAddrDecoder().decodeAddr$1(address);
          t1 = A.List_List$of(B.List_65, true, type$.int);
          J.addAll$1$ax(t1, decode);
          t1 = A.BytesUtils_toHexString(t1, true, _null);
          return new A.TronAddress(address, t1);
        } else if (A.boolConversionCheck(visible)) {
          decode0 = new A.TrxAddrDecoder().decodeAddr$1(address);
          t2 = A.List_List$of(B.List_65, true, type$.int);
          J.addAll$1$ax(t2, decode0);
          t1 = A.BytesUtils_toHexString(t2, true, _null);
          return new A.TronAddress(address, t1);
        } else {
          t1 = A.BytesUtils_fromHexString(address);
          addr = A.TrxAddressUtils_fromHexBytes(t1);
          t1 = A.BytesUtils_toHexString(t1, true, _null);
          return new A.TronAddress(addr, t1);
        }
      } catch (exception) {
        t1 = A.MessageException$("invalid tron address", A.LinkedHashMap_LinkedHashMap$_literal(["input", address, "visible", visible], type$.String, type$.dynamic));
        throw A.wrapException(t1);
      }
    },
    TronAddress: function TronAddress(t0, t1) {
      this._address = t0;
      this._hexAddress = t1;
    },
    PermissionType_fromName($name, defaultPermission) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_OLT, new A.PermissionType_fromName_closure($name), new A.PermissionType_fromName_closure0(defaultPermission));
    },
    PermissionType: function PermissionType(t0, t1) {
      this.name = t0;
      this.value = t1;
    },
    PermissionType_fromName_closure: function PermissionType_fromName_closure(t0) {
      this.name = t0;
    },
    PermissionType_fromName_closure0: function PermissionType_fromName_closure0(t0) {
      this.defaultPermission = t0;
    },
    ResourceCode_fromName($name) {
      var t1, exception, orElse = null;
      try {
        t1 = orElse == null ? null : new A.ResourceCode_fromName_closure(orElse);
        t1 = B.JSArray_methods.firstWhere$2$orElse(B.List_B8J, new A.ResourceCode_fromName_closure0($name), t1);
        return t1;
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.StateError)
          return null;
        else
          throw exception;
      }
    },
    ResourceCode: function ResourceCode(t0, t1) {
      this.value = t0;
      this.name = t1;
    },
    ResourceCode_fromName_closure0: function ResourceCode_fromName_closure0(t0) {
      this.name = t0;
    },
    ResourceCode_fromName_closure: function ResourceCode_fromName_closure(t0) {
      this.orElse = t0;
    },
    _parseUri(uri) {
      return uri;
    },
    _validateArgList(method, args) {
      var numArgs, i, numArgs0, message, t1, t2, t3, t4;
      for (numArgs = args.length, i = 1; i < numArgs; ++i) {
        if (args[i] == null || args[i - 1] != null)
          continue;
        for (; numArgs >= 1; numArgs = numArgs0) {
          numArgs0 = numArgs - 1;
          if (args[numArgs0] != null)
            break;
        }
        message = new A.StringBuffer("");
        t1 = "" + (method + "(");
        message._contents = t1;
        t2 = A._arrayInstanceType(args);
        t3 = t2._eval$1("SubListIterable<1>");
        t4 = new A.SubListIterable(args, 0, numArgs, t3);
        t4.SubListIterable$3(args, 0, numArgs, t2._precomputed1);
        t3 = t1 + new A.MappedListIterable(t4, t3._eval$1("String(ListIterable.E)")._as(new A._validateArgList_closure()), t3._eval$1("MappedListIterable<ListIterable.E,String>")).join$1(0, ", ");
        message._contents = t3;
        message._contents = t3 + ("): part " + (i - 1) + " was null, but part " + i + " was not.");
        throw A.wrapException(A.ArgumentError$(message.toString$0(0), null));
      }
    },
    Context: function Context(t0) {
      this.style = t0;
    },
    Context_joinAll_closure: function Context_joinAll_closure() {
    },
    Context_split_closure: function Context_split_closure() {
    },
    _validateArgList_closure: function _validateArgList_closure() {
    },
    InternalStyle: function InternalStyle() {
    },
    ParsedPath_ParsedPath$parse(path, style) {
      var t1, parts, separators, t2, start, i,
        root = style.getRoot$1(path);
      style.isRootRelative$1(path);
      if (root != null)
        path = B.JSString_methods.substring$1(path, root.length);
      t1 = type$.JSArray_String;
      parts = A._setArrayType([], t1);
      separators = A._setArrayType([], t1);
      t1 = path.length;
      if (t1 !== 0) {
        if (0 >= t1)
          return A.ioore(path, 0);
        t2 = style.isSeparator$1(path.charCodeAt(0));
      } else
        t2 = false;
      if (t2) {
        if (0 >= t1)
          return A.ioore(path, 0);
        B.JSArray_methods.add$1(separators, path[0]);
        start = 1;
      } else {
        B.JSArray_methods.add$1(separators, "");
        start = 0;
      }
      for (i = start; i < t1; ++i)
        if (style.isSeparator$1(path.charCodeAt(i))) {
          B.JSArray_methods.add$1(parts, B.JSString_methods.substring$2(path, start, i));
          B.JSArray_methods.add$1(separators, path[i]);
          start = i + 1;
        }
      if (start < t1) {
        B.JSArray_methods.add$1(parts, B.JSString_methods.substring$1(path, start));
        B.JSArray_methods.add$1(separators, "");
      }
      return new A.ParsedPath(style, root, parts, separators);
    },
    ParsedPath: function ParsedPath(t0, t1, t2, t3) {
      var _ = this;
      _.style = t0;
      _.root = t1;
      _.parts = t2;
      _.separators = t3;
    },
    PathException$(message) {
      return new A.PathException(message);
    },
    PathException: function PathException(t0) {
      this.message = t0;
    },
    Style__getPlatformStyle() {
      var userInfo, host, query, fragment, port, t1, hasAuthority, path, _null = null;
      if (A.Uri_base().get$scheme() !== "file")
        return $.$get$Style_url();
      if (!B.JSString_methods.endsWith$1(A.Uri_base().get$path(), "/"))
        return $.$get$Style_url();
      userInfo = A._Uri__makeUserInfo(_null, 0, 0);
      host = A._Uri__makeHost(_null, 0, 0, false);
      query = A._Uri__makeQuery(_null, 0, 0, _null);
      fragment = A._Uri__makeFragment(_null, 0, 0);
      port = A._Uri__makePort(_null, "");
      if (host == null)
        if (userInfo.length === 0)
          t1 = port != null;
        else
          t1 = true;
      else
        t1 = false;
      if (t1)
        host = "";
      t1 = host == null;
      hasAuthority = !t1;
      path = A._Uri__makePath("a/b", 0, 3, _null, "", hasAuthority);
      if (t1 && !B.JSString_methods.startsWith$1(path, "/"))
        path = A._Uri__normalizeRelativePath(path, hasAuthority);
      else
        path = A._Uri__removeDotSegments(path);
      if (A._Uri$_internal("", userInfo, t1 && B.JSString_methods.startsWith$1(path, "//") ? "" : host, port, path, query, fragment).toFilePath$0() === "a\\b")
        return $.$get$Style_windows();
      return $.$get$Style_posix();
    },
    Style: function Style() {
    },
    PosixStyle: function PosixStyle(t0, t1, t2) {
      this.separatorPattern = t0;
      this.needsSeparatorPattern = t1;
      this.rootPattern = t2;
    },
    UrlStyle: function UrlStyle(t0, t1, t2, t3) {
      var _ = this;
      _.separatorPattern = t0;
      _.needsSeparatorPattern = t1;
      _.rootPattern = t2;
      _.relativeRootPattern = t3;
    },
    WindowsStyle: function WindowsStyle(t0, t1, t2, t3) {
      var _ = this;
      _.separatorPattern = t0;
      _.needsSeparatorPattern = t1;
      _.rootPattern = t2;
      _.relativeRootPattern = t3;
    },
    PlatformInterface: function PlatformInterface() {
    },
    SubstrateAddress_SubstrateAddress(address, ss58Format) {
      var decBytes, t3, t4, ss58Format0, ss58FormatLen, checkSumLength, dataBytes, checksumBytes, checksumBytesGot, _null = null,
        t1 = type$.dynamic,
        t2 = type$.int;
      ss58Format = A.AddrKeyValidator_nullOrValidateAddressArgs(type$.Map_String_dynamic._as(A.LinkedHashMap_LinkedHashMap$_literal(["ss58_format", ss58Format], type$.String, t1)), "ss58_format", t2);
      decBytes = A.Base58Decoder_decode(address, B.Base58Alphabets_0);
      t3 = decBytes.length;
      if (0 >= t3)
        return A.ioore(decBytes, 0);
      t4 = decBytes[0];
      if (typeof t4 !== "number")
        return t4.$and();
      if ((t4 & 64) !== 0) {
        if (1 >= t3)
          return A.ioore(decBytes, 1);
        t3 = decBytes[1];
        if (typeof t3 !== "number")
          return t3.$shr();
        ss58Format0 = ((t4 & 63) << 2 | B.JSNumber_methods._shrOtherPositive$1(t3, 6) | (t3 & 63) << 8) >>> 0;
        ss58FormatLen = 2;
      } else {
        ss58Format0 = t4;
        ss58FormatLen = 1;
      }
      if (B.JSArray_methods.contains$1(B.List_46_47, ss58Format0))
        A.throwExpression(A.ArgumentException$("Invalid SS58 format (" + ss58Format0 + ")"));
      t3 = decBytes.length;
      t4 = type$.JSArray_int;
      checkSumLength = B.JSArray_methods.contains$1(A._setArrayType([33, 34], t4), t3 - ss58FormatLen) ? 2 : 1;
      dataBytes = A.List_List$from(B.JSArray_methods.sublist$2(decBytes, ss58FormatLen, decBytes.length - checkSumLength), true, t2);
      checksumBytes = A.List_List$unmodifiable(B.JSArray_methods.sublist$1(decBytes, decBytes.length - checkSumLength), t2);
      t3 = B.JSArray_methods.sublist$2(decBytes, 0, decBytes.length - checkSumLength);
      t1 = A.List_List$of($.$get$_Ss58Const_checksumPrefix(), true, t1);
      B.JSArray_methods.addAll$1(t1, t3);
      t2 = A.QuickCrypto__blake2bHash(A.List_List$from(t1, true, t2), 64, _null, _null);
      t3 = t3.length;
      checksumBytesGot = B.JSArray_methods.sublist$2(t2, 0, B.JSArray_methods.contains$1(A._setArrayType([33, 34], t4), t3) ? 2 : 1);
      if (!A.BytesUtils_bytesEqual(checksumBytesGot, checksumBytes))
        A.throwExpression(new A.SS58ChecksumError("Invalid checksum (expected " + A.BytesUtils_toHexString(checksumBytesGot, true, _null) + ", got " + A.BytesUtils_toHexString(checksumBytes, true, _null) + ")"));
      t1 = dataBytes.length;
      if (t1 !== 32)
        A.throwExpression(A.AddressConverterException$("Invalid address bytes. (expected 32, got " + t1 + ")", _null));
      if (ss58Format != null && ss58Format !== ss58Format0)
        A.throwExpression(A.AddressConverterException$("Invalid SS58 format (expected " + A.S(ss58Format) + ", got " + ss58Format0 + ")", _null));
      return new A.SubstrateAddress(address, ss58Format0);
    },
    SubstrateAddress: function SubstrateAddress(t0, t1) {
      this.address = t0;
      this.ss58Format = t1;
    },
    FileLocation$_(file, offset) {
      if (offset < 0)
        A.throwExpression(A.RangeError$("Offset may not be negative, was " + offset + "."));
      else if (offset > file._decodedChars.length)
        A.throwExpression(A.RangeError$("Offset " + offset + string$.x20must_ + file.get$length(0) + "."));
      return new A.FileLocation(file, offset);
    },
    SourceFile: function SourceFile(t0, t1, t2) {
      var _ = this;
      _.url = t0;
      _._lineStarts = t1;
      _._decodedChars = t2;
      _._cachedLine = null;
    },
    FileLocation: function FileLocation(t0, t1) {
      this.file = t0;
      this.offset = t1;
    },
    _FileSpan: function _FileSpan(t0, t1, t2) {
      this.file = t0;
      this._file$_start = t1;
      this._end = t2;
    },
    Highlighter$(span, color) {
      var t1 = A.Highlighter__collateLines(A._setArrayType([A._Highlight$(span, true)], type$.JSArray__Highlight)),
        t2 = new A.Highlighter_closure(color).call$0(),
        t3 = B.JSInt_methods.toString$0(B.JSArray_methods.get$last(t1).number + 1),
        t4 = A.Highlighter__contiguous(t1) ? 0 : 3,
        t5 = A._arrayInstanceType(t1);
      return new A.Highlighter(t1, t2, null, 1 + Math.max(t3.length, t4), new A.MappedListIterable(t1, t5._eval$1("int(1)")._as(new A.Highlighter$__closure()), t5._eval$1("MappedListIterable<1,int>")).reduce$1(0, B.CONSTANT), !A.isAllTheSame(new A.MappedListIterable(t1, t5._eval$1("Object?(1)")._as(new A.Highlighter$__closure0()), t5._eval$1("MappedListIterable<1,Object?>"))), new A.StringBuffer(""));
    },
    Highlighter__contiguous(lines) {
      var i, thisLine, nextLine;
      for (i = 0; i < lines.length - 1;) {
        thisLine = lines[i];
        ++i;
        nextLine = lines[i];
        if (thisLine.number + 1 !== nextLine.number && J.$eq$(thisLine.url, nextLine.url))
          return false;
      }
      return true;
    },
    Highlighter__collateLines(highlights) {
      var t1, t2, t3,
        highlightsByUrl = A.groupBy(highlights, new A.Highlighter__collateLines_closure(), type$._Highlight, type$.Object);
      for (t1 = highlightsByUrl.get$values(), t2 = A._instanceType(t1), t2 = t2._eval$1("@<1>")._bind$1(t2._rest[1]), t1 = new A.MappedIterator(J.get$iterator$ax(t1.__internal$_iterable), t1._f, t2._eval$1("MappedIterator<1,2>")), t2 = t2._rest[1]; t1.moveNext$0();) {
        t3 = t1.__internal$_current;
        if (t3 == null)
          t3 = t2._as(t3);
        J.sort$1$ax(t3, new A.Highlighter__collateLines_closure0());
      }
      t1 = highlightsByUrl.get$entries();
      t2 = A._instanceType(t1);
      t3 = t2._eval$1("ExpandIterable<Iterable.E,_Line>");
      return A.List_List$of(new A.ExpandIterable(t1, t2._eval$1("Iterable<_Line>(Iterable.E)")._as(new A.Highlighter__collateLines_closure1()), t3), true, t3._eval$1("Iterable.E"));
    },
    _Highlight$(span, primary) {
      var t1 = new A._Highlight_closure(span).call$0();
      return new A._Highlight(t1, true, null);
    },
    _Highlight__normalizeNewlines(span) {
      var endOffset, t1, i, t2, t3, t4,
        text = span.get$text();
      if (!B.JSString_methods.contains$1(text, "\r\n"))
        return span;
      endOffset = span.get$end().get$offset();
      for (t1 = text.length - 1, i = 0; i < t1; ++i)
        if (text.charCodeAt(i) === 13 && text.charCodeAt(i + 1) === 10)
          --endOffset;
      t1 = span.get$start();
      t2 = span.get$sourceUrl();
      t3 = span.get$end().get$line();
      t2 = A.SourceLocation$(endOffset, span.get$end().get$column(), t3, t2);
      t3 = A.stringReplaceAllUnchecked(text, "\r\n", "\n");
      t4 = span.get$context();
      return A.SourceSpanWithContext$(t1, t2, t3, A.stringReplaceAllUnchecked(t4, "\r\n", "\n"));
    },
    _Highlight__normalizeTrailingNewline(span) {
      var context, text, start, end, t1, t2, t3;
      if (!B.JSString_methods.endsWith$1(span.get$context(), "\n"))
        return span;
      if (B.JSString_methods.endsWith$1(span.get$text(), "\n\n"))
        return span;
      context = B.JSString_methods.substring$2(span.get$context(), 0, span.get$context().length - 1);
      text = span.get$text();
      start = span.get$start();
      end = span.get$end();
      if (B.JSString_methods.endsWith$1(span.get$text(), "\n")) {
        t1 = A.findLineStart(span.get$context(), span.get$text(), span.get$start().get$column());
        t1.toString;
        t1 = t1 + span.get$start().get$column() + span.get$length(span) === span.get$context().length;
      } else
        t1 = false;
      if (t1) {
        text = B.JSString_methods.substring$2(span.get$text(), 0, span.get$text().length - 1);
        if (text.length === 0)
          end = start;
        else {
          t1 = span.get$end().get$offset();
          t2 = span.get$sourceUrl();
          t3 = span.get$end().get$line();
          end = A.SourceLocation$(t1 - 1, A._Highlight__lastLineLength(context), t3 - 1, t2);
          start = span.get$start().get$offset() === span.get$end().get$offset() ? end : span.get$start();
        }
      }
      return A.SourceSpanWithContext$(start, end, text, context);
    },
    _Highlight__normalizeEndOfLine(span) {
      var text, t1, t2, t3, t4;
      if (span.get$end().get$column() !== 0)
        return span;
      if (span.get$end().get$line() === span.get$start().get$line())
        return span;
      text = B.JSString_methods.substring$2(span.get$text(), 0, span.get$text().length - 1);
      t1 = span.get$start();
      t2 = span.get$end().get$offset();
      t3 = span.get$sourceUrl();
      t4 = span.get$end().get$line();
      t3 = A.SourceLocation$(t2 - 1, text.length - B.JSString_methods.lastIndexOf$1(text, "\n") - 1, t4 - 1, t3);
      return A.SourceSpanWithContext$(t1, t3, text, B.JSString_methods.endsWith$1(span.get$context(), "\n") ? B.JSString_methods.substring$2(span.get$context(), 0, span.get$context().length - 1) : span.get$context());
    },
    _Highlight__lastLineLength(text) {
      var t2,
        t1 = text.length;
      if (t1 === 0)
        return 0;
      else {
        t2 = t1 - 1;
        if (!(t2 >= 0))
          return A.ioore(text, t2);
        if (text.charCodeAt(t2) === 10)
          return t1 === 1 ? 0 : t1 - B.JSString_methods.lastIndexOf$2(text, "\n", t1 - 2) - 1;
        else
          return t1 - B.JSString_methods.lastIndexOf$1(text, "\n") - 1;
      }
    },
    Highlighter: function Highlighter(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._lines = t0;
      _._primaryColor = t1;
      _._secondaryColor = t2;
      _._paddingBeforeSidebar = t3;
      _._maxMultilineSpans = t4;
      _._multipleFiles = t5;
      _._highlighter$_buffer = t6;
    },
    Highlighter_closure: function Highlighter_closure(t0) {
      this.color = t0;
    },
    Highlighter$__closure: function Highlighter$__closure() {
    },
    Highlighter$___closure: function Highlighter$___closure() {
    },
    Highlighter$__closure0: function Highlighter$__closure0() {
    },
    Highlighter__collateLines_closure: function Highlighter__collateLines_closure() {
    },
    Highlighter__collateLines_closure0: function Highlighter__collateLines_closure0() {
    },
    Highlighter__collateLines_closure1: function Highlighter__collateLines_closure1() {
    },
    Highlighter__collateLines__closure: function Highlighter__collateLines__closure(t0) {
      this.line = t0;
    },
    Highlighter_highlight_closure: function Highlighter_highlight_closure() {
    },
    Highlighter__writeFileStart_closure: function Highlighter__writeFileStart_closure(t0) {
      this.$this = t0;
    },
    Highlighter__writeMultilineHighlights_closure: function Highlighter__writeMultilineHighlights_closure(t0, t1, t2) {
      this.$this = t0;
      this.startLine = t1;
      this.line = t2;
    },
    Highlighter__writeMultilineHighlights_closure0: function Highlighter__writeMultilineHighlights_closure0(t0, t1) {
      this.$this = t0;
      this.highlight = t1;
    },
    Highlighter__writeMultilineHighlights_closure1: function Highlighter__writeMultilineHighlights_closure1(t0) {
      this.$this = t0;
    },
    Highlighter__writeMultilineHighlights_closure2: function Highlighter__writeMultilineHighlights_closure2(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.current = t2;
      _.startLine = t3;
      _.line = t4;
      _.highlight = t5;
      _.endLine = t6;
    },
    Highlighter__writeMultilineHighlights__closure: function Highlighter__writeMultilineHighlights__closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Highlighter__writeMultilineHighlights__closure0: function Highlighter__writeMultilineHighlights__closure0(t0, t1) {
      this.$this = t0;
      this.vertical = t1;
    },
    Highlighter__writeHighlightedText_closure: function Highlighter__writeHighlightedText_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.text = t1;
      _.startColumn = t2;
      _.endColumn = t3;
    },
    Highlighter__writeIndicator_closure: function Highlighter__writeIndicator_closure(t0, t1, t2) {
      this.$this = t0;
      this.line = t1;
      this.highlight = t2;
    },
    Highlighter__writeIndicator_closure0: function Highlighter__writeIndicator_closure0(t0, t1, t2) {
      this.$this = t0;
      this.line = t1;
      this.highlight = t2;
    },
    Highlighter__writeIndicator_closure1: function Highlighter__writeIndicator_closure1(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.coversWholeLine = t1;
      _.line = t2;
      _.highlight = t3;
    },
    Highlighter__writeSidebar_closure: function Highlighter__writeSidebar_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.end = t2;
    },
    _Highlight: function _Highlight(t0, t1, t2) {
      this.span = t0;
      this.isPrimary = t1;
      this.label = t2;
    },
    _Highlight_closure: function _Highlight_closure(t0) {
      this.span = t0;
    },
    _Line: function _Line(t0, t1, t2, t3) {
      var _ = this;
      _.text = t0;
      _.number = t1;
      _.url = t2;
      _.highlights = t3;
    },
    SourceLocation$(offset, column, line, sourceUrl) {
      if (offset < 0)
        A.throwExpression(A.RangeError$("Offset may not be negative, was " + offset + "."));
      else if (line < 0)
        A.throwExpression(A.RangeError$("Line may not be negative, was " + line + "."));
      else if (column < 0)
        A.throwExpression(A.RangeError$("Column may not be negative, was " + column + "."));
      return new A.SourceLocation(sourceUrl, offset, line, column);
    },
    SourceLocation: function SourceLocation(t0, t1, t2, t3) {
      var _ = this;
      _.sourceUrl = t0;
      _.offset = t1;
      _.line = t2;
      _.column = t3;
    },
    SourceLocationMixin: function SourceLocationMixin() {
    },
    SourceSpanBase: function SourceSpanBase() {
    },
    SourceSpanFormatException$(message, span, source) {
      return new A.SourceSpanFormatException(source, message, span);
    },
    SourceSpanException: function SourceSpanException() {
    },
    SourceSpanFormatException: function SourceSpanFormatException(t0, t1, t2) {
      this.source = t0;
      this._span_exception$_message = t1;
      this._span = t2;
    },
    SourceSpanMixin: function SourceSpanMixin() {
    },
    SourceSpanWithContext$(start, end, text, _context) {
      var t1 = new A.SourceSpanWithContext(_context, start, end, text);
      t1.SourceSpanBase$3(start, end, text);
      if (!B.JSString_methods.contains$1(_context, text))
        A.throwExpression(A.ArgumentError$('The context line "' + _context + '" must contain "' + text + '".', null));
      if (A.findLineStart(_context, text, start.get$column()) == null)
        A.throwExpression(A.ArgumentError$('The span text "' + text + '" must start at column ' + (start.get$column() + 1) + ' in a line within "' + _context + '".', null));
      return t1;
    },
    SourceSpanWithContext: function SourceSpanWithContext(t0, t1, t2, t3) {
      var _ = this;
      _._context = t0;
      _.start = t1;
      _.end = t2;
      _.text = t3;
    },
    StringScannerException: function StringScannerException(t0, t1, t2) {
      this.source = t0;
      this._span_exception$_message = t1;
      this._span = t2;
    },
    StringScanner: function StringScanner(t0, t1) {
      var _ = this;
      _.sourceUrl = t0;
      _.string = t1;
      _._string_scanner$_position = 0;
      _._lastMatchPosition = _._lastMatch = null;
    },
    TonAddress_TonAddress(address) {
      var t1, t2, workChain, decode, flags;
      $.$get$TonAddress__decoder();
      t1 = type$.String;
      t2 = type$.dynamic;
      workChain = A.AddrKeyValidator_nullOrValidateAddressArgs(type$.Map_String_dynamic._as(A.LinkedHashMap_LinkedHashMap$_literal(["workchain", null], t1, t2)), "workchain", type$.int);
      decode = A.TonAddressUtils_decodeAddress(address);
      if (workChain != null && workChain !== decode.workchain)
        A.throwExpression(A.AddressConverterException$("Invalid address workchain.", A.LinkedHashMap_LinkedHashMap$_literal(["excepted", workChain, "workchain", decode.workchain], t1, t2)));
      t1 = type$.FriendlyAddressFlags;
      flags = A.List_List$from(decode.flags, true, t1);
      return new A.TonAddress(decode.workchain, decode.hash, A.List_List$unmodifiable(flags, t1));
    },
    TonAddress: function TonAddress(t0, t1, t2) {
      this.workChain = t0;
      this.hash = t1;
      this.defaultFlags = t2;
    },
    TonContractException: function TonContractException(t0, t1) {
      this.message = t0;
      this.details = t1;
    },
    WalletVersion_WalletVersion$fromValue($name) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_oOy, new A.WalletVersion_WalletVersion$fromValue_closure($name), new A.WalletVersion_WalletVersion$fromValue_closure0($name));
    },
    WalletVersion: function WalletVersion(t0) {
      this.name = t0;
    },
    WalletVersion_WalletVersion$fromValue_closure: function WalletVersion_WalletVersion$fromValue_closure(t0) {
      this.name = t0;
    },
    WalletVersion_WalletVersion$fromValue_closure0: function WalletVersion_WalletVersion$fromValue_closure0(t0) {
      this.name = t0;
    },
    TonDartPluginException$(message, details) {
      return new A.TonDartPluginException(message, details);
    },
    TonDartPluginException: function TonDartPluginException(t0, t1) {
      this.message = t0;
      this.details = t1;
    },
    TonDartPluginException_toString_closure: function TonDartPluginException_toString_closure() {
    },
    TonDartPluginException_toString_closure0: function TonDartPluginException_toString_closure0() {
    },
    TonApiType_TonApiType$fromValue($name) {
      return B.JSArray_methods.firstWhere$2$orElse(B.List_ivT, new A.TonApiType_TonApiType$fromValue_closure($name), new A.TonApiType_TonApiType$fromValue_closure0($name));
    },
    TonApiType: function TonApiType(t0) {
      this.name = t0;
    },
    TonApiType_TonApiType$fromValue_closure: function TonApiType_TonApiType$fromValue_closure(t0) {
      this.name = t0;
    },
    TonApiType_TonApiType$fromValue_closure0: function TonApiType_TonApiType$fromValue_closure0(t0) {
      this.name = t0;
    },
    _EventStreamSubscription$(_target, _eventType, onData, _useCapture, $T) {
      var t1;
      if (onData == null)
        t1 = null;
      else {
        t1 = A._wrapZone(new A._EventStreamSubscription_closure(onData), type$.JSObject);
        t1 = t1 == null ? null : type$.JavaScriptFunction._as(A.allowInterop(t1, type$.Function));
      }
      t1 = new A._EventStreamSubscription(_target, _eventType, t1, false, $T._eval$1("_EventStreamSubscription<0>"));
      t1._tryResume$0();
      return t1;
    },
    _wrapZone(callback, $T) {
      var t1 = $.Zone__current;
      if (t1 === B.C__RootZone)
        return callback;
      return t1.bindUnaryCallbackGuarded$1$1(callback, $T);
    },
    EventStreamProvider: function EventStreamProvider(t0, t1) {
      this._eventType = t0;
      this.$ti = t1;
    },
    _EventStream: function _EventStream(t0, t1, t2, t3) {
      var _ = this;
      _._target = t0;
      _._eventType = t1;
      _._useCapture = t2;
      _.$ti = t3;
    },
    _EventStreamSubscription: function _EventStreamSubscription(t0, t1, t2, t3, t4) {
      var _ = this;
      _._pauseCount = 0;
      _._target = t0;
      _._eventType = t1;
      _._onData = t2;
      _._useCapture = t3;
      _.$ti = t4;
    },
    _EventStreamSubscription_closure: function _EventStreamSubscription_closure(t0) {
      this.onData = t0;
    },
    _EventStreamSubscription_onData_closure: function _EventStreamSubscription_onData_closure(t0) {
      this.handleData = t0;
    },
    XRPAddress_XRPAddress(address) {
      var t1, addrNetVar, decodeXAddress, t2, toClassic, netVarBytes, addrDecBytes, exception, _null = null, allowXAddress = null, isTestnet = null;
      try {
        if (!J.$eq$(allowXAddress, false) && A.XRPAddressUtils_isXAddress(address)) {
          t1 = isTestnet;
          if (t1 != null)
            addrNetVar = t1 ? B.List_4_147 : B.List_5_68;
          else
            addrNetVar = _null;
          decodeXAddress = A.XRPAddressUtils_decodeXAddress(address, addrNetVar);
          t1 = decodeXAddress.bytes;
          t2 = t1.length;
          if (t2 !== 20)
            A.throwExpression(A.AddressConverterException$("address hash must be 20 bytes length but got " + t2, _null));
          t2 = A.List_List$of(B.List_00, true, type$.dynamic);
          B.JSArray_methods.addAll$1(t2, t1);
          toClassic = A.Base58Encoder_checkEncode(A.List_List$from(t2, true, type$.int), B.Base58Alphabets_1);
          return new A.XRPAddress(toClassic, decodeXAddress.tag);
        }
        t1 = type$.Map_String_dynamic;
        t1._as(B.Map_empty0);
        t1 = t1._as(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_00, "base58_alph", B.Base58Alphabets_1], type$.String, type$.dynamic));
        t2 = type$.List_int;
        A.AddrKeyValidator_validateAddressArgs(t1, "net_ver", t2);
        netVarBytes = t2._as(t1.$index(0, "net_ver"));
        t1 = t1.$index(0, "base58_alph");
        if (t1 == null)
          t1 = B.Base58Alphabets_0;
        addrDecBytes = A.Base58Decoder_checkDecode(address, type$.Base58Alphabets._as(t1));
        A.AddrDecUtils_validateBytesLength(addrDecBytes, 20 + netVarBytes.length, _null);
        A.List_List$from(A.AddrDecUtils_validateAndRemovePrefixBytes(addrDecBytes, netVarBytes), true, type$.int);
        return new A.XRPAddress(address, _null);
      } catch (exception) {
        throw A.wrapException(B.C_XRPLAddressCodecException);
      }
    },
    XRPAddress: function XRPAddress(t0, t1) {
      this.address = t0;
      this.tag = t1;
    },
    XRPLAddressCodecException: function XRPLAddressCodecException() {
    },
    MessageCompleterHandler: function MessageCompleterHandler(t0) {
      this._awaitingMessages = t0;
    },
    MessageCompleter: function MessageCompleter(t0, t1) {
      this.id = t0;
      this.completer = t1;
    },
    JsEthereumHandler: function JsEthereumHandler(t0) {
      this._currentChain = t0;
    },
    EthereumRequestParams_toJson(_this) {
      var t1 = A._asStringQ(_this.method);
      return A.LinkedHashMap_LinkedHashMap$_literal(["method", t1, "params", _this.params == null ? [] : A.dartify(_this.params)], type$.String, type$.dynamic);
    },
    EthereumRequestParams_toStringListParam(_this, $length) {
      var toListString, _s6_ = "method",
        t1 = _this.params,
        toDart = t1 == null ? null : A.dartify(t1);
      if (toDart == null || !type$.List_dynamic._is(toDart)) {
        A.getProperty(_this, _s6_, type$.nullable_String).toString;
        A.throwExpression(B.Web3InternalException_izR);
      }
      t1 = J.get$length$asx(toDart);
      if (t1 < $length) {
        A.getProperty(_this, _s6_, type$.nullable_String).toString;
        A.throwExpression(B.Web3InternalException_izR);
      }
      toListString = A.MethodUtils_nullOnException(new A.EthereumRequestParams_toStringListParam_closure(toDart), type$.List_String);
      if (toListString == null) {
        A.getProperty(_this, _s6_, type$.nullable_String).toString;
        throw A.wrapException(B.Web3InternalException_izR);
      }
      return toListString;
    },
    EthereumRequestParams_tryParamsToList(_this, $length) {
      var toDart, t1, exception;
      try {
        t1 = _this.params;
        toDart = t1 == null ? null : A.dartify(t1);
        if (toDart != null)
          if (type$.List_dynamic._is(toDart))
            t1 = J.get$length$asx(toDart) < $length;
          else
            t1 = true;
        else
          t1 = true;
        if (t1)
          return null;
        return toDart;
      } catch (exception) {
        return null;
      }
    },
    EthereumRequestParams_toStringListParam_closure: function EthereumRequestParams_toStringListParam_closure(t0) {
      this.toDart = t0;
    },
    FutureTest_get_toPromise(_this, $T) {
      return type$.JSObject._as(new self.Promise(type$.JavaScriptFunction._as(A.allowInterop(new A.FutureTest_get_toPromise_closure(_this), type$.Function))));
    },
    JSWalletHandler: function JSWalletHandler(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._crypto = t0;
      _.scriptId = t1;
      _.clientId = t2;
      _.ethereum = t3;
      _.completer = t4;
      _.chain = t5;
    },
    FutureTest_get_toPromise_closure: function FutureTest_get_toPromise_closure(t0) {
      this._this = t0;
    },
    FutureTest_get_toPromise__closure: function FutureTest_get_toPromise__closure(t0) {
      this.resolve = t0;
    },
    FutureTest_get_toPromise__closure0: function FutureTest_get_toPromise__closure0(t0) {
      this.reject = t0;
    },
    FutureTest_get_toPromise__closure1: function FutureTest_get_toPromise__closure1(t0, t1) {
      this.reject = t0;
      this.resolve = t1;
    },
    main(args) {
      return A.main$body(args);
    },
    main$body(args) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$handler = 1, $async$currentError, walletHandler, completer, onActivation, eth, e, s, t1, t2, t3, t4, t5, t6, t7, exception, $async$exception;
      var $async$main = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 3;
              walletHandler = A._Cell$named("walletHandler");
              completer = new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_JSWalletHandler), type$._AsyncCompleter_JSWalletHandler);
              A.print("\x1b[33mWallet come inistialize\x1b[0m");
              onActivation = new A.main_onActivation(completer);
              t1 = self;
              t2 = type$.JSObject;
              t3 = type$.Function;
              t4 = type$.JavaScriptFunction;
              t2._as(t1.MRT).onMrtMessage = t4._as(A.allowInterop(onActivation, t3));
              A.print("\x1b[33m" + ("scriptIDD " + A._asString(t2._as(t1.MRT).scriptId())) + "\x1b[0m");
              t5 = walletHandler;
              $async$goto = 6;
              return A._asyncAwait(completer.future, $async$main);
            case 6:
              // returning from await.
              t6 = $async$result;
              t7 = t5._value;
              if (t7 == null ? t5 != null : t7 !== t5)
                A.throwExpression(new A.LateError("Local '" + t5._name + "' has already been initialized."));
              t5._value = t6;
              A.print("\x1b[33mONACtivation Done\x1b[0m");
              t2._as(t1.MRT).onMrtMessage = t4._as(A.allowInterop(walletHandler._readLocal$0().get$onResponse(), t3));
              t2._as(t1.MRT).clientId = walletHandler._readLocal$0().clientId;
              eth = {};
              eth.request = t4._as(A.allowInterop(walletHandler._readLocal$0().get$onEthereumRequest(), t3));
              t2._as(t1.MRT).ethereum = eth;
              A.print("\x1b[33mWallet has been inited\x1b[0m");
              $async$handler = 1;
              // goto after finally
              $async$goto = 5;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$currentError;
              e = A.unwrapException($async$exception);
              s = A.getTraceFromException($async$exception);
              A.print("\x1b[33m" + ("Error " + A.S(e) + " " + A.S(s)) + "\x1b[0m");
              // goto after finally
              $async$goto = 5;
              break;
            case 2:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 5:
              // after finally
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return A._asyncStartSync($async$main, $async$completer);
    },
    main_onActivation: function main_onActivation(t0) {
      this.completer = t0;
    },
    PlatformWebScoket_connect(url) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.PlatformWebScoket),
        $async$returnValue;
      var $async$PlatformWebScoket_connect = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = A.connectSoc(url, null);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$PlatformWebScoket_connect, $async$completer);
    },
    ContactCore_fromCborBytesOrObject(network, obj, $T) {
      var contact, cbor, t1, address, $name, _null = null;
      switch (network.get$type()) {
        case B.NetworkType_8eb:
        case B.NetworkType_8eb0:
          contact = A.BitcoinContact_BitcoinContact$fromCborBytesOrObject(type$.WalletBitcoinNetwork._as(network), _null, obj);
          break;
        case B.NetworkType_iDZ:
          contact = A.EthereumContract_EthereumContract$fromCborBytesOrObject(_null, obj);
          break;
        case B.NetworkType_SkF:
          contact = A.TronContact_TronContact$fromCborBytesOrObject(_null, obj);
          break;
        case B.NetworkType_4QF:
          contact = A.SolanaContact_SolanaContact$fromCborBytesOrObject(_null, obj);
          break;
        case B.NetworkType_4ei:
          contact = A.CardanoContact_CardanoContact$fromCborBytesOrObject(_null, obj);
          break;
        case B.NetworkType_QJm:
          contact = A.CosmosContact_CosmosContact$fromCborBytesOrObject(_null, obj);
          break;
        case B.NetworkType_66M:
          contact = A.TonContact_TonContact$fromCborBytesOrObject(_null, obj);
          break;
        case B.NetworkType_Oh2:
          contact = A.RippleContact_RippleContact$fromCborBytesOrObject(_null, obj);
          break;
        default:
          cbor = A.CborSerializable_decodeCborTags(_null, obj, B.List_100_8, type$.CborListValue_dynamic);
          t1 = type$.String;
          address = A.ExtractCborList_elementAt(cbor, 0, t1);
          A.ExtractCborList_elementAt(cbor, 1, type$.DateTime);
          $name = A.ExtractCborList_elementAt(cbor, 2, t1);
          contact = new A.SubstrateContact(A.SubstrateAddress_SubstrateAddress(address, _null), $name);
          break;
      }
      t1 = $T._eval$1("ContactCore<0>");
      if (!t1._is(contact))
        throw A.wrapException(A.WalletExceptionConst_invalidArgruments(A.createRuntimeType(t1).toString$0(0), A.getRuntimeTypeOfDartObject(contact).toString$0(0)));
      return contact;
    },
    printString(string) {
      if (typeof dartPrint == "function") {
        dartPrint(string);
        return;
      }
      if (typeof console == "object" && typeof console.log != "undefined") {
        console.log(string);
        return;
      }
      if (typeof print == "function") {
        print(string);
        return;
      }
      throw "Unable to print message: " + String(string);
    },
    opPushData(hexData) {
      var lengthBytes, t2,
        dataBytes = A.BytesUtils_fromHexString(hexData),
        t1 = dataBytes.length;
      if (t1 < 76)
        return B.JSArray_methods.$add(A.List_List$from([t1], true, type$.int), dataBytes);
      else if (t1 < 255) {
        t1 = type$.int;
        return B.JSArray_methods.$add(B.JSArray_methods.$add(A.List_List$from([76], true, t1), A.List_List$from([dataBytes.length], true, t1)), dataBytes);
      } else if (t1 < 65535) {
        t1 = type$.int;
        lengthBytes = A.List_List$filled(2, 0, false, t1);
        A.writeUint16LE(dataBytes.length, lengthBytes, 0);
        t2 = [77];
        B.JSArray_methods.addAll$1(t2, lengthBytes);
        B.JSArray_methods.addAll$1(t2, dataBytes);
        return A.List_List$from(t2, true, t1);
      } else if (t1 < 4294967295) {
        t1 = type$.int;
        lengthBytes = A.List_List$filled(4, 0, false, t1);
        A.writeUint32LE(4, lengthBytes, 0);
        t2 = [78];
        B.JSArray_methods.addAll$1(t2, lengthBytes);
        B.JSArray_methods.addAll$1(t2, dataBytes);
        return A.List_List$from(t2, true, t1);
      } else
        throw A.wrapException(B.BitcoinBasePluginException_uhV);
    },
    pushInteger(integer) {
      var numberOfBytes, t1, integerBytes, i, t2;
      if (integer < 0)
        throw A.wrapException(B.BitcoinBasePluginException_xLE);
      numberOfBytes = B.JSInt_methods._tdivFast$1(B.JSInt_methods.get$bitLength(integer) + 7, 8);
      t1 = type$.int;
      integerBytes = A.List_List$filled(numberOfBytes, 0, false, t1);
      for (i = 0; i < numberOfBytes; ++i)
        B.JSArray_methods.$indexSet(integerBytes, i, B.JSInt_methods._shrOtherPositive$1(integer, i * 8) & 255);
      if ((integer & B.JSInt_methods.$shl(1, numberOfBytes * 8 - 1)) >>> 0 !== 0) {
        t2 = A.List_List$of(integerBytes, true, type$.dynamic);
        t2.push(0);
        integerBytes = A.List_List$from(t2, true, t1);
      }
      return A.List_List$from(A.opPushData(A.BytesUtils_toHexString(integerBytes, true, null)), true, t1);
    },
    SegwitBech32Encoder__computeChecksum(hrp, data) {
      type$.List_int._as(data);
      if (0 >= data.length)
        return A.ioore(data, 0);
      return A.Bech32Utils_computeChecksum(hrp, data, J.$eq$(data[0], 0) ? B.Bech32Encodings_0 : B.Bech32Encodings_1);
    },
    SegwitBech32Decoder_decode(hrp, addr) {
      var t1, convData, t2, witVer,
        decoded = A.Bech32DecoderBase_decodeBech32(addr, "1", 6, A.segwit_bech32_SegwitBech32Decoder__verifyChecksum$closure()),
        hrpGot = decoded.item1,
        data = decoded.item2;
      if (hrp !== hrpGot)
        throw A.wrapException(A.ArgumentException$("Invalid format (HRP not valid, expected " + hrp + ", got " + hrpGot + ")"));
      t1 = J.getInterceptor$ax(data);
      convData = A.Bech32BaseUtils_convertFromBase32(t1.sublist$1(data, 1));
      t2 = convData.length;
      if (t2 < 2 || t2 > 40)
        throw A.wrapException(A.ArgumentException$("Invalid format (witness program length not valid: " + t2 + ")"));
      witVer = t1.$index(data, 0);
      if (witVer > 16)
        throw A.wrapException(A.ArgumentException$("Invalid format (witness version not valid: " + A.S(witVer) + ")"));
      if (witVer === 0 && !B.JSArray_methods.contains$1(B.List_20_32, convData.length))
        throw A.wrapException(A.ArgumentException$("Invalid format (length not valid: " + convData.length + ")"));
      return new A.Tuple(witVer, convData, type$.Tuple_of_int_and_List_int);
    },
    SegwitBech32Decoder__verifyChecksum(hrp, data) {
      type$.List_int._as(data);
      if (0 >= data.length)
        return A.ioore(data, 0);
      return A.Bech32Utils_verifyChecksum(hrp, data, J.$eq$(data[0], 0) ? B.Bech32Encodings_0 : B.Bech32Encodings_1);
    },
    AddrDecUtils_validateAndRemovePrefixBytes(addr, prefix) {
      var t1 = J.getInterceptor$ax(addr),
        prefixGot = t1.sublist$2(addr, 0, prefix.length);
      if (!A.BytesUtils_bytesEqual(prefix, prefixGot))
        throw A.wrapException(A.AddressConverterException$("Invalid prefix (expected " + A.S(prefix) + ", got " + A.S(prefixGot) + ")", null));
      return t1.sublist$1(addr, prefix.length);
    },
    AddrDecUtils_validateBytesLength(addr, lenExp, minLength) {
      var t2,
        t1 = minLength == null;
      if (!(!t1 && J.get$length$asx(addr) < minLength))
        t2 = t1 && J.get$length$asx(addr) !== lenExp;
      else
        t2 = true;
      if (t2) {
        t1 = t1 ? lenExp : minLength;
        throw A.wrapException(A.AddressConverterException$("Invalid length (expected " + t1 + ", got " + J.get$length$asx(addr) + ")", null));
      }
    },
    AddrDecUtils_validateLength(addr, lenExp) {
      var t1 = addr.length;
      if (t1 !== lenExp)
        throw A.wrapException(A.AddressConverterException$("Invalid length (expected " + lenExp + ", got " + t1 + ")", null));
    },
    AddrKeyValidator_validateAddressArgs(kwargs, key, $T) {
      if (!kwargs.containsKey$1(key) || !$T._is(kwargs.$index(0, key)))
        throw A.wrapException(A.AddressConverterException$("Invalid or Missing required parameters: " + key + " as type " + A.createRuntimeType($T).toString$0(0), null));
      return $T._as(kwargs.$index(0, key));
    },
    AddrKeyValidator_nullOrValidateAddressArgs(kwargs, key, $T) {
      if (kwargs.$index(0, key) == null)
        return null;
      return A.AddrKeyValidator_validateAddressArgs(kwargs, key, $T);
    },
    IPublicKey_IPublicKey$fromBytes(keybytes, type) {
      var point, t1, prefix, keyBytes;
      switch (type) {
        case B.EllipticCurveTypes_nist256p1:
          point = A.ProjectiveECCPoint_ProjectiveECCPoint$fromBytes($.$get$Curves_curve256(), keybytes, null);
          return new A.Nist256p1PublicKey(A.ECDSAPublicKey_ECDSAPublicKey($.$get$Curves_generator256(), point));
        case B.EllipticCurveTypes_sr25519:
          t1 = J.getInterceptor$asx(keybytes);
          if (t1.get$length(keybytes) !== 32)
            A.throwExpression(A.ArgumentException$("invalid public key bytes length expected 32 but " + t1.get$length(keybytes)));
          A.RistrettoPoint_RistrettoPoint$fromBytes(keybytes);
          return new A.Sr25519PublicKey(new A.SchnorrkelPublicKey(A.BytesUtils_toBytes(keybytes, true)));
        case B.EllipticCurveTypes_ed25519:
          t1 = J.getInterceptor$asx(keybytes);
          if (t1.get$length(keybytes) === 33) {
            prefix = t1.sublist$2(keybytes, 0, 1);
            keyBytes = A.BytesUtils_bytesEqual(prefix, B.List_00) || A.BytesUtils_bytesEqual(prefix, B.List_237) ? t1.sublist$1(keybytes, 1) : keybytes;
          } else
            keyBytes = keybytes;
          t1 = $.$get$Curves_generatorED25519();
          return new A.Ed25519PublicKey(A.EDDSAPublicKey_EDDSAPublicKey$fromPoint(t1, A.EDPoint_EDPoint$fromBytes(t1.curve, keyBytes)));
        case B.EllipticCurveTypes_ed25519Kholaw:
          t1 = J.getInterceptor$asx(keybytes);
          keyBytes = t1.get$length(keybytes) === 33 && J.$eq$(t1.$index(keybytes, 0), 0) ? t1.sublist$1(keybytes, 1) : keybytes;
          t1 = $.$get$Curves_generatorED25519();
          return new A.Ed25519KholawPublicKey(A.EDDSAPublicKey_EDDSAPublicKey$fromPoint(t1, A.EDPoint_EDPoint$fromBytes(t1.curve, keyBytes)));
        case B.EllipticCurveTypes_ed25519Monero:
          return new A.MoneroPublicKey(A.MoneroPublicKey__keyFromBytes(keybytes));
        case B.EllipticCurveTypes_ed25519Blake2b:
          t1 = J.getInterceptor$asx(keybytes);
          keyBytes = t1.get$length(keybytes) === 33 && J.$eq$(t1.$index(keybytes, 0), 0) ? t1.sublist$1(keybytes, 1) : keybytes;
          t1 = $.$get$Curves_generatorED25519();
          return new A.Ed25519Blake2bPublicKey(A.EDDSAPublicKey_EDDSAPublicKey$fromPoint(t1, A.EDPoint_EDPoint$fromBytes(t1.curve, keyBytes)));
        default:
          return A.Secp256k1PublicKeyEcdsa_Secp256k1PublicKeyEcdsa$fromBytes(keybytes);
      }
    },
    positiveMod(a, b) {
      var result = a.$mod(0, b);
      return result.compareTo$1(0, $.$get$_BigIntImpl_zero()) >= 0 ? result : b.$add(0, result);
    },
    _mExp(x, power, modulo) {
      var res;
      for (res = x; power.compareTo$1(0, $.$get$_BigIntImpl_zero()) > 0;) {
        res = res.$mul(0, res).$mod(0, modulo);
        power = power.$sub(0, $.$get$_BigIntImpl_one());
      }
      return res;
    },
    sqrtUV(u, v) {
      var root2, useRoot2, noRoot,
        $P = $.$get$Curves_curveEd25519().p,
        v3 = A.positiveMod(v.$mul(0, v).$mul(0, v), $P),
        t1 = u.$mul(0, A.positiveMod(v3.$mul(0, v3).$mul(0, v), $P)),
        xCubed = t1.$mul(0, t1).$mod(0, $P).$mul(0, t1).$mod(0, $P),
        t2 = $.$get$_BigIntImpl_two(),
        xTo4th = A._mExp(xCubed, t2, $P).$mul(0, xCubed).$mod(0, $P),
        t3 = $.$get$_BigIntImpl_one(),
        xTo5th = A._mExp(xTo4th, t3, $P).$mul(0, t1).$mod(0, $P),
        xTo10th = A._mExp(xTo5th, A._BigIntImpl__BigIntImpl$from(5), $P).$mul(0, xTo5th).$mod(0, $P),
        xTo20th = A._mExp(xTo10th, A._BigIntImpl__BigIntImpl$from(10), $P).$mul(0, xTo10th).$mod(0, $P),
        xTo40th = A._mExp(xTo20th, A._BigIntImpl__BigIntImpl$from(20), $P).$mul(0, xTo20th).$mod(0, $P),
        xTo80th = A._mExp(xTo40th, A._BigIntImpl__BigIntImpl$from(40), $P).$mul(0, xTo40th).$mod(0, $P),
        result = A._mExp(A._mExp(A._mExp(A._mExp(xTo80th, A._BigIntImpl__BigIntImpl$from(80), $P).$mul(0, xTo80th).$mod(0, $P), A._BigIntImpl__BigIntImpl$from(80), $P).$mul(0, xTo80th).$mod(0, $P), A._BigIntImpl__BigIntImpl$from(10), $P).$mul(0, xTo10th).$mod(0, $P), t2, $P).$mul(0, t1).$mod(0, $P),
        x = A.positiveMod(u.$mul(0, v3).$mul(0, result), $P),
        vx2 = A.positiveMod(v.$mul(0, x).$mul(0, x), $P);
      t1 = $.$get$sqrtM1();
      root2 = A.positiveMod(x.$mul(0, t1), $P);
      t2 = vx2.compareTo$1(0, u);
      useRoot2 = vx2.compareTo$1(0, A.positiveMod(u.$negate(0), $P)) === 0;
      noRoot = vx2.compareTo$1(0, A.positiveMod(u.$negate(0).$mul(0, t1), $P)) === 0;
      if (useRoot2 || noRoot)
        x = root2;
      t1 = A.positiveMod(x, $P).$and(0, t3).compareTo$1(0, t3);
      if (t1 === 0)
        x = A.positiveMod(x.$negate(0), $P);
      t1 = t2 === 0 || useRoot2;
      return new A.Tuple(t1, x, type$.Tuple_bool_BigInt);
    },
    ECDSAUtils_polynomialExponentiationMod(base, exponent, polymod, p) {
      var $G, t2, t3, t4, s, k,
        t1 = exponent.compareTo$1(0, $.$get$_BigIntImpl_zero());
      if (t1 === 0)
        return A._setArrayType([$.$get$_BigIntImpl_one()], type$.JSArray_BigInt);
      t1 = type$.BigInt;
      $G = A.List_List$from(base, true, t1);
      t2 = $.$get$_BigIntImpl_two();
      t3 = exponent.$mod(0, t2);
      t4 = $.$get$_BigIntImpl_one();
      t3 = t3.compareTo$1(0, t4);
      s = t3 === 0 ? A.List_List$from($G, true, t1) : A._setArrayType([t4], type$.JSArray_BigInt);
      for (k = exponent; k.compareTo$1(0, t4) > 0;) {
        if (t2._used === 0)
          A.throwExpression(B.C_IntegerDivisionByZeroException);
        k = k._div$1(t2);
        $G = A.ECDSAUtils_polynomialMultiplyMod($G, $G, polymod, p);
        t1 = k.$mod(0, t2).compareTo$1(0, t4);
        if (t1 === 0)
          s = A.ECDSAUtils_polynomialMultiplyMod($G, s, polymod, p);
      }
      return s;
    },
    ECDSAUtils_modularSquareRootPrime(a, p) {
      var b, t3, quadraticForm, t4, result,
        t1 = $.$get$_BigIntImpl_zero(),
        t2 = a.compareTo$1(0, t1);
      if (t2 === 0)
        return t1;
      t1 = p.compareTo$1(0, $.$get$_BigIntImpl_two());
      if (t1 === 0)
        return a;
      t1 = A.ECDSAUtils_jacobi(a, p).compareTo$1(0, A._BigIntImpl__BigIntImpl$from(-1));
      if (t1 === 0)
        throw A.wrapException(new A.SquareRootError(a.toString$0(0) + " has no square root modulo " + p.toString$0(0)));
      t1 = p.$mod(0, A._BigIntImpl__BigIntImpl$from(4)).compareTo$1(0, A._BigIntImpl__BigIntImpl$from(3));
      if (t1 === 0)
        return a.modPow$2(0, p.$add(0, $.$get$_BigIntImpl_one()).$tdiv(0, A._BigIntImpl__BigIntImpl$from(4)), p);
      t1 = p.$mod(0, A._BigIntImpl__BigIntImpl$from(8)).compareTo$1(0, A._BigIntImpl__BigIntImpl$from(5));
      if (t1 === 0) {
        t1 = $.$get$_BigIntImpl_one();
        t1 = a.modPow$2(0, p.$sub(0, t1).$tdiv(0, A._BigIntImpl__BigIntImpl$from(4)), p).compareTo$1(0, t1);
        if (t1 === 0)
          return a.modPow$2(0, p.$add(0, A._BigIntImpl__BigIntImpl$from(3)).$tdiv(0, A._BigIntImpl__BigIntImpl$from(8)), p);
        return A._BigIntImpl__BigIntImpl$from(2).$mul(0, a).$mul(0, A._BigIntImpl__BigIntImpl$from(4).$mul(0, a).modPow$2(0, p.$sub(0, A._BigIntImpl__BigIntImpl$from(5)).$tdiv(0, A._BigIntImpl__BigIntImpl$from(8)), p)).$mod(0, p);
      }
      for (b = A._BigIntImpl__BigIntImpl$from(2); b.compareTo$1(0, p) < 0; b = b.$add(0, $.$get$_BigIntImpl_one())) {
        t1 = A.ECDSAUtils_jacobi(b.$mul(0, b).$sub(0, A._BigIntImpl__BigIntImpl$from(4).$mul(0, a)), p).compareTo$1(0, A._BigIntImpl__BigIntImpl$from(-1));
        if (t1 === 0) {
          t1 = b.$negate(0);
          t2 = $.$get$_BigIntImpl_one();
          t3 = type$.JSArray_BigInt;
          quadraticForm = A._setArrayType([a, t1, t2], t3);
          t1 = $.$get$_BigIntImpl_zero();
          t3 = A._setArrayType([t1, t2], t3);
          t2 = p.$add(0, t2);
          t4 = A._BigIntImpl__BigIntImpl$from(2);
          if (t4._used === 0)
            A.throwExpression(B.C_IntegerDivisionByZeroException);
          result = A.ECDSAUtils_polynomialExponentiationMod(t3, t2._div$1(t4), quadraticForm, p);
          if (1 >= result.length)
            return A.ioore(result, 1);
          t1 = J.compareTo$1$ns(result[1], t1);
          if (t1 !== 0)
            throw A.wrapException(B.SquareRootError_7FR);
          if (0 >= result.length)
            return A.ioore(result, 0);
          return result[0];
        }
      }
      throw A.wrapException(B.MessageException_QWS);
    },
    ECDSAUtils_polynomialMultiplyMod(m1, m2, polymod, p) {
      var i, j, t2, t3,
        t1 = m1.length + m2.length - 1,
        prod = A.List_List$filled(t1, $.$get$_BigIntImpl_zero(), false, type$.BigInt);
      for (i = 0; i < m1.length; ++i)
        for (j = 0; j < m2.length; ++j) {
          t2 = i + j;
          if (!(t2 < t1))
            return A.ioore(prod, t2);
          t3 = prod[t2];
          if (!(i < m1.length))
            return A.ioore(m1, i);
          B.JSArray_methods.$indexSet(prod, t2, t3.$add(0, J.$mul$ns(m1[i], m2[j])).$mod(0, p));
        }
      return A.ECDSAUtils_polynomialReduceMod(prod, polymod, p);
    },
    ECDSAUtils_polynomialReduceMod(poly, polymod, p) {
      var t1, t2, t3, i;
      for (t1 = poly.length, t2 = t1 >= 3; t2;) {
        t3 = B.JSArray_methods.get$last(poly).compareTo$1(0, $.$get$_BigIntImpl_zero());
        if (t3 !== 0)
          for (i = 2; i <= 3; ++i) {
            t3 = t1 - i;
            B.JSArray_methods.$indexSet(poly, t3, poly[t3].$sub(0, B.JSArray_methods.get$last(poly).$mul(0, polymod[3 - i])).$mod(0, p));
          }
        B.JSArray_methods.removeLast$0(poly);
      }
      return poly;
    },
    ECDSAUtils_jacobi(a, n) {
      var t1, t2, s, e, e0, a1, s0;
      if (n.compareTo$1(0, A._BigIntImpl__BigIntImpl$from(3)) < 0)
        throw A.wrapException(B.JacobiError_QXN);
      t1 = $.$get$_BigIntImpl_two();
      t2 = n.$mod(0, t1);
      s = $.$get$_BigIntImpl_one();
      t2 = t2.compareTo$1(0, s);
      if (t2 !== 0)
        throw A.wrapException(B.JacobiError_afZ);
      a = a.$mod(0, n);
      e = $.$get$_BigIntImpl_zero();
      t2 = a.compareTo$1(0, e);
      if (t2 === 0)
        return e;
      t2 = a.compareTo$1(0, s);
      if (t2 === 0)
        return s;
      e0 = e;
      a1 = a;
      while (true) {
        t2 = a1.$mod(0, t1).compareTo$1(0, e);
        if (!(t2 === 0))
          break;
        if (t1._used === 0)
          A.throwExpression(B.C_IntegerDivisionByZeroException);
        a1 = a1._div$1(t1);
        e0 = e0.$add(0, s);
      }
      t1 = e0.$mod(0, t1).compareTo$1(0, e);
      if (t1 !== 0) {
        t1 = n.$mod(0, A._BigIntImpl__BigIntImpl$from(8)).compareTo$1(0, s);
        if (t1 !== 0)
          t1 = n.$mod(0, A._BigIntImpl__BigIntImpl$from(8)).compareTo$1(0, A._BigIntImpl__BigIntImpl$from(7)) === 0;
        else
          t1 = true;
      } else
        t1 = true;
      s0 = t1 ? s : A._BigIntImpl__BigIntImpl$from(-1);
      t1 = a1.compareTo$1(0, s);
      if (t1 === 0)
        return s0;
      t1 = n.$mod(0, A._BigIntImpl__BigIntImpl$from(4)).compareTo$1(0, A._BigIntImpl__BigIntImpl$from(3));
      if (t1 === 0)
        t1 = a1.$mod(0, A._BigIntImpl__BigIntImpl$from(4)).compareTo$1(0, A._BigIntImpl__BigIntImpl$from(3)) === 0;
      else
        t1 = false;
      s = t1 ? s0.$negate(0) : s0;
      return s.$mul(0, A.ECDSAUtils_jacobi(n.$mod(0, a1), a1));
    },
    ChaCha20__quarterround(output, a, b, c, d) {
      var t1, t2;
      if (!(d < 16))
        return A.ioore(output, d);
      t1 = output[d];
      if (!(a < 16))
        return A.ioore(output, a);
      t2 = output[a];
      if (!(b < 16))
        return A.ioore(output, b);
      t2 += output[b];
      B.JSArray_methods.$indexSet(output, a, t2);
      B.JSArray_methods.$indexSet(output, d, A.rotl32((t1 ^ t2) >>> 0, 16));
      t2 = output[b];
      if (!(c < 16))
        return A.ioore(output, c);
      t1 = output[c] + output[d];
      B.JSArray_methods.$indexSet(output, c, t1);
      B.JSArray_methods.$indexSet(output, b, A.rotl32((t2 ^ t1) >>> 0, 12));
      t1 = output[d];
      t2 = output[a] + output[b];
      B.JSArray_methods.$indexSet(output, a, t2);
      B.JSArray_methods.$indexSet(output, d, A.rotl32((t1 ^ t2) >>> 0, 8));
      t2 = output[b];
      t1 = output[c] + output[d];
      B.JSArray_methods.$indexSet(output, c, t1);
      B.JSArray_methods.$indexSet(output, b, A.rotl32((t2 ^ t1) >>> 0, 7));
      B.JSArray_methods.$indexSet(output, a, output[a] >>> 0);
      B.JSArray_methods.$indexSet(output, b, output[b] >>> 0);
      B.JSArray_methods.$indexSet(output, c, output[c] >>> 0);
      B.JSArray_methods.$indexSet(output, d, output[d] >>> 0);
    },
    ChaCha20__core(out, input, key) {
      var t2, t3, t4, t5, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15, i,
        mix = A.List_List$filled(16, 0, false, type$.int),
        t1 = key.length;
      if (3 >= t1)
        return A.ioore(key, 3);
      t2 = key[3];
      if (typeof t2 !== "number")
        return t2.$shl();
      t3 = key[2];
      if (typeof t3 !== "number")
        return t3.$shl();
      t4 = key[1];
      if (typeof t4 !== "number")
        return t4.$shl();
      t5 = key[0];
      if (typeof t5 !== "number")
        return A.iae(t5);
      j4 = (t2 << 24 | t3 << 16 | t4 << 8 | t5) >>> 0;
      if (7 >= t1)
        return A.ioore(key, 7);
      t5 = key[7];
      if (typeof t5 !== "number")
        return t5.$shl();
      t4 = key[6];
      if (typeof t4 !== "number")
        return t4.$shl();
      t3 = key[5];
      if (typeof t3 !== "number")
        return t3.$shl();
      t2 = key[4];
      if (typeof t2 !== "number")
        return A.iae(t2);
      j5 = (t5 << 24 | t4 << 16 | t3 << 8 | t2) >>> 0;
      if (11 >= t1)
        return A.ioore(key, 11);
      t2 = key[11];
      if (typeof t2 !== "number")
        return t2.$shl();
      t3 = key[10];
      if (typeof t3 !== "number")
        return t3.$shl();
      t4 = key[9];
      if (typeof t4 !== "number")
        return t4.$shl();
      t5 = key[8];
      if (typeof t5 !== "number")
        return A.iae(t5);
      j6 = (t2 << 24 | t3 << 16 | t4 << 8 | t5) >>> 0;
      if (15 >= t1)
        return A.ioore(key, 15);
      t5 = key[15];
      if (typeof t5 !== "number")
        return t5.$shl();
      t4 = key[14];
      if (typeof t4 !== "number")
        return t4.$shl();
      t3 = key[13];
      if (typeof t3 !== "number")
        return t3.$shl();
      t2 = key[12];
      if (typeof t2 !== "number")
        return A.iae(t2);
      j7 = (t5 << 24 | t4 << 16 | t3 << 8 | t2) >>> 0;
      if (19 >= t1)
        return A.ioore(key, 19);
      t2 = key[19];
      if (typeof t2 !== "number")
        return t2.$shl();
      t3 = key[18];
      if (typeof t3 !== "number")
        return t3.$shl();
      t4 = key[17];
      if (typeof t4 !== "number")
        return t4.$shl();
      t5 = key[16];
      if (typeof t5 !== "number")
        return A.iae(t5);
      j8 = (t2 << 24 | t3 << 16 | t4 << 8 | t5) >>> 0;
      if (23 >= t1)
        return A.ioore(key, 23);
      t5 = key[23];
      if (typeof t5 !== "number")
        return t5.$shl();
      t4 = key[22];
      if (typeof t4 !== "number")
        return t4.$shl();
      t3 = key[21];
      if (typeof t3 !== "number")
        return t3.$shl();
      t2 = key[20];
      if (typeof t2 !== "number")
        return A.iae(t2);
      j9 = (t5 << 24 | t4 << 16 | t3 << 8 | t2) >>> 0;
      if (27 >= t1)
        return A.ioore(key, 27);
      t2 = key[27];
      if (typeof t2 !== "number")
        return t2.$shl();
      t3 = key[26];
      if (typeof t3 !== "number")
        return t3.$shl();
      t4 = key[25];
      if (typeof t4 !== "number")
        return t4.$shl();
      t5 = key[24];
      if (typeof t5 !== "number")
        return A.iae(t5);
      j10 = (t2 << 24 | t3 << 16 | t4 << 8 | t5) >>> 0;
      if (31 >= t1)
        return A.ioore(key, 31);
      t1 = key[31];
      if (typeof t1 !== "number")
        return t1.$shl();
      t5 = key[30];
      if (typeof t5 !== "number")
        return t5.$shl();
      t4 = key[29];
      if (typeof t4 !== "number")
        return t4.$shl();
      t3 = key[28];
      if (typeof t3 !== "number")
        return A.iae(t3);
      j11 = (t1 << 24 | t5 << 16 | t4 << 8 | t3) >>> 0;
      t3 = input[3];
      if (typeof t3 !== "number")
        return t3.$shl();
      t4 = input[2];
      if (typeof t4 !== "number")
        return t4.$shl();
      t5 = input[1];
      if (typeof t5 !== "number")
        return t5.$shl();
      t1 = input[0];
      if (typeof t1 !== "number")
        return A.iae(t1);
      j12 = (t3 << 24 | t4 << 16 | t5 << 8 | t1) >>> 0;
      t1 = input[7];
      if (typeof t1 !== "number")
        return t1.$shl();
      t5 = input[6];
      if (typeof t5 !== "number")
        return t5.$shl();
      t4 = input[5];
      if (typeof t4 !== "number")
        return t4.$shl();
      t3 = input[4];
      if (typeof t3 !== "number")
        return A.iae(t3);
      j13 = (t1 << 24 | t5 << 16 | t4 << 8 | t3) >>> 0;
      t3 = input[11];
      if (typeof t3 !== "number")
        return t3.$shl();
      t4 = input[10];
      if (typeof t4 !== "number")
        return t4.$shl();
      t5 = input[9];
      if (typeof t5 !== "number")
        return t5.$shl();
      t1 = input[8];
      if (typeof t1 !== "number")
        return A.iae(t1);
      j14 = (t3 << 24 | t4 << 16 | t5 << 8 | t1) >>> 0;
      t1 = input[15];
      if (typeof t1 !== "number")
        return t1.$shl();
      t5 = input[14];
      if (typeof t5 !== "number")
        return t5.$shl();
      t4 = input[13];
      if (typeof t4 !== "number")
        return t4.$shl();
      t3 = input[12];
      if (typeof t3 !== "number")
        return A.iae(t3);
      j15 = (t1 << 24 | t5 << 16 | t4 << 8 | t3) >>> 0;
      B.JSArray_methods.$indexSet(mix, 0, 1634760805);
      B.JSArray_methods.$indexSet(mix, 1, 857760878);
      B.JSArray_methods.$indexSet(mix, 2, 2036477234);
      B.JSArray_methods.$indexSet(mix, 3, 1797285236);
      B.JSArray_methods.$indexSet(mix, 4, j4);
      B.JSArray_methods.$indexSet(mix, 5, j5);
      B.JSArray_methods.$indexSet(mix, 6, j6);
      B.JSArray_methods.$indexSet(mix, 7, j7);
      B.JSArray_methods.$indexSet(mix, 8, j8);
      B.JSArray_methods.$indexSet(mix, 9, j9);
      B.JSArray_methods.$indexSet(mix, 10, j10);
      B.JSArray_methods.$indexSet(mix, 11, j11);
      B.JSArray_methods.$indexSet(mix, 12, j12);
      B.JSArray_methods.$indexSet(mix, 13, j13);
      B.JSArray_methods.$indexSet(mix, 14, j14);
      B.JSArray_methods.$indexSet(mix, 15, j15);
      for (i = 0; i < 20; i += 2) {
        A.ChaCha20__quarterround(mix, 0, 4, 8, 12);
        A.ChaCha20__quarterround(mix, 1, 5, 9, 13);
        A.ChaCha20__quarterround(mix, 2, 6, 10, 14);
        A.ChaCha20__quarterround(mix, 3, 7, 11, 15);
        A.ChaCha20__quarterround(mix, 0, 5, 10, 15);
        A.ChaCha20__quarterround(mix, 1, 6, 11, 12);
        A.ChaCha20__quarterround(mix, 2, 7, 8, 13);
        A.ChaCha20__quarterround(mix, 3, 4, 9, 14);
      }
      A.writeUint32LE(mix[0] + 1634760805 >>> 0, out, 0);
      A.writeUint32LE(mix[1] + 857760878 >>> 0, out, 4);
      A.writeUint32LE(mix[2] + 2036477234 >>> 0, out, 8);
      A.writeUint32LE(mix[3] + 1797285236 >>> 0, out, 12);
      A.writeUint32LE(mix[4] + j4 >>> 0, out, 16);
      A.writeUint32LE(mix[5] + j5 >>> 0, out, 20);
      A.writeUint32LE(mix[6] + j6 >>> 0, out, 24);
      A.writeUint32LE(mix[7] + j7 >>> 0, out, 28);
      A.writeUint32LE(mix[8] + j8 >>> 0, out, 32);
      A.writeUint32LE(mix[9] + j9 >>> 0, out, 36);
      A.writeUint32LE(mix[10] + j10 >>> 0, out, 40);
      A.writeUint32LE(mix[11] + j11 >>> 0, out, 44);
      A.writeUint32LE(mix[12] + j12 >>> 0, out, 48);
      A.writeUint32LE(mix[13] + j13 >>> 0, out, 52);
      A.writeUint32LE(mix[14] + j14 >>> 0, out, 56);
      A.writeUint32LE(mix[15] + j15 >>> 0, out, 60);
    },
    ChaCha20__incrementCounter(counter, pos, len) {
      var carry, t1;
      for (carry = 1; len > 0;) {
        if (!(pos < 16))
          return A.ioore(counter, pos);
        t1 = counter[pos];
        if (typeof t1 !== "number")
          return t1.$and();
        carry += t1 & 255;
        B.JSArray_methods.$indexSet(counter, pos, carry & 255);
        carry = carry >>> 8;
        ++pos;
        --len;
      }
      if (carry > 0)
        throw A.wrapException(B.MessageException_asg);
    },
    ChaCha20_streamXOR(key, nonce, src, dst, nonceInplaceCounterLength) {
      var t1, block, i, i0, j, t2, t3;
      if (key.length !== 32)
        throw A.wrapException(B.ArgumentException_qBh);
      if (dst.length < src.length)
        throw A.wrapException(B.ArgumentException_APm);
      t1 = nonceInplaceCounterLength === 0;
      if (t1)
        throw A.wrapException(B.ArgumentException_ALf);
      block = A.List_List$filled(64, 0, false, type$.int);
      for (i = 0; i < src.length; i = i0) {
        A.ChaCha20__core(block, nonce, key);
        i0 = i + 64;
        j = i;
        while (true) {
          if (!(j < i0 && j < src.length))
            break;
          if (!(j < src.length))
            return A.ioore(src, j);
          t2 = src[j];
          if (typeof t2 !== "number")
            return t2.$and();
          t3 = j - i;
          if (!(t3 >= 0 && t3 < 64))
            return A.ioore(block, t3);
          B.JSArray_methods.$indexSet(dst, j, t2 & 255 ^ block[t3]);
          ++j;
        }
        A.ChaCha20__incrementCounter(nonce, 0, nonceInplaceCounterLength);
      }
      A.zero(block);
      if (t1)
        A.zero(nonce);
      return dst;
    },
    Crc16_quickIntDigest(data) {
      var reg, _i, byte, mask,
        t1 = data.length + 2,
        t2 = type$.int,
        message = A.List_List$filled(t1, 0, false, t2);
      B.JSArray_methods.setAll$2(message, 0, data);
      for (reg = 0, _i = 0; _i < t1; ++_i) {
        byte = message[_i];
        for (mask = 128; mask > 0;) {
          reg = reg << 1 >>> 0;
          if (typeof byte !== "number")
            return byte.$and();
          if ((byte & mask) !== 0)
            ++reg;
          mask = mask >>> 1;
          if (reg > 65535)
            reg = reg & 65535 ^ 4129;
        }
      }
      return A.List_List$from([reg >>> 8, reg & 255], true, t2);
    },
    Crc32_quickIntDigest(data) {
      var t1, crc;
      for (t1 = J.get$iterator$ax(data), crc = 4294967295; t1.moveNext$0();)
        crc = crc >>> 8 ^ B.List_YyJ[(crc ^ t1.get$current()) & 255];
      return (crc ^ 4294967295) >>> 0;
    },
    writeUint64LE(value, out) {
      A.writeUint32LE(value >>> 0, out, 0);
      A.writeUint32LE(B.JSInt_methods._shrOtherPositive$1(value, 32), out, 4);
      return out;
    },
    writeUint32LE(value, out, offset) {
      B.JSArray_methods.$indexSet(out, offset, value & 255);
      B.JSArray_methods.$indexSet(out, offset + 1, B.JSInt_methods._shrOtherPositive$1(value, 8) & 255);
      B.JSArray_methods.$indexSet(out, offset + 2, B.JSInt_methods._shrOtherPositive$1(value, 16) & 255);
      B.JSArray_methods.$indexSet(out, offset + 3, B.JSInt_methods._shrOtherPositive$1(value, 24) & 255);
    },
    writeUint16LE(value, out, offset) {
      B.JSArray_methods.$indexSet(out, offset, value & 255);
      B.JSArray_methods.$indexSet(out, offset + 1, B.JSInt_methods._shrOtherPositive$1(value, 8) & 255);
    },
    readUint32LE(array, offset) {
      var t3, t4,
        t1 = offset + 3,
        t2 = array.length;
      if (!(t1 < t2))
        return A.ioore(array, t1);
      t1 = array[t1];
      if (typeof t1 !== "number")
        return t1.$shl();
      t3 = offset + 2;
      if (!(t3 < t2))
        return A.ioore(array, t3);
      t3 = array[t3];
      if (typeof t3 !== "number")
        return t3.$shl();
      t4 = offset + 1;
      if (!(t4 < t2))
        return A.ioore(array, t4);
      t4 = array[t4];
      if (typeof t4 !== "number")
        return t4.$shl();
      if (!(offset < t2))
        return A.ioore(array, offset);
      t2 = array[offset];
      if (typeof t2 !== "number")
        return A.iae(t2);
      return (t1 << 24 | t3 << 16 | t4 << 8 | t2) >>> 0;
    },
    writeUint32BE(value, out, offset) {
      B.JSArray_methods.$indexSet(out, offset, value >>> 24 & 255);
      B.JSArray_methods.$indexSet(out, offset + 1, value >>> 16 & 255);
      B.JSArray_methods.$indexSet(out, offset + 2, value >>> 8 & 255);
      B.JSArray_methods.$indexSet(out, offset + 3, value & 255);
    },
    readUint32BE(array, offset) {
      var t2, t3, t4, t5,
        t1 = array.length;
      if (!(offset < t1))
        return A.ioore(array, offset);
      t2 = array[offset];
      if (typeof t2 !== "number")
        return t2.$shl();
      t3 = offset + 1;
      if (!(t3 < t1))
        return A.ioore(array, t3);
      t3 = array[t3];
      if (typeof t3 !== "number")
        return t3.$shl();
      t4 = offset + 2;
      if (!(t4 < t1))
        return A.ioore(array, t4);
      t4 = array[t4];
      if (typeof t4 !== "number")
        return t4.$shl();
      t5 = offset + 3;
      if (!(t5 < t1))
        return A.ioore(array, t5);
      t5 = array[t5];
      if (typeof t5 !== "number")
        return A.iae(t5);
      return (t2 << 24 | t3 << 16 | t4 << 8 | t5) >>> 0;
    },
    rotl32(val, shift) {
      var modShift = shift & 31;
      return (val << modShift | B.JSInt_methods._shrReceiverPositive$1(val >>> 0, 32 - modShift)) >>> 0;
    },
    zero(array) {
      var t1, i;
      for (t1 = array.length, i = 0; i < t1; ++i)
        B.JSArray_methods.$indexSet(array, i, 0);
    },
    CompareUtils_iterableIsEqual(a, b, $T) {
      var t1, t2, index;
      if (a == null)
        return b == null;
      if (b == null || J.get$length$asx(a) !== J.get$length$asx(b))
        return false;
      if (a === b)
        return true;
      for (t1 = J.getInterceptor$asx(a), t2 = J.getInterceptor$ax(b), index = 0; index < t1.get$length(a); ++index)
        if (!J.$eq$(t1.elementAt$1(a, index), t2.elementAt$1(b, index)))
          return false;
      return true;
    },
    BigintUtils_orderLen(value) {
      return B.JSInt_methods._tdivFast$1(value.toRadixString$1(0, 16).length + 1, 2);
    },
    BigintUtils_inverseMod(a, m) {
      var lm, low, high, lm0, r, nm, newLow,
        hm = $.$get$_BigIntImpl_zero(),
        t1 = a.compareTo$1(0, hm);
      if (t1 === 0)
        return hm;
      lm = $.$get$_BigIntImpl_one();
      if (a.compareTo$1(0, lm) >= 0 && a.compareTo$1(0, m) < 0)
        return a.modInverse$1(0, m);
      low = a.$mod(0, m);
      for (high = m, lm0 = lm; low.compareTo$1(0, lm) > 0; high = low, low = newLow, hm = lm0, lm0 = nm) {
        if (low._used === 0)
          A.throwExpression(B.C_IntegerDivisionByZeroException);
        r = high._div$1(low);
        nm = hm.$sub(0, lm0.$mul(0, r));
        newLow = high.$sub(0, low.$mul(0, r));
      }
      return lm0.$mod(0, m);
    },
    BigintUtils_computeNAF(mult) {
      var t1, t2, nafDigit,
        nafList = A._setArrayType([], type$.JSArray_BigInt);
      while (true) {
        t1 = $.$get$_BigIntImpl_zero();
        t2 = mult.compareTo$1(0, t1);
        if (!(t2 !== 0))
          break;
        if (mult._used !== 0) {
          t2 = mult._digits;
          if (0 >= t2.length)
            return A.ioore(t2, 0);
          t2 = (t2[0] & 1) === 0;
        } else
          t2 = true;
        if (!t2) {
          nafDigit = mult.$mod(0, A._BigIntImpl__BigIntImpl$from(4));
          if (nafDigit.compareTo$1(0, $.$get$_BigIntImpl_two()) >= 0)
            nafDigit = nafDigit.$sub(0, A._BigIntImpl__BigIntImpl$from(4));
          B.JSArray_methods.add$1(nafList, nafDigit);
          mult = mult.$sub(0, nafDigit);
        } else
          B.JSArray_methods.add$1(nafList, t1);
        t1 = $.$get$_BigIntImpl_two();
        if (t1._used === 0)
          A.throwExpression(B.C_IntegerDivisionByZeroException);
        mult = mult._div$1(t1);
      }
      return nafList;
    },
    BigintUtils_toBytes(val, $length, order) {
      var bigMaskEight, byteList, i, t2,
        t1 = val.compareTo$1(0, $.$get$_BigIntImpl_zero());
      if (t1 === 0)
        return A.List_List$filled($length, 0, false, type$.int);
      bigMaskEight = A._BigIntImpl__BigIntImpl$from(255);
      t1 = type$.int;
      byteList = A.List_List$filled($length, 0, false, t1);
      for (i = 0; i < $length; ++i) {
        B.JSArray_methods.$indexSet(byteList, $length - i - 1, val.$and(0, bigMaskEight).toInt$0(0));
        val = val.$shr(0, 8);
      }
      if (order === B.C_Endian0) {
        t2 = A._arrayInstanceType(byteList)._eval$1("ReversedListIterable<1>");
        byteList = A.List_List$of(new A.ReversedListIterable(byteList, t2), true, t2._eval$1("ListIterable.E"));
      }
      return A.List_List$from(byteList, true, t1);
    },
    BigintUtils_fromBytes(bytes, byteOrder, sign) {
      var t1, result, i, t2, t3;
      if (byteOrder === B.C_Endian0) {
        t1 = J.get$reversed$ax(bytes);
        bytes = A.List_List$from(A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E")), true, type$.int);
      }
      result = $.$get$_BigIntImpl_zero();
      for (t1 = J.getInterceptor$asx(bytes), i = 0; i < t1.get$length(bytes); ++i)
        result = result.$add(0, A._BigIntImpl__BigIntImpl$from(t1.$index(bytes, t1.get$length(bytes) - i - 1)).$shl(0, 8 * i));
      t2 = $.$get$_BigIntImpl_zero();
      t3 = result.compareTo$1(0, t2);
      if (t3 === 0)
        return t2;
      if (sign) {
        t1 = t1.$index(bytes, 0);
        if (typeof t1 !== "number")
          return t1.$and();
        t1 = (t1 & 128) !== 0;
      } else
        t1 = false;
      if (t1)
        return result.toSigned$1(0, B.JSInt_methods._tdivFast$1((result._isNegative ? result.$negate(0) : result).get$bitLength(0) + 7, 8) * 8);
      return result;
    },
    BigintUtils_parse(v) {
      var parse, t1, exception;
      try {
        if (v instanceof A._BigIntImpl)
          return v;
        if (A._isInt(v)) {
          t1 = A._BigIntImpl__BigIntImpl$from(v);
          return t1;
        }
        if (type$.List_int._is(v)) {
          t1 = A.BigintUtils_fromBytes(v, B.C_Endian, true);
          return t1;
        }
        if (typeof v == "string") {
          parse = A._BigIntImpl__tryParse(v, null);
          if (parse == null) {
            t1 = $.$get$StringUtils__hexaDecimalRegex();
            t1 = t1._nativeRegExp.test(v);
          } else
            t1 = false;
          if (t1)
            parse = A._BigIntImpl_parse(A.StringUtils_strip0x(v), 16);
          t1 = parse;
          t1.toString;
          return t1;
        }
      } catch (exception) {
      }
      throw A.wrapException(B.ArgumentException_PzB);
    },
    BigintUtils_tryParse(v) {
      var t1, exception;
      try {
        t1 = A.BigintUtils_parse(v);
        return t1;
      } catch (exception) {
        if (A.unwrapException(exception) instanceof A.ArgumentException)
          return null;
        else
          throw exception;
      }
    },
    BigintUtils_variableNatDecode(bytes) {
      var t1, bytesRead, _i, byte, t2,
        output = $.$get$_BigIntImpl_zero();
      for (t1 = bytes.length, bytesRead = 0, _i = 0; _i < bytes.length; bytes.length === t1 || (0, A.throwConcurrentModificationError)(bytes), ++_i) {
        byte = bytes[_i];
        t2 = output.$shl(0, 7);
        if (typeof byte !== "number")
          return byte.$and();
        output = t2.$or(0, A._BigIntImpl__BigIntImpl$from(byte & 127));
        if (output.compareTo$1(0, $.$get$maxU64()) > 0)
          throw A.wrapException(B.MessageException_s43);
        ++bytesRead;
        if ((byte & 128) === 0)
          return new A.Tuple(output, bytesRead, type$.Tuple_BigInt_int);
      }
      throw A.wrapException(B.MessageException_zLW);
    },
    IntUtils_bitlengthInBytes(val) {
      var bitlength = B.JSInt_methods.get$bitLength(val);
      if (bitlength === 0)
        return 1;
      return B.JSInt_methods._tdivFast$1((B.JSInt_methods.get$isNegative(val) ? bitlength + 1 : bitlength) + 7, 8);
    },
    IntUtils_toBytes(val, byteOrder, $length) {
      var t1, t2, byteList, i;
      if ($length > 4) {
        t1 = A.List_List$of(A.IntUtils_toBytes(B.JSInt_methods._shrOtherPositive$1(val, 32), B.C_Endian, $length - 4), true, type$.int);
        B.JSArray_methods.addAll$1(t1, A.IntUtils_toBytes(val >>> 0, B.C_Endian, 4));
        if (byteOrder === B.C_Endian0) {
          t2 = A._arrayInstanceType(t1)._eval$1("ReversedListIterable<1>");
          return A.List_List$of(new A.ReversedListIterable(t1, t2), true, t2._eval$1("ListIterable.E"));
        }
        return t1;
      }
      byteList = A.List_List$filled($length, 0, false, type$.int);
      for (i = 0; i < $length; ++i) {
        B.JSArray_methods.$indexSet(byteList, $length - i - 1, val & 255);
        val = B.JSInt_methods._shrOtherPositive$1(val, 8);
      }
      if (byteOrder === B.C_Endian0) {
        t1 = A._arrayInstanceType(byteList)._eval$1("ReversedListIterable<1>");
        return A.List_List$of(new A.ReversedListIterable(byteList, t1), true, t1._eval$1("ListIterable.E"));
      }
      return byteList;
    },
    IntUtils_fromBytes(bytes) {
      var t2, lowerPart, result, i,
        t1 = bytes.length;
      if (t1 > 4) {
        t2 = J.getInterceptor$ax(bytes);
        lowerPart = A.IntUtils_fromBytes(t2.sublist$2(bytes, t1 - 4, t1));
        result = (B.JSInt_methods._shlPositive$1(A.IntUtils_fromBytes(t2.sublist$2(bytes, 0, bytes.length - 4)), 32) | lowerPart) >>> 0;
      } else
        for (result = 0, i = 0; i < t1; ++i) {
          t2 = t1 - i - 1;
          if (!(t2 >= 0))
            return A.ioore(bytes, t2);
          t2 = bytes[t2];
          if (typeof t2 !== "number")
            return t2.$shl();
          result = (result | B.JSNumber_methods._shlPositive$1(t2, 8 * i)) >>> 0;
        }
      return result;
    },
    groupBy(values, key, $S, $T) {
      var t1, _i, element, t2, t3,
        map = A.LinkedHashMap_LinkedHashMap$_empty($T, $S._eval$1("List<0>"));
      for (t1 = $S._eval$1("JSArray<0>"), _i = 0; _i < 1; ++_i) {
        element = values[_i];
        t2 = key.call$1(element);
        t3 = map.$index(0, t2);
        if (t3 == null) {
          t3 = A._setArrayType([], t1);
          map.$indexSet(0, t2, t3);
          t2 = t3;
        } else
          t2 = t3;
        J.add$1$ax(t2, element);
      }
      return map;
    },
    CosmosAddrUtils_decodeBytes(addr, hrp) {
      var decode = A.Bech32Decoder_decodeWithoutHRP(addr),
        t1 = decode.item2,
        t2 = J.getInterceptor$asx(t1);
      if (t2.get$length(t1) !== 20 && t2.get$length(t1) !== 32)
        A.throwExpression(A.MessageException$("Invalid address bytes length.", A.LinkedHashMap_LinkedHashMap$_literal(["length", t2.get$length(t1), "Excepted", "20 or 32"], type$.String, type$.dynamic)));
      if (hrp != null && hrp !== decode.item1)
        throw A.wrapException(A.MessageException$("Invalid network address prefix.", A.LinkedHashMap_LinkedHashMap$_literal(["Excepted", hrp, "hrp", decode.item1], type$.String, type$.dynamic)));
      return t1;
    },
    encodingForCharset(charset) {
      var t1;
      if (charset == null)
        return B.C_Latin1Codec;
      t1 = A.Encoding_getByName(charset);
      return t1 == null ? B.C_Latin1Codec : t1;
    },
    toUint8List(input) {
      return input;
    },
    toByteStream(stream) {
      return stream;
    },
    wrapFormatException($name, value, body, $T) {
      var error, error0, t1, exception;
      try {
        t1 = body.call$0();
        return t1;
      } catch (exception) {
        t1 = A.unwrapException(exception);
        if (t1 instanceof A.SourceSpanFormatException) {
          error = t1;
          throw A.wrapException(A.SourceSpanFormatException$("Invalid " + $name + ": " + error._span_exception$_message, error._span, error.get$source()));
        } else if (type$.FormatException._is(t1)) {
          error0 = t1;
          throw A.wrapException(A.FormatException$("Invalid " + $name + ' "' + value + '": ' + error0.get$message(), error0.get$source(), error0.get$offset()));
        } else
          throw exception;
      }
    },
    RetionalConst_fromDecimalNumber(decimal) {
      switch (decimal) {
        case 8:
          return $.$get$RetionalConst_bigR8();
        case 18:
          return $.$get$RetionalConst_bigR18();
        case 6:
          return $.$get$RetionalConst_bigR6();
        default:
          return A.BigRational_BigRational(A._BigIntImpl__BigIntImpl$from(10).pow$1(decimal), null);
      }
    },
    ElectrumService_ElectrumService$fromProvider(provider, service) {
      var t6,
        t1 = type$.void_Function,
        t2 = type$.JSArray_ApiRequest,
        t3 = type$.int,
        t4 = type$.SocketRequestCompeleter,
        t5 = type$.Live_APIServiceStatus;
      switch (service.get$protocol()) {
        case B.ServiceProtocol_SSL_1_ssl:
          t6 = service.get$endpoint();
          return new A.ElectrumSSLSocketService(new A.APIServiceTracker(new A.Live(B.APIServiceStatus_0, A.LinkedHashSet_LinkedHashSet$_empty(t1), t5), A._setArrayType([], t2)), t6, new A.SynchronizedLock(), B.SocketStatus_1, A.LinkedHashMap_LinkedHashMap$_empty(t3, t4));
        case B.ServiceProtocol_TCP_2_tcp:
          t6 = service.get$endpoint();
          return new A.ElectrumSocketService(new A.APIServiceTracker(new A.Live(B.APIServiceStatus_0, A.LinkedHashSet_LinkedHashSet$_empty(t1), t5), A._setArrayType([], t2)), t6, new A.SynchronizedLock(), B.SocketStatus_1, A.LinkedHashMap_LinkedHashMap$_empty(t3, t4));
        default:
          t6 = service.get$endpoint();
          return new A.ElectrumWebsocketService(new A.APIServiceTracker(new A.Live(B.APIServiceStatus_0, A.LinkedHashSet_LinkedHashSet$_empty(t1), t5), A._setArrayType([], t2)), t6, new A.SynchronizedLock(), B.SocketStatus_1, A.LinkedHashMap_LinkedHashMap$_empty(t3, t4));
      }
    },
    APIUtils__buildEthereumRPC(provider) {
      if (provider.protocol === B.ServiceProtocol_WebSocket_3_websocket)
        return new A.EVMRPC();
      return new A.EVMRPC();
    },
    APIUtils__buildRippleProvider(provider) {
      if (provider.protocol === B.ServiceProtocol_WebSocket_3_websocket)
        return new A.RippleWebsocketService(new A.APIServiceTracker(new A.Live(B.APIServiceStatus_0, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_APIServiceStatus), A._setArrayType([], type$.JSArray_ApiRequest)), provider.uri, new A.SynchronizedLock(), B.SocketStatus_1, A.LinkedHashMap_LinkedHashMap$_empty(type$.int, type$.SocketRequestCompeleter));
      return new A.RippleHTTPService(provider.uri, new A.APIServiceTracker(new A.Live(B.APIServiceStatus_0, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_APIServiceStatus), A._setArrayType([], type$.JSArray_ApiRequest)));
    },
    APIUtils_buildBitcoinApiPorivder(provider, network) {
      var t1;
      if (provider instanceof A.ElectrumAPIProvider) {
        A.ElectrumService_ElectrumService$fromProvider(provider, provider);
        return new A.BitcoinElectrumClient(network, new A.Live(B.NodeClientStatus_1, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_NodeClientStatus), new A.SynchronizedLock());
      }
      type$.BitcoinExplorerAPIProvider._as(provider);
      A._BitcoinExplorerAPIProviderUtils_createConfig(network.coinParam.transacationNetwork, provider.explorerType.get$type(), provider.uri);
      t1 = type$.String;
      A.LinkedHashMap_LinkedHashMap$_literal(["Content-Type", "application/json"], t1, t1);
      return new A.BitcoinExplorerApiProvider(network, new A.Live(B.NodeClientStatus_1, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_NodeClientStatus), new A.SynchronizedLock());
    },
    APIUtils_createApiClient(network, service, $T) {
      var client, t1, t2,
        serviceProvider = network.getProvider$1$1(service, type$.APIProvider);
      if (serviceProvider == null)
        serviceProvider = A.ProvidersConst_getDefaultService(network, service);
      if (serviceProvider == null)
        return null;
      switch (network.get$type()) {
        case B.NetworkType_8eb:
        case B.NetworkType_8eb0:
          client = A.APIUtils_buildBitcoinApiPorivder(serviceProvider, network.toNetwork$1$0(type$.WalletBitcoinNetwork));
          break;
        case B.NetworkType_4ei:
          serviceProvider.toProvider$1$0(type$.CardanoAPIProvider);
          client = new A.CardanoClient(network.toNetwork$1$0(type$.WalletCardanoNetwork), new A.Live(B.NodeClientStatus_1, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_NodeClientStatus), new A.SynchronizedLock());
          break;
        case B.NetworkType_QJm:
          serviceProvider.toProvider$1$0(type$.CosmosAPIProvider);
          t1 = network.toNetwork$1$0(type$.WalletCosmosNetwork);
          client = new A.CosmosClient(t1, new A.Live(B.NodeClientStatus_1, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_NodeClientStatus), new A.SynchronizedLock());
          break;
        case B.NetworkType_iDZ:
          client = A.EthereumClient$(network, A.APIUtils__buildEthereumRPC(serviceProvider.toProvider$1$0(type$.EthereumAPIProvider)));
          break;
        case B.NetworkType_Oh2:
          t1 = serviceProvider.toProvider$1$0(type$.RippleAPIProvider);
          t2 = network.toNetwork$1$0(type$.WalletXRPNetwork);
          A.APIUtils__buildRippleProvider(t1);
          client = new A.RippleClient(t2, new A.Live(B.NodeClientStatus_1, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_NodeClientStatus), new A.SynchronizedLock());
          break;
        case B.NetworkType_4QF:
          serviceProvider.toProvider$1$0(type$.SolanaAPIProvider);
          client = new A.SolanaClient(network.toNetwork$1$0(type$.WalletSolanaNetwork), new A.Live(B.NodeClientStatus_1, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_NodeClientStatus), new A.SynchronizedLock());
          break;
        case B.NetworkType_SkF:
          t1 = serviceProvider.toProvider$1$0(type$.TronAPIProvider);
          t2 = network.toNetwork$1$0(type$.WalletTronNetwork);
          A.EthereumClient$(t2, A.APIUtils__buildEthereumRPC(t1.solidityProvider));
          client = new A.TronClient(t2, new A.Live(B.NodeClientStatus_1, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_NodeClientStatus), new A.SynchronizedLock());
          break;
        case B.NetworkType_66M:
          serviceProvider.toProvider$1$0(type$.TonAPIProvider);
          client = new A.TonClient(network.toNetwork$1$0(type$.WalletTonNetwork), new A.Live(B.NodeClientStatus_1, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_NodeClientStatus), new A.SynchronizedLock());
          break;
        case B.NetworkType_GRA:
        case B.NetworkType_0:
          serviceProvider.toProvider$1$0(type$.SubstrateAPIProvider);
          client = new A.SubstrateClient(network.toNetwork$1$0(type$.WalletPolkadotNetwork), new A.Live(B.NodeClientStatus_1, A.LinkedHashSet_LinkedHashSet$_empty(type$.void_Function), type$.Live_NodeClientStatus), new A.SynchronizedLock());
          break;
        default:
          throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      }
      if (!$T._is(client))
        return null;
      return client;
    },
    ChainConst_updateNetwork(network, networkId) {
      var t1, t2, t3;
      if (networkId != null)
        t1 = network != null && networkId !== network.get$value();
      else
        t1 = true;
      if (t1)
        throw A.wrapException($.$get$WalletExceptionConst_dataVerificationFailed());
      t1 = $.$get$ChainConst_defaultCoins();
      if (!t1.containsKey$1(networkId)) {
        if (network == null)
          throw A.wrapException($.$get$WalletExceptionConst_dataVerificationFailed());
        return network;
      }
      t1 = t1.$index(0, networkId);
      t1.toString;
      t2 = t1.get$coinParam();
      t3 = network == null ? null : network.get$coinParam().providers;
      return t1.copyWith$2$coinParam$value(t2.updateProviders$1(t3 == null ? A._setArrayType([], type$.JSArray_APIProvider) : t3), t1.get$value());
    },
    BlockchainAddressUtils_toBitcoinAddress(address, network, p2shAddressType) {
      var decodeAddress, t1, t2, exception, addr = null;
      try {
        if (network instanceof A.BitcoinCashNetwork) {
          decodeAddress = A._BitcoinAddressUtils_decodeBchAddress(address, network, false);
          if (decodeAddress == null)
            A.throwExpression(A.BitcoinBasePluginException$("Invalid " + network.value + " address."));
          addr = decodeAddress;
        } else if (network instanceof A.BitcoinNetwork)
          addr = A._BitcoinAddressUtils_decodeAddress(address, network);
        else if (network instanceof A.DogecoinNetwork)
          addr = A._BitcoinAddressUtils_decodeAddress(address, network);
        else if (network instanceof A.DashNetwork)
          addr = A._BitcoinAddressUtils_decodeAddress(address, network);
        else if (network instanceof A.LitecoinNetwork)
          addr = A._BitcoinAddressUtils_decodeAddress(address, network);
        else if (network instanceof A.PepeNetwork)
          addr = A._BitcoinAddressUtils_decodeAddress(address, network);
        else {
          t1 = A.UnimplementedError$(null);
          throw A.wrapException(t1);
        }
        t1 = addr.get$type().get$isP2sh();
        if (t1)
          if (addr.get$type() !== p2shAddressType) {
            t1 = addr.get$addressProgram();
            t2 = p2shAddressType.get$isP2sh() ? type$.P2shAddressType._as(p2shAddressType) : B.P2shAddressType_g2q;
            addr = new A.P2shAddress(t2, A._BitcoinAddressUtils_validateAddressProgram(t1, t2));
          }
        t1 = addr;
        return t1;
      } catch (exception) {
        t1 = A.ArgumentError$("invalid " + network.get$conf().coinName.toString$0(0) + " address", null);
        throw A.wrapException(t1);
      }
    },
    BlockchainAddressUtils_publicKeyToBitcoinAddress(publicKey, coin, addressType) {
      var t1, bitcoinPublicKey, address,
        _s15_ = "_addressProgram";
      A.Bip32KeyData$();
      $.$get$Bip32Const_mainNetKeyNetVersions();
      t1 = A.IPublicKey_IPublicKey$fromBytes(publicKey, B.EllipticCurveTypes_secp256k1);
      t1.get$curve();
      bitcoinPublicKey = new A.ECPublic(new A.Bip32PublicKey(t1));
      switch (coin.get$proposal()) {
        case B.BipProposal_bip44:
          address = bitcoinPublicKey.toAddress$0();
          if (addressType === B.P2pkhAddressType_P2PKHWT) {
            t1 = address.__LegacyAddress__addressProgram_F;
            t1 === $ && A.throwLateFieldNI(_s15_);
            address = new A.P2pkhAddress(B.P2pkhAddressType_P2PKHWT, A._BitcoinAddressUtils_validateAddressProgram(t1, B.P2pkhAddressType_P2PKHWT));
          }
          break;
        case B.BipProposal_bip49:
          switch (addressType) {
            case B.P2shAddressType_qI5:
              address = new A.P2shAddress(B.P2shAddressType_qI5, A._BitcoinAddressUtils_scriptToHash160(new A.Script(A.List_List$unmodifiable(["OP_0", A._BitcoinAddressUtils_segwitScriptToSHA256(bitcoinPublicKey.toP2wshScript$1$compressed(true))], type$.dynamic))));
              break;
            case B.P2shAddressType_SfU:
              t1 = bitcoinPublicKey.toSegwitAddress$1$compressed(true).__SegwitAddress_addressProgram_F;
              t1 === $ && A.throwLateFieldNI("addressProgram");
              address = new A.P2shAddress(B.P2shAddressType_SfU, A._BitcoinAddressUtils_scriptToHash160(new A.Script(A.List_List$unmodifiable(["OP_0", t1], type$.dynamic))));
              break;
            case B.P2shAddressType_sc9:
            case B.P2shAddressType_hK7:
            case B.P2shAddressType_lhG:
            case B.P2shAddressType_0:
              address = bitcoinPublicKey.toP2pkhInP2sh$1$useBCHP2sh32(addressType === B.P2shAddressType_hK7 || addressType === B.P2shAddressType_0);
              if (addressType === B.P2shAddressType_lhG || addressType === B.P2shAddressType_0) {
                t1 = address.__LegacyAddress__addressProgram_F;
                t1 === $ && A.throwLateFieldNI(_s15_);
                type$.P2shAddressType._as(addressType);
                address = new A.P2shAddress(addressType, A._BitcoinAddressUtils_validateAddressProgram(t1, addressType));
              }
              break;
            case B.P2shAddressType_g2q:
            case B.P2shAddressType_Q9u:
            case B.P2shAddressType_CXi:
            case B.P2shAddressType_TLC:
              address = bitcoinPublicKey.toP2pkInP2sh$1$useBCHP2sh32(addressType === B.P2shAddressType_Q9u || addressType === B.P2shAddressType_TLC);
              if (addressType === B.P2shAddressType_CXi || addressType === B.P2shAddressType_TLC) {
                t1 = address.__LegacyAddress__addressProgram_F;
                t1 === $ && A.throwLateFieldNI(_s15_);
                type$.P2shAddressType._as(addressType);
                address = new A.P2shAddress(addressType, A._BitcoinAddressUtils_validateAddressProgram(t1, addressType));
              }
              break;
            default:
              throw A.wrapException($.$get$WalletExceptionConst_invalidBitcoinAddressType());
          }
          break;
        case B.BipProposal_bip84:
          address = addressType === B.SegwitAddresType_P2WSH ? new A.P2wshAddress(A._BitcoinAddressUtils_segwitScriptToSHA256(bitcoinPublicKey.toP2wshScript$1$compressed(true)), 0) : bitcoinPublicKey.toSegwitAddress$0();
          break;
        default:
          address = new A.P2trAddress(A._BitcoinAddressUtils_validateAddressProgram(bitcoinPublicKey.toTapRotHex$1$script(null), B.SegwitAddresType_P2TR), 1);
          break;
      }
      if (address.get$type() !== addressType)
        throw A.wrapException($.$get$WalletExceptionConst_invalidBitcoinAddressType());
      return address;
    },
    BlockchainAddressUtils_toBitcoinAddressFromType(addressType, bitcoinAddress, network) {
      var t1, address,
        bitcoinNetwork = network.coinParam.transacationNetwork;
      if (addressType.get$isP2sh()) {
        t1 = new A.P2shAddress(type$.P2shAddressType._as(addressType), $);
        t1.LegacyAddress$fromAddress$2$address$network(bitcoinAddress, bitcoinNetwork);
        return t1;
      }
      switch (addressType) {
        case B.P2pkhAddressType_P2PKH:
        case B.P2pkhAddressType_P2PKHWT:
          address = new A.P2pkhAddress(B.P2pkhAddressType_P2PKH, $);
          address.LegacyAddress$fromAddress$2$address$network(bitcoinAddress, bitcoinNetwork);
          break;
        case B.C_PubKeyAddressType:
          t1 = A.BytesUtils_fromHexString(bitcoinAddress);
          A.Bip32KeyData$();
          $.$get$Bip32Const_mainNetKeyNetVersions();
          t1 = A.IPublicKey_IPublicKey$fromBytes(t1, B.EllipticCurveTypes_secp256k1);
          t1.get$curve();
          t1 = new A.ECPublic(new A.Bip32PublicKey(t1)).toHex$0();
          address = new A.P2pkAddress($);
          if (!A.Secp256k1PublicKeyEcdsa_isValidBytes(A.BytesUtils_fromHexString(t1)))
            A.throwExpression(B.BitcoinBasePluginException_8Gl);
          address.__P2pkAddress_publicHex_F = t1;
          break;
        case B.SegwitAddresType_P2WPKH:
          address = new A.P2wpkhAddress($, 0);
          address.SegwitAddress$fromAddress$3$address$network$segwitVersion(bitcoinAddress, bitcoinNetwork, 0);
          break;
        case B.SegwitAddresType_P2TR:
          address = new A.P2trAddress($, 1);
          address.SegwitAddress$fromAddress$3$address$network$segwitVersion(bitcoinAddress, bitcoinNetwork, 1);
          break;
        case B.SegwitAddresType_P2WSH:
          address = new A.P2wshAddress($, 0);
          address.SegwitAddress$fromAddress$3$address$network$segwitVersion(bitcoinAddress, bitcoinNetwork, 0);
          break;
        default:
          throw A.wrapException(A.UnimplementedError$("invalid address types"));
      }
      return address;
    },
    CardanoUtils_extractRewardAddress(addr) {
      var t1;
      switch (addr.get$addressType()) {
        case B.ADAAddressType_0_Base:
          type$.ADABaseAddress._as(addr);
          t1 = addr.network;
          return new A.ADARewardAddress(new A.AdaShelleyStakingAddrEncoder().encodeCredential$2(A.AdaAddressUtils_toAdaStakeCredential(addr.stakeCredential), A.LinkedHashMap_LinkedHashMap$_literal(["net_tag", t1], type$.String, type$.dynamic)), t1);
        case B.ADAAddressType_14_Reward:
          return type$.ADARewardAddress._as(addr);
        default:
          return null;
      }
    },
    AdaAddressUtils_decodeAddres(address, addrType, network) {
      var t1 = type$.String,
        t2 = type$.dynamic,
        decodeAddr = new A.AdaGenericAddrDecoder().decode$2(address, A.LinkedHashMap_LinkedHashMap$_literal(["net_tag", network], t1, t2)),
        t3 = decodeAddr.type;
      if (t3.header !== addrType.header)
        throw A.wrapException(A.MessageException$("Incorrect address type. ", A.LinkedHashMap_LinkedHashMap$_literal(["Excepted", addrType.name, "type", t3], t1, t2)));
      return decodeAddr;
    },
    AdaAddressUtils_toCerdential(credential) {
      var t1, t2;
      if (credential.type === B.AdaStakeCredType_Key_0)
        return new A.StakeCredKey(A.AdaTransactionUtils_validateFixedLengthBytes(credential.hash, 28));
      t1 = credential.hash;
      t2 = t1.length;
      if (t2 !== 28)
        A.throwExpression(A.MessageException$("Invalid hash length.", A.LinkedHashMap_LinkedHashMap$_literal(["Excepted", 28, "length", t2], type$.String, type$.dynamic)));
      return new A.StakeCredScript(A.BytesUtils_toBytes(t1, true));
    },
    AdaAddressUtils_toAdaStakeCredential(credential) {
      if (credential.get$type() === B.StakeCredType_key_0)
        return A.AdaStakeCredential_AdaStakeCredential(credential.data, B.AdaStakeCredType_Key_0);
      return A.AdaStakeCredential_AdaStakeCredential(credential.data, B.AdaStakeCredType_Script_1);
    },
    AdaAddressUtils_publicKeyToHash(pubKeyBytes) {
      return A.QuickCrypto_blake2b224Hash(B.JSArray_methods.sublist$1(A.IPublicKey_IPublicKey$fromBytes(pubKeyBytes, B.EllipticCurveTypes_ed25519).get$compressed(), 1));
    },
    AdaTransactionUtils_validateFixedLengthBytes(bytes, $length) {
      var t1 = bytes.length;
      if (t1 !== $length)
        throw A.wrapException(A.MessageException$("Invalid hash length.", A.LinkedHashMap_LinkedHashMap$_literal(["Excepted", $length, "length", t1], type$.String, type$.dynamic)));
      return A.BytesUtils_toBytes(bytes, true);
    },
    current() {
      var exception, t1, path, lastIndex, uri = null;
      try {
        uri = A.Uri_base();
      } catch (exception) {
        if (type$.Exception._is(A.unwrapException(exception))) {
          t1 = $._current;
          if (t1 != null)
            return t1;
          throw exception;
        } else
          throw exception;
      }
      if (J.$eq$(uri, $._currentUriBase)) {
        t1 = $._current;
        t1.toString;
        return t1;
      }
      $._currentUriBase = uri;
      if ($.$get$Style_platform() === $.$get$Style_url())
        t1 = $._current = uri.resolve$1(".").toString$0(0);
      else {
        path = uri.toFilePath$0();
        lastIndex = path.length - 1;
        t1 = $._current = lastIndex === 0 ? path : B.JSString_methods.substring$2(path, 0, lastIndex);
      }
      return t1;
    },
    isAlphabetic(char) {
      var t1;
      if (!(char >= 65 && char <= 90))
        t1 = char >= 97 && char <= 122;
      else
        t1 = true;
      return t1;
    },
    driveLetterEnd(path, index) {
      var t2, t3, _null = null,
        t1 = path.length,
        index0 = index + 2;
      if (t1 < index0)
        return _null;
      if (!(index >= 0 && index < t1))
        return A.ioore(path, index);
      if (!A.isAlphabetic(path.charCodeAt(index)))
        return _null;
      t2 = index + 1;
      if (!(t2 < t1))
        return A.ioore(path, t2);
      if (path.charCodeAt(t2) !== 58) {
        t3 = index + 4;
        if (t1 < t3)
          return _null;
        if (B.JSString_methods.substring$2(path, t2, t3).toLowerCase() !== "%3a")
          return _null;
        index = index0;
      }
      t2 = index + 2;
      if (t1 === t2)
        return t2;
      if (!(t2 >= 0 && t2 < t1))
        return A.ioore(path, t2);
      if (path.charCodeAt(t2) !== 47)
        return _null;
      return index + 3;
    },
    isAllTheSame(iter) {
      var firstValue, t1, t2, value;
      if (iter.get$length(0) === 0)
        return true;
      firstValue = iter.get$first(0);
      for (t1 = A.SubListIterable$(iter, 1, null, iter.$ti._eval$1("ListIterable.E")), t2 = t1.$ti, t1 = new A.ListIterator(t1, t1.get$length(0), t2._eval$1("ListIterator<ListIterable.E>")), t2 = t2._eval$1("ListIterable.E"); t1.moveNext$0();) {
        value = t1.__internal$_current;
        if (!J.$eq$(value == null ? t2._as(value) : value, firstValue))
          return false;
      }
      return true;
    },
    replaceFirstNull(list, element, $E) {
      var index = B.JSArray_methods.indexOf$1(list, null);
      if (index < 0)
        throw A.wrapException(A.ArgumentError$(A.S(list) + " contains no null elements.", null));
      B.JSArray_methods.$indexSet(list, index, element);
    },
    replaceWithNull(list, element, $E) {
      var index = B.JSArray_methods.indexOf$1(list, element);
      if (index < 0)
        throw A.wrapException(A.ArgumentError$(A.S(list) + " contains no elements matching " + element.toString$0(0) + ".", null));
      B.JSArray_methods.$indexSet(list, index, null);
    },
    countCodeUnits(string, codeUnit) {
      var t1, t2, count, t3;
      for (t1 = new A.CodeUnits(string), t2 = type$.CodeUnits, t1 = new A.ListIterator(t1, t1.get$length(0), t2._eval$1("ListIterator<ListBase.E>")), t2 = t2._eval$1("ListBase.E"), count = 0; t1.moveNext$0();) {
        t3 = t1.__internal$_current;
        if ((t3 == null ? t2._as(t3) : t3) === codeUnit)
          ++count;
      }
      return count;
    },
    findLineStart(context, text, column) {
      var beginningOfLine, index, lineStart;
      if (text.length === 0)
        for (beginningOfLine = 0; true;) {
          index = B.JSString_methods.indexOf$2(context, "\n", beginningOfLine);
          if (index === -1)
            return context.length - beginningOfLine >= column ? beginningOfLine : null;
          if (index - beginningOfLine >= column)
            return beginningOfLine;
          beginningOfLine = index + 1;
        }
      index = B.JSString_methods.indexOf$1(context, text);
      for (; index !== -1;) {
        lineStart = index === 0 ? 0 : B.JSString_methods.lastIndexOf$2(context, "\n", index - 1) + 1;
        if (column === index - lineStart)
          return lineStart;
        index = B.JSString_methods.indexOf$2(context, text, index + 1);
      }
      return null;
    },
    ToWalletError_toWalletError(_this, request) {
      var t2, t3, t4, _null = null,
        t1 = _this.requestId;
      if (t1 == null)
        t1 = _null;
      t2 = _this.code;
      if (t2 == null)
        t2 = _null;
      t3 = _this.info;
      if (t3 == null)
        t3 = _null;
      t4 = _this.request;
      t4 = t4 != null ? A.StringUtils_toJson(t4, type$.nullable_Map_String_dynamic) : request;
      if (t2 == null)
        t2 = _null;
      t3 = t3 == null ? _null : A.jsify(t3);
      t4 = t4 == null ? _null : A.jsify(t4);
      if (t1 == null)
        t1 = _null;
      t1 = A.jsify(A.LinkedHashMap_LinkedHashMap$_literal(["message", _this.message, "code", t2, "info", t3, "request", t4, "requestId", t1, "stack", ""], type$.String, type$.nullable_Object));
      return t1 == null ? {} : t1;
    },
    EthereumJsParamsValidator__typdedDataToJson(data) {
      var mapResult, t1, exception;
      try {
        mapResult = null;
        if (typeof data == "string")
          mapResult = A.StringUtils_toJson(data, type$.Map_String_dynamic);
        else
          mapResult = A.LinkedHashMap_LinkedHashMap$from(type$.Map_dynamic_dynamic._as(data), type$.String, type$.dynamic);
        t1 = mapResult;
        return t1;
      } catch (exception) {
        throw A.wrapException(B.Web3ArgsException_soc);
      }
    }
  },
  B = {};
  var holders = [A, J, B];
  var $ = {};
  A.JS_CONST.prototype = {};
  J.Interceptor.prototype = {
    $eq(receiver, other) {
      return receiver === other;
    },
    get$hashCode(receiver) {
      return A.Primitives_objectHashCode(receiver);
    },
    toString$0(receiver) {
      return "Instance of '" + A.Primitives_objectTypeName(receiver) + "'";
    },
    noSuchMethod$1(receiver, invocation) {
      throw A.wrapException(A.NoSuchMethodError_NoSuchMethodError$withInvocation(receiver, type$.Invocation._as(invocation)));
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(A._instanceTypeFromConstructor(this));
    }
  };
  J.JSBool.prototype = {
    toString$0(receiver) {
      return String(receiver);
    },
    $or(receiver, other) {
      return other || receiver;
    },
    get$hashCode(receiver) {
      return receiver ? 519018 : 218159;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.bool);
    },
    $isTrustedGetRuntimeType: 1,
    $isbool: 1
  };
  J.JSNull.prototype = {
    $eq(receiver, other) {
      return null == other;
    },
    toString$0(receiver) {
      return "null";
    },
    get$hashCode(receiver) {
      return 0;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.Null);
    },
    $isTrustedGetRuntimeType: 1,
    $isNull: 1
  };
  J.JavaScriptObject.prototype = {$isJSObject: 1};
  J.LegacyJavaScriptObject.prototype = {
    get$hashCode(receiver) {
      return 0;
    },
    get$runtimeType(receiver) {
      return B.Type_JSObject_0ua;
    },
    toString$0(receiver) {
      return String(receiver);
    }
  };
  J.PlainJavaScriptObject.prototype = {};
  J.UnknownJavaScriptObject.prototype = {};
  J.JavaScriptFunction.prototype = {
    toString$0(receiver) {
      var dartClosure = receiver[$.$get$DART_CLOSURE_PROPERTY_NAME()];
      if (dartClosure == null)
        return this.super$LegacyJavaScriptObject$toString(receiver);
      return "JavaScript function for " + J.toString$0$(dartClosure);
    },
    $isFunction: 1
  };
  J.JavaScriptBigInt.prototype = {
    get$hashCode(receiver) {
      return 0;
    },
    toString$0(receiver) {
      return String(receiver);
    }
  };
  J.JavaScriptSymbol.prototype = {
    get$hashCode(receiver) {
      return 0;
    },
    toString$0(receiver) {
      return String(receiver);
    }
  };
  J.JSArray.prototype = {
    add$1(receiver, value) {
      A._arrayInstanceType(receiver)._precomputed1._as(value);
      if (!!receiver.fixed$length)
        A.throwExpression(A.UnsupportedError$("add"));
      receiver.push(value);
    },
    removeAt$1(receiver, index) {
      var t1;
      if (!!receiver.fixed$length)
        A.throwExpression(A.UnsupportedError$("removeAt"));
      t1 = receiver.length;
      if (index >= t1)
        throw A.wrapException(A.RangeError$value(index, null));
      return receiver.splice(index, 1)[0];
    },
    insert$2(receiver, index, value) {
      var t1;
      A._arrayInstanceType(receiver)._precomputed1._as(value);
      if (!!receiver.fixed$length)
        A.throwExpression(A.UnsupportedError$("insert"));
      t1 = receiver.length;
      if (index > t1)
        throw A.wrapException(A.RangeError$value(index, null));
      receiver.splice(index, 0, value);
    },
    insertAll$2(receiver, index, iterable) {
      var insertionLength, end;
      A._arrayInstanceType(receiver)._eval$1("Iterable<1>")._as(iterable);
      if (!!receiver.fixed$length)
        A.throwExpression(A.UnsupportedError$("insertAll"));
      A.RangeError_checkValueInInterval(index, 0, receiver.length, "index");
      if (!type$.EfficientLengthIterable_dynamic._is(iterable))
        iterable = J.toList$0$ax(iterable);
      insertionLength = J.get$length$asx(iterable);
      receiver.length = receiver.length + insertionLength;
      end = index + insertionLength;
      this.setRange$4(receiver, end, receiver.length, receiver, index);
      this.setRange$3(receiver, index, end, iterable);
    },
    setAll$2(receiver, index, iterable) {
      var t1, index0;
      A._arrayInstanceType(receiver)._eval$1("Iterable<1>")._as(iterable);
      if (!!receiver.immutable$list)
        A.throwExpression(A.UnsupportedError$("setAll"));
      A.RangeError_checkValueInInterval(index, 0, receiver.length, "index");
      for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0(); index = index0) {
        index0 = index + 1;
        this.$indexSet(receiver, index, t1.get$current());
      }
    },
    removeLast$0(receiver) {
      if (!!receiver.fixed$length)
        A.throwExpression(A.UnsupportedError$("removeLast"));
      if (receiver.length === 0)
        throw A.wrapException(A.diagnoseIndexError(receiver, -1));
      return receiver.pop();
    },
    _removeWhere$2(receiver, test, removeMatching) {
      var retained, end, i, element, t1;
      A._arrayInstanceType(receiver)._eval$1("bool(1)")._as(test);
      retained = [];
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        element = receiver[i];
        if (!A.boolConversionCheck(test.call$1(element)))
          retained.push(element);
        if (receiver.length !== end)
          throw A.wrapException(A.ConcurrentModificationError$(receiver));
      }
      t1 = retained.length;
      if (t1 === end)
        return;
      this.set$length(receiver, t1);
      for (i = 0; i < retained.length; ++i)
        receiver[i] = retained[i];
    },
    where$1(receiver, f) {
      var t1 = A._arrayInstanceType(receiver);
      return new A.WhereIterable(receiver, t1._eval$1("bool(1)")._as(f), t1._eval$1("WhereIterable<1>"));
    },
    addAll$1(receiver, collection) {
      var t1;
      A._arrayInstanceType(receiver)._eval$1("Iterable<1>")._as(collection);
      if (!!receiver.fixed$length)
        A.throwExpression(A.UnsupportedError$("addAll"));
      if (Array.isArray(collection)) {
        this._addAllFromArray$1(receiver, collection);
        return;
      }
      for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
        receiver.push(t1.get$current());
    },
    _addAllFromArray$1(receiver, array) {
      var len, i;
      type$.JSArray_dynamic._as(array);
      len = array.length;
      if (len === 0)
        return;
      if (receiver === array)
        throw A.wrapException(A.ConcurrentModificationError$(receiver));
      for (i = 0; i < len; ++i)
        receiver.push(array[i]);
    },
    clear$0(receiver) {
      if (!!receiver.fixed$length)
        A.throwExpression(A.UnsupportedError$("clear"));
      receiver.length = 0;
    },
    map$1$1(receiver, f, $T) {
      var t1 = A._arrayInstanceType(receiver);
      return new A.MappedListIterable(receiver, t1._bind$1($T)._eval$1("1(2)")._as(f), t1._eval$1("@<1>")._bind$1($T)._eval$1("MappedListIterable<1,2>"));
    },
    join$1(receiver, separator) {
      var i,
        list = A.List_List$filled(receiver.length, "", false, type$.String);
      for (i = 0; i < receiver.length; ++i)
        this.$indexSet(list, i, A.S(receiver[i]));
      return list.join(separator);
    },
    join$0(receiver) {
      return this.join$1(receiver, "");
    },
    take$1(receiver, n) {
      return A.SubListIterable$(receiver, 0, A.checkNotNullable(n, "count", type$.int), A._arrayInstanceType(receiver)._precomputed1);
    },
    skip$1(receiver, n) {
      return A.SubListIterable$(receiver, n, null, A._arrayInstanceType(receiver)._precomputed1);
    },
    fold$1$2(receiver, initialValue, combine, $T) {
      var $length, value, i;
      $T._as(initialValue);
      A._arrayInstanceType(receiver)._bind$1($T)._eval$1("1(1,2)")._as(combine);
      $length = receiver.length;
      for (value = initialValue, i = 0; i < $length; ++i) {
        value = combine.call$2(value, receiver[i]);
        if (receiver.length !== $length)
          throw A.wrapException(A.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    firstWhere$2$orElse(receiver, test, orElse) {
      var end, i, element,
        t1 = A._arrayInstanceType(receiver);
      t1._eval$1("bool(1)")._as(test);
      t1._eval$1("1()?")._as(orElse);
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        element = receiver[i];
        if (A.boolConversionCheck(test.call$1(element)))
          return element;
        if (receiver.length !== end)
          throw A.wrapException(A.ConcurrentModificationError$(receiver));
      }
      if (orElse != null)
        return orElse.call$0();
      throw A.wrapException(A.IterableElementError_noElement());
    },
    firstWhere$1(receiver, test) {
      return this.firstWhere$2$orElse(receiver, test, null);
    },
    elementAt$1(receiver, index) {
      if (!(index >= 0 && index < receiver.length))
        return A.ioore(receiver, index);
      return receiver[index];
    },
    sublist$2(receiver, start, end) {
      if (start < 0 || start > receiver.length)
        throw A.wrapException(A.RangeError$range(start, 0, receiver.length, "start", null));
      if (end == null)
        end = receiver.length;
      else if (end < start || end > receiver.length)
        throw A.wrapException(A.RangeError$range(end, start, receiver.length, "end", null));
      if (start === end)
        return A._setArrayType([], A._arrayInstanceType(receiver));
      return A._setArrayType(receiver.slice(start, end), A._arrayInstanceType(receiver));
    },
    sublist$1(receiver, start) {
      return this.sublist$2(receiver, start, null);
    },
    getRange$2(receiver, start, end) {
      A.RangeError_checkValidRange(start, end, receiver.length);
      return A.SubListIterable$(receiver, start, end, A._arrayInstanceType(receiver)._precomputed1);
    },
    get$first(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw A.wrapException(A.IterableElementError_noElement());
    },
    get$last(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw A.wrapException(A.IterableElementError_noElement());
    },
    removeRange$2(receiver, start, end) {
      if (!!receiver.fixed$length)
        A.throwExpression(A.UnsupportedError$("removeRange"));
      A.RangeError_checkValidRange(start, end, receiver.length);
      receiver.splice(start, end - start);
    },
    setRange$4(receiver, start, end, iterable, skipCount) {
      var $length, otherList, otherStart, t1, i;
      A._arrayInstanceType(receiver)._eval$1("Iterable<1>")._as(iterable);
      if (!!receiver.immutable$list)
        A.throwExpression(A.UnsupportedError$("setRange"));
      A.RangeError_checkValidRange(start, end, receiver.length);
      $length = end - start;
      if ($length === 0)
        return;
      A.RangeError_checkNotNegative(skipCount, "skipCount");
      if (type$.List_dynamic._is(iterable)) {
        otherList = iterable;
        otherStart = skipCount;
      } else {
        otherList = J.skip$1$ax(iterable, skipCount).toList$1$growable(0, false);
        otherStart = 0;
      }
      t1 = J.getInterceptor$asx(otherList);
      if (otherStart + $length > t1.get$length(otherList))
        throw A.wrapException(A.IterableElementError_tooFew());
      if (otherStart < start)
        for (i = $length - 1; i >= 0; --i)
          receiver[start + i] = t1.$index(otherList, otherStart + i);
      else
        for (i = 0; i < $length; ++i)
          receiver[start + i] = t1.$index(otherList, otherStart + i);
    },
    setRange$3(receiver, start, end, iterable) {
      return this.setRange$4(receiver, start, end, iterable, 0);
    },
    any$1(receiver, test) {
      var end, i;
      A._arrayInstanceType(receiver)._eval$1("bool(1)")._as(test);
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        if (A.boolConversionCheck(test.call$1(receiver[i])))
          return true;
        if (receiver.length !== end)
          throw A.wrapException(A.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    get$reversed(receiver) {
      return new A.ReversedListIterable(receiver, A._arrayInstanceType(receiver)._eval$1("ReversedListIterable<1>"));
    },
    sort$1(receiver, compare) {
      var len, a, b, undefineds, i,
        t1 = A._arrayInstanceType(receiver);
      t1._eval$1("int(1,1)?")._as(compare);
      if (!!receiver.immutable$list)
        A.throwExpression(A.UnsupportedError$("sort"));
      len = receiver.length;
      if (len < 2)
        return;
      if (compare == null)
        compare = J._interceptors_JSArray__compareAny$closure();
      if (len === 2) {
        a = receiver[0];
        b = receiver[1];
        t1 = compare.call$2(a, b);
        if (typeof t1 !== "number")
          return t1.$gt();
        if (t1 > 0) {
          receiver[0] = b;
          receiver[1] = a;
        }
        return;
      }
      if (t1._precomputed1._is(null)) {
        for (undefineds = 0, i = 0; i < receiver.length; ++i)
          if (receiver[i] === void 0) {
            receiver[i] = null;
            ++undefineds;
          }
      } else
        undefineds = 0;
      receiver.sort(A.convertDartClosureToJS(compare, 2));
      if (undefineds > 0)
        this._replaceSomeNullsWithUndefined$1(receiver, undefineds);
    },
    sort$0(receiver) {
      return this.sort$1(receiver, null);
    },
    _replaceSomeNullsWithUndefined$1(receiver, count) {
      var i0,
        i = receiver.length;
      for (; i0 = i - 1, i > 0; i = i0)
        if (receiver[i0] === null) {
          receiver[i0] = void 0;
          --count;
          if (count === 0)
            break;
        }
    },
    indexOf$1(receiver, element) {
      var i,
        $length = receiver.length;
      if (0 >= $length)
        return -1;
      for (i = 0; i < $length; ++i) {
        if (!(i < receiver.length))
          return A.ioore(receiver, i);
        if (J.$eq$(receiver[i], element))
          return i;
      }
      return -1;
    },
    contains$1(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], other))
          return true;
      return false;
    },
    get$isEmpty(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty(receiver) {
      return receiver.length !== 0;
    },
    toString$0(receiver) {
      return A.Iterable_iterableToFullString(receiver, "[", "]");
    },
    toList$1$growable(receiver, growable) {
      var t1 = A._setArrayType(receiver.slice(0), A._arrayInstanceType(receiver));
      return t1;
    },
    toList$0(receiver) {
      return this.toList$1$growable(receiver, true);
    },
    get$iterator(receiver) {
      return new J.ArrayIterator(receiver, receiver.length, A._arrayInstanceType(receiver)._eval$1("ArrayIterator<1>"));
    },
    get$hashCode(receiver) {
      return A.Primitives_objectHashCode(receiver);
    },
    get$length(receiver) {
      return receiver.length;
    },
    set$length(receiver, newLength) {
      if (!!receiver.fixed$length)
        A.throwExpression(A.UnsupportedError$("set length"));
      if (newLength < 0)
        throw A.wrapException(A.RangeError$range(newLength, 0, null, "newLength", null));
      if (newLength > receiver.length)
        A._arrayInstanceType(receiver)._precomputed1._as(null);
      receiver.length = newLength;
    },
    $index(receiver, index) {
      if (!(index >= 0 && index < receiver.length))
        throw A.wrapException(A.diagnoseIndexError(receiver, index));
      return receiver[index];
    },
    $indexSet(receiver, index, value) {
      A._arrayInstanceType(receiver)._precomputed1._as(value);
      if (!!receiver.immutable$list)
        A.throwExpression(A.UnsupportedError$("indexed set"));
      if (!(index >= 0 && index < receiver.length))
        throw A.wrapException(A.diagnoseIndexError(receiver, index));
      receiver[index] = value;
    },
    $add(receiver, other) {
      var t1 = A._arrayInstanceType(receiver);
      t1._eval$1("List<1>")._as(other);
      t1 = A.List_List$of(receiver, true, t1._precomputed1);
      this.addAll$1(t1, other);
      return t1;
    },
    indexWhere$1(receiver, test) {
      var i;
      A._arrayInstanceType(receiver)._eval$1("bool(1)")._as(test);
      if (0 >= receiver.length)
        return -1;
      for (i = 0; i < receiver.length; ++i)
        if (A.boolConversionCheck(test.call$1(receiver[i])))
          return i;
      return -1;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(A._arrayInstanceType(receiver));
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isList: 1
  };
  J.JSUnmodifiableArray.prototype = {};
  J.ArrayIterator.prototype = {
    get$current() {
      var t1 = this._current;
      return t1 == null ? this.$ti._precomputed1._as(t1) : t1;
    },
    moveNext$0() {
      var t2, _this = this,
        t1 = _this._iterable,
        $length = t1.length;
      if (_this._length !== $length) {
        t1 = A.throwConcurrentModificationError(t1);
        throw A.wrapException(t1);
      }
      t2 = _this._index;
      if (t2 >= $length) {
        _this.set$_current(null);
        return false;
      }
      _this.set$_current(t1[t2]);
      ++_this._index;
      return true;
    },
    set$_current(_current) {
      this._current = this.$ti._eval$1("1?")._as(_current);
    },
    $isIterator: 1
  };
  J.JSNumber.prototype = {
    compareTo$1(receiver, b) {
      var bIsNegative;
      A._asNum(b);
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    toInt$0(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw A.wrapException(A.UnsupportedError$("" + receiver + ".toInt()"));
    },
    ceil$0(receiver) {
      var truncated, d;
      if (receiver >= 0) {
        if (receiver <= 2147483647) {
          truncated = receiver | 0;
          return receiver === truncated ? truncated : truncated + 1;
        }
      } else if (receiver >= -2147483648)
        return receiver | 0;
      d = Math.ceil(receiver);
      if (isFinite(d))
        return d;
      throw A.wrapException(A.UnsupportedError$("" + receiver + ".ceil()"));
    },
    round$0(receiver) {
      if (receiver > 0) {
        if (receiver !== 1 / 0)
          return Math.round(receiver);
      } else if (receiver > -1 / 0)
        return 0 - Math.round(0 - receiver);
      throw A.wrapException(A.UnsupportedError$("" + receiver + ".round()"));
    },
    toRadixString$1(receiver, radix) {
      var result, t1, t2, match, exponent;
      if (radix < 2 || radix > 36)
        throw A.wrapException(A.RangeError$range(radix, 2, 36, "radix", null));
      result = receiver.toString(radix);
      t1 = result.length;
      t2 = t1 - 1;
      if (!(t2 >= 0))
        return A.ioore(result, t2);
      if (result.charCodeAt(t2) !== 41)
        return result;
      match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
      if (match == null)
        A.throwExpression(A.UnsupportedError$("Unexpected toString result: " + result));
      t1 = match.length;
      if (1 >= t1)
        return A.ioore(match, 1);
      result = match[1];
      if (3 >= t1)
        return A.ioore(match, 3);
      exponent = +match[3];
      t1 = match[2];
      if (t1 != null) {
        result += t1;
        exponent -= t1.length;
      }
      return result + B.JSString_methods.$mul("0", exponent);
    },
    toString$0(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode(receiver) {
      var absolute, floorLog2, factor, scaled,
        intValue = receiver | 0;
      if (receiver === intValue)
        return intValue & 536870911;
      absolute = Math.abs(receiver);
      floorLog2 = Math.log(absolute) / 0.6931471805599453 | 0;
      factor = Math.pow(2, floorLog2);
      scaled = absolute < 1 ? absolute / factor : factor / absolute;
      return ((scaled * 9007199254740992 | 0) + (scaled * 3542243181176521 | 0)) * 599197 + floorLog2 * 1259 & 536870911;
    },
    $add(receiver, other) {
      return receiver + other;
    },
    $mod(receiver, other) {
      var result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      return result + other;
    },
    $tdiv(receiver, other) {
      if ((receiver | 0) === receiver)
        if (other >= 1 || other < -1)
          return receiver / other | 0;
      return this._tdivSlow$1(receiver, other);
    },
    _tdivFast$1(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this._tdivSlow$1(receiver, other);
    },
    _tdivSlow$1(receiver, other) {
      var quotient = receiver / other;
      if (quotient >= -2147483648 && quotient <= 2147483647)
        return quotient | 0;
      if (quotient > 0) {
        if (quotient !== 1 / 0)
          return Math.floor(quotient);
      } else if (quotient > -1 / 0)
        return Math.ceil(quotient);
      throw A.wrapException(A.UnsupportedError$("Result of truncating division is " + A.S(quotient) + ": " + A.S(receiver) + " ~/ " + other));
    },
    $shl(receiver, other) {
      if (other < 0)
        throw A.wrapException(A.argumentErrorValue(other));
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    _shlPositive$1(receiver, other) {
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    _shrOtherPositive$1(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = this._shrBothPositive$1(receiver, other);
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrReceiverPositive$1(receiver, other) {
      if (0 > other)
        throw A.wrapException(A.argumentErrorValue(other));
      return this._shrBothPositive$1(receiver, other);
    },
    _shrBothPositive$1(receiver, other) {
      return other > 31 ? 0 : receiver >>> other;
    },
    $gt(receiver, other) {
      return receiver > other;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.num);
    },
    $isComparable: 1,
    $isdouble: 1,
    $isnum: 1
  };
  J.JSInt.prototype = {
    get$bitLength(receiver) {
      var wordBits,
        t1 = receiver < 0 ? -receiver - 1 : receiver,
        nonneg = t1;
      for (wordBits = 32; nonneg >= 4294967296;) {
        nonneg = this._tdivFast$1(nonneg, 4294967296);
        wordBits += 32;
      }
      return wordBits - Math.clz32(nonneg);
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.int);
    },
    $isTrustedGetRuntimeType: 1,
    $isint: 1
  };
  J.JSNumNotInt.prototype = {
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.double);
    },
    $isTrustedGetRuntimeType: 1
  };
  J.JSString.prototype = {
    allMatches$2(receiver, string, start) {
      var t1 = string.length;
      if (start > t1)
        throw A.wrapException(A.RangeError$range(start, 0, t1, null, null));
      return new A._StringAllMatchesIterable(string, receiver, start);
    },
    allMatches$1(receiver, string) {
      return this.allMatches$2(receiver, string, 0);
    },
    matchAsPrefix$2(receiver, string, start) {
      var t1, t2, i, t3, _null = null;
      if (start < 0 || start > string.length)
        throw A.wrapException(A.RangeError$range(start, 0, string.length, _null, _null));
      t1 = receiver.length;
      t2 = string.length;
      if (start + t1 > t2)
        return _null;
      for (i = 0; i < t1; ++i) {
        t3 = start + i;
        if (!(t3 >= 0 && t3 < t2))
          return A.ioore(string, t3);
        if (string.charCodeAt(t3) !== receiver.charCodeAt(i))
          return _null;
      }
      return new A.StringMatch(start, receiver);
    },
    $add(receiver, other) {
      return receiver + other;
    },
    endsWith$1(receiver, other) {
      var otherLength = other.length,
        t1 = receiver.length;
      if (otherLength > t1)
        return false;
      return other === this.substring$1(receiver, t1 - otherLength);
    },
    split$1(receiver, pattern) {
      if (typeof pattern == "string")
        return A._setArrayType(receiver.split(pattern), type$.JSArray_String);
      else if (pattern instanceof A.JSSyntaxRegExp && pattern.get$_nativeAnchoredVersion().exec("").length - 2 === 0)
        return A._setArrayType(receiver.split(pattern._nativeRegExp), type$.JSArray_String);
      else
        return this._defaultSplit$1(receiver, pattern);
    },
    replaceRange$3(receiver, start, end, replacement) {
      var e = A.RangeError_checkValidRange(start, end, receiver.length);
      return A.stringReplaceRangeUnchecked(receiver, start, e, replacement);
    },
    _defaultSplit$1(receiver, pattern) {
      var t1, start, $length, match, matchStart, matchEnd,
        result = A._setArrayType([], type$.JSArray_String);
      for (t1 = J.allMatches$1$s(pattern, receiver), t1 = t1.get$iterator(t1), start = 0, $length = 1; t1.moveNext$0();) {
        match = t1.get$current();
        matchStart = match.get$start();
        matchEnd = match.get$end();
        $length = matchEnd - matchStart;
        if ($length === 0 && start === matchStart)
          continue;
        B.JSArray_methods.add$1(result, this.substring$2(receiver, start, matchStart));
        start = matchEnd;
      }
      if (start < receiver.length || $length > 0)
        B.JSArray_methods.add$1(result, this.substring$1(receiver, start));
      return result;
    },
    startsWith$2(receiver, pattern, index) {
      var endIndex;
      if (index < 0 || index > receiver.length)
        throw A.wrapException(A.RangeError$range(index, 0, receiver.length, null, null));
      endIndex = index + pattern.length;
      if (endIndex > receiver.length)
        return false;
      return pattern === receiver.substring(index, endIndex);
    },
    startsWith$1(receiver, pattern) {
      return this.startsWith$2(receiver, pattern, 0);
    },
    substring$2(receiver, start, end) {
      return receiver.substring(start, A.RangeError_checkValidRange(start, end, receiver.length));
    },
    substring$1(receiver, start) {
      return this.substring$2(receiver, start, null);
    },
    trim$0(receiver) {
      var startIndex, t1, endIndex0,
        result = receiver.trim(),
        endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (0 >= endIndex)
        return A.ioore(result, 0);
      if (result.charCodeAt(0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      if (!(t1 >= 0))
        return A.ioore(result, t1);
      endIndex0 = result.charCodeAt(t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    $mul(receiver, times) {
      var s, result;
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw A.wrapException(B.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    padLeft$2(receiver, width, padding) {
      var delta = width - receiver.length;
      if (delta <= 0)
        return receiver;
      return this.$mul(padding, delta) + receiver;
    },
    padRight$1(receiver, width) {
      var delta = width - receiver.length;
      if (delta <= 0)
        return receiver;
      return receiver + this.$mul(" ", delta);
    },
    indexOf$2(receiver, pattern, start) {
      var t1;
      if (start < 0 || start > receiver.length)
        throw A.wrapException(A.RangeError$range(start, 0, receiver.length, null, null));
      t1 = receiver.indexOf(pattern, start);
      return t1;
    },
    indexOf$1(receiver, pattern) {
      return this.indexOf$2(receiver, pattern, 0);
    },
    lastIndexOf$2(receiver, pattern, start) {
      var t1, t2;
      if (start == null)
        start = receiver.length;
      else if (start < 0 || start > receiver.length)
        throw A.wrapException(A.RangeError$range(start, 0, receiver.length, null, null));
      t1 = pattern.length;
      t2 = receiver.length;
      if (start + t1 > t2)
        start = t2 - t1;
      return receiver.lastIndexOf(pattern, start);
    },
    lastIndexOf$1(receiver, pattern) {
      return this.lastIndexOf$2(receiver, pattern, null);
    },
    contains$1(receiver, other) {
      return A.stringContainsUnchecked(receiver, other, 0);
    },
    compareTo$1(receiver, other) {
      var t1;
      A._asString(other);
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0(receiver) {
      return receiver;
    },
    get$hashCode(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = hash + receiver.charCodeAt(i) & 536870911;
        hash = hash + ((hash & 524287) << 10) & 536870911;
        hash ^= hash >> 6;
      }
      hash = hash + ((hash & 67108863) << 3) & 536870911;
      hash ^= hash >> 11;
      return hash + ((hash & 16383) << 15) & 536870911;
    },
    get$runtimeType(receiver) {
      return A.createRuntimeType(type$.String);
    },
    get$length(receiver) {
      return receiver.length;
    },
    $index(receiver, index) {
      if (!(index >= 0 && index < receiver.length))
        throw A.wrapException(A.diagnoseIndexError(receiver, index));
      return receiver[index];
    },
    $isTrustedGetRuntimeType: 1,
    $isComparable: 1,
    $isPattern: 1,
    $isString: 1
  };
  A.CastStream.prototype = {
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      var t2,
        t1 = this.$ti;
      t1._eval$1("~(2)?")._as(onData);
      t2 = this._source.listen$3$cancelOnError$onDone(null, cancelOnError, type$.nullable_void_Function._as(onDone));
      t1 = new A.CastStreamSubscription(t2, $.Zone__current, t1._eval$1("@<1>")._bind$1(t1._rest[1])._eval$1("CastStreamSubscription<1,2>"));
      t2.onData$1(t1.get$__internal$_onData());
      t1.onData$1(onData);
      t1.onError$1(onError);
      return t1;
    },
    listen$2$onDone(onData, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
    },
    listen$3$cancelOnError$onDone(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    }
  };
  A.CastStreamSubscription.prototype = {
    cancel$0() {
      return this._source.cancel$0();
    },
    onData$1(handleData) {
      var t1 = this.$ti;
      t1._eval$1("~(2)?")._as(handleData);
      this.set$_handleData(handleData == null ? null : type$.$env_1_1_dynamic._bind$1(t1._rest[1])._eval$1("1(2)")._as(handleData));
    },
    onError$1(handleError) {
      var _this = this;
      _this._source.onError$1(handleError);
      if (handleError == null)
        _this._handleError = null;
      else if (type$.void_Function_Object_StackTrace._is(handleError))
        _this._handleError = _this.__internal$_zone.registerBinaryCallback$3$1(handleError, type$.dynamic, type$.Object, type$.StackTrace);
      else if (type$.void_Function_Object._is(handleError))
        _this._handleError = type$.dynamic_Function_Object._as(handleError);
      else
        throw A.wrapException(A.ArgumentError$(string$.handle, null));
    },
    __internal$_onData$1(data) {
      var targetData, error, stack, handleError, t2, exception, _this = this,
        t1 = _this.$ti;
      t1._precomputed1._as(data);
      t2 = _this._handleData;
      if (t2 == null)
        return;
      targetData = null;
      try {
        targetData = t1._rest[1]._as(data);
      } catch (exception) {
        error = A.unwrapException(exception);
        stack = A.getTraceFromException(exception);
        handleError = _this._handleError;
        if (handleError == null)
          A._rootHandleError(type$.Object._as(error), type$.StackTrace._as(stack));
        else {
          t1 = type$.Object;
          t2 = _this.__internal$_zone;
          if (type$.void_Function_Object_StackTrace._is(handleError))
            t2.runBinaryGuarded$2$3(handleError, error, stack, t1, type$.StackTrace);
          else
            t2.runUnaryGuarded$1$2(type$.void_Function_Object._as(handleError), error, t1);
        }
        return;
      }
      _this.__internal$_zone.runUnaryGuarded$1$2(t2, targetData, t1._rest[1]);
    },
    set$_handleData(_handleData) {
      this._handleData = this.$ti._eval$1("~(2)?")._as(_handleData);
    },
    $isStreamSubscription: 1
  };
  A._CastIterableBase.prototype = {
    get$iterator(_) {
      var t1 = A._instanceType(this);
      return new A.CastIterator(J.get$iterator$ax(this.get$_source()), t1._eval$1("@<1>")._bind$1(t1._rest[1])._eval$1("CastIterator<1,2>"));
    },
    get$length(_) {
      return J.get$length$asx(this.get$_source());
    },
    get$isEmpty(_) {
      return J.get$isEmpty$asx(this.get$_source());
    },
    get$isNotEmpty(_) {
      return J.get$isNotEmpty$asx(this.get$_source());
    },
    skip$1(_, count) {
      var t1 = A._instanceType(this);
      return A.CastIterable_CastIterable(J.skip$1$ax(this.get$_source(), count), t1._precomputed1, t1._rest[1]);
    },
    take$1(_, count) {
      var t1 = A._instanceType(this);
      return A.CastIterable_CastIterable(J.take$1$ax(this.get$_source(), count), t1._precomputed1, t1._rest[1]);
    },
    elementAt$1(_, index) {
      return A._instanceType(this)._rest[1]._as(J.elementAt$1$ax(this.get$_source(), index));
    },
    get$last(_) {
      return A._instanceType(this)._rest[1]._as(J.get$last$ax(this.get$_source()));
    },
    contains$1(_, other) {
      return J.contains$1$asx(this.get$_source(), other);
    },
    toString$0(_) {
      return J.toString$0$(this.get$_source());
    }
  };
  A.CastIterator.prototype = {
    moveNext$0() {
      return this._source.moveNext$0();
    },
    get$current() {
      return this.$ti._rest[1]._as(this._source.get$current());
    },
    $isIterator: 1
  };
  A.CastIterable.prototype = {
    get$_source() {
      return this._source;
    }
  };
  A._EfficientLengthCastIterable.prototype = {$isEfficientLengthIterable: 1};
  A._CastListBase.prototype = {
    $index(_, index) {
      return this.$ti._rest[1]._as(J.$index$asx(this._source, index));
    },
    $indexSet(_, index, value) {
      var t1 = this.$ti;
      J.$indexSet$ax(this._source, index, t1._precomputed1._as(t1._rest[1]._as(value)));
    },
    set$length(_, $length) {
      J.set$length$asx(this._source, $length);
    },
    add$1(_, value) {
      var t1 = this.$ti;
      J.add$1$ax(this._source, t1._precomputed1._as(t1._rest[1]._as(value)));
    },
    sort$1(_, compare) {
      var t1;
      this.$ti._eval$1("int(2,2)?")._as(compare);
      t1 = compare == null ? null : new A._CastListBase_sort_closure(this, compare);
      J.sort$1$ax(this._source, t1);
    },
    getRange$2(_, start, end) {
      var t1 = this.$ti;
      return A.CastIterable_CastIterable(J.getRange$2$ax(this._source, start, end), t1._precomputed1, t1._rest[1]);
    },
    $isEfficientLengthIterable: 1,
    $isList: 1
  };
  A._CastListBase_sort_closure.prototype = {
    call$2(v1, v2) {
      var t1 = this.$this.$ti,
        t2 = t1._precomputed1;
      t2._as(v1);
      t2._as(v2);
      t1 = t1._rest[1];
      return this.compare.call$2(t1._as(v1), t1._as(v2));
    },
    $signature() {
      return this.$this.$ti._eval$1("int(1,1)");
    }
  };
  A.CastList.prototype = {
    get$_source() {
      return this._source;
    }
  };
  A.CastMap.prototype = {
    cast$2$0(_, RK, RV) {
      var t1 = this.$ti;
      return new A.CastMap(this._source, t1._eval$1("@<1>")._bind$1(t1._rest[1])._bind$1(RK)._bind$1(RV)._eval$1("CastMap<1,2,3,4>"));
    },
    containsKey$1(key) {
      return this._source.containsKey$1(key);
    },
    $index(_, key) {
      return this.$ti._eval$1("4?")._as(this._source.$index(0, key));
    },
    $indexSet(_, key, value) {
      var t1 = this.$ti;
      t1._rest[2]._as(key);
      t1._rest[3]._as(value);
      this._source.$indexSet(0, t1._precomputed1._as(key), t1._rest[1]._as(value));
    },
    forEach$1(_, f) {
      this._source.forEach$1(0, new A.CastMap_forEach_closure(this, this.$ti._eval$1("~(3,4)")._as(f)));
    },
    get$keys() {
      var t1 = this.$ti;
      return A.CastIterable_CastIterable(this._source.get$keys(), t1._precomputed1, t1._rest[2]);
    },
    get$length(_) {
      var t1 = this._source;
      return t1.get$length(t1);
    },
    get$isEmpty(_) {
      var t1 = this._source;
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty(_) {
      var t1 = this._source;
      return t1.get$isNotEmpty(t1);
    },
    get$entries() {
      return this._source.get$entries().map$1$1(0, new A.CastMap_entries_closure(this), this.$ti._eval$1("MapEntry<3,4>"));
    }
  };
  A.CastMap_forEach_closure.prototype = {
    call$2(key, value) {
      var t1 = this.$this.$ti;
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      this.f.call$2(t1._rest[2]._as(key), t1._rest[3]._as(value));
    },
    $signature() {
      return this.$this.$ti._eval$1("~(1,2)");
    }
  };
  A.CastMap_entries_closure.prototype = {
    call$1(e) {
      var t2,
        t1 = this.$this.$ti;
      t1._eval$1("MapEntry<1,2>")._as(e);
      t2 = t1._rest[3];
      return new A.MapEntry(t1._rest[2]._as(e.key), t2._as(e.value), t1._eval$1("@<3>")._bind$1(t2)._eval$1("MapEntry<1,2>"));
    },
    $signature() {
      return this.$this.$ti._eval$1("MapEntry<3,4>(MapEntry<1,2>)");
    }
  };
  A.LateError.prototype = {
    toString$0(_) {
      return "LateInitializationError: " + this.__internal$_message;
    }
  };
  A.CodeUnits.prototype = {
    get$length(_) {
      return this.__internal$_string.length;
    },
    $index(_, i) {
      var t1 = this.__internal$_string;
      if (!(i >= 0 && i < t1.length))
        return A.ioore(t1, i);
      return t1.charCodeAt(i);
    }
  };
  A.nullFuture_closure.prototype = {
    call$0() {
      return A.Future_Future$value(null, type$.Null);
    },
    $signature: 18
  };
  A.SentinelValue.prototype = {};
  A.EfficientLengthIterable.prototype = {};
  A.ListIterable.prototype = {
    get$iterator(_) {
      var _this = this;
      return new A.ListIterator(_this, _this.get$length(_this), A._instanceType(_this)._eval$1("ListIterator<ListIterable.E>"));
    },
    get$isEmpty(_) {
      return this.get$length(this) === 0;
    },
    get$first(_) {
      if (this.get$length(this) === 0)
        throw A.wrapException(A.IterableElementError_noElement());
      return this.elementAt$1(0, 0);
    },
    get$last(_) {
      var _this = this;
      if (_this.get$length(_this) === 0)
        throw A.wrapException(A.IterableElementError_noElement());
      return _this.elementAt$1(0, _this.get$length(_this) - 1);
    },
    contains$1(_, element) {
      var i, _this = this,
        $length = _this.get$length(_this);
      for (i = 0; i < $length; ++i) {
        if (J.$eq$(_this.elementAt$1(0, i), element))
          return true;
        if ($length !== _this.get$length(_this))
          throw A.wrapException(A.ConcurrentModificationError$(_this));
      }
      return false;
    },
    join$1(_, separator) {
      var first, t1, i, _this = this,
        $length = _this.get$length(_this);
      if (separator.length !== 0) {
        if ($length === 0)
          return "";
        first = A.S(_this.elementAt$1(0, 0));
        if ($length !== _this.get$length(_this))
          throw A.wrapException(A.ConcurrentModificationError$(_this));
        for (t1 = first, i = 1; i < $length; ++i) {
          t1 = t1 + separator + A.S(_this.elementAt$1(0, i));
          if ($length !== _this.get$length(_this))
            throw A.wrapException(A.ConcurrentModificationError$(_this));
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      } else {
        for (i = 0, t1 = ""; i < $length; ++i) {
          t1 += A.S(_this.elementAt$1(0, i));
          if ($length !== _this.get$length(_this))
            throw A.wrapException(A.ConcurrentModificationError$(_this));
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
    },
    join$0(_) {
      return this.join$1(0, "");
    },
    where$1(_, test) {
      return this.super$Iterable$where(0, A._instanceType(this)._eval$1("bool(ListIterable.E)")._as(test));
    },
    map$1$1(_, toElement, $T) {
      var t1 = A._instanceType(this);
      return new A.MappedListIterable(this, t1._bind$1($T)._eval$1("1(ListIterable.E)")._as(toElement), t1._eval$1("@<ListIterable.E>")._bind$1($T)._eval$1("MappedListIterable<1,2>"));
    },
    reduce$1(_, combine) {
      var $length, value, i, _this = this;
      A._instanceType(_this)._eval$1("ListIterable.E(ListIterable.E,ListIterable.E)")._as(combine);
      $length = _this.get$length(_this);
      if ($length === 0)
        throw A.wrapException(A.IterableElementError_noElement());
      value = _this.elementAt$1(0, 0);
      for (i = 1; i < $length; ++i) {
        value = combine.call$2(value, _this.elementAt$1(0, i));
        if ($length !== _this.get$length(_this))
          throw A.wrapException(A.ConcurrentModificationError$(_this));
      }
      return value;
    },
    skip$1(_, count) {
      return A.SubListIterable$(this, count, null, A._instanceType(this)._eval$1("ListIterable.E"));
    },
    take$1(_, count) {
      return A.SubListIterable$(this, 0, A.checkNotNullable(count, "count", type$.int), A._instanceType(this)._eval$1("ListIterable.E"));
    },
    toList$1$growable(_, growable) {
      return A.List_List$of(this, true, A._instanceType(this)._eval$1("ListIterable.E"));
    },
    toList$0(_) {
      return this.toList$1$growable(0, true);
    }
  };
  A.SubListIterable.prototype = {
    SubListIterable$3(_iterable, _start, _endOrLength, $E) {
      var endOrLength,
        t1 = this._start;
      A.RangeError_checkNotNegative(t1, "start");
      endOrLength = this._endOrLength;
      if (endOrLength != null) {
        A.RangeError_checkNotNegative(endOrLength, "end");
        if (t1 > endOrLength)
          throw A.wrapException(A.RangeError$range(t1, 0, endOrLength, "start", null));
      }
    },
    get$_endIndex() {
      var $length = J.get$length$asx(this.__internal$_iterable),
        endOrLength = this._endOrLength;
      if (endOrLength == null || endOrLength > $length)
        return $length;
      return endOrLength;
    },
    get$_startIndex() {
      var $length = J.get$length$asx(this.__internal$_iterable),
        t1 = this._start;
      if (t1 > $length)
        return $length;
      return t1;
    },
    get$length(_) {
      var endOrLength,
        $length = J.get$length$asx(this.__internal$_iterable),
        t1 = this._start;
      if (t1 >= $length)
        return 0;
      endOrLength = this._endOrLength;
      if (endOrLength == null || endOrLength >= $length)
        return $length - t1;
      if (typeof endOrLength !== "number")
        return endOrLength.$sub();
      return endOrLength - t1;
    },
    elementAt$1(_, index) {
      var _this = this,
        realIndex = _this.get$_startIndex() + index;
      if (index < 0 || realIndex >= _this.get$_endIndex())
        throw A.wrapException(A.IndexError$withLength(index, _this.get$length(0), _this, null, "index"));
      return J.elementAt$1$ax(_this.__internal$_iterable, realIndex);
    },
    skip$1(_, count) {
      var newStart, endOrLength, _this = this;
      A.RangeError_checkNotNegative(count, "count");
      newStart = _this._start + count;
      endOrLength = _this._endOrLength;
      if (endOrLength != null && newStart >= endOrLength)
        return new A.EmptyIterable(_this.$ti._eval$1("EmptyIterable<1>"));
      return A.SubListIterable$(_this.__internal$_iterable, newStart, endOrLength, _this.$ti._precomputed1);
    },
    take$1(_, count) {
      var endOrLength, t1, newEnd, _this = this;
      A.RangeError_checkNotNegative(count, "count");
      endOrLength = _this._endOrLength;
      t1 = _this._start;
      if (endOrLength == null)
        return A.SubListIterable$(_this.__internal$_iterable, t1, B.JSInt_methods.$add(t1, count), _this.$ti._precomputed1);
      else {
        newEnd = B.JSInt_methods.$add(t1, count);
        if (endOrLength < newEnd)
          return _this;
        return A.SubListIterable$(_this.__internal$_iterable, t1, newEnd, _this.$ti._precomputed1);
      }
    },
    toList$1$growable(_, growable) {
      var $length, result, i, _this = this,
        start = _this._start,
        t1 = _this.__internal$_iterable,
        t2 = J.getInterceptor$asx(t1),
        end = t2.get$length(t1),
        endOrLength = _this._endOrLength;
      if (endOrLength != null && endOrLength < end)
        end = endOrLength;
      $length = end - start;
      if ($length <= 0) {
        t1 = J.JSArray_JSArray$fixed(0, _this.$ti._precomputed1);
        return t1;
      }
      result = A.List_List$filled($length, t2.elementAt$1(t1, start), false, _this.$ti._precomputed1);
      for (i = 1; i < $length; ++i) {
        B.JSArray_methods.$indexSet(result, i, t2.elementAt$1(t1, start + i));
        if (t2.get$length(t1) < end)
          throw A.wrapException(A.ConcurrentModificationError$(_this));
      }
      return result;
    }
  };
  A.ListIterator.prototype = {
    get$current() {
      var t1 = this.__internal$_current;
      return t1 == null ? this.$ti._precomputed1._as(t1) : t1;
    },
    moveNext$0() {
      var t3, _this = this,
        t1 = _this.__internal$_iterable,
        t2 = J.getInterceptor$asx(t1),
        $length = t2.get$length(t1);
      if (_this.__internal$_length !== $length)
        throw A.wrapException(A.ConcurrentModificationError$(t1));
      t3 = _this.__internal$_index;
      if (t3 >= $length) {
        _this.set$__internal$_current(null);
        return false;
      }
      _this.set$__internal$_current(t2.elementAt$1(t1, t3));
      ++_this.__internal$_index;
      return true;
    },
    set$__internal$_current(_current) {
      this.__internal$_current = this.$ti._eval$1("1?")._as(_current);
    },
    $isIterator: 1
  };
  A.MappedIterable.prototype = {
    get$iterator(_) {
      var t1 = A._instanceType(this);
      return new A.MappedIterator(J.get$iterator$ax(this.__internal$_iterable), this._f, t1._eval$1("@<1>")._bind$1(t1._rest[1])._eval$1("MappedIterator<1,2>"));
    },
    get$length(_) {
      return J.get$length$asx(this.__internal$_iterable);
    },
    get$isEmpty(_) {
      return J.get$isEmpty$asx(this.__internal$_iterable);
    },
    get$last(_) {
      return this._f.call$1(J.get$last$ax(this.__internal$_iterable));
    },
    elementAt$1(_, index) {
      return this._f.call$1(J.elementAt$1$ax(this.__internal$_iterable, index));
    }
  };
  A.EfficientLengthMappedIterable.prototype = {$isEfficientLengthIterable: 1};
  A.MappedIterator.prototype = {
    moveNext$0() {
      var _this = this,
        t1 = _this._iterator;
      if (t1.moveNext$0()) {
        _this.set$__internal$_current(_this._f.call$1(t1.get$current()));
        return true;
      }
      _this.set$__internal$_current(null);
      return false;
    },
    get$current() {
      var t1 = this.__internal$_current;
      return t1 == null ? this.$ti._rest[1]._as(t1) : t1;
    },
    set$__internal$_current(_current) {
      this.__internal$_current = this.$ti._eval$1("2?")._as(_current);
    },
    $isIterator: 1
  };
  A.MappedListIterable.prototype = {
    get$length(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1(_, index) {
      return this._f.call$1(J.elementAt$1$ax(this._source, index));
    }
  };
  A.WhereIterable.prototype = {
    get$iterator(_) {
      return new A.WhereIterator(J.get$iterator$ax(this.__internal$_iterable), this._f, this.$ti._eval$1("WhereIterator<1>"));
    },
    map$1$1(_, toElement, $T) {
      var t1 = this.$ti;
      return new A.MappedIterable(this, t1._bind$1($T)._eval$1("1(2)")._as(toElement), t1._eval$1("@<1>")._bind$1($T)._eval$1("MappedIterable<1,2>"));
    }
  };
  A.WhereIterator.prototype = {
    moveNext$0() {
      var t1, t2;
      for (t1 = this._iterator, t2 = this._f; t1.moveNext$0();)
        if (A.boolConversionCheck(t2.call$1(t1.get$current())))
          return true;
      return false;
    },
    get$current() {
      return this._iterator.get$current();
    },
    $isIterator: 1
  };
  A.ExpandIterable.prototype = {
    get$iterator(_) {
      var t1 = this.$ti;
      return new A.ExpandIterator(J.get$iterator$ax(this.__internal$_iterable), this._f, B.C_EmptyIterator, t1._eval$1("@<1>")._bind$1(t1._rest[1])._eval$1("ExpandIterator<1,2>"));
    }
  };
  A.ExpandIterator.prototype = {
    get$current() {
      var t1 = this.__internal$_current;
      return t1 == null ? this.$ti._rest[1]._as(t1) : t1;
    },
    moveNext$0() {
      var t1, t2, _this = this;
      if (_this._currentExpansion == null)
        return false;
      for (t1 = _this._iterator, t2 = _this._f; !_this._currentExpansion.moveNext$0();) {
        _this.set$__internal$_current(null);
        if (t1.moveNext$0()) {
          _this.set$_currentExpansion(null);
          _this.set$_currentExpansion(J.get$iterator$ax(t2.call$1(t1.get$current())));
        } else
          return false;
      }
      _this.set$__internal$_current(_this._currentExpansion.get$current());
      return true;
    },
    set$_currentExpansion(_currentExpansion) {
      this._currentExpansion = this.$ti._eval$1("Iterator<2>?")._as(_currentExpansion);
    },
    set$__internal$_current(_current) {
      this.__internal$_current = this.$ti._eval$1("2?")._as(_current);
    },
    $isIterator: 1
  };
  A.TakeIterable.prototype = {
    get$iterator(_) {
      return new A.TakeIterator(J.get$iterator$ax(this.__internal$_iterable), this._takeCount, A._instanceType(this)._eval$1("TakeIterator<1>"));
    }
  };
  A.EfficientLengthTakeIterable.prototype = {
    get$length(_) {
      var iterableLength = J.get$length$asx(this.__internal$_iterable),
        t1 = this._takeCount;
      if (B.JSInt_methods.$gt(iterableLength, t1))
        return t1;
      return iterableLength;
    },
    $isEfficientLengthIterable: 1
  };
  A.TakeIterator.prototype = {
    moveNext$0() {
      if (--this._remaining >= 0)
        return this._iterator.moveNext$0();
      this._remaining = -1;
      return false;
    },
    get$current() {
      if (this._remaining < 0) {
        this.$ti._precomputed1._as(null);
        return null;
      }
      return this._iterator.get$current();
    },
    $isIterator: 1
  };
  A.SkipIterable.prototype = {
    skip$1(_, count) {
      A.ArgumentError_checkNotNull(count, "count", type$.int);
      A.RangeError_checkNotNegative(count, "count");
      return new A.SkipIterable(this.__internal$_iterable, this._skipCount + count, A._instanceType(this)._eval$1("SkipIterable<1>"));
    },
    get$iterator(_) {
      return new A.SkipIterator(J.get$iterator$ax(this.__internal$_iterable), this._skipCount, A._instanceType(this)._eval$1("SkipIterator<1>"));
    }
  };
  A.EfficientLengthSkipIterable.prototype = {
    get$length(_) {
      var $length = J.get$length$asx(this.__internal$_iterable) - this._skipCount;
      if ($length >= 0)
        return $length;
      return 0;
    },
    skip$1(_, count) {
      A.ArgumentError_checkNotNull(count, "count", type$.int);
      A.RangeError_checkNotNegative(count, "count");
      return new A.EfficientLengthSkipIterable(this.__internal$_iterable, this._skipCount + count, this.$ti);
    },
    $isEfficientLengthIterable: 1
  };
  A.SkipIterator.prototype = {
    moveNext$0() {
      var t1, i;
      for (t1 = this._iterator, i = 0; i < this._skipCount; ++i)
        t1.moveNext$0();
      this._skipCount = 0;
      return t1.moveNext$0();
    },
    get$current() {
      return this._iterator.get$current();
    },
    $isIterator: 1
  };
  A.EmptyIterable.prototype = {
    get$iterator(_) {
      return B.C_EmptyIterator;
    },
    get$isEmpty(_) {
      return true;
    },
    get$length(_) {
      return 0;
    },
    get$last(_) {
      throw A.wrapException(A.IterableElementError_noElement());
    },
    elementAt$1(_, index) {
      throw A.wrapException(A.RangeError$range(index, 0, 0, "index", null));
    },
    contains$1(_, element) {
      return false;
    },
    join$1(_, separator) {
      return "";
    },
    where$1(_, test) {
      this.$ti._eval$1("bool(1)")._as(test);
      return this;
    },
    map$1$1(_, toElement, $T) {
      this.$ti._bind$1($T)._eval$1("1(2)")._as(toElement);
      return new A.EmptyIterable($T._eval$1("EmptyIterable<0>"));
    },
    skip$1(_, count) {
      A.RangeError_checkNotNegative(count, "count");
      return this;
    },
    take$1(_, count) {
      A.RangeError_checkNotNegative(count, "count");
      return this;
    },
    toList$1$growable(_, growable) {
      var t1 = this.$ti._precomputed1;
      return growable ? J.JSArray_JSArray$growable(0, t1) : J.JSArray_JSArray$fixed(0, t1);
    },
    toList$0(_) {
      return this.toList$1$growable(0, true);
    }
  };
  A.EmptyIterator.prototype = {
    moveNext$0() {
      return false;
    },
    get$current() {
      throw A.wrapException(A.IterableElementError_noElement());
    },
    $isIterator: 1
  };
  A.WhereTypeIterable.prototype = {
    get$iterator(_) {
      return new A.WhereTypeIterator(J.get$iterator$ax(this._source), this.$ti._eval$1("WhereTypeIterator<1>"));
    }
  };
  A.WhereTypeIterator.prototype = {
    moveNext$0() {
      var t1, t2;
      for (t1 = this._source, t2 = this.$ti._precomputed1; t1.moveNext$0();)
        if (t2._is(t1.get$current()))
          return true;
      return false;
    },
    get$current() {
      return this.$ti._precomputed1._as(this._source.get$current());
    },
    $isIterator: 1
  };
  A.FixedLengthListMixin.prototype = {
    set$length(receiver, newLength) {
      throw A.wrapException(A.UnsupportedError$("Cannot change the length of a fixed-length list"));
    },
    add$1(receiver, value) {
      A.instanceType(receiver)._eval$1("FixedLengthListMixin.E")._as(value);
      throw A.wrapException(A.UnsupportedError$("Cannot add to a fixed-length list"));
    }
  };
  A.UnmodifiableListMixin.prototype = {
    $indexSet(_, index, value) {
      A._instanceType(this)._eval$1("UnmodifiableListMixin.E")._as(value);
      throw A.wrapException(A.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    set$length(_, newLength) {
      throw A.wrapException(A.UnsupportedError$("Cannot change the length of an unmodifiable list"));
    },
    add$1(_, value) {
      A._instanceType(this)._eval$1("UnmodifiableListMixin.E")._as(value);
      throw A.wrapException(A.UnsupportedError$("Cannot add to an unmodifiable list"));
    },
    sort$1(_, compare) {
      A._instanceType(this)._eval$1("int(UnmodifiableListMixin.E,UnmodifiableListMixin.E)?")._as(compare);
      throw A.wrapException(A.UnsupportedError$("Cannot modify an unmodifiable list"));
    }
  };
  A.UnmodifiableListBase.prototype = {};
  A._ListIndicesIterable.prototype = {
    get$length(_) {
      return J.get$length$asx(this._backedList);
    },
    elementAt$1(_, index) {
      var t1 = J.get$length$asx(this._backedList);
      if (0 > index || index >= t1)
        A.throwExpression(A.IndexError$withLength(index, t1, this, null, "index"));
      return index;
    }
  };
  A.ListMapView.prototype = {
    $index(_, key) {
      return this.containsKey$1(key) ? J.$index$asx(this.__internal$_values, A._asInt(key)) : null;
    },
    get$length(_) {
      return J.get$length$asx(this.__internal$_values);
    },
    get$keys() {
      return new A._ListIndicesIterable(this.__internal$_values);
    },
    get$isEmpty(_) {
      return J.get$isEmpty$asx(this.__internal$_values);
    },
    get$isNotEmpty(_) {
      return J.get$isNotEmpty$asx(this.__internal$_values);
    },
    containsKey$1(key) {
      return A._isInt(key) && key >= 0 && key < J.get$length$asx(this.__internal$_values);
    },
    forEach$1(_, f) {
      var t1, t2, $length, i;
      this.$ti._eval$1("~(int,1)")._as(f);
      t1 = this.__internal$_values;
      t2 = J.getInterceptor$asx(t1);
      $length = t2.get$length(t1);
      for (i = 0; i < $length; ++i) {
        f.call$2(i, t2.$index(t1, i));
        if ($length !== t2.get$length(t1))
          throw A.wrapException(A.ConcurrentModificationError$(t1));
      }
    }
  };
  A.ReversedListIterable.prototype = {
    get$length(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1(_, index) {
      var t1 = this._source,
        t2 = J.getInterceptor$asx(t1);
      return t2.elementAt$1(t1, t2.get$length(t1) - 1 - index);
    }
  };
  A.Symbol.prototype = {
    get$hashCode(_) {
      var hash = this._hashCode;
      if (hash != null)
        return hash;
      hash = 664597 * B.JSString_methods.get$hashCode(this.__internal$_name) & 536870911;
      this._hashCode = hash;
      return hash;
    },
    toString$0(_) {
      return 'Symbol("' + this.__internal$_name + '")';
    },
    $eq(_, other) {
      if (other == null)
        return false;
      return other instanceof A.Symbol && this.__internal$_name === other.__internal$_name;
    },
    $isSymbol0: 1
  };
  A.__CastListBase__CastIterableBase_ListMixin.prototype = {};
  A.ConstantMapView.prototype = {};
  A.ConstantMap.prototype = {
    cast$2$0(_, RK, RV) {
      var t1 = A._instanceType(this);
      return A.Map_castFrom(this, t1._precomputed1, t1._rest[1], RK, RV);
    },
    get$isEmpty(_) {
      return this.get$length(this) === 0;
    },
    get$isNotEmpty(_) {
      return this.get$length(this) !== 0;
    },
    toString$0(_) {
      return A.MapBase_mapToString(this);
    },
    $indexSet(_, key, value) {
      var t1 = A._instanceType(this);
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      A.ConstantMap__throwUnmodifiable();
    },
    get$entries() {
      return new A._SyncStarIterable(this.entries$body$ConstantMap(), A._instanceType(this)._eval$1("_SyncStarIterable<MapEntry<1,2>>"));
    },
    entries$body$ConstantMap() {
      var $async$self = this;
      return function() {
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1, t2, t3, key, t4;
        return function $async$get$entries($async$iterator, $async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.get$keys(), t1 = t1.get$iterator(t1), t2 = A._instanceType($async$self), t3 = t2._rest[1], t2 = t2._eval$1("@<1>")._bind$1(t3)._eval$1("MapEntry<1,2>");
              case 2:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                key = t1.get$current();
                t4 = $async$self.$index(0, key);
                $async$goto = 4;
                return $async$iterator._async$_current = new A.MapEntry(key, t4 == null ? t3._as(t4) : t4, t2), 1;
              case 4:
                // after yield
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return 0;
              case 1:
                // rethrow
                return $async$iterator._datum = $async$currentError, 3;
            }
        };
      };
    },
    $isMap: 1
  };
  A.ConstantStringMap.prototype = {
    get$length(_) {
      return this._values.length;
    },
    get$_keys() {
      var keys = this.$keys;
      if (keys == null) {
        keys = Object.keys(this._jsIndex);
        this.$keys = keys;
      }
      return keys;
    },
    containsKey$1(key) {
      if (typeof key != "string")
        return false;
      if ("__proto__" === key)
        return false;
      return this._jsIndex.hasOwnProperty(key);
    },
    $index(_, key) {
      if (!this.containsKey$1(key))
        return null;
      return this._values[this._jsIndex[key]];
    },
    forEach$1(_, f) {
      var keys, values, t1, i;
      this.$ti._eval$1("~(1,2)")._as(f);
      keys = this.get$_keys();
      values = this._values;
      for (t1 = keys.length, i = 0; i < t1; ++i)
        f.call$2(keys[i], values[i]);
    },
    get$keys() {
      return new A._KeysOrValues(this.get$_keys(), this.$ti._eval$1("_KeysOrValues<1>"));
    }
  };
  A._KeysOrValues.prototype = {
    get$length(_) {
      return this._elements.length;
    },
    get$isEmpty(_) {
      return 0 === this._elements.length;
    },
    get$isNotEmpty(_) {
      return 0 !== this._elements.length;
    },
    get$iterator(_) {
      var t1 = this._elements;
      return new A._KeysOrValuesOrElementsIterator(t1, t1.length, this.$ti._eval$1("_KeysOrValuesOrElementsIterator<1>"));
    }
  };
  A._KeysOrValuesOrElementsIterator.prototype = {
    get$current() {
      var t1 = this.__js_helper$_current;
      return t1 == null ? this.$ti._precomputed1._as(t1) : t1;
    },
    moveNext$0() {
      var _this = this,
        t1 = _this.__js_helper$_index;
      if (t1 >= _this.__js_helper$_length) {
        _this.set$__js_helper$_current(null);
        return false;
      }
      _this.set$__js_helper$_current(_this._elements[t1]);
      ++_this.__js_helper$_index;
      return true;
    },
    set$__js_helper$_current(_current) {
      this.__js_helper$_current = this.$ti._eval$1("1?")._as(_current);
    },
    $isIterator: 1
  };
  A.GeneralConstantMap.prototype = {
    _getMap$0() {
      var t1, _this = this,
        backingMap = _this.$map;
      if (backingMap == null) {
        t1 = _this.$ti;
        backingMap = new A.JsConstantLinkedHashMap(t1._eval$1("@<1>")._bind$1(t1._rest[1])._eval$1("JsConstantLinkedHashMap<1,2>"));
        A.fillLiteralMap(_this._jsData, backingMap);
        _this.$map = backingMap;
      }
      return backingMap;
    },
    containsKey$1(key) {
      return this._getMap$0().containsKey$1(key);
    },
    $index(_, key) {
      return this._getMap$0().$index(0, key);
    },
    forEach$1(_, f) {
      this.$ti._eval$1("~(1,2)")._as(f);
      this._getMap$0().forEach$1(0, f);
    },
    get$keys() {
      var t1 = this._getMap$0();
      return new A.LinkedHashMapKeyIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapKeyIterable<1>"));
    },
    get$length(_) {
      return this._getMap$0().__js_helper$_length;
    }
  };
  A.Instantiation.prototype = {
    Instantiation$1(_genericClosure) {
      if (false)
        A.instantiatedGenericFunctionType(0, 0);
    },
    $eq(_, other) {
      if (other == null)
        return false;
      return other instanceof A.Instantiation1 && this._genericClosure.$eq(0, other._genericClosure) && A.getRuntimeTypeOfClosure(this) === A.getRuntimeTypeOfClosure(other);
    },
    get$hashCode(_) {
      return A.Object_hash(this._genericClosure, A.getRuntimeTypeOfClosure(this), B.C_SentinelValue);
    },
    toString$0(_) {
      var t1 = B.JSArray_methods.join$1([A.createRuntimeType(this.$ti._precomputed1)], ", ");
      return this._genericClosure.toString$0(0) + " with " + ("<" + t1 + ">");
    }
  };
  A.Instantiation1.prototype = {
    call$2(a0, a1) {
      return this._genericClosure.call$1$2(a0, a1, this.$ti._rest[0]);
    },
    call$0() {
      return this._genericClosure.call$1$0(this.$ti._rest[0]);
    },
    $signature() {
      return A.instantiatedGenericFunctionType(A.closureFunctionType(this._genericClosure), this.$ti);
    }
  };
  A.JSInvocationMirror.prototype = {
    get$memberName() {
      var t1 = this._memberName;
      if (t1 instanceof A.Symbol)
        return t1;
      return this._memberName = new A.Symbol(A._asString(t1));
    },
    get$positionalArguments() {
      var t1, t2, argumentCount, list, index, _this = this;
      if (_this.__js_helper$_kind === 1)
        return B.List_empty;
      t1 = _this._arguments;
      t2 = J.getInterceptor$asx(t1);
      argumentCount = t2.get$length(t1) - J.get$length$asx(_this._namedArgumentNames) - _this._typeArgumentCount;
      if (argumentCount === 0)
        return B.List_empty;
      list = [];
      for (index = 0; index < argumentCount; ++index)
        list.push(t2.$index(t1, index));
      return J.JSArray_markUnmodifiableList(list);
    },
    get$namedArguments() {
      var t1, t2, namedArgumentCount, t3, t4, namedArgumentsStartIndex, map, i, _this = this;
      if (_this.__js_helper$_kind !== 0)
        return B.Map_empty;
      t1 = _this._namedArgumentNames;
      t2 = J.getInterceptor$asx(t1);
      namedArgumentCount = t2.get$length(t1);
      t3 = _this._arguments;
      t4 = J.getInterceptor$asx(t3);
      namedArgumentsStartIndex = t4.get$length(t3) - namedArgumentCount - _this._typeArgumentCount;
      if (namedArgumentCount === 0)
        return B.Map_empty;
      map = new A.JsLinkedHashMap(type$.JsLinkedHashMap_Symbol_dynamic);
      for (i = 0; i < namedArgumentCount; ++i)
        map.$indexSet(0, new A.Symbol(A._asString(t2.$index(t1, i))), t4.$index(t3, namedArgumentsStartIndex + i));
      return new A.ConstantMapView(map, type$.ConstantMapView_Symbol_dynamic);
    },
    $isInvocation: 1
  };
  A.Primitives_functionNoSuchMethod_closure.prototype = {
    call$2($name, argument) {
      var t1;
      A._asString($name);
      t1 = this._box_0;
      t1.names = t1.names + "$" + $name;
      B.JSArray_methods.add$1(this.namedArgumentList, $name);
      B.JSArray_methods.add$1(this.$arguments, argument);
      ++t1.argumentCount;
    },
    $signature: 237
  };
  A.TypeErrorDecoder.prototype = {
    matchTypeError$1(message) {
      var result, t1, _this = this,
        match = new RegExp(_this._pattern).exec(message);
      if (match == null)
        return null;
      result = Object.create(null);
      t1 = _this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = _this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = _this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = _this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = _this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    }
  };
  A.NullError.prototype = {
    toString$0(_) {
      return "Null check operator used on a null value";
    }
  };
  A.JsNoSuchMethodError.prototype = {
    toString$0(_) {
      var t2, _this = this,
        _s38_ = "NoSuchMethodError: method not found: '",
        t1 = _this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + _this.__js_helper$_message;
      t2 = _this._receiver;
      if (t2 == null)
        return _s38_ + t1 + "' (" + _this.__js_helper$_message + ")";
      return _s38_ + t1 + "' on '" + t2 + "' (" + _this.__js_helper$_message + ")";
    }
  };
  A.UnknownJsTypeError.prototype = {
    toString$0(_) {
      var t1 = this.__js_helper$_message;
      return t1.length === 0 ? "Error" : "Error: " + t1;
    }
  };
  A.NullThrownFromJavaScriptException.prototype = {
    toString$0(_) {
      return "Throw of null ('" + (this._irritant === null ? "null" : "undefined") + "' from JavaScript)";
    },
    $isException: 1
  };
  A.ExceptionAndStackTrace.prototype = {};
  A._StackTrace.prototype = {
    toString$0(_) {
      var trace,
        t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
      return this._trace = trace == null ? "" : trace;
    },
    $isStackTrace: 1
  };
  A.Closure.prototype = {
    toString$0(_) {
      var $constructor = this.constructor,
        $name = $constructor == null ? null : $constructor.name;
      return "Closure '" + A.unminifyOrTag($name == null ? "unknown" : $name) + "'";
    },
    get$runtimeType(_) {
      var rti = A.closureFunctionType(this);
      return A.createRuntimeType(rti == null ? A.instanceType(this) : rti);
    },
    $isFunction: 1,
    get$$call() {
      return this;
    },
    "call*": "call$1",
    $requiredArgCount: 1,
    $defaultValues: null
  };
  A.Closure0Args.prototype = {"call*": "call$0", $requiredArgCount: 0};
  A.Closure2Args.prototype = {"call*": "call$2", $requiredArgCount: 2};
  A.TearOffClosure.prototype = {};
  A.StaticClosure.prototype = {
    toString$0(_) {
      var $name = this.$static_name;
      if ($name == null)
        return "Closure of unknown static method";
      return "Closure '" + A.unminifyOrTag($name) + "'";
    }
  };
  A.BoundClosure.prototype = {
    $eq(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof A.BoundClosure))
        return false;
      return this.$_target === other.$_target && this._receiver === other._receiver;
    },
    get$hashCode(_) {
      return (A.objectHashCode(this._receiver) ^ A.Primitives_objectHashCode(this.$_target)) >>> 0;
    },
    toString$0(_) {
      return "Closure '" + this.$_name + "' of " + ("Instance of '" + A.Primitives_objectTypeName(this._receiver) + "'");
    }
  };
  A._CyclicInitializationError.prototype = {
    toString$0(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    }
  };
  A.RuntimeError.prototype = {
    toString$0(_) {
      return "RuntimeError: " + this.message;
    }
  };
  A._AssertionError.prototype = {
    toString$0(_) {
      return "Assertion failed: " + A.Error_safeToString(this.message);
    }
  };
  A._Required.prototype = {};
  A.JsLinkedHashMap.prototype = {
    get$length(_) {
      return this.__js_helper$_length;
    },
    get$isEmpty(_) {
      return this.__js_helper$_length === 0;
    },
    get$isNotEmpty(_) {
      return this.__js_helper$_length !== 0;
    },
    get$keys() {
      return new A.LinkedHashMapKeyIterable(this, A._instanceType(this)._eval$1("LinkedHashMapKeyIterable<1>"));
    },
    get$values() {
      var t1 = A._instanceType(this);
      return A.MappedIterable_MappedIterable(new A.LinkedHashMapKeyIterable(this, t1._eval$1("LinkedHashMapKeyIterable<1>")), new A.JsLinkedHashMap_values_closure(this), t1._precomputed1, t1._rest[1]);
    },
    containsKey$1(key) {
      var strings, nums;
      if (typeof key == "string") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[key] != null;
      } else if (typeof key == "number" && (key & 0x3fffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[key] != null;
      } else
        return this.internalContainsKey$1(key);
    },
    internalContainsKey$1(key) {
      var rest = this.__js_helper$_rest;
      if (rest == null)
        return false;
      return this.internalFindBucketIndex$2(rest[this.internalComputeHashCode$1(key)], key) >= 0;
    },
    addAll$1(_, other) {
      A._instanceType(this)._eval$1("Map<1,2>")._as(other).forEach$1(0, new A.JsLinkedHashMap_addAll_closure(this));
    },
    $index(_, key) {
      var strings, cell, t1, nums, _null = null;
      if (typeof key == "string") {
        strings = this._strings;
        if (strings == null)
          return _null;
        cell = strings[key];
        t1 = cell == null ? _null : cell.hashMapCellValue;
        return t1;
      } else if (typeof key == "number" && (key & 0x3fffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return _null;
        cell = nums[key];
        t1 = cell == null ? _null : cell.hashMapCellValue;
        return t1;
      } else
        return this.internalGet$1(key);
    },
    internalGet$1(key) {
      var bucket, index,
        rest = this.__js_helper$_rest;
      if (rest == null)
        return null;
      bucket = rest[this.internalComputeHashCode$1(key)];
      index = this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return null;
      return bucket[index].hashMapCellValue;
    },
    $indexSet(_, key, value) {
      var strings, nums, _this = this,
        t1 = A._instanceType(_this);
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      if (typeof key == "string") {
        strings = _this._strings;
        _this._addHashTableEntry$3(strings == null ? _this._strings = _this._newHashTable$0() : strings, key, value);
      } else if (typeof key == "number" && (key & 0x3fffffff) === key) {
        nums = _this._nums;
        _this._addHashTableEntry$3(nums == null ? _this._nums = _this._newHashTable$0() : nums, key, value);
      } else
        _this.internalSet$2(key, value);
    },
    internalSet$2(key, value) {
      var rest, hash, bucket, index, _this = this,
        t1 = A._instanceType(_this);
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      rest = _this.__js_helper$_rest;
      if (rest == null)
        rest = _this.__js_helper$_rest = _this._newHashTable$0();
      hash = _this.internalComputeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [_this._newLinkedCell$2(key, value)];
      else {
        index = _this.internalFindBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].hashMapCellValue = value;
        else
          bucket.push(_this._newLinkedCell$2(key, value));
      }
    },
    remove$1(_, key) {
      var _this = this;
      if (typeof key == "string")
        return _this._removeHashTableEntry$2(_this._strings, key);
      else if (typeof key == "number" && (key & 0x3fffffff) === key)
        return _this._removeHashTableEntry$2(_this._nums, key);
      else
        return _this.internalRemove$1(key);
    },
    internalRemove$1(key) {
      var hash, bucket, index, cell, _this = this,
        rest = _this.__js_helper$_rest;
      if (rest == null)
        return null;
      hash = _this.internalComputeHashCode$1(key);
      bucket = rest[hash];
      index = _this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return null;
      cell = bucket.splice(index, 1)[0];
      _this._unlinkCell$1(cell);
      if (bucket.length === 0)
        delete rest[hash];
      return cell.hashMapCellValue;
    },
    forEach$1(_, action) {
      var cell, modifications, _this = this;
      A._instanceType(_this)._eval$1("~(1,2)")._as(action);
      cell = _this._first;
      modifications = _this._modifications;
      for (; cell != null;) {
        action.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
        if (modifications !== _this._modifications)
          throw A.wrapException(A.ConcurrentModificationError$(_this));
        cell = cell._next;
      }
    },
    _addHashTableEntry$3(table, key, value) {
      var cell,
        t1 = A._instanceType(this);
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      cell = table[key];
      if (cell == null)
        table[key] = this._newLinkedCell$2(key, value);
      else
        cell.hashMapCellValue = value;
    },
    _removeHashTableEntry$2(table, key) {
      var cell;
      if (table == null)
        return null;
      cell = table[key];
      if (cell == null)
        return null;
      this._unlinkCell$1(cell);
      delete table[key];
      return cell.hashMapCellValue;
    },
    _modified$0() {
      this._modifications = this._modifications + 1 & 1073741823;
    },
    _newLinkedCell$2(key, value) {
      var _this = this,
        t1 = A._instanceType(_this),
        cell = new A.LinkedHashMapCell(t1._precomputed1._as(key), t1._rest[1]._as(value));
      if (_this._first == null)
        _this._first = _this._last = cell;
      else {
        t1 = _this._last;
        t1.toString;
        cell._previous = t1;
        _this._last = t1._next = cell;
      }
      ++_this.__js_helper$_length;
      _this._modified$0();
      return cell;
    },
    _unlinkCell$1(cell) {
      var _this = this,
        previous = cell._previous,
        next = cell._next;
      if (previous == null)
        _this._first = next;
      else
        previous._next = next;
      if (next == null)
        _this._last = previous;
      else
        next._previous = previous;
      --_this.__js_helper$_length;
      _this._modified$0();
    },
    internalComputeHashCode$1(key) {
      return J.get$hashCode$(key) & 1073741823;
    },
    internalFindBucketIndex$2(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i].hashMapCellKey, key))
          return i;
      return -1;
    },
    toString$0(_) {
      return A.MapBase_mapToString(this);
    },
    _newHashTable$0() {
      var table = Object.create(null);
      table["<non-identifier-key>"] = table;
      delete table["<non-identifier-key>"];
      return table;
    },
    $isLinkedHashMap: 1
  };
  A.JsLinkedHashMap_values_closure.prototype = {
    call$1(each) {
      var t1 = this.$this,
        t2 = A._instanceType(t1);
      t1 = t1.$index(0, t2._precomputed1._as(each));
      return t1 == null ? t2._rest[1]._as(t1) : t1;
    },
    $signature() {
      return A._instanceType(this.$this)._eval$1("2(1)");
    }
  };
  A.JsLinkedHashMap_addAll_closure.prototype = {
    call$2(key, value) {
      var t1 = this.$this,
        t2 = A._instanceType(t1);
      t1.$indexSet(0, t2._precomputed1._as(key), t2._rest[1]._as(value));
    },
    $signature() {
      return A._instanceType(this.$this)._eval$1("~(1,2)");
    }
  };
  A.LinkedHashMapCell.prototype = {};
  A.LinkedHashMapKeyIterable.prototype = {
    get$length(_) {
      return this._map.__js_helper$_length;
    },
    get$isEmpty(_) {
      return this._map.__js_helper$_length === 0;
    },
    get$iterator(_) {
      var t1 = this._map,
        t2 = new A.LinkedHashMapKeyIterator(t1, t1._modifications, this.$ti._eval$1("LinkedHashMapKeyIterator<1>"));
      t2._cell = t1._first;
      return t2;
    },
    contains$1(_, element) {
      return this._map.containsKey$1(element);
    }
  };
  A.LinkedHashMapKeyIterator.prototype = {
    get$current() {
      return this.__js_helper$_current;
    },
    moveNext$0() {
      var cell, _this = this,
        t1 = _this._map;
      if (_this._modifications !== t1._modifications)
        throw A.wrapException(A.ConcurrentModificationError$(t1));
      cell = _this._cell;
      if (cell == null) {
        _this.set$__js_helper$_current(null);
        return false;
      } else {
        _this.set$__js_helper$_current(cell.hashMapCellKey);
        _this._cell = cell._next;
        return true;
      }
    },
    set$__js_helper$_current(_current) {
      this.__js_helper$_current = this.$ti._eval$1("1?")._as(_current);
    },
    $isIterator: 1
  };
  A.JsIdentityLinkedHashMap.prototype = {
    internalComputeHashCode$1(key) {
      return A.objectHashCode(key) & 1073741823;
    },
    internalFindBucketIndex$2(bucket, key) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i) {
        t1 = bucket[i].hashMapCellKey;
        if (t1 == null ? key == null : t1 === key)
          return i;
      }
      return -1;
    }
  };
  A.JsConstantLinkedHashMap.prototype = {
    internalComputeHashCode$1(key) {
      return A.constantHashCode(key) & 1073741823;
    },
    internalFindBucketIndex$2(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i].hashMapCellKey, key))
          return i;
      return -1;
    }
  };
  A.initHooks_closure.prototype = {
    call$1(o) {
      return this.getTag(o);
    },
    $signature: 15
  };
  A.initHooks_closure0.prototype = {
    call$2(o, tag) {
      return this.getUnknownTag(o, tag);
    },
    $signature: 87
  };
  A.initHooks_closure1.prototype = {
    call$1(tag) {
      return this.prototypeForTag(A._asString(tag));
    },
    $signature: 240
  };
  A.JSSyntaxRegExp.prototype = {
    toString$0(_) {
      return "RegExp/" + this.pattern + "/" + this._nativeRegExp.flags;
    },
    get$_nativeGlobalVersion() {
      var _this = this,
        t1 = _this._nativeGlobalRegExp;
      if (t1 != null)
        return t1;
      t1 = _this._nativeRegExp;
      return _this._nativeGlobalRegExp = A.JSSyntaxRegExp_makeNative(_this.pattern, t1.multiline, !t1.ignoreCase, t1.unicode, t1.dotAll, true);
    },
    get$_nativeAnchoredVersion() {
      var _this = this,
        t1 = _this._nativeAnchoredRegExp;
      if (t1 != null)
        return t1;
      t1 = _this._nativeRegExp;
      return _this._nativeAnchoredRegExp = A.JSSyntaxRegExp_makeNative(_this.pattern + "|()", t1.multiline, !t1.ignoreCase, t1.unicode, t1.dotAll, true);
    },
    firstMatch$1(string) {
      var m = this._nativeRegExp.exec(string);
      if (m == null)
        return null;
      return new A._MatchImplementation(m);
    },
    allMatches$2(_, string, start) {
      var t1 = string.length;
      if (start > t1)
        throw A.wrapException(A.RangeError$range(start, 0, t1, null, null));
      return new A._AllMatchesIterable(this, string, start);
    },
    allMatches$1(_, string) {
      return this.allMatches$2(0, string, 0);
    },
    _execGlobal$2(string, start) {
      var match,
        regexp = this.get$_nativeGlobalVersion();
      if (regexp == null)
        regexp = type$.Object._as(regexp);
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return null;
      return new A._MatchImplementation(match);
    },
    _execAnchored$2(string, start) {
      var match,
        regexp = this.get$_nativeAnchoredVersion();
      if (regexp == null)
        regexp = type$.Object._as(regexp);
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return null;
      if (0 >= match.length)
        return A.ioore(match, -1);
      if (match.pop() != null)
        return null;
      return new A._MatchImplementation(match);
    },
    matchAsPrefix$2(_, string, start) {
      if (start < 0 || start > string.length)
        throw A.wrapException(A.RangeError$range(start, 0, string.length, null, null));
      return this._execAnchored$2(string, start);
    },
    $isPattern: 1,
    $isRegExp: 1
  };
  A._MatchImplementation.prototype = {
    get$start() {
      return this._match.index;
    },
    get$end() {
      var t1 = this._match;
      return t1.index + t1[0].length;
    },
    group$1(index) {
      var t1 = this._match;
      if (!(index < t1.length))
        return A.ioore(t1, index);
      return t1[index];
    },
    $index(_, index) {
      var t1 = this._match;
      if (!(index < t1.length))
        return A.ioore(t1, index);
      return t1[index];
    },
    $isMatch: 1,
    $isRegExpMatch: 1
  };
  A._AllMatchesIterable.prototype = {
    get$iterator(_) {
      return new A._AllMatchesIterator(this._re, this._string, this.__js_helper$_start);
    }
  };
  A._AllMatchesIterator.prototype = {
    get$current() {
      var t1 = this.__js_helper$_current;
      return t1 == null ? type$.RegExpMatch._as(t1) : t1;
    },
    moveNext$0() {
      var t1, t2, t3, match, nextIndex, _this = this,
        string = _this._string;
      if (string == null)
        return false;
      t1 = _this._nextIndex;
      t2 = string.length;
      if (t1 <= t2) {
        t3 = _this._regExp;
        match = t3._execGlobal$2(string, t1);
        if (match != null) {
          _this.__js_helper$_current = match;
          nextIndex = match.get$end();
          if (match._match.index === nextIndex) {
            if (t3._nativeRegExp.unicode) {
              t1 = _this._nextIndex;
              t3 = t1 + 1;
              if (t3 < t2) {
                if (!(t1 >= 0 && t1 < t2))
                  return A.ioore(string, t1);
                t1 = string.charCodeAt(t1);
                if (t1 >= 55296 && t1 <= 56319) {
                  if (!(t3 >= 0))
                    return A.ioore(string, t3);
                  t1 = string.charCodeAt(t3);
                  t1 = t1 >= 56320 && t1 <= 57343;
                } else
                  t1 = false;
              } else
                t1 = false;
            } else
              t1 = false;
            nextIndex = (t1 ? nextIndex + 1 : nextIndex) + 1;
          }
          _this._nextIndex = nextIndex;
          return true;
        }
      }
      _this._string = _this.__js_helper$_current = null;
      return false;
    },
    $isIterator: 1
  };
  A.StringMatch.prototype = {
    get$end() {
      return this.start + this.pattern.length;
    },
    $index(_, g) {
      if (g !== 0)
        A.throwExpression(A.RangeError$value(g, null));
      return this.pattern;
    },
    group$1(group_) {
      if (group_ !== 0)
        throw A.wrapException(A.RangeError$value(group_, null));
      return this.pattern;
    },
    $isMatch: 1,
    get$start() {
      return this.start;
    }
  };
  A._StringAllMatchesIterable.prototype = {
    get$iterator(_) {
      return new A._StringAllMatchesIterator(this._input, this._pattern, this.__js_helper$_index);
    }
  };
  A._StringAllMatchesIterator.prototype = {
    moveNext$0() {
      var index, end, _this = this,
        t1 = _this.__js_helper$_index,
        t2 = _this._pattern,
        t3 = t2.length,
        t4 = _this._input,
        t5 = t4.length;
      if (t1 + t3 > t5) {
        _this.__js_helper$_current = null;
        return false;
      }
      index = t4.indexOf(t2, t1);
      if (index < 0) {
        _this.__js_helper$_index = t5 + 1;
        _this.__js_helper$_current = null;
        return false;
      }
      end = index + t3;
      _this.__js_helper$_current = new A.StringMatch(index, t2);
      _this.__js_helper$_index = end === _this.__js_helper$_index ? end + 1 : end;
      return true;
    },
    get$current() {
      var t1 = this.__js_helper$_current;
      t1.toString;
      return t1;
    },
    $isIterator: 1
  };
  A._Cell.prototype = {
    _readLocal$0() {
      var t1 = this._value;
      if (t1 === this)
        throw A.wrapException(new A.LateError("Local '" + this._name + "' has not been initialized."));
      return t1;
    },
    _readField$0() {
      var t1 = this._value;
      if (t1 === this)
        throw A.wrapException(A.LateError$fieldNI(this._name));
      return t1;
    }
  };
  A.NativeByteBuffer.prototype = {
    get$runtimeType(receiver) {
      return B.Type_ByteBuffer_EOZ;
    },
    $isTrustedGetRuntimeType: 1,
    $isNativeByteBuffer: 1,
    $isByteBuffer: 1
  };
  A.NativeTypedData.prototype = {
    _invalidPosition$3(receiver, position, $length, $name) {
      var t1 = A.RangeError$range(position, 0, $length, $name, null);
      throw A.wrapException(t1);
    },
    _checkPosition$3(receiver, position, $length, $name) {
      if (position >>> 0 !== position || position > $length)
        this._invalidPosition$3(receiver, position, $length, $name);
    }
  };
  A.NativeByteData.prototype = {
    get$runtimeType(receiver) {
      return B.Type_ByteData_mF8;
    },
    _getFloat32$2(receiver, byteOffset, littleEndian) {
      return receiver.getFloat32(byteOffset, littleEndian);
    },
    _getFloat64$2(receiver, byteOffset, littleEndian) {
      return receiver.getFloat64(byteOffset, littleEndian);
    },
    _getInt16$2(receiver, byteOffset, littleEndian) {
      return receiver.getInt16(byteOffset, littleEndian);
    },
    _getUint32$2(receiver, byteOffset, littleEndian) {
      return receiver.getUint32(byteOffset, littleEndian);
    },
    _setFloat32$3(receiver, byteOffset, value, littleEndian) {
      return receiver.setFloat32(byteOffset, value, littleEndian);
    },
    _setFloat64$3(receiver, byteOffset, value, littleEndian) {
      return receiver.setFloat64(byteOffset, value, littleEndian);
    },
    _setUint32$3(receiver, byteOffset, value, littleEndian) {
      return receiver.setUint32(byteOffset, value, littleEndian);
    },
    $isTrustedGetRuntimeType: 1,
    $isByteData: 1
  };
  A.NativeTypedArray.prototype = {
    get$length(receiver) {
      return receiver.length;
    },
    _setRangeFast$4(receiver, start, end, source, skipCount) {
      var count, sourceLength,
        targetLength = receiver.length;
      this._checkPosition$3(receiver, start, targetLength, "start");
      this._checkPosition$3(receiver, end, targetLength, "end");
      if (start > end)
        throw A.wrapException(A.RangeError$range(start, 0, end, null, null));
      count = end - start;
      sourceLength = source.length;
      if (sourceLength - skipCount < count)
        throw A.wrapException(A.StateError$("Not enough elements"));
      if (skipCount !== 0 || sourceLength !== count)
        source = source.subarray(skipCount, skipCount + count);
      receiver.set(source, start);
    },
    $isJavaScriptIndexingBehavior: 1
  };
  A.NativeTypedArrayOfDouble.prototype = {
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $indexSet(receiver, index, value) {
      A._asDouble(value);
      A._checkValidIndex(index, receiver, receiver.length);
      receiver[index] = value;
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isList: 1
  };
  A.NativeTypedArrayOfInt.prototype = {
    $indexSet(receiver, index, value) {
      A._asInt(value);
      A._checkValidIndex(index, receiver, receiver.length);
      receiver[index] = value;
    },
    setRange$4(receiver, start, end, iterable, skipCount) {
      type$.Iterable_int._as(iterable);
      if (type$.NativeTypedArrayOfInt._is(iterable)) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      this.super$ListBase$setRange(receiver, start, end, iterable, skipCount);
    },
    setRange$3(receiver, start, end, iterable) {
      return this.setRange$4(receiver, start, end, iterable, 0);
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isList: 1
  };
  A.NativeFloat32List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Float32List_Ymk;
    },
    sublist$2(receiver, start, end) {
      return new Float32Array(receiver.subarray(start, A._checkValidRange(start, end, receiver.length)));
    },
    sublist$1(receiver, start) {
      return this.sublist$2(receiver, start, null);
    },
    $isTrustedGetRuntimeType: 1,
    $isFloat32List: 1
  };
  A.NativeFloat64List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Float64List_Ymk;
    },
    sublist$2(receiver, start, end) {
      return new Float64Array(receiver.subarray(start, A._checkValidRange(start, end, receiver.length)));
    },
    sublist$1(receiver, start) {
      return this.sublist$2(receiver, start, null);
    },
    $isTrustedGetRuntimeType: 1,
    $isFloat64List: 1
  };
  A.NativeInt16List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Int16List_cot;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2(receiver, start, end) {
      return new Int16Array(receiver.subarray(start, A._checkValidRange(start, end, receiver.length)));
    },
    sublist$1(receiver, start) {
      return this.sublist$2(receiver, start, null);
    },
    $isTrustedGetRuntimeType: 1,
    $isInt16List: 1
  };
  A.NativeInt32List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Int32List_m1p;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2(receiver, start, end) {
      return new Int32Array(receiver.subarray(start, A._checkValidRange(start, end, receiver.length)));
    },
    sublist$1(receiver, start) {
      return this.sublist$2(receiver, start, null);
    },
    $isTrustedGetRuntimeType: 1,
    $isInt32List: 1
  };
  A.NativeInt8List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Int8List_woc;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2(receiver, start, end) {
      return new Int8Array(receiver.subarray(start, A._checkValidRange(start, end, receiver.length)));
    },
    sublist$1(receiver, start) {
      return this.sublist$2(receiver, start, null);
    },
    $isTrustedGetRuntimeType: 1,
    $isInt8List: 1
  };
  A.NativeUint16List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Uint16List_2mh;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2(receiver, start, end) {
      return new Uint16Array(receiver.subarray(start, A._checkValidRange(start, end, receiver.length)));
    },
    sublist$1(receiver, start) {
      return this.sublist$2(receiver, start, null);
    },
    $isTrustedGetRuntimeType: 1,
    $isUint16List: 1
  };
  A.NativeUint32List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Uint32List_2mh;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2(receiver, start, end) {
      return new Uint32Array(receiver.subarray(start, A._checkValidRange(start, end, receiver.length)));
    },
    sublist$1(receiver, start) {
      return this.sublist$2(receiver, start, null);
    },
    $isTrustedGetRuntimeType: 1,
    $isUint32List: 1
  };
  A.NativeUint8ClampedList.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Uint8ClampedList_9Bb;
    },
    get$length(receiver) {
      return receiver.length;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2(receiver, start, end) {
      return new Uint8ClampedArray(receiver.subarray(start, A._checkValidRange(start, end, receiver.length)));
    },
    sublist$1(receiver, start) {
      return this.sublist$2(receiver, start, null);
    },
    $isTrustedGetRuntimeType: 1,
    $isUint8ClampedList: 1
  };
  A.NativeUint8List.prototype = {
    get$runtimeType(receiver) {
      return B.Type_Uint8List_CSc;
    },
    get$length(receiver) {
      return receiver.length;
    },
    $index(receiver, index) {
      A._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2(receiver, start, end) {
      return new Uint8Array(receiver.subarray(start, A._checkValidRange(start, end, receiver.length)));
    },
    sublist$1(receiver, start) {
      return this.sublist$2(receiver, start, null);
    },
    $isTrustedGetRuntimeType: 1,
    $isNativeUint8List: 1,
    $isUint8List: 1
  };
  A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.prototype = {};
  A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.prototype = {};
  A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  A.Rti.prototype = {
    _eval$1(recipe) {
      return A._Universe_evalInEnvironment(init.typeUniverse, this, recipe);
    },
    _bind$1(typeOrTuple) {
      return A._Universe_bind(init.typeUniverse, this, typeOrTuple);
    }
  };
  A._FunctionParameters.prototype = {};
  A._Type.prototype = {
    toString$0(_) {
      return A._rtiToString(this._rti, null);
    }
  };
  A._Error.prototype = {
    toString$0(_) {
      return this._message;
    }
  };
  A._TypeError.prototype = {$isTypeError: 1};
  A._AsyncRun__initializeScheduleImmediate_internalCallback.prototype = {
    call$1(_) {
      var t1 = this._box_0,
        f = t1.storedCallback;
      t1.storedCallback = null;
      f.call$0();
    },
    $signature: 21
  };
  A._AsyncRun__initializeScheduleImmediate_closure.prototype = {
    call$1(callback) {
      var t1, t2;
      this._box_0.storedCallback = type$.void_Function._as(callback);
      t1 = this.div;
      t2 = this.span;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    },
    $signature: 80
  };
  A._AsyncRun__scheduleImmediateJsOverride_internalCallback.prototype = {
    call$0() {
      this.callback.call$0();
    },
    $signature: 11
  };
  A._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback.prototype = {
    call$0() {
      this.callback.call$0();
    },
    $signature: 11
  };
  A._TimerImpl.prototype = {
    _TimerImpl$2(milliseconds, callback) {
      if (self.setTimeout != null)
        this._handle = self.setTimeout(A.convertDartClosureToJS(new A._TimerImpl_internalCallback(this, callback), 0), milliseconds);
      else
        throw A.wrapException(A.UnsupportedError$("`setTimeout()` not found."));
    },
    cancel$0() {
      if (self.setTimeout != null) {
        var t1 = this._handle;
        if (t1 == null)
          return;
        self.clearTimeout(t1);
        this._handle = null;
      } else
        throw A.wrapException(A.UnsupportedError$("Canceling a timer."));
    }
  };
  A._TimerImpl_internalCallback.prototype = {
    call$0() {
      this.$this._handle = null;
      this.callback.call$0();
    },
    $signature: 0
  };
  A._AsyncAwaitCompleter.prototype = {
    complete$1(value) {
      var t2, _this = this,
        t1 = _this.$ti;
      t1._eval$1("1/?")._as(value);
      if (value == null)
        value = t1._precomputed1._as(value);
      if (!_this.isSync)
        _this._future._asyncComplete$1(value);
      else {
        t2 = _this._future;
        if (t1._eval$1("Future<1>")._is(value))
          t2._chainFuture$1(value);
        else
          t2._completeWithValue$1(value);
      }
    },
    completeError$2(e, st) {
      var t1 = this._future;
      if (this.isSync)
        t1._completeError$2(e, st);
      else
        t1._asyncCompleteError$2(e, st);
    },
    $isCompleter: 1
  };
  A._awaitOnObject_closure.prototype = {
    call$1(result) {
      return this.bodyFunction.call$2(0, result);
    },
    $signature: 12
  };
  A._awaitOnObject_closure0.prototype = {
    call$2(error, stackTrace) {
      this.bodyFunction.call$2(1, new A.ExceptionAndStackTrace(error, type$.StackTrace._as(stackTrace)));
    },
    $signature: 220
  };
  A._wrapJsFunctionForAsync_closure.prototype = {
    call$2(errorCode, result) {
      this.$protected(A._asInt(errorCode), result);
    },
    $signature: 202
  };
  A._SyncStarIterator.prototype = {
    get$current() {
      var t1 = this._async$_current;
      return t1 == null ? this.$ti._precomputed1._as(t1) : t1;
    },
    _resumeBody$2(errorCode, errorValue) {
      var body, t1, exception;
      errorCode = A._asInt(errorCode);
      errorValue = errorValue;
      body = this._body;
      for (; true;)
        try {
          t1 = body(this, errorCode, errorValue);
          return t1;
        } catch (exception) {
          errorValue = exception;
          errorCode = 1;
        }
    },
    moveNext$0() {
      var nestedIterator, exception, value, suspendedBodies, _this = this, _null = null, errorValue = null, errorCode = 0;
      for (; true;) {
        nestedIterator = _this._nestedIterator;
        if (nestedIterator != null)
          try {
            if (nestedIterator.moveNext$0()) {
              _this.set$_async$_current(nestedIterator.get$current());
              return true;
            } else
              _this.set$_nestedIterator(_null);
          } catch (exception) {
            errorValue = exception;
            errorCode = 1;
            _this.set$_nestedIterator(_null);
          }
        value = _this._resumeBody$2(errorCode, errorValue);
        if (1 === value)
          return true;
        if (0 === value) {
          _this.set$_async$_current(_null);
          suspendedBodies = _this._suspendedBodies;
          if (suspendedBodies == null || suspendedBodies.length === 0) {
            _this._body = A._SyncStarIterator__terminatedBody;
            return false;
          }
          if (0 >= suspendedBodies.length)
            return A.ioore(suspendedBodies, -1);
          _this._body = suspendedBodies.pop();
          errorCode = 0;
          errorValue = null;
          continue;
        }
        if (2 === value) {
          errorCode = 0;
          errorValue = null;
          continue;
        }
        if (3 === value) {
          errorValue = _this._datum;
          _this._datum = null;
          suspendedBodies = _this._suspendedBodies;
          if (suspendedBodies == null || suspendedBodies.length === 0) {
            _this.set$_async$_current(_null);
            _this._body = A._SyncStarIterator__terminatedBody;
            throw errorValue;
            return false;
          }
          if (0 >= suspendedBodies.length)
            return A.ioore(suspendedBodies, -1);
          _this._body = suspendedBodies.pop();
          errorCode = 1;
          continue;
        }
        throw A.wrapException(A.StateError$("sync*"));
      }
      return false;
    },
    _yieldStar$1(iterable) {
      var t1, t2, _this = this;
      if (iterable instanceof A._SyncStarIterable) {
        t1 = iterable._outerHelper();
        t2 = _this._suspendedBodies;
        if (t2 == null)
          t2 = _this._suspendedBodies = [];
        B.JSArray_methods.add$1(t2, _this._body);
        _this._body = t1;
        return 2;
      } else {
        _this.set$_nestedIterator(J.get$iterator$ax(iterable));
        return 2;
      }
    },
    set$_async$_current(_current) {
      this._async$_current = this.$ti._eval$1("1?")._as(_current);
    },
    set$_nestedIterator(_nestedIterator) {
      this._nestedIterator = this.$ti._eval$1("Iterator<1>?")._as(_nestedIterator);
    },
    $isIterator: 1
  };
  A._SyncStarIterable.prototype = {
    get$iterator(_) {
      return new A._SyncStarIterator(this._outerHelper(), this.$ti._eval$1("_SyncStarIterator<1>"));
    }
  };
  A.AsyncError.prototype = {
    toString$0(_) {
      return A.S(this.error);
    },
    $isError: 1,
    get$stackTrace() {
      return this.stackTrace;
    }
  };
  A.Future_Future$delayed_closure.prototype = {
    call$0() {
      this.T._as(null);
      this.result._complete$1(null);
    },
    $signature: 0
  };
  A.TimeoutException.prototype = {
    toString$0(_) {
      var t1 = this.duration.toString$0(0);
      return "TimeoutException after " + t1 + ": " + this.message;
    },
    $isException: 1
  };
  A._Completer.prototype = {
    completeError$2(error, stackTrace) {
      var t1 = type$.Object;
      t1._as(error);
      type$.nullable_StackTrace._as(stackTrace);
      A.checkNotNullable(error, "error", t1);
      if ((this.future._state & 30) !== 0)
        throw A.wrapException(A.StateError$("Future already completed"));
      if (stackTrace == null)
        stackTrace = A.AsyncError_defaultStackTrace(error);
      this._completeError$2(error, stackTrace);
    },
    completeError$1(error) {
      return this.completeError$2(error, null);
    },
    $isCompleter: 1
  };
  A._AsyncCompleter.prototype = {
    complete$1(value) {
      var t2,
        t1 = this.$ti;
      t1._eval$1("1/?")._as(value);
      t2 = this.future;
      if ((t2._state & 30) !== 0)
        throw A.wrapException(A.StateError$("Future already completed"));
      t2._asyncComplete$1(t1._eval$1("1/")._as(value));
    },
    complete$0() {
      return this.complete$1(null);
    },
    _completeError$2(error, stackTrace) {
      this.future._asyncCompleteError$2(error, stackTrace);
    }
  };
  A._SyncCompleter.prototype = {
    complete$1(value) {
      var t2,
        t1 = this.$ti;
      t1._eval$1("1/?")._as(value);
      t2 = this.future;
      if ((t2._state & 30) !== 0)
        throw A.wrapException(A.StateError$("Future already completed"));
      t2._complete$1(t1._eval$1("1/")._as(value));
    },
    complete$0() {
      return this.complete$1(null);
    },
    _completeError$2(error, stackTrace) {
      this.future._completeError$2(error, stackTrace);
    }
  };
  A._FutureListener.prototype = {
    matchesErrorTest$1(asyncError) {
      if ((this.state & 15) !== 6)
        return true;
      return this.result._zone.runUnary$2$2(type$.bool_Function_Object._as(this.callback), asyncError.error, type$.bool, type$.Object);
    },
    handleError$1(asyncError) {
      var exception, _this = this,
        errorCallback = _this.errorCallback,
        result = null,
        t1 = type$.dynamic,
        t2 = type$.Object,
        t3 = asyncError.error,
        t4 = _this.result._zone;
      if (type$.dynamic_Function_Object_StackTrace._is(errorCallback))
        result = t4.runBinary$3$3(errorCallback, t3, asyncError.stackTrace, t1, t2, type$.StackTrace);
      else
        result = t4.runUnary$2$2(type$.dynamic_Function_Object._as(errorCallback), t3, t1, t2);
      try {
        t1 = _this.$ti._eval$1("2/")._as(result);
        return t1;
      } catch (exception) {
        if (type$.TypeError._is(A.unwrapException(exception))) {
          if ((_this.state & 1) !== 0)
            throw A.wrapException(A.ArgumentError$("The error handler of Future.then must return a value of the returned future's type", "onError"));
          throw A.wrapException(A.ArgumentError$("The error handler of Future.catchError must return a value of the future's type", "onError"));
        } else
          throw exception;
      }
    }
  };
  A._Future.prototype = {
    _setChained$1(source) {
      this._state = this._state & 1 | 4;
      this._resultOrListeners = source;
    },
    then$1$2$onError(f, onError, $R) {
      var currentZone, result, t2,
        t1 = this.$ti;
      t1._bind$1($R)._eval$1("1/(2)")._as(f);
      currentZone = $.Zone__current;
      if (currentZone === B.C__RootZone) {
        if (onError != null && !type$.dynamic_Function_Object_StackTrace._is(onError) && !type$.dynamic_Function_Object._is(onError))
          throw A.wrapException(A.ArgumentError$value(onError, "onError", string$.Error_));
      } else {
        $R._eval$1("@<0/>")._bind$1(t1._precomputed1)._eval$1("1(2)")._as(f);
        if (onError != null)
          onError = A._registerErrorHandler(onError, currentZone);
      }
      result = new A._Future(currentZone, $R._eval$1("_Future<0>"));
      t2 = onError == null ? 1 : 3;
      this._addListener$1(new A._FutureListener(result, t2, f, onError, t1._eval$1("@<1>")._bind$1($R)._eval$1("_FutureListener<1,2>")));
      return result;
    },
    then$1$1(f, $R) {
      return this.then$1$2$onError(f, null, $R);
    },
    _thenAwait$1$2(f, onError, $E) {
      var result,
        t1 = this.$ti;
      t1._bind$1($E)._eval$1("1/(2)")._as(f);
      result = new A._Future($.Zone__current, $E._eval$1("_Future<0>"));
      this._addListener$1(new A._FutureListener(result, 19, f, onError, t1._eval$1("@<1>")._bind$1($E)._eval$1("_FutureListener<1,2>")));
      return result;
    },
    catchError$1(onError) {
      var t1 = this.$ti,
        t2 = $.Zone__current,
        result = new A._Future(t2, t1);
      if (t2 !== B.C__RootZone)
        onError = A._registerErrorHandler(onError, t2);
      this._addListener$1(new A._FutureListener(result, 2, null, onError, t1._eval$1("@<1>")._bind$1(t1._precomputed1)._eval$1("_FutureListener<1,2>")));
      return result;
    },
    whenComplete$1(action) {
      var t1, result;
      type$.dynamic_Function._as(action);
      t1 = this.$ti;
      result = new A._Future($.Zone__current, t1);
      this._addListener$1(new A._FutureListener(result, 8, action, null, t1._eval$1("@<1>")._bind$1(t1._precomputed1)._eval$1("_FutureListener<1,2>")));
      return result;
    },
    _setErrorObject$1(error) {
      this._state = this._state & 1 | 16;
      this._resultOrListeners = error;
    },
    _cloneResult$1(source) {
      this._state = source._state & 30 | this._state & 1;
      this._resultOrListeners = source._resultOrListeners;
    },
    _addListener$1(listener) {
      var source, _this = this,
        t1 = _this._state;
      if (t1 <= 3) {
        listener._nextListener = type$.nullable__FutureListener_dynamic_dynamic._as(_this._resultOrListeners);
        _this._resultOrListeners = listener;
      } else {
        if ((t1 & 4) !== 0) {
          source = type$._Future_dynamic._as(_this._resultOrListeners);
          if ((source._state & 24) === 0) {
            source._addListener$1(listener);
            return;
          }
          _this._cloneResult$1(source);
        }
        A._rootScheduleMicrotask(null, null, _this._zone, type$.void_Function._as(new A._Future__addListener_closure(_this, listener)));
      }
    },
    _prependListeners$1(listeners) {
      var t1, existingListeners, next, cursor, next0, source, _this = this, _box_0 = {};
      _box_0.listeners = listeners;
      if (listeners == null)
        return;
      t1 = _this._state;
      if (t1 <= 3) {
        existingListeners = type$.nullable__FutureListener_dynamic_dynamic._as(_this._resultOrListeners);
        _this._resultOrListeners = listeners;
        if (existingListeners != null) {
          next = listeners._nextListener;
          for (cursor = listeners; next != null; cursor = next, next = next0)
            next0 = next._nextListener;
          cursor._nextListener = existingListeners;
        }
      } else {
        if ((t1 & 4) !== 0) {
          source = type$._Future_dynamic._as(_this._resultOrListeners);
          if ((source._state & 24) === 0) {
            source._prependListeners$1(listeners);
            return;
          }
          _this._cloneResult$1(source);
        }
        _box_0.listeners = _this._reverseListeners$1(listeners);
        A._rootScheduleMicrotask(null, null, _this._zone, type$.void_Function._as(new A._Future__prependListeners_closure(_box_0, _this)));
      }
    },
    _removeListeners$0() {
      var current = type$.nullable__FutureListener_dynamic_dynamic._as(this._resultOrListeners);
      this._resultOrListeners = null;
      return this._reverseListeners$1(current);
    },
    _reverseListeners$1(listeners) {
      var current, prev, next;
      for (current = listeners, prev = null; current != null; prev = current, current = next) {
        next = current._nextListener;
        current._nextListener = prev;
      }
      return prev;
    },
    _chainForeignFuture$1(source) {
      var e, s, exception, _this = this;
      _this._state ^= 2;
      try {
        source.then$1$2$onError(new A._Future__chainForeignFuture_closure(_this), new A._Future__chainForeignFuture_closure0(_this), type$.Null);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A.scheduleMicrotask(new A._Future__chainForeignFuture_closure1(_this, e, s));
      }
    },
    _complete$1(value) {
      var listeners, _this = this,
        t1 = _this.$ti;
      t1._eval$1("1/")._as(value);
      if (t1._eval$1("Future<1>")._is(value))
        if (t1._is(value))
          A._Future__chainCoreFutureSync(value, _this);
        else
          _this._chainForeignFuture$1(value);
      else {
        listeners = _this._removeListeners$0();
        t1._precomputed1._as(value);
        _this._state = 8;
        _this._resultOrListeners = value;
        A._Future__propagateToListeners(_this, listeners);
      }
    },
    _completeWithValue$1(value) {
      var listeners, _this = this;
      _this.$ti._precomputed1._as(value);
      listeners = _this._removeListeners$0();
      _this._state = 8;
      _this._resultOrListeners = value;
      A._Future__propagateToListeners(_this, listeners);
    },
    _completeError$2(error, stackTrace) {
      var listeners;
      type$.Object._as(error);
      type$.StackTrace._as(stackTrace);
      listeners = this._removeListeners$0();
      this._setErrorObject$1(A.AsyncError$(error, stackTrace));
      A._Future__propagateToListeners(this, listeners);
    },
    _asyncComplete$1(value) {
      var t1 = this.$ti;
      t1._eval$1("1/")._as(value);
      if (t1._eval$1("Future<1>")._is(value)) {
        this._chainFuture$1(value);
        return;
      }
      this._asyncCompleteWithValue$1(value);
    },
    _asyncCompleteWithValue$1(value) {
      var _this = this;
      _this.$ti._precomputed1._as(value);
      _this._state ^= 2;
      A._rootScheduleMicrotask(null, null, _this._zone, type$.void_Function._as(new A._Future__asyncCompleteWithValue_closure(_this, value)));
    },
    _chainFuture$1(value) {
      var t1 = this.$ti;
      t1._eval$1("Future<1>")._as(value);
      if (t1._is(value)) {
        A._Future__chainCoreFutureAsync(value, this);
        return;
      }
      this._chainForeignFuture$1(value);
    },
    _asyncCompleteError$2(error, stackTrace) {
      type$.StackTrace._as(stackTrace);
      this._state ^= 2;
      A._rootScheduleMicrotask(null, null, this._zone, type$.void_Function._as(new A._Future__asyncCompleteError_closure(this, error, stackTrace)));
    },
    timeout$1(timeLimit) {
      var _future, _this = this, t1 = {};
      if ((_this._state & 24) !== 0) {
        t1 = new A._Future($.Zone__current, _this.$ti);
        t1._asyncComplete$1(_this);
        return t1;
      }
      _future = new A._Future($.Zone__current, _this.$ti);
      t1.timer = null;
      t1.timer = A.Timer_Timer(timeLimit, new A._Future_timeout_closure(_future, timeLimit));
      _this.then$1$2$onError(new A._Future_timeout_closure0(t1, _this, _future), new A._Future_timeout_closure1(t1, _future), type$.Null);
      return _future;
    },
    $isFuture: 1
  };
  A._Future__addListener_closure.prototype = {
    call$0() {
      A._Future__propagateToListeners(this.$this, this.listener);
    },
    $signature: 0
  };
  A._Future__prependListeners_closure.prototype = {
    call$0() {
      A._Future__propagateToListeners(this.$this, this._box_0.listeners);
    },
    $signature: 0
  };
  A._Future__chainForeignFuture_closure.prototype = {
    call$1(value) {
      var error, stackTrace, exception,
        t1 = this.$this;
      t1._state ^= 2;
      try {
        t1._completeWithValue$1(t1.$ti._precomputed1._as(value));
      } catch (exception) {
        error = A.unwrapException(exception);
        stackTrace = A.getTraceFromException(exception);
        t1._completeError$2(error, stackTrace);
      }
    },
    $signature: 21
  };
  A._Future__chainForeignFuture_closure0.prototype = {
    call$2(error, stackTrace) {
      this.$this._completeError$2(type$.Object._as(error), type$.StackTrace._as(stackTrace));
    },
    $signature: 38
  };
  A._Future__chainForeignFuture_closure1.prototype = {
    call$0() {
      this.$this._completeError$2(this.e, this.s);
    },
    $signature: 0
  };
  A._Future__chainCoreFutureAsync_closure.prototype = {
    call$0() {
      A._Future__chainCoreFutureSync(this._box_0.source, this.target);
    },
    $signature: 0
  };
  A._Future__asyncCompleteWithValue_closure.prototype = {
    call$0() {
      this.$this._completeWithValue$1(this.value);
    },
    $signature: 0
  };
  A._Future__asyncCompleteError_closure.prototype = {
    call$0() {
      this.$this._completeError$2(this.error, this.stackTrace);
    },
    $signature: 0
  };
  A._Future__propagateToListeners_handleWhenCompleteCallback.prototype = {
    call$0() {
      var e, s, t1, exception, t2, originalSource, _this = this, completeResult = null;
      try {
        t1 = _this._box_0.listener;
        completeResult = t1.result._zone.run$1$1(type$.dynamic_Function._as(t1.callback), type$.dynamic);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        t1 = _this.hasError && type$.AsyncError._as(_this._box_1.source._resultOrListeners).error === e;
        t2 = _this._box_0;
        if (t1)
          t2.listenerValueOrError = type$.AsyncError._as(_this._box_1.source._resultOrListeners);
        else
          t2.listenerValueOrError = A.AsyncError$(e, s);
        t2.listenerHasError = true;
        return;
      }
      if (completeResult instanceof A._Future && (completeResult._state & 24) !== 0) {
        if ((completeResult._state & 16) !== 0) {
          t1 = _this._box_0;
          t1.listenerValueOrError = type$.AsyncError._as(completeResult._resultOrListeners);
          t1.listenerHasError = true;
        }
        return;
      }
      if (completeResult instanceof A._Future) {
        originalSource = _this._box_1.source;
        t1 = _this._box_0;
        t1.listenerValueOrError = completeResult.then$1$1(new A._Future__propagateToListeners_handleWhenCompleteCallback_closure(originalSource), type$.dynamic);
        t1.listenerHasError = false;
      }
    },
    $signature: 0
  };
  A._Future__propagateToListeners_handleWhenCompleteCallback_closure.prototype = {
    call$1(_) {
      return this.originalSource;
    },
    $signature: 123
  };
  A._Future__propagateToListeners_handleValueCallback.prototype = {
    call$0() {
      var e, s, t1, t2, t3, t4, t5, exception;
      try {
        t1 = this._box_0;
        t2 = t1.listener;
        t3 = t2.$ti;
        t4 = t3._precomputed1;
        t5 = t4._as(this.sourceResult);
        t1.listenerValueOrError = t2.result._zone.runUnary$2$2(t3._eval$1("2/(1)")._as(t2.callback), t5, t3._eval$1("2/"), t4);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        t1 = this._box_0;
        t1.listenerValueOrError = A.AsyncError$(e, s);
        t1.listenerHasError = true;
      }
    },
    $signature: 0
  };
  A._Future__propagateToListeners_handleError.prototype = {
    call$0() {
      var asyncError, e, s, t1, exception, t2, _this = this;
      try {
        asyncError = type$.AsyncError._as(_this._box_1.source._resultOrListeners);
        t1 = _this._box_0;
        if (t1.listener.matchesErrorTest$1(asyncError) && t1.listener.errorCallback != null) {
          t1.listenerValueOrError = t1.listener.handleError$1(asyncError);
          t1.listenerHasError = false;
        }
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        t1 = type$.AsyncError._as(_this._box_1.source._resultOrListeners);
        t2 = _this._box_0;
        if (t1.error === e)
          t2.listenerValueOrError = t1;
        else
          t2.listenerValueOrError = A.AsyncError$(e, s);
        t2.listenerHasError = true;
      }
    },
    $signature: 0
  };
  A._Future_timeout_closure.prototype = {
    call$0() {
      this._future._completeError$2(new A.TimeoutException("Future not completed", this.timeLimit), B.C__StringStackTrace);
    },
    $signature: 0
  };
  A._Future_timeout_closure0.prototype = {
    call$1(v) {
      var t1;
      this.$this.$ti._precomputed1._as(v);
      t1 = this._box_0.timer;
      if (t1._handle != null) {
        t1.cancel$0();
        this._future._completeWithValue$1(v);
      }
    },
    $signature() {
      return this.$this.$ti._eval$1("Null(1)");
    }
  };
  A._Future_timeout_closure1.prototype = {
    call$2(e, s) {
      var t1;
      type$.Object._as(e);
      type$.StackTrace._as(s);
      t1 = this._box_0.timer;
      if (t1._handle != null) {
        t1.cancel$0();
        this._future._completeError$2(e, s);
      }
    },
    $signature: 38
  };
  A._AsyncCallbackEntry.prototype = {};
  A.Stream.prototype = {
    get$length(_) {
      var t1 = {},
        future = new A._Future($.Zone__current, type$._Future_int);
      t1.count = 0;
      this.listen$4$cancelOnError$onDone$onError(new A.Stream_length_closure(t1, this), true, new A.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    },
    get$first(_) {
      var future = new A._Future($.Zone__current, A._instanceType(this)._eval$1("_Future<Stream.T>")),
        subscription = this.listen$4$cancelOnError$onDone$onError(null, true, new A.Stream_first_closure(future), future.get$_completeError());
      subscription.onData$1(new A.Stream_first_closure0(this, subscription, future));
      return future;
    }
  };
  A.Stream_length_closure.prototype = {
    call$1(_) {
      A._instanceType(this.$this)._eval$1("Stream.T")._as(_);
      ++this._box_0.count;
    },
    $signature() {
      return A._instanceType(this.$this)._eval$1("~(Stream.T)");
    }
  };
  A.Stream_length_closure0.prototype = {
    call$0() {
      this.future._complete$1(this._box_0.count);
    },
    $signature: 0
  };
  A.Stream_first_closure.prototype = {
    call$0() {
      var e, s, t1, exception;
      try {
        t1 = A.IterableElementError_noElement();
        throw A.wrapException(t1);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A._completeWithErrorCallback(this.future, e, s);
      }
    },
    $signature: 0
  };
  A.Stream_first_closure0.prototype = {
    call$1(value) {
      A._cancelAndValue(this.subscription, this.future, A._instanceType(this.$this)._eval$1("Stream.T")._as(value));
    },
    $signature() {
      return A._instanceType(this.$this)._eval$1("~(Stream.T)");
    }
  };
  A.StreamView.prototype = {
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      return this._stream.listen$4$cancelOnError$onDone$onError(A._instanceType(this)._eval$1("~(StreamView.T)?")._as(onData), cancelOnError, type$.nullable_void_Function._as(onDone), onError);
    },
    listen$3$cancelOnError$onDone(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    }
  };
  A._StreamController.prototype = {
    get$_pendingEvents() {
      var t1, _this = this;
      if ((_this._state & 8) === 0)
        return A._instanceType(_this)._eval$1("_PendingEvents<1>?")._as(_this._varData);
      t1 = A._instanceType(_this);
      return t1._eval$1("_PendingEvents<1>?")._as(t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData).get$_varData());
    },
    _ensurePendingEvents$0() {
      var events, t1, _this = this;
      if ((_this._state & 8) === 0) {
        events = _this._varData;
        if (events == null)
          events = _this._varData = new A._PendingEvents(A._instanceType(_this)._eval$1("_PendingEvents<1>"));
        return A._instanceType(_this)._eval$1("_PendingEvents<1>")._as(events);
      }
      t1 = A._instanceType(_this);
      events = t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData).get$_varData();
      return t1._eval$1("_PendingEvents<1>")._as(events);
    },
    get$_subscription() {
      var varData = this._varData;
      if ((this._state & 8) !== 0)
        varData = type$._StreamControllerAddStreamState_nullable_Object._as(varData).get$_varData();
      return A._instanceType(this)._eval$1("_ControllerSubscription<1>")._as(varData);
    },
    _badEventState$0() {
      if ((this._state & 4) !== 0)
        return new A.StateError("Cannot add event after closing");
      return new A.StateError("Cannot add event while adding a stream");
    },
    _ensureDoneFuture$0() {
      var t1 = this._doneFuture;
      if (t1 == null)
        t1 = this._doneFuture = (this._state & 2) !== 0 ? $.$get$Future__nullFuture() : new A._Future($.Zone__current, type$._Future_void);
      return t1;
    },
    add$1(_, value) {
      var _this = this;
      A._instanceType(_this)._precomputed1._as(value);
      if (_this._state >= 4)
        throw A.wrapException(_this._badEventState$0());
      _this._async$_add$1(value);
    },
    close$0() {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 4) !== 0)
        return _this._ensureDoneFuture$0();
      if (t1 >= 4)
        throw A.wrapException(_this._badEventState$0());
      _this._closeUnchecked$0();
      return _this._ensureDoneFuture$0();
    },
    _closeUnchecked$0() {
      var t1 = this._state |= 4;
      if ((t1 & 1) !== 0)
        this._sendDone$0();
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, B.C__DelayedDone);
    },
    _async$_add$1(value) {
      var t2, _this = this,
        t1 = A._instanceType(_this);
      t1._precomputed1._as(value);
      t2 = _this._state;
      if ((t2 & 1) !== 0)
        _this._sendData$1(value);
      else if ((t2 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, new A._DelayedData(value, t1._eval$1("_DelayedData<1>")));
    },
    _subscribe$4(onData, onError, onDone, cancelOnError) {
      var t2, t3, t4, subscription, pendingEvents, addState, _this = this,
        t1 = A._instanceType(_this);
      t1._eval$1("~(1)?")._as(onData);
      type$.nullable_void_Function._as(onDone);
      if ((_this._state & 3) !== 0)
        throw A.wrapException(A.StateError$("Stream has already been listened to."));
      t2 = $.Zone__current;
      t3 = cancelOnError ? 1 : 0;
      t4 = onError != null ? 32 : 0;
      subscription = new A._ControllerSubscription(_this, A._BufferingStreamSubscription__registerDataHandler(t2, onData, t1._precomputed1), A._BufferingStreamSubscription__registerErrorHandler(t2, onError), A._BufferingStreamSubscription__registerDoneHandler(t2, onDone), t2, t3 | t4, t1._eval$1("_ControllerSubscription<1>"));
      pendingEvents = _this.get$_pendingEvents();
      t4 = _this._state |= 1;
      if ((t4 & 8) !== 0) {
        addState = t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData);
        addState.set$_varData(subscription);
        addState.resume$0();
      } else
        _this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new A._StreamController__subscribe_closure(_this));
      return subscription;
    },
    _recordCancel$1(subscription) {
      var result, onCancel, cancelResult, e, s, exception, result0, _this = this,
        t1 = A._instanceType(_this);
      t1._eval$1("StreamSubscription<1>")._as(subscription);
      result = null;
      if ((_this._state & 8) !== 0)
        result = t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData).cancel$0();
      _this._varData = null;
      _this._state = _this._state & 4294967286 | 2;
      onCancel = _this.onCancel;
      if (onCancel != null)
        if (result == null)
          try {
            cancelResult = onCancel.call$0();
            if (cancelResult instanceof A._Future)
              result = cancelResult;
          } catch (exception) {
            e = A.unwrapException(exception);
            s = A.getTraceFromException(exception);
            result0 = new A._Future($.Zone__current, type$._Future_void);
            result0._asyncCompleteError$2(e, s);
            result = result0;
          }
        else
          result = result.whenComplete$1(onCancel);
      t1 = new A._StreamController__recordCancel_complete(_this);
      if (result != null)
        result = result.whenComplete$1(t1);
      else
        t1.call$0();
      return result;
    },
    set$onListen(onListen) {
      this.onListen = type$.nullable_void_Function._as(onListen);
    },
    set$onPause(onPause) {
      this.onPause = type$.nullable_void_Function._as(onPause);
    },
    set$onResume(onResume) {
      this.onResume = type$.nullable_void_Function._as(onResume);
    },
    set$onCancel(onCancel) {
      this.onCancel = type$.nullable_void_Function._as(onCancel);
    },
    $isStreamController: 1,
    $is_StreamControllerLifecycle: 1,
    $is_EventDispatch: 1
  };
  A._StreamController__subscribe_closure.prototype = {
    call$0() {
      A._runGuarded(this.$this.onListen);
    },
    $signature: 0
  };
  A._StreamController__recordCancel_complete.prototype = {
    call$0() {
      var doneFuture = this.$this._doneFuture;
      if (doneFuture != null && (doneFuture._state & 30) === 0)
        doneFuture._asyncComplete$1(null);
    },
    $signature: 0
  };
  A._SyncStreamControllerDispatch.prototype = {
    _sendData$1(data) {
      this.$ti._precomputed1._as(data);
      this.get$_subscription()._async$_add$1(data);
    },
    _sendError$2(error, stackTrace) {
      this.get$_subscription()._addError$2(error, stackTrace);
    },
    _sendDone$0() {
      this.get$_subscription()._close$0();
    }
  };
  A._AsyncStreamControllerDispatch.prototype = {
    _sendData$1(data) {
      var t1 = this.$ti;
      t1._precomputed1._as(data);
      this.get$_subscription()._addPending$1(new A._DelayedData(data, t1._eval$1("_DelayedData<1>")));
    },
    _sendError$2(error, stackTrace) {
      this.get$_subscription()._addPending$1(new A._DelayedError(error, stackTrace));
    },
    _sendDone$0() {
      this.get$_subscription()._addPending$1(B.C__DelayedDone);
    }
  };
  A._AsyncStreamController.prototype = {};
  A._SyncStreamController.prototype = {};
  A._ControllerStream.prototype = {
    get$hashCode(_) {
      return (A.Primitives_objectHashCode(this._controller) ^ 892482866) >>> 0;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return other instanceof A._ControllerStream && other._controller === this._controller;
    }
  };
  A._ControllerSubscription.prototype = {
    _onCancel$0() {
      return this._controller._recordCancel$1(this);
    },
    _onPause$0() {
      var t1 = this._controller,
        t2 = A._instanceType(t1);
      t2._eval$1("StreamSubscription<1>")._as(this);
      if ((t1._state & 8) !== 0)
        t2._eval$1("_StreamControllerAddStreamState<1>")._as(t1._varData).pause$0();
      A._runGuarded(t1.onPause);
    },
    _onResume$0() {
      var t1 = this._controller,
        t2 = A._instanceType(t1);
      t2._eval$1("StreamSubscription<1>")._as(this);
      if ((t1._state & 8) !== 0)
        t2._eval$1("_StreamControllerAddStreamState<1>")._as(t1._varData).resume$0();
      A._runGuarded(t1.onResume);
    }
  };
  A._BufferingStreamSubscription.prototype = {
    _setPendingEvents$1(pendingEvents) {
      var _this = this;
      A._instanceType(_this)._eval$1("_PendingEvents<1>?")._as(pendingEvents);
      if (pendingEvents == null)
        return;
      _this.set$_pending(pendingEvents);
      if (pendingEvents.lastPendingEvent != null) {
        _this._state = (_this._state | 128) >>> 0;
        pendingEvents.schedule$1(_this);
      }
    },
    onData$1(handleData) {
      var t1 = A._instanceType(this);
      this.set$_async$_onData(A._BufferingStreamSubscription__registerDataHandler(this._zone, t1._eval$1("~(1)?")._as(handleData), t1._precomputed1));
    },
    onError$1(handleError) {
      var _this = this,
        t1 = _this._state;
      if (handleError == null)
        _this._state = (t1 & 4294967263) >>> 0;
      else
        _this._state = (t1 | 32) >>> 0;
      _this._onError = A._BufferingStreamSubscription__registerErrorHandler(_this._zone, handleError);
    },
    cancel$0() {
      var _this = this,
        t1 = (_this._state & 4294967279) >>> 0;
      _this._state = t1;
      if ((t1 & 8) === 0)
        _this._cancel$0();
      t1 = _this._cancelFuture;
      return t1 == null ? $.$get$Future__nullFuture() : t1;
    },
    _cancel$0() {
      var t2, _this = this,
        t1 = _this._state = (_this._state | 8) >>> 0;
      if ((t1 & 128) !== 0) {
        t2 = _this._pending;
        if (t2._state === 1)
          t2._state = 3;
      }
      if ((t1 & 64) === 0)
        _this.set$_pending(null);
      _this._cancelFuture = _this._onCancel$0();
    },
    _async$_add$1(data) {
      var t2, _this = this,
        t1 = A._instanceType(_this);
      t1._precomputed1._as(data);
      t2 = _this._state;
      if ((t2 & 8) !== 0)
        return;
      if (t2 < 64)
        _this._sendData$1(data);
      else
        _this._addPending$1(new A._DelayedData(data, t1._eval$1("_DelayedData<1>")));
    },
    _addError$2(error, stackTrace) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 64)
        this._sendError$2(error, stackTrace);
      else
        this._addPending$1(new A._DelayedError(error, stackTrace));
    },
    _close$0() {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      t1 = (t1 | 2) >>> 0;
      _this._state = t1;
      if (t1 < 64)
        _this._sendDone$0();
      else
        _this._addPending$1(B.C__DelayedDone);
    },
    _onPause$0() {
    },
    _onResume$0() {
    },
    _onCancel$0() {
      return null;
    },
    _addPending$1($event) {
      var t1, _this = this,
        pending = _this._pending;
      if (pending == null) {
        pending = new A._PendingEvents(A._instanceType(_this)._eval$1("_PendingEvents<1>"));
        _this.set$_pending(pending);
      }
      pending.add$1(0, $event);
      t1 = _this._state;
      if ((t1 & 128) === 0) {
        t1 = (t1 | 128) >>> 0;
        _this._state = t1;
        if (t1 < 256)
          pending.schedule$1(_this);
      }
    },
    _sendData$1(data) {
      var t2, _this = this,
        t1 = A._instanceType(_this)._precomputed1;
      t1._as(data);
      t2 = _this._state;
      _this._state = (t2 | 64) >>> 0;
      _this._zone.runUnaryGuarded$1$2(_this._async$_onData, data, t1);
      _this._state = (_this._state & 4294967231) >>> 0;
      _this._checkState$1((t2 & 4) !== 0);
    },
    _sendError$2(error, stackTrace) {
      var cancelFuture, _this = this,
        t1 = _this._state,
        t2 = new A._BufferingStreamSubscription__sendError_sendError(_this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        _this._state = (t1 | 16) >>> 0;
        _this._cancel$0();
        cancelFuture = _this._cancelFuture;
        if (cancelFuture != null && cancelFuture !== $.$get$Future__nullFuture())
          cancelFuture.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        _this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0() {
      var cancelFuture, _this = this,
        t1 = new A._BufferingStreamSubscription__sendDone_sendDone(_this);
      _this._cancel$0();
      _this._state = (_this._state | 16) >>> 0;
      cancelFuture = _this._cancelFuture;
      if (cancelFuture != null && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1(callback) {
      var t1, _this = this;
      type$.void_Function._as(callback);
      t1 = _this._state;
      _this._state = (t1 | 64) >>> 0;
      callback.call$0();
      _this._state = (_this._state & 4294967231) >>> 0;
      _this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1(wasInputPaused) {
      var t2, isInputPaused, _this = this,
        t1 = _this._state;
      if ((t1 & 128) !== 0 && _this._pending.lastPendingEvent == null) {
        t1 = _this._state = (t1 & 4294967167) >>> 0;
        if ((t1 & 4) !== 0)
          if (t1 < 256) {
            t2 = _this._pending;
            t2 = t2 == null ? null : t2.lastPendingEvent == null;
            t2 = t2 !== false;
          } else
            t2 = false;
        else
          t2 = false;
        if (t2) {
          t1 = (t1 & 4294967291) >>> 0;
          _this._state = t1;
        }
      }
      for (; true; wasInputPaused = isInputPaused) {
        if ((t1 & 8) !== 0) {
          _this.set$_pending(null);
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        _this._state = (t1 ^ 64) >>> 0;
        if (isInputPaused)
          _this._onPause$0();
        else
          _this._onResume$0();
        t1 = (_this._state & 4294967231) >>> 0;
        _this._state = t1;
      }
      if ((t1 & 128) !== 0 && t1 < 256)
        _this._pending.schedule$1(_this);
    },
    set$_async$_onData(_onData) {
      this._async$_onData = A._instanceType(this)._eval$1("~(1)")._as(_onData);
    },
    set$_pending(_pending) {
      this._pending = A._instanceType(this)._eval$1("_PendingEvents<1>?")._as(_pending);
    },
    $isStreamSubscription: 1,
    $is_EventDispatch: 1
  };
  A._BufferingStreamSubscription__sendError_sendError.prototype = {
    call$0() {
      var onError, t3, t4,
        t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 64) >>> 0;
      onError = t1._onError;
      t2 = this.error;
      t3 = type$.Object;
      t4 = t1._zone;
      if (type$.void_Function_Object_StackTrace._is(onError))
        t4.runBinaryGuarded$2$3(onError, t2, this.stackTrace, t3, type$.StackTrace);
      else
        t4.runUnaryGuarded$1$2(type$.void_Function_Object._as(onError), t2, t3);
      t1._state = (t1._state & 4294967231) >>> 0;
    },
    $signature: 0
  };
  A._BufferingStreamSubscription__sendDone_sendDone.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 74) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967231) >>> 0;
    },
    $signature: 0
  };
  A._StreamImpl.prototype = {
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      var t1 = this.$ti;
      t1._eval$1("~(1)?")._as(onData);
      type$.nullable_void_Function._as(onDone);
      return this._controller._subscribe$4(t1._eval$1("~(1)?")._as(onData), onError, onDone, cancelOnError === true);
    },
    listen$3$cancelOnError$onDone(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    },
    listen$1(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    }
  };
  A._DelayedEvent.prototype = {
    set$next(next) {
      this.next = type$.nullable__DelayedEvent_dynamic._as(next);
    },
    get$next() {
      return this.next;
    }
  };
  A._DelayedData.prototype = {
    perform$1(dispatch) {
      this.$ti._eval$1("_EventDispatch<1>")._as(dispatch)._sendData$1(this.value);
    },
    get$value() {
      return this.value;
    }
  };
  A._DelayedError.prototype = {
    perform$1(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    }
  };
  A._DelayedDone.prototype = {
    perform$1(dispatch) {
      dispatch._sendDone$0();
    },
    get$next() {
      return null;
    },
    set$next(_) {
      throw A.wrapException(A.StateError$("No events after a done."));
    },
    $is_DelayedEvent: 1
  };
  A._PendingEvents.prototype = {
    schedule$1(dispatch) {
      var t1, _this = this;
      _this.$ti._eval$1("_EventDispatch<1>")._as(dispatch);
      t1 = _this._state;
      if (t1 === 1)
        return;
      if (t1 >= 1) {
        _this._state = 1;
        return;
      }
      A.scheduleMicrotask(new A._PendingEvents_schedule_closure(_this, dispatch));
      _this._state = 1;
    },
    add$1(_, $event) {
      var _this = this,
        lastEvent = _this.lastPendingEvent;
      if (lastEvent == null)
        _this.firstPendingEvent = _this.lastPendingEvent = $event;
      else {
        lastEvent.set$next($event);
        _this.lastPendingEvent = $event;
      }
    }
  };
  A._PendingEvents_schedule_closure.prototype = {
    call$0() {
      var t2, $event, nextEvent,
        t1 = this.$this,
        oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t2 = t1.$ti._eval$1("_EventDispatch<1>")._as(this.dispatch);
      $event = t1.firstPendingEvent;
      nextEvent = $event.get$next();
      t1.firstPendingEvent = nextEvent;
      if (nextEvent == null)
        t1.lastPendingEvent = null;
      $event.perform$1(t2);
    },
    $signature: 0
  };
  A._DoneStreamSubscription.prototype = {
    onData$1(handleData) {
      this.$ti._eval$1("~(1)?")._as(handleData);
    },
    onError$1(handleError) {
    },
    cancel$0() {
      this._state = -1;
      this.set$_onDone(null);
      return $.$get$Future__nullFuture();
    },
    _onMicrotask$0() {
      var _0_0, _this = this,
        unscheduledState = _this._state - 1;
      if (unscheduledState === 0) {
        _this._state = -1;
        _0_0 = _this._onDone;
        if (_0_0 != null) {
          _this.set$_onDone(null);
          _this._zone.runGuarded$1(_0_0);
        }
      } else
        _this._state = unscheduledState;
    },
    set$_onDone(_onDone) {
      this._onDone = type$.nullable_void_Function._as(_onDone);
    },
    $isStreamSubscription: 1
  };
  A._StreamIterator.prototype = {};
  A._EmptyStream.prototype = {
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      var t1 = this.$ti;
      t1._eval$1("~(1)?")._as(onData);
      type$.nullable_void_Function._as(onDone);
      t1 = new A._DoneStreamSubscription($.Zone__current, t1._eval$1("_DoneStreamSubscription<1>"));
      A.scheduleMicrotask(t1.get$_onMicrotask());
      t1.set$_onDone(type$.void_Function._as(onDone));
      return t1;
    },
    listen$3$cancelOnError$onDone(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    }
  };
  A._cancelAndValue_closure.prototype = {
    call$0() {
      return this.future._complete$1(this.value);
    },
    $signature: 0
  };
  A._Zone.prototype = {$isZone: 1};
  A._rootHandleError_closure.prototype = {
    call$0() {
      A.Error_throwWithStackTrace(this.error, this.stackTrace);
    },
    $signature: 0
  };
  A._RootZone.prototype = {
    runGuarded$1(f) {
      var e, s, exception;
      type$.void_Function._as(f);
      try {
        if (B.C__RootZone === $.Zone__current) {
          f.call$0();
          return;
        }
        A._rootRun(null, null, this, f, type$.void);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A._rootHandleError(type$.Object._as(e), type$.StackTrace._as(s));
      }
    },
    runUnaryGuarded$1$2(f, arg, $T) {
      var e, s, exception;
      $T._eval$1("~(0)")._as(f);
      $T._as(arg);
      try {
        if (B.C__RootZone === $.Zone__current) {
          f.call$1(arg);
          return;
        }
        A._rootRunUnary(null, null, this, f, arg, type$.void, $T);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A._rootHandleError(type$.Object._as(e), type$.StackTrace._as(s));
      }
    },
    runBinaryGuarded$2$3(f, arg1, arg2, T1, T2) {
      var e, s, exception;
      T1._eval$1("@<0>")._bind$1(T2)._eval$1("~(1,2)")._as(f);
      T1._as(arg1);
      T2._as(arg2);
      try {
        if (B.C__RootZone === $.Zone__current) {
          f.call$2(arg1, arg2);
          return;
        }
        A._rootRunBinary(null, null, this, f, arg1, arg2, type$.void, T1, T2);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A._rootHandleError(type$.Object._as(e), type$.StackTrace._as(s));
      }
    },
    bindCallbackGuarded$1(f) {
      return new A._RootZone_bindCallbackGuarded_closure(this, type$.void_Function._as(f));
    },
    bindUnaryCallbackGuarded$1$1(f, $T) {
      return new A._RootZone_bindUnaryCallbackGuarded_closure(this, $T._eval$1("~(0)")._as(f), $T);
    },
    run$1$1(f, $R) {
      $R._eval$1("0()")._as(f);
      if ($.Zone__current === B.C__RootZone)
        return f.call$0();
      return A._rootRun(null, null, this, f, $R);
    },
    runUnary$2$2(f, arg, $R, $T) {
      $R._eval$1("@<0>")._bind$1($T)._eval$1("1(2)")._as(f);
      $T._as(arg);
      if ($.Zone__current === B.C__RootZone)
        return f.call$1(arg);
      return A._rootRunUnary(null, null, this, f, arg, $R, $T);
    },
    runBinary$3$3(f, arg1, arg2, $R, T1, T2) {
      $R._eval$1("@<0>")._bind$1(T1)._bind$1(T2)._eval$1("1(2,3)")._as(f);
      T1._as(arg1);
      T2._as(arg2);
      if ($.Zone__current === B.C__RootZone)
        return f.call$2(arg1, arg2);
      return A._rootRunBinary(null, null, this, f, arg1, arg2, $R, T1, T2);
    },
    registerBinaryCallback$3$1(f, $R, T1, T2) {
      return $R._eval$1("@<0>")._bind$1(T1)._bind$1(T2)._eval$1("1(2,3)")._as(f);
    }
  };
  A._RootZone_bindCallbackGuarded_closure.prototype = {
    call$0() {
      return this.$this.runGuarded$1(this.f);
    },
    $signature: 0
  };
  A._RootZone_bindUnaryCallbackGuarded_closure.prototype = {
    call$1(arg) {
      var t1 = this.T;
      return this.$this.runUnaryGuarded$1$2(this.f, t1._as(arg), t1);
    },
    $signature() {
      return this.T._eval$1("~(0)");
    }
  };
  A._HashMap.prototype = {
    get$length(_) {
      return this._collection$_length;
    },
    get$isEmpty(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty(_) {
      return this._collection$_length !== 0;
    },
    get$keys() {
      return new A._HashMapKeyIterable(this, this.$ti._eval$1("_HashMapKeyIterable<1>"));
    },
    containsKey$1(key) {
      var strings, nums;
      if (typeof key == "string" && key !== "__proto__") {
        strings = this._collection$_strings;
        return strings == null ? false : strings[key] != null;
      } else if (typeof key == "number" && (key & 1073741823) === key) {
        nums = this._collection$_nums;
        return nums == null ? false : nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1(key) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(this._getBucket$2(rest, key), key) >= 0;
    },
    $index(_, key) {
      var strings, t1, nums;
      if (typeof key == "string" && key !== "__proto__") {
        strings = this._collection$_strings;
        t1 = strings == null ? null : A._HashMap__getTableEntry(strings, key);
        return t1;
      } else if (typeof key == "number" && (key & 1073741823) === key) {
        nums = this._collection$_nums;
        t1 = nums == null ? null : A._HashMap__getTableEntry(nums, key);
        return t1;
      } else
        return this._get$1(key);
    },
    _get$1(key) {
      var bucket, index,
        rest = this._collection$_rest;
      if (rest == null)
        return null;
      bucket = this._getBucket$2(rest, key);
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet(_, key, value) {
      var strings, nums, rest, hash, bucket, index, _this = this,
        t1 = _this.$ti;
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      if (typeof key == "string" && key !== "__proto__") {
        strings = _this._collection$_strings;
        _this._collection$_addHashTableEntry$3(strings == null ? _this._collection$_strings = A._HashMap__newHashTable() : strings, key, value);
      } else if (typeof key == "number" && (key & 1073741823) === key) {
        nums = _this._collection$_nums;
        _this._collection$_addHashTableEntry$3(nums == null ? _this._collection$_nums = A._HashMap__newHashTable() : nums, key, value);
      } else {
        rest = _this._collection$_rest;
        if (rest == null)
          rest = _this._collection$_rest = A._HashMap__newHashTable();
        hash = A.objectHashCode(key) & 1073741823;
        bucket = rest[hash];
        if (bucket == null) {
          A._HashMap__setTableEntry(rest, hash, [key, value]);
          ++_this._collection$_length;
          _this._collection$_keys = null;
        } else {
          index = _this._findBucketIndex$2(bucket, key);
          if (index >= 0)
            bucket[index + 1] = value;
          else {
            bucket.push(key, value);
            ++_this._collection$_length;
            _this._collection$_keys = null;
          }
        }
      }
    },
    forEach$1(_, action) {
      var keys, $length, t2, i, key, t3, _this = this,
        t1 = _this.$ti;
      t1._eval$1("~(1,2)")._as(action);
      keys = _this._computeKeys$0();
      for ($length = keys.length, t2 = t1._precomputed1, t1 = t1._rest[1], i = 0; i < $length; ++i) {
        key = keys[i];
        t2._as(key);
        t3 = _this.$index(0, key);
        action.call$2(key, t3 == null ? t1._as(t3) : t3);
        if (keys !== _this._collection$_keys)
          throw A.wrapException(A.ConcurrentModificationError$(_this));
      }
    },
    _computeKeys$0() {
      var strings, names, entries, index, i, nums, rest, bucket, $length, i0, _this = this,
        result = _this._collection$_keys;
      if (result != null)
        return result;
      result = A.List_List$filled(_this._collection$_length, null, false, type$.dynamic);
      strings = _this._collection$_strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = _this._collection$_nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = _this._collection$_rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; i0 += 2) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      return _this._collection$_keys = result;
    },
    _collection$_addHashTableEntry$3(table, key, value) {
      var t1 = this.$ti;
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      if (table[key] == null) {
        ++this._collection$_length;
        this._collection$_keys = null;
      }
      A._HashMap__setTableEntry(table, key, value);
    },
    _getBucket$2(table, key) {
      return table[A.objectHashCode(key) & 1073741823];
    }
  };
  A._IdentityHashMap.prototype = {
    _findBucketIndex$2(bucket, key) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2) {
        t1 = bucket[i];
        if (t1 == null ? key == null : t1 === key)
          return i;
      }
      return -1;
    }
  };
  A._HashMapKeyIterable.prototype = {
    get$length(_) {
      return this._collection$_map._collection$_length;
    },
    get$isEmpty(_) {
      return this._collection$_map._collection$_length === 0;
    },
    get$isNotEmpty(_) {
      return this._collection$_map._collection$_length !== 0;
    },
    get$iterator(_) {
      var t1 = this._collection$_map;
      return new A._HashMapKeyIterator(t1, t1._computeKeys$0(), this.$ti._eval$1("_HashMapKeyIterator<1>"));
    },
    contains$1(_, element) {
      return this._collection$_map.containsKey$1(element);
    }
  };
  A._HashMapKeyIterator.prototype = {
    get$current() {
      var t1 = this._collection$_current;
      return t1 == null ? this.$ti._precomputed1._as(t1) : t1;
    },
    moveNext$0() {
      var _this = this,
        keys = _this._collection$_keys,
        offset = _this._offset,
        t1 = _this._collection$_map;
      if (keys !== t1._collection$_keys)
        throw A.wrapException(A.ConcurrentModificationError$(t1));
      else if (offset >= keys.length) {
        _this.set$_collection$_current(null);
        return false;
      } else {
        _this.set$_collection$_current(keys[offset]);
        _this._offset = offset + 1;
        return true;
      }
    },
    set$_collection$_current(_current) {
      this._collection$_current = this.$ti._eval$1("1?")._as(_current);
    },
    $isIterator: 1
  };
  A._LinkedCustomHashMap.prototype = {
    $index(_, key) {
      if (!A.boolConversionCheck(this._validKey.call$1(key)))
        return null;
      return this.super$JsLinkedHashMap$internalGet(key);
    },
    $indexSet(_, key, value) {
      var t1 = this.$ti;
      this.super$JsLinkedHashMap$internalSet(t1._precomputed1._as(key), t1._rest[1]._as(value));
    },
    containsKey$1(key) {
      if (!A.boolConversionCheck(this._validKey.call$1(key)))
        return false;
      return this.super$JsLinkedHashMap$internalContainsKey(key);
    },
    remove$1(_, key) {
      if (!A.boolConversionCheck(this._validKey.call$1(key)))
        return null;
      return this.super$JsLinkedHashMap$internalRemove(key);
    },
    internalComputeHashCode$1(key) {
      return this._hashCode.call$1(this.$ti._precomputed1._as(key)) & 1073741823;
    },
    internalFindBucketIndex$2(bucket, key) {
      var $length, t1, t2, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (t1 = this.$ti._precomputed1, t2 = this._equals, i = 0; i < $length; ++i)
        if (A.boolConversionCheck(t2.call$2(t1._as(bucket[i].hashMapCellKey), t1._as(key))))
          return i;
      return -1;
    }
  };
  A._LinkedCustomHashMap_closure.prototype = {
    call$1(v) {
      return this.K._is(v);
    },
    $signature: 110
  };
  A._LinkedHashSet.prototype = {
    get$iterator(_) {
      var _this = this,
        t1 = new A._LinkedHashSetIterator(_this, _this._collection$_modifications, A._instanceType(_this)._eval$1("_LinkedHashSetIterator<1>"));
      t1._collection$_cell = _this._collection$_first;
      return t1;
    },
    get$length(_) {
      return this._collection$_length;
    },
    get$isEmpty(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty(_) {
      return this._collection$_length !== 0;
    },
    contains$1(_, object) {
      var strings, nums;
      if (typeof object == "string" && object !== "__proto__") {
        strings = this._collection$_strings;
        if (strings == null)
          return false;
        return type$.nullable__LinkedHashSetCell._as(strings[object]) != null;
      } else if (typeof object == "number" && (object & 1073741823) === object) {
        nums = this._collection$_nums;
        if (nums == null)
          return false;
        return type$.nullable__LinkedHashSetCell._as(nums[object]) != null;
      } else
        return this._contains$1(object);
    },
    _contains$1(object) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    get$last(_) {
      var last = this._collection$_last;
      if (last == null)
        throw A.wrapException(A.StateError$("No elements"));
      return A._instanceType(this)._precomputed1._as(last._element);
    },
    add$1(_, element) {
      var strings, nums, _this = this;
      A._instanceType(_this)._precomputed1._as(element);
      if (typeof element == "string" && element !== "__proto__") {
        strings = _this._collection$_strings;
        return _this._collection$_addHashTableEntry$2(strings == null ? _this._collection$_strings = A._LinkedHashSet__newHashTable() : strings, element);
      } else if (typeof element == "number" && (element & 1073741823) === element) {
        nums = _this._collection$_nums;
        return _this._collection$_addHashTableEntry$2(nums == null ? _this._collection$_nums = A._LinkedHashSet__newHashTable() : nums, element);
      } else
        return _this._add$1(element);
    },
    _add$1(element) {
      var rest, hash, bucket, _this = this;
      A._instanceType(_this)._precomputed1._as(element);
      rest = _this._collection$_rest;
      if (rest == null)
        rest = _this._collection$_rest = A._LinkedHashSet__newHashTable();
      hash = _this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [_this._collection$_newLinkedCell$1(element)];
      else {
        if (_this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(_this._collection$_newLinkedCell$1(element));
      }
      return true;
    },
    remove$1(_, object) {
      var t1 = this._remove$1(object);
      return t1;
    },
    _remove$1(object) {
      var hash, bucket, index, cell, _this = this,
        rest = _this._collection$_rest;
      if (rest == null)
        return false;
      hash = _this._computeHashCode$1(object);
      bucket = rest[hash];
      index = _this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      cell = bucket.splice(index, 1)[0];
      if (0 === bucket.length)
        delete rest[hash];
      _this._collection$_unlinkCell$1(cell);
      return true;
    },
    _collection$_addHashTableEntry$2(table, element) {
      A._instanceType(this)._precomputed1._as(element);
      if (type$.nullable__LinkedHashSetCell._as(table[element]) != null)
        return false;
      table[element] = this._collection$_newLinkedCell$1(element);
      return true;
    },
    _collection$_modified$0() {
      this._collection$_modifications = this._collection$_modifications + 1 & 1073741823;
    },
    _collection$_newLinkedCell$1(element) {
      var t1, _this = this,
        cell = new A._LinkedHashSetCell(A._instanceType(_this)._precomputed1._as(element));
      if (_this._collection$_first == null)
        _this._collection$_first = _this._collection$_last = cell;
      else {
        t1 = _this._collection$_last;
        t1.toString;
        cell._collection$_previous = t1;
        _this._collection$_last = t1._collection$_next = cell;
      }
      ++_this._collection$_length;
      _this._collection$_modified$0();
      return cell;
    },
    _collection$_unlinkCell$1(cell) {
      var _this = this,
        previous = cell._collection$_previous,
        next = cell._collection$_next;
      if (previous == null)
        _this._collection$_first = next;
      else
        previous._collection$_next = next;
      if (next == null)
        _this._collection$_last = previous;
      else
        next._collection$_previous = previous;
      --_this._collection$_length;
      _this._collection$_modified$0();
    },
    _computeHashCode$1(element) {
      return J.get$hashCode$(element) & 1073741823;
    },
    _findBucketIndex$2(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i]._element, element))
          return i;
      return -1;
    }
  };
  A._LinkedHashSetCell.prototype = {};
  A._LinkedHashSetIterator.prototype = {
    get$current() {
      var t1 = this._collection$_current;
      return t1 == null ? this.$ti._precomputed1._as(t1) : t1;
    },
    moveNext$0() {
      var _this = this,
        cell = _this._collection$_cell,
        t1 = _this._set;
      if (_this._collection$_modifications !== t1._collection$_modifications)
        throw A.wrapException(A.ConcurrentModificationError$(t1));
      else if (cell == null) {
        _this.set$_collection$_current(null);
        return false;
      } else {
        _this.set$_collection$_current(_this.$ti._eval$1("1?")._as(cell._element));
        _this._collection$_cell = cell._collection$_next;
        return true;
      }
    },
    set$_collection$_current(_current) {
      this._collection$_current = this.$ti._eval$1("1?")._as(_current);
    },
    $isIterator: 1
  };
  A.LinkedHashMap_LinkedHashMap$from_closure.prototype = {
    call$2(k, v) {
      this.result.$indexSet(0, this.K._as(k), this.V._as(v));
    },
    $signature: 109
  };
  A.ListBase.prototype = {
    get$iterator(receiver) {
      return new A.ListIterator(receiver, this.get$length(receiver), A.instanceType(receiver)._eval$1("ListIterator<ListBase.E>"));
    },
    elementAt$1(receiver, index) {
      return this.$index(receiver, index);
    },
    get$isEmpty(receiver) {
      return this.get$length(receiver) === 0;
    },
    get$isNotEmpty(receiver) {
      return !this.get$isEmpty(receiver);
    },
    get$last(receiver) {
      if (this.get$length(receiver) === 0)
        throw A.wrapException(A.IterableElementError_noElement());
      return this.$index(receiver, this.get$length(receiver) - 1);
    },
    contains$1(receiver, element) {
      var i,
        $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        if (J.$eq$(this.$index(receiver, i), element))
          return true;
        if ($length !== this.get$length(receiver))
          throw A.wrapException(A.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    any$1(receiver, test) {
      var $length, i;
      A.instanceType(receiver)._eval$1("bool(ListBase.E)")._as(test);
      $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        if (A.boolConversionCheck(test.call$1(this.$index(receiver, i))))
          return true;
        if ($length !== this.get$length(receiver))
          throw A.wrapException(A.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    join$1(receiver, separator) {
      var t1;
      if (this.get$length(receiver) === 0)
        return "";
      t1 = A.StringBuffer__writeAll("", receiver, separator);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    where$1(receiver, test) {
      var t1 = A.instanceType(receiver);
      return new A.WhereIterable(receiver, t1._eval$1("bool(ListBase.E)")._as(test), t1._eval$1("WhereIterable<ListBase.E>"));
    },
    map$1$1(receiver, f, $T) {
      var t1 = A.instanceType(receiver);
      return new A.MappedListIterable(receiver, t1._bind$1($T)._eval$1("1(ListBase.E)")._as(f), t1._eval$1("@<ListBase.E>")._bind$1($T)._eval$1("MappedListIterable<1,2>"));
    },
    fold$1$2(receiver, initialValue, combine, $T) {
      var $length, value, i;
      $T._as(initialValue);
      A.instanceType(receiver)._bind$1($T)._eval$1("1(1,ListBase.E)")._as(combine);
      $length = this.get$length(receiver);
      for (value = initialValue, i = 0; i < $length; ++i) {
        value = combine.call$2(value, this.$index(receiver, i));
        if ($length !== this.get$length(receiver))
          throw A.wrapException(A.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    skip$1(receiver, count) {
      return A.SubListIterable$(receiver, count, null, A.instanceType(receiver)._eval$1("ListBase.E"));
    },
    take$1(receiver, count) {
      return A.SubListIterable$(receiver, 0, A.checkNotNullable(count, "count", type$.int), A.instanceType(receiver)._eval$1("ListBase.E"));
    },
    toList$1$growable(receiver, growable) {
      var t1, first, result, i, _this = this;
      if (_this.get$isEmpty(receiver)) {
        t1 = J.JSArray_JSArray$growable(0, A.instanceType(receiver)._eval$1("ListBase.E"));
        return t1;
      }
      first = _this.$index(receiver, 0);
      result = A.List_List$filled(_this.get$length(receiver), first, true, A.instanceType(receiver)._eval$1("ListBase.E"));
      for (i = 1; i < _this.get$length(receiver); ++i)
        B.JSArray_methods.$indexSet(result, i, _this.$index(receiver, i));
      return result;
    },
    toList$0(receiver) {
      return this.toList$1$growable(receiver, true);
    },
    add$1(receiver, element) {
      var t1;
      A.instanceType(receiver)._eval$1("ListBase.E")._as(element);
      t1 = this.get$length(receiver);
      this.set$length(receiver, t1 + 1);
      this.$indexSet(receiver, t1, element);
    },
    sort$1(receiver, compare) {
      var t2,
        t1 = A.instanceType(receiver);
      t1._eval$1("int(ListBase.E,ListBase.E)?")._as(compare);
      t2 = compare == null ? A.collection_ListBase__compareAny$closure() : compare;
      A.Sort__doSort(receiver, 0, this.get$length(receiver) - 1, t2, t1._eval$1("ListBase.E"));
    },
    sublist$2(receiver, start, end) {
      var listLength = this.get$length(receiver);
      if (end == null)
        end = listLength;
      A.RangeError_checkValidRange(start, end, listLength);
      return A.List_List$from(this.getRange$2(receiver, start, end), true, A.instanceType(receiver)._eval$1("ListBase.E"));
    },
    sublist$1(receiver, start) {
      return this.sublist$2(receiver, start, null);
    },
    getRange$2(receiver, start, end) {
      A.RangeError_checkValidRange(start, end, this.get$length(receiver));
      return A.SubListIterable$(receiver, start, end, A.instanceType(receiver)._eval$1("ListBase.E"));
    },
    fillRange$3(receiver, start, end, fill) {
      var i;
      A.instanceType(receiver)._eval$1("ListBase.E?")._as(fill);
      A.RangeError_checkValidRange(start, end, this.get$length(receiver));
      for (i = start; i < end; ++i)
        this.$indexSet(receiver, i, fill);
    },
    setRange$4(receiver, start, end, iterable, skipCount) {
      var $length, otherStart, otherList, i,
        t1 = A.instanceType(receiver);
      t1._eval$1("Iterable<ListBase.E>")._as(iterable);
      A.RangeError_checkValidRange(start, end, this.get$length(receiver));
      $length = end - start;
      if ($length === 0)
        return;
      A.RangeError_checkNotNegative(skipCount, "skipCount");
      if (t1._eval$1("List<ListBase.E>")._is(iterable)) {
        otherStart = skipCount;
        otherList = iterable;
      } else {
        otherList = J.skip$1$ax(iterable, skipCount).toList$1$growable(0, false);
        otherStart = 0;
      }
      t1 = J.getInterceptor$asx(otherList);
      if (otherStart + $length > t1.get$length(otherList))
        throw A.wrapException(A.IterableElementError_tooFew());
      if (otherStart < start)
        for (i = $length - 1; i >= 0; --i)
          this.$indexSet(receiver, start + i, t1.$index(otherList, otherStart + i));
      else
        for (i = 0; i < $length; ++i)
          this.$indexSet(receiver, start + i, t1.$index(otherList, otherStart + i));
    },
    get$reversed(receiver) {
      return new A.ReversedListIterable(receiver, A.instanceType(receiver)._eval$1("ReversedListIterable<ListBase.E>"));
    },
    toString$0(receiver) {
      return A.Iterable_iterableToFullString(receiver, "[", "]");
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isList: 1
  };
  A.MapBase.prototype = {
    cast$2$0(_, RK, RV) {
      var t1 = A._instanceType(this);
      return A.Map_castFrom(this, t1._eval$1("MapBase.K"), t1._eval$1("MapBase.V"), RK, RV);
    },
    forEach$1(_, action) {
      var t2, key, t3,
        t1 = A._instanceType(this);
      t1._eval$1("~(MapBase.K,MapBase.V)")._as(action);
      for (t2 = this.get$keys(), t2 = t2.get$iterator(t2), t1 = t1._eval$1("MapBase.V"); t2.moveNext$0();) {
        key = t2.get$current();
        t3 = this.$index(0, key);
        action.call$2(key, t3 == null ? t1._as(t3) : t3);
      }
    },
    get$entries() {
      var t1 = this.get$keys();
      return t1.map$1$1(t1, new A.MapBase_entries_closure(this), A._instanceType(this)._eval$1("MapEntry<MapBase.K,MapBase.V>"));
    },
    map$2$1(_, transform, K2, V2) {
      var result, t2, key, t3, entry,
        t1 = A._instanceType(this);
      t1._bind$1(K2)._bind$1(V2)._eval$1("MapEntry<1,2>(MapBase.K,MapBase.V)")._as(transform);
      result = A.LinkedHashMap_LinkedHashMap$_empty(K2, V2);
      for (t2 = this.get$keys(), t2 = t2.get$iterator(t2), t1 = t1._eval$1("MapBase.V"); t2.moveNext$0();) {
        key = t2.get$current();
        t3 = this.$index(0, key);
        entry = transform.call$2(key, t3 == null ? t1._as(t3) : t3);
        result.$indexSet(0, entry.key, entry.value);
      }
      return result;
    },
    addEntries$1(newEntries) {
      var t1, t2;
      for (t1 = J.get$iterator$ax(A._instanceType(this)._eval$1("Iterable<MapEntry<MapBase.K,MapBase.V>>")._as(newEntries)); t1.moveNext$0();) {
        t2 = t1.get$current();
        this.$indexSet(0, t2.key, t2.value);
      }
    },
    containsKey$1(key) {
      var t1 = this.get$keys();
      return t1.contains$1(t1, key);
    },
    get$length(_) {
      var t1 = this.get$keys();
      return t1.get$length(t1);
    },
    get$isEmpty(_) {
      var t1 = this.get$keys();
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty(_) {
      var t1 = this.get$keys();
      return t1.get$isNotEmpty(t1);
    },
    toString$0(_) {
      return A.MapBase_mapToString(this);
    },
    $isMap: 1
  };
  A.MapBase_entries_closure.prototype = {
    call$1(key) {
      var t1 = this.$this,
        t2 = A._instanceType(t1);
      t2._eval$1("MapBase.K")._as(key);
      t1 = t1.$index(0, key);
      if (t1 == null)
        t1 = t2._eval$1("MapBase.V")._as(t1);
      return new A.MapEntry(key, t1, t2._eval$1("@<MapBase.K>")._bind$1(t2._eval$1("MapBase.V"))._eval$1("MapEntry<1,2>"));
    },
    $signature() {
      return A._instanceType(this.$this)._eval$1("MapEntry<MapBase.K,MapBase.V>(MapBase.K)");
    }
  };
  A.MapBase_mapToString_closure.prototype = {
    call$2(k, v) {
      var t2,
        t1 = this._box_0;
      if (!t1.first)
        this.result._contents += ", ";
      t1.first = false;
      t1 = this.result;
      t2 = A.S(k);
      t2 = t1._contents += t2;
      t1._contents = t2 + ": ";
      t2 = A.S(v);
      t1._contents += t2;
    },
    $signature: 41
  };
  A.UnmodifiableMapBase.prototype = {};
  A._UnmodifiableMapMixin.prototype = {
    $indexSet(_, key, value) {
      var t1 = A._instanceType(this);
      t1._eval$1("_UnmodifiableMapMixin.K")._as(key);
      t1._eval$1("_UnmodifiableMapMixin.V")._as(value);
      throw A.wrapException(A.UnsupportedError$("Cannot modify unmodifiable map"));
    }
  };
  A.MapView.prototype = {
    cast$2$0(_, RK, RV) {
      return this._collection$_map.cast$2$0(0, RK, RV);
    },
    $index(_, key) {
      return this._collection$_map.$index(0, key);
    },
    $indexSet(_, key, value) {
      var t1 = A._instanceType(this);
      this._collection$_map.$indexSet(0, t1._precomputed1._as(key), t1._rest[1]._as(value));
    },
    containsKey$1(key) {
      return this._collection$_map.containsKey$1(key);
    },
    forEach$1(_, action) {
      this._collection$_map.forEach$1(0, A._instanceType(this)._eval$1("~(1,2)")._as(action));
    },
    get$isEmpty(_) {
      var t1 = this._collection$_map;
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty(_) {
      var t1 = this._collection$_map;
      return t1.get$isNotEmpty(t1);
    },
    get$length(_) {
      var t1 = this._collection$_map;
      return t1.get$length(t1);
    },
    get$keys() {
      return this._collection$_map.get$keys();
    },
    toString$0(_) {
      return this._collection$_map.toString$0(0);
    },
    get$entries() {
      return this._collection$_map.get$entries();
    },
    $isMap: 1
  };
  A.UnmodifiableMapView.prototype = {
    cast$2$0(_, RK, RV) {
      return new A.UnmodifiableMapView(this._collection$_map.cast$2$0(0, RK, RV), RK._eval$1("@<0>")._bind$1(RV)._eval$1("UnmodifiableMapView<1,2>"));
    }
  };
  A.SetBase.prototype = {
    get$isEmpty(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty(_) {
      return this._collection$_length !== 0;
    },
    map$1$1(_, f, $T) {
      var t1 = A._instanceType(this);
      return new A.EfficientLengthMappedIterable(this, t1._bind$1($T)._eval$1("1(2)")._as(f), t1._eval$1("@<1>")._bind$1($T)._eval$1("EfficientLengthMappedIterable<1,2>"));
    },
    toString$0(_) {
      return A.Iterable_iterableToFullString(this, "{", "}");
    },
    join$1(_, separator) {
      var t1, first, t2, t3,
        iterator = A._LinkedHashSetIterator$(this, this._collection$_modifications, A._instanceType(this)._precomputed1);
      if (!iterator.moveNext$0())
        return "";
      t1 = iterator._collection$_current;
      first = J.toString$0$(t1 == null ? iterator.$ti._precomputed1._as(t1) : t1);
      if (!iterator.moveNext$0())
        return first;
      t1 = iterator.$ti._precomputed1;
      if (separator.length === 0) {
        t2 = first;
        do {
          t3 = iterator._collection$_current;
          t2 += A.S(t3 == null ? t1._as(t3) : t3);
        } while (iterator.moveNext$0());
        t1 = t2;
      } else {
        t2 = first;
        do {
          t3 = iterator._collection$_current;
          t2 = t2 + separator + A.S(t3 == null ? t1._as(t3) : t3);
        } while (iterator.moveNext$0());
        t1 = t2;
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    take$1(_, n) {
      return A.TakeIterable_TakeIterable(this, n, A._instanceType(this)._precomputed1);
    },
    skip$1(_, n) {
      return A.SkipIterable_SkipIterable(this, n, A._instanceType(this)._precomputed1);
    },
    get$last(_) {
      var t1, result,
        it = A._LinkedHashSetIterator$(this, this._collection$_modifications, A._instanceType(this)._precomputed1);
      if (!it.moveNext$0())
        throw A.wrapException(A.IterableElementError_noElement());
      t1 = it.$ti._precomputed1;
      do {
        result = it._collection$_current;
        if (result == null)
          result = t1._as(result);
      } while (it.moveNext$0());
      return result;
    },
    elementAt$1(_, index) {
      var iterator, skipCount, t1, _this = this;
      A.RangeError_checkNotNegative(index, "index");
      iterator = A._LinkedHashSetIterator$(_this, _this._collection$_modifications, A._instanceType(_this)._precomputed1);
      for (skipCount = index; iterator.moveNext$0();) {
        if (skipCount === 0) {
          t1 = iterator._collection$_current;
          return t1 == null ? iterator.$ti._precomputed1._as(t1) : t1;
        }
        --skipCount;
      }
      throw A.wrapException(A.IndexError$withLength(index, index - skipCount, _this, null, "index"));
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isSet: 1
  };
  A._SetBase.prototype = {};
  A._UnmodifiableMapView_MapView__UnmodifiableMapMixin.prototype = {};
  A._JsonMap.prototype = {
    $index(_, key) {
      var result,
        t1 = this._processed;
      if (t1 == null)
        return this._data.$index(0, key);
      else if (typeof key != "string")
        return null;
      else {
        result = t1[key];
        return typeof result == "undefined" ? this._process$1(key) : result;
      }
    },
    get$length(_) {
      return this._processed == null ? this._data.__js_helper$_length : this._convert$_computeKeys$0().length;
    },
    get$isEmpty(_) {
      return this.get$length(0) === 0;
    },
    get$isNotEmpty(_) {
      return this.get$length(0) > 0;
    },
    get$keys() {
      if (this._processed == null) {
        var t1 = this._data;
        return new A.LinkedHashMapKeyIterable(t1, A._instanceType(t1)._eval$1("LinkedHashMapKeyIterable<1>"));
      }
      return new A._JsonMapKeyIterable(this);
    },
    $indexSet(_, key, value) {
      var processed, original, _this = this;
      A._asString(key);
      if (_this._processed == null)
        _this._data.$indexSet(0, key, value);
      else if (_this.containsKey$1(key)) {
        processed = _this._processed;
        processed[key] = value;
        original = _this._original;
        if (original == null ? processed != null : original !== processed)
          original[key] = null;
      } else
        _this._upgrade$0().$indexSet(0, key, value);
    },
    containsKey$1(key) {
      if (this._processed == null)
        return this._data.containsKey$1(key);
      if (typeof key != "string")
        return false;
      return Object.prototype.hasOwnProperty.call(this._original, key);
    },
    forEach$1(_, f) {
      var keys, i, key, value, _this = this;
      type$.void_Function_String_dynamic._as(f);
      if (_this._processed == null)
        return _this._data.forEach$1(0, f);
      keys = _this._convert$_computeKeys$0();
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        value = _this._processed[key];
        if (typeof value == "undefined") {
          value = A._convertJsonToDartLazy(_this._original[key]);
          _this._processed[key] = value;
        }
        f.call$2(key, value);
        if (keys !== _this._data)
          throw A.wrapException(A.ConcurrentModificationError$(_this));
      }
    },
    _convert$_computeKeys$0() {
      var keys = type$.nullable_List_dynamic._as(this._data);
      if (keys == null)
        keys = this._data = A._setArrayType(Object.keys(this._original), type$.JSArray_String);
      return keys;
    },
    _upgrade$0() {
      var result, keys, i, t1, key, _this = this;
      if (_this._processed == null)
        return _this._data;
      result = A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic);
      keys = _this._convert$_computeKeys$0();
      for (i = 0; t1 = keys.length, i < t1; ++i) {
        key = keys[i];
        result.$indexSet(0, key, _this.$index(0, key));
      }
      if (t1 === 0)
        B.JSArray_methods.add$1(keys, "");
      else
        B.JSArray_methods.clear$0(keys);
      _this._original = _this._processed = null;
      return _this._data = result;
    },
    _process$1(key) {
      var result;
      if (!Object.prototype.hasOwnProperty.call(this._original, key))
        return null;
      result = A._convertJsonToDartLazy(this._original[key]);
      return this._processed[key] = result;
    }
  };
  A._JsonMapKeyIterable.prototype = {
    get$length(_) {
      return this._parent.get$length(0);
    },
    elementAt$1(_, index) {
      var t1 = this._parent;
      if (t1._processed == null)
        t1 = t1.get$keys().elementAt$1(0, index);
      else {
        t1 = t1._convert$_computeKeys$0();
        if (!(index >= 0 && index < t1.length))
          return A.ioore(t1, index);
        t1 = t1[index];
      }
      return t1;
    },
    get$iterator(_) {
      var t1 = this._parent;
      if (t1._processed == null) {
        t1 = t1.get$keys();
        t1 = t1.get$iterator(t1);
      } else {
        t1 = t1._convert$_computeKeys$0();
        t1 = new J.ArrayIterator(t1, t1.length, A._arrayInstanceType(t1)._eval$1("ArrayIterator<1>"));
      }
      return t1;
    },
    contains$1(_, key) {
      return this._parent.containsKey$1(key);
    }
  };
  A._Utf8Decoder__decoder_closure.prototype = {
    call$0() {
      var t1, exception;
      try {
        t1 = new TextDecoder("utf-8", {fatal: true});
        return t1;
      } catch (exception) {
      }
      return null;
    },
    $signature: 69
  };
  A._Utf8Decoder__decoderNonfatal_closure.prototype = {
    call$0() {
      var t1, exception;
      try {
        t1 = new TextDecoder("utf-8", {fatal: false});
        return t1;
      } catch (exception) {
      }
      return null;
    },
    $signature: 69
  };
  A.AsciiCodec.prototype = {
    get$name() {
      return "us-ascii";
    },
    encode$1(source) {
      return B.AsciiEncoder_127.convert$1(source);
    },
    decode$2$allowInvalid(bytes, allowInvalid) {
      type$.List_int._as(bytes);
      if (allowInvalid === true)
        return B.AsciiDecoder_true_127.convert$1(bytes);
      else
        return B.AsciiDecoder_false_127.convert$1(bytes);
    },
    decode$1(bytes) {
      return this.decode$2$allowInvalid(bytes, null);
    }
  };
  A._UnicodeSubsetEncoder.prototype = {
    convert$1(string) {
      var stringLength, $length, result, t1, i, codeUnit;
      A._asString(string);
      stringLength = string.length;
      $length = A.RangeError_checkValidRange(0, null, stringLength) - 0;
      result = new Uint8Array($length);
      for (t1 = ~this._subsetMask, i = 0; i < $length; ++i) {
        if (!(i < stringLength))
          return A.ioore(string, i);
        codeUnit = string.charCodeAt(i);
        if ((codeUnit & t1) !== 0)
          throw A.wrapException(A.ArgumentError$value(string, "string", "Contains invalid characters."));
        if (!(i < $length))
          return A.ioore(result, i);
        result[i] = codeUnit;
      }
      return result;
    }
  };
  A.AsciiEncoder.prototype = {};
  A._UnicodeSubsetDecoder.prototype = {
    convert$1(bytes) {
      var t1, end, t2, i, byte;
      type$.List_int._as(bytes);
      t1 = J.getInterceptor$asx(bytes);
      end = A.RangeError_checkValidRange(0, null, t1.get$length(bytes));
      for (t2 = ~this._subsetMask, i = 0; i < end; ++i) {
        byte = t1.$index(bytes, i);
        if ((byte & t2) >>> 0 !== 0) {
          if (!this._allowInvalid)
            throw A.wrapException(A.FormatException$("Invalid value in input: " + A.S(byte), null, null));
          return this._convertInvalid$3(bytes, 0, end);
        }
      }
      return A.String_String$fromCharCodes(bytes, 0, end);
    },
    _convertInvalid$3(bytes, start, end) {
      var t1, t2, i, t3, value;
      type$.List_int._as(bytes);
      for (t1 = ~this._subsetMask, t2 = J.getInterceptor$asx(bytes), i = start, t3 = ""; i < end; ++i) {
        value = t2.$index(bytes, i);
        t3 += A.Primitives_stringFromCharCode((value & t1) >>> 0 !== 0 ? 65533 : value);
      }
      return t3.charCodeAt(0) == 0 ? t3 : t3;
    }
  };
  A.AsciiDecoder.prototype = {};
  A.Base64Codec.prototype = {
    get$encoder() {
      return this._encoder;
    },
    normalize$3(source, start, end) {
      var inverseAlphabet, t2, i, sliceStart, buffer, firstPadding, firstPaddingSourceIndex, paddingCount, i0, char, i1, digit1, t3, digit2, char0, value, t4, endLength, $length,
        _s64_ = string$.ABCDEF,
        _s31_ = "Invalid base64 encoding length ",
        t1 = source.length;
      end = A.RangeError_checkValidRange(start, end, t1);
      inverseAlphabet = $.$get$_Base64Decoder__inverseAlphabet();
      for (t2 = inverseAlphabet.length, i = start, sliceStart = i, buffer = null, firstPadding = -1, firstPaddingSourceIndex = -1, paddingCount = 0; i < end; i = i0) {
        i0 = i + 1;
        if (!(i < t1))
          return A.ioore(source, i);
        char = source.charCodeAt(i);
        if (char === 37) {
          i1 = i0 + 2;
          if (i1 <= end) {
            if (!(i0 < t1))
              return A.ioore(source, i0);
            digit1 = A.hexDigitValue(source.charCodeAt(i0));
            t3 = i0 + 1;
            if (!(t3 < t1))
              return A.ioore(source, t3);
            digit2 = A.hexDigitValue(source.charCodeAt(t3));
            char0 = digit1 * 16 + digit2 - (digit2 & 256);
            if (char0 === 37)
              char0 = -1;
            i0 = i1;
          } else
            char0 = -1;
        } else
          char0 = char;
        if (0 <= char0 && char0 <= 127) {
          if (!(char0 >= 0 && char0 < t2))
            return A.ioore(inverseAlphabet, char0);
          value = inverseAlphabet[char0];
          if (value >= 0) {
            if (!(value < 64))
              return A.ioore(_s64_, value);
            char0 = _s64_.charCodeAt(value);
            if (char0 === char)
              continue;
            char = char0;
          } else {
            if (value === -1) {
              if (firstPadding < 0) {
                t3 = buffer == null ? null : buffer._contents.length;
                if (t3 == null)
                  t3 = 0;
                firstPadding = t3 + (i - sliceStart);
                firstPaddingSourceIndex = i;
              }
              ++paddingCount;
              if (char === 61)
                continue;
            }
            char = char0;
          }
          if (value !== -2) {
            if (buffer == null) {
              buffer = new A.StringBuffer("");
              t3 = buffer;
            } else
              t3 = buffer;
            t3._contents += B.JSString_methods.substring$2(source, sliceStart, i);
            t4 = A.Primitives_stringFromCharCode(char);
            t3._contents += t4;
            sliceStart = i0;
            continue;
          }
        }
        throw A.wrapException(A.FormatException$("Invalid base64 data", source, i));
      }
      if (buffer != null) {
        t1 = B.JSString_methods.substring$2(source, sliceStart, end);
        t1 = buffer._contents += t1;
        t2 = t1.length;
        if (firstPadding >= 0)
          A.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, t2);
        else {
          endLength = B.JSInt_methods.$mod(t2 - 1, 4) + 1;
          if (endLength === 1)
            throw A.wrapException(A.FormatException$(_s31_, source, end));
          for (; endLength < 4;) {
            t1 += "=";
            buffer._contents = t1;
            ++endLength;
          }
        }
        t1 = buffer._contents;
        return B.JSString_methods.replaceRange$3(source, start, end, t1.charCodeAt(0) == 0 ? t1 : t1);
      }
      $length = end - start;
      if (firstPadding >= 0)
        A.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, $length);
      else {
        endLength = B.JSInt_methods.$mod($length, 4);
        if (endLength === 1)
          throw A.wrapException(A.FormatException$(_s31_, source, end));
        if (endLength > 1)
          source = B.JSString_methods.replaceRange$3(source, end, end, endLength === 2 ? "==" : "=");
      }
      return source;
    }
  };
  A.Base64Encoder.prototype = {
    convert$1(input) {
      var t1, t2;
      type$.List_int._as(input);
      t1 = J.getInterceptor$asx(input);
      if (t1.get$isEmpty(input))
        return "";
      t2 = this._urlSafe ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : string$.ABCDEF;
      t1 = new A._Base64Encoder(t2).encode$4(input, 0, t1.get$length(input), true);
      t1.toString;
      return A.String_String$fromCharCodes(t1, 0, null);
    }
  };
  A._Base64Encoder.prototype = {
    encode$4(bytes, start, end, isLast) {
      var t1, byteCount, fullChunks, bufferLength, output;
      type$.List_int._as(bytes);
      t1 = this._convert$_state;
      byteCount = (t1 & 3) + (end - start);
      fullChunks = B.JSInt_methods._tdivFast$1(byteCount, 3);
      bufferLength = fullChunks * 4;
      if (byteCount - fullChunks * 3 > 0)
        bufferLength += 4;
      output = new Uint8Array(bufferLength);
      this._convert$_state = A._Base64Encoder_encodeChunk(this._alphabet, bytes, start, end, true, output, 0, t1);
      if (bufferLength > 0)
        return output;
      return null;
    }
  };
  A.Base64Decoder.prototype = {
    convert$1(input) {
      var end, decoder, t1, t2;
      A._asString(input);
      end = A.RangeError_checkValidRange(0, null, input.length);
      if (0 === end)
        return new Uint8Array(0);
      decoder = new A._Base64Decoder();
      t1 = decoder.decode$3(input, 0, end);
      t1.toString;
      t2 = decoder._convert$_state;
      if (t2 < -1)
        A.throwExpression(A.FormatException$("Missing padding character", input, end));
      if (t2 > 0)
        A.throwExpression(A.FormatException$("Invalid length, must be multiple of four", input, end));
      decoder._convert$_state = -1;
      return t1;
    }
  };
  A._Base64Decoder.prototype = {
    decode$3(input, start, end) {
      var buffer, _this = this,
        t1 = _this._convert$_state;
      if (t1 < 0) {
        _this._convert$_state = A._Base64Decoder__checkPadding(input, start, end, t1);
        return null;
      }
      if (start === end)
        return new Uint8Array(0);
      buffer = A._Base64Decoder__allocateBuffer(input, start, end, t1);
      _this._convert$_state = A._Base64Decoder_decodeChunk(input, start, end, buffer, 0, _this._convert$_state);
      return buffer;
    }
  };
  A.ByteConversionSink.prototype = {};
  A._ByteCallbackSink.prototype = {
    add$1(_, chunk) {
      var t1, t2, t3, v, grown, _this = this;
      type$.Iterable_int._as(chunk);
      t1 = _this._convert$_buffer;
      t2 = _this._bufferIndex;
      t3 = J.getInterceptor$asx(chunk);
      if (t3.get$length(chunk) > t1.length - t2) {
        t1 = _this._convert$_buffer;
        v = t3.get$length(chunk) + t1.length - 1;
        v |= B.JSInt_methods._shrOtherPositive$1(v, 1);
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        grown = new Uint8Array((((v | v >>> 16) >>> 0) + 1) * 2);
        t1 = _this._convert$_buffer;
        B.NativeUint8List_methods.setRange$3(grown, 0, t1.length, t1);
        _this.set$_convert$_buffer(grown);
      }
      t1 = _this._convert$_buffer;
      t2 = _this._bufferIndex;
      B.NativeUint8List_methods.setRange$3(t1, t2, t2 + t3.get$length(chunk), chunk);
      _this._bufferIndex = _this._bufferIndex + t3.get$length(chunk);
    },
    close$0() {
      this._callback.call$1(B.NativeUint8List_methods.sublist$2(this._convert$_buffer, 0, this._bufferIndex));
    },
    set$_convert$_buffer(_buffer) {
      this._convert$_buffer = type$.List_int._as(_buffer);
    }
  };
  A.Codec.prototype = {};
  A.Converter.prototype = {};
  A.Encoding.prototype = {};
  A.JsonUnsupportedObjectError.prototype = {
    toString$0(_) {
      var safeString = A.Error_safeToString(this.unsupportedObject);
      return (this.cause != null ? "Converting object to an encodable object failed:" : "Converting object did not return an encodable object:") + " " + safeString;
    }
  };
  A.JsonCyclicError.prototype = {
    toString$0(_) {
      return "Cyclic error in JSON stringify";
    }
  };
  A.JsonCodec.prototype = {
    decode$2$reviver(source, reviver) {
      var t1 = A._parseJson(source, this.get$decoder()._reviver);
      return t1;
    },
    encode$2$toEncodable(value, toEncodable) {
      var t1 = A._JsonStringStringifier_stringify(value, this.get$encoder()._toEncodable, null);
      return t1;
    },
    get$encoder() {
      return B.JsonEncoder_null;
    },
    get$decoder() {
      return B.JsonDecoder_null;
    }
  };
  A.JsonEncoder.prototype = {};
  A.JsonDecoder.prototype = {};
  A._JsonStringifier.prototype = {
    writeStringContent$1(s) {
      var t1, offset, i, charCode, t2, t3,
        $length = s.length;
      for (t1 = this._sink, offset = 0, i = 0; i < $length; ++i) {
        charCode = s.charCodeAt(i);
        if (charCode > 92) {
          if (charCode >= 55296) {
            t2 = charCode & 64512;
            if (t2 === 55296) {
              t3 = i + 1;
              t3 = !(t3 < $length && (s.charCodeAt(t3) & 64512) === 56320);
            } else
              t3 = false;
            if (!t3)
              if (t2 === 56320) {
                t2 = i - 1;
                t2 = !(t2 >= 0 && (s.charCodeAt(t2) & 64512) === 55296);
              } else
                t2 = false;
            else
              t2 = true;
            if (t2) {
              if (i > offset)
                t1._contents += B.JSString_methods.substring$2(s, offset, i);
              offset = i + 1;
              t2 = A.Primitives_stringFromCharCode(92);
              t1._contents += t2;
              t2 = A.Primitives_stringFromCharCode(117);
              t1._contents += t2;
              t2 = A.Primitives_stringFromCharCode(100);
              t1._contents += t2;
              t2 = charCode >>> 8 & 15;
              t2 = A.Primitives_stringFromCharCode(t2 < 10 ? 48 + t2 : 87 + t2);
              t1._contents += t2;
              t2 = charCode >>> 4 & 15;
              t2 = A.Primitives_stringFromCharCode(t2 < 10 ? 48 + t2 : 87 + t2);
              t1._contents += t2;
              t2 = charCode & 15;
              t2 = A.Primitives_stringFromCharCode(t2 < 10 ? 48 + t2 : 87 + t2);
              t1._contents += t2;
            }
          }
          continue;
        }
        if (charCode < 32) {
          if (i > offset)
            t1._contents += B.JSString_methods.substring$2(s, offset, i);
          offset = i + 1;
          t2 = A.Primitives_stringFromCharCode(92);
          t1._contents += t2;
          switch (charCode) {
            case 8:
              t2 = A.Primitives_stringFromCharCode(98);
              t1._contents += t2;
              break;
            case 9:
              t2 = A.Primitives_stringFromCharCode(116);
              t1._contents += t2;
              break;
            case 10:
              t2 = A.Primitives_stringFromCharCode(110);
              t1._contents += t2;
              break;
            case 12:
              t2 = A.Primitives_stringFromCharCode(102);
              t1._contents += t2;
              break;
            case 13:
              t2 = A.Primitives_stringFromCharCode(114);
              t1._contents += t2;
              break;
            default:
              t2 = A.Primitives_stringFromCharCode(117);
              t1._contents += t2;
              t2 = A.Primitives_stringFromCharCode(48);
              t1._contents += t2;
              t2 = A.Primitives_stringFromCharCode(48);
              t1._contents += t2;
              t2 = charCode >>> 4 & 15;
              t2 = A.Primitives_stringFromCharCode(t2 < 10 ? 48 + t2 : 87 + t2);
              t1._contents += t2;
              t2 = charCode & 15;
              t2 = A.Primitives_stringFromCharCode(t2 < 10 ? 48 + t2 : 87 + t2);
              t1._contents += t2;
              break;
          }
        } else if (charCode === 34 || charCode === 92) {
          if (i > offset)
            t1._contents += B.JSString_methods.substring$2(s, offset, i);
          offset = i + 1;
          t2 = A.Primitives_stringFromCharCode(92);
          t1._contents += t2;
          t2 = A.Primitives_stringFromCharCode(charCode);
          t1._contents += t2;
        }
      }
      if (offset === 0)
        t1._contents += s;
      else if (offset < $length)
        t1._contents += B.JSString_methods.substring$2(s, offset, $length);
    },
    _checkCycle$1(object) {
      var t1, t2, i, t3;
      for (t1 = this._seen, t2 = t1.length, i = 0; i < t2; ++i) {
        t3 = t1[i];
        if (object == null ? t3 == null : object === t3)
          throw A.wrapException(new A.JsonCyclicError(object, null));
      }
      B.JSArray_methods.add$1(t1, object);
    },
    writeObject$1(object) {
      var customJson, e, t1, exception, _this = this;
      if (_this.writeJsonValue$1(object))
        return;
      _this._checkCycle$1(object);
      try {
        customJson = _this._toEncodable.call$1(object);
        if (!_this.writeJsonValue$1(customJson)) {
          t1 = A.JsonUnsupportedObjectError$(object, null, _this.get$_partialResult());
          throw A.wrapException(t1);
        }
        t1 = _this._seen;
        if (0 >= t1.length)
          return A.ioore(t1, -1);
        t1.pop();
      } catch (exception) {
        e = A.unwrapException(exception);
        t1 = A.JsonUnsupportedObjectError$(object, e, _this.get$_partialResult());
        throw A.wrapException(t1);
      }
    },
    writeJsonValue$1(object) {
      var t1, t2, success, _this = this;
      if (typeof object == "number") {
        if (!isFinite(object))
          return false;
        t1 = _this._sink;
        t2 = B.JSNumber_methods.toString$0(object);
        t1._contents += t2;
        return true;
      } else if (object === true) {
        _this._sink._contents += "true";
        return true;
      } else if (object === false) {
        _this._sink._contents += "false";
        return true;
      } else if (object == null) {
        _this._sink._contents += "null";
        return true;
      } else if (typeof object == "string") {
        t1 = _this._sink;
        t1._contents += '"';
        _this.writeStringContent$1(object);
        t1._contents += '"';
        return true;
      } else if (type$.List_dynamic._is(object)) {
        _this._checkCycle$1(object);
        _this.writeList$1(object);
        t1 = _this._seen;
        if (0 >= t1.length)
          return A.ioore(t1, -1);
        t1.pop();
        return true;
      } else if (type$.Map_dynamic_dynamic._is(object)) {
        _this._checkCycle$1(object);
        success = _this.writeMap$1(object);
        t1 = _this._seen;
        if (0 >= t1.length)
          return A.ioore(t1, -1);
        t1.pop();
        return success;
      } else
        return false;
    },
    writeList$1(list) {
      var t2, i,
        t1 = this._sink;
      t1._contents += "[";
      t2 = J.getInterceptor$asx(list);
      if (t2.get$isNotEmpty(list)) {
        this.writeObject$1(t2.$index(list, 0));
        for (i = 1; i < t2.get$length(list); ++i) {
          t1._contents += ",";
          this.writeObject$1(t2.$index(list, i));
        }
      }
      t1._contents += "]";
    },
    writeMap$1(map) {
      var t1, keyValueList, i, t2, separator, t3, _this = this, _box_0 = {};
      if (map.get$isEmpty(map)) {
        _this._sink._contents += "{}";
        return true;
      }
      t1 = map.get$length(map) * 2;
      keyValueList = A.List_List$filled(t1, null, false, type$.nullable_Object);
      i = _box_0.i = 0;
      _box_0.allStringKeys = true;
      map.forEach$1(0, new A._JsonStringifier_writeMap_closure(_box_0, keyValueList));
      if (!_box_0.allStringKeys)
        return false;
      t2 = _this._sink;
      t2._contents += "{";
      for (separator = '"'; i < t1; i += 2, separator = ',"') {
        t2._contents += separator;
        _this.writeStringContent$1(A._asString(keyValueList[i]));
        t2._contents += '":';
        t3 = i + 1;
        if (!(t3 < t1))
          return A.ioore(keyValueList, t3);
        _this.writeObject$1(keyValueList[t3]);
      }
      t2._contents += "}";
      return true;
    }
  };
  A._JsonStringifier_writeMap_closure.prototype = {
    call$2(key, value) {
      var t1, t2;
      if (typeof key != "string")
        this._box_0.allStringKeys = false;
      t1 = this.keyValueList;
      t2 = this._box_0;
      B.JSArray_methods.$indexSet(t1, t2.i++, key);
      B.JSArray_methods.$indexSet(t1, t2.i++, value);
    },
    $signature: 41
  };
  A._JsonStringStringifier.prototype = {
    get$_partialResult() {
      var t1 = this._sink._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  A.Latin1Codec.prototype = {
    get$name() {
      return "iso-8859-1";
    },
    encode$1(source) {
      return B.Latin1Encoder_255.convert$1(source);
    },
    decode$1(bytes) {
      var t1;
      type$.List_int._as(bytes);
      t1 = B.Latin1Decoder_false_255.convert$1(bytes);
      return t1;
    }
  };
  A.Latin1Encoder.prototype = {};
  A.Latin1Decoder.prototype = {};
  A.Utf8Codec.prototype = {
    get$name() {
      return "utf-8";
    },
    decode$2$allowMalformed(codeUnits, allowMalformed) {
      type$.List_int._as(codeUnits);
      return (allowMalformed === true ? B.Utf8Decoder_true : B.Utf8Decoder_false).convert$1(codeUnits);
    },
    decode$1(codeUnits) {
      return this.decode$2$allowMalformed(codeUnits, null);
    },
    encode$1(string) {
      return B.C_Utf8Encoder.convert$1(string);
    }
  };
  A.Utf8Encoder.prototype = {
    convert$1(string) {
      var stringLength, end, $length, t1, encoder, t2;
      A._asString(string);
      stringLength = string.length;
      end = A.RangeError_checkValidRange(0, null, stringLength);
      $length = end - 0;
      if ($length === 0)
        return new Uint8Array(0);
      t1 = new Uint8Array($length * 3);
      encoder = new A._Utf8Encoder(t1);
      if (encoder._fillBuffer$3(string, 0, end) !== end) {
        t2 = end - 1;
        if (!(t2 >= 0 && t2 < stringLength))
          return A.ioore(string, t2);
        encoder._writeReplacementCharacter$0();
      }
      return B.NativeUint8List_methods.sublist$2(t1, 0, encoder._bufferIndex);
    }
  };
  A._Utf8Encoder.prototype = {
    _writeReplacementCharacter$0() {
      var _this = this,
        t1 = _this._convert$_buffer,
        t2 = _this._bufferIndex,
        t3 = _this._bufferIndex = t2 + 1,
        t4 = t1.length;
      if (!(t2 < t4))
        return A.ioore(t1, t2);
      t1[t2] = 239;
      t2 = _this._bufferIndex = t3 + 1;
      if (!(t3 < t4))
        return A.ioore(t1, t3);
      t1[t3] = 191;
      _this._bufferIndex = t2 + 1;
      if (!(t2 < t4))
        return A.ioore(t1, t2);
      t1[t2] = 189;
    },
    _writeSurrogate$2(leadingSurrogate, nextCodeUnit) {
      var rune, t1, t2, t3, t4, _this = this;
      if ((nextCodeUnit & 64512) === 56320) {
        rune = 65536 + ((leadingSurrogate & 1023) << 10) | nextCodeUnit & 1023;
        t1 = _this._convert$_buffer;
        t2 = _this._bufferIndex;
        t3 = _this._bufferIndex = t2 + 1;
        t4 = t1.length;
        if (!(t2 < t4))
          return A.ioore(t1, t2);
        t1[t2] = rune >>> 18 | 240;
        t2 = _this._bufferIndex = t3 + 1;
        if (!(t3 < t4))
          return A.ioore(t1, t3);
        t1[t3] = rune >>> 12 & 63 | 128;
        t3 = _this._bufferIndex = t2 + 1;
        if (!(t2 < t4))
          return A.ioore(t1, t2);
        t1[t2] = rune >>> 6 & 63 | 128;
        _this._bufferIndex = t3 + 1;
        if (!(t3 < t4))
          return A.ioore(t1, t3);
        t1[t3] = rune & 63 | 128;
        return true;
      } else {
        _this._writeReplacementCharacter$0();
        return false;
      }
    },
    _fillBuffer$3(str, start, end) {
      var t1, t2, t3, stringIndex, codeUnit, t4, t5, _this = this;
      if (start !== end) {
        t1 = end - 1;
        if (!(t1 >= 0 && t1 < str.length))
          return A.ioore(str, t1);
        t1 = (str.charCodeAt(t1) & 64512) === 55296;
      } else
        t1 = false;
      if (t1)
        --end;
      for (t1 = _this._convert$_buffer, t2 = t1.length, t3 = str.length, stringIndex = start; stringIndex < end; ++stringIndex) {
        if (!(stringIndex < t3))
          return A.ioore(str, stringIndex);
        codeUnit = str.charCodeAt(stringIndex);
        if (codeUnit <= 127) {
          t4 = _this._bufferIndex;
          if (t4 >= t2)
            break;
          _this._bufferIndex = t4 + 1;
          t1[t4] = codeUnit;
        } else {
          t4 = codeUnit & 64512;
          if (t4 === 55296) {
            if (_this._bufferIndex + 4 > t2)
              break;
            t4 = stringIndex + 1;
            if (!(t4 < t3))
              return A.ioore(str, t4);
            if (_this._writeSurrogate$2(codeUnit, str.charCodeAt(t4)))
              stringIndex = t4;
          } else if (t4 === 56320) {
            if (_this._bufferIndex + 3 > t2)
              break;
            _this._writeReplacementCharacter$0();
          } else if (codeUnit <= 2047) {
            t4 = _this._bufferIndex;
            t5 = t4 + 1;
            if (t5 >= t2)
              break;
            _this._bufferIndex = t5;
            if (!(t4 < t2))
              return A.ioore(t1, t4);
            t1[t4] = codeUnit >>> 6 | 192;
            _this._bufferIndex = t5 + 1;
            t1[t5] = codeUnit & 63 | 128;
          } else {
            t4 = _this._bufferIndex;
            if (t4 + 2 >= t2)
              break;
            t5 = _this._bufferIndex = t4 + 1;
            if (!(t4 < t2))
              return A.ioore(t1, t4);
            t1[t4] = codeUnit >>> 12 | 224;
            t4 = _this._bufferIndex = t5 + 1;
            if (!(t5 < t2))
              return A.ioore(t1, t5);
            t1[t5] = codeUnit >>> 6 & 63 | 128;
            _this._bufferIndex = t4 + 1;
            if (!(t4 < t2))
              return A.ioore(t1, t4);
            t1[t4] = codeUnit & 63 | 128;
          }
        }
      }
      return stringIndex;
    }
  };
  A.Utf8Decoder.prototype = {
    convert$1(codeUnits) {
      return new A._Utf8Decoder(this._allowMalformed)._convertGeneral$4(type$.List_int._as(codeUnits), 0, null, true);
    }
  };
  A._Utf8Decoder.prototype = {
    _convertGeneral$4(codeUnits, start, maybeEnd, single) {
      var end, casted, bytes, errorOffset, t1, result, message, _this = this;
      type$.List_int._as(codeUnits);
      end = A.RangeError_checkValidRange(start, maybeEnd, J.get$length$asx(codeUnits));
      if (start === end)
        return "";
      if (codeUnits instanceof Uint8Array) {
        casted = codeUnits;
        bytes = casted;
        errorOffset = 0;
      } else {
        bytes = A._Utf8Decoder__makeNativeUint8List(codeUnits, start, end);
        end -= start;
        errorOffset = start;
        start = 0;
      }
      if (end - start >= 15) {
        t1 = _this.allowMalformed;
        result = A._Utf8Decoder__convertInterceptedUint8List(t1, bytes, start, end);
        if (result != null) {
          if (!t1)
            return result;
          if (result.indexOf("\ufffd") < 0)
            return result;
        }
      }
      result = _this._decodeRecursive$4(bytes, start, end, true);
      t1 = _this._convert$_state;
      if ((t1 & 1) !== 0) {
        message = A._Utf8Decoder_errorDescription(t1);
        _this._convert$_state = 0;
        throw A.wrapException(A.FormatException$(message, codeUnits, errorOffset + _this._charOrIndex));
      }
      return result;
    },
    _decodeRecursive$4(bytes, start, end, single) {
      var mid, s1, _this = this;
      if (end - start > 1000) {
        mid = B.JSInt_methods._tdivFast$1(start + end, 2);
        s1 = _this._decodeRecursive$4(bytes, start, mid, false);
        if ((_this._convert$_state & 1) !== 0)
          return s1;
        return s1 + _this._decodeRecursive$4(bytes, mid, end, single);
      }
      return _this.decodeGeneral$4(bytes, start, end, single);
    },
    decodeGeneral$4(bytes, start, end, single) {
      var byte, t2, type, t3, i0, markEnd, i1, m, _this = this,
        _s256_ = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFFFFFFFFFFFFFFFFGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHHHHHHHHIHHHJEEBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBKCCCCCCCCCCCCDCLONNNMEEEEEEEEEEE",
        _s144_ = " \x000:XECCCCCN:lDb \x000:XECCCCCNvlDb \x000:XECCCCCN:lDb AAAAA\x00\x00\x00\x00\x00AAAAA00000AAAAA:::::AAAAAGG000AAAAA00KKKAAAAAG::::AAAAA:IIIIAAAAA000\x800AAAAA\x00\x00\x00\x00 AAAAA",
        _65533 = 65533,
        state = _this._convert$_state,
        char = _this._charOrIndex,
        buffer = new A.StringBuffer(""),
        i = start + 1,
        t1 = bytes.length;
      if (!(start >= 0 && start < t1))
        return A.ioore(bytes, start);
      byte = bytes[start];
      $label0$0:
        for (t2 = _this.allowMalformed; true;) {
          for (; true; i = i0) {
            if (!(byte >= 0 && byte < 256))
              return A.ioore(_s256_, byte);
            type = _s256_.charCodeAt(byte) & 31;
            char = state <= 32 ? byte & 61694 >>> type : (byte & 63 | char << 6) >>> 0;
            t3 = state + type;
            if (!(t3 >= 0 && t3 < 144))
              return A.ioore(_s144_, t3);
            state = _s144_.charCodeAt(t3);
            if (state === 0) {
              t3 = A.Primitives_stringFromCharCode(char);
              buffer._contents += t3;
              if (i === end)
                break $label0$0;
              break;
            } else if ((state & 1) !== 0) {
              if (t2)
                switch (state) {
                  case 69:
                  case 67:
                    t3 = A.Primitives_stringFromCharCode(_65533);
                    buffer._contents += t3;
                    break;
                  case 65:
                    t3 = A.Primitives_stringFromCharCode(_65533);
                    buffer._contents += t3;
                    --i;
                    break;
                  default:
                    t3 = A.Primitives_stringFromCharCode(_65533);
                    t3 = buffer._contents += t3;
                    buffer._contents = t3 + A.Primitives_stringFromCharCode(_65533);
                    break;
                }
              else {
                _this._convert$_state = state;
                _this._charOrIndex = i - 1;
                return "";
              }
              state = 0;
            }
            if (i === end)
              break $label0$0;
            i0 = i + 1;
            if (!(i >= 0 && i < t1))
              return A.ioore(bytes, i);
            byte = bytes[i];
          }
          i0 = i + 1;
          if (!(i >= 0 && i < t1))
            return A.ioore(bytes, i);
          byte = bytes[i];
          if (byte < 128) {
            while (true) {
              if (!(i0 < end)) {
                markEnd = end;
                break;
              }
              i1 = i0 + 1;
              if (!(i0 >= 0 && i0 < t1))
                return A.ioore(bytes, i0);
              byte = bytes[i0];
              if (byte >= 128) {
                markEnd = i1 - 1;
                i0 = i1;
                break;
              }
              i0 = i1;
            }
            if (markEnd - i < 20)
              for (m = i; m < markEnd; ++m) {
                if (!(m < t1))
                  return A.ioore(bytes, m);
                t3 = A.Primitives_stringFromCharCode(bytes[m]);
                buffer._contents += t3;
              }
            else {
              t3 = A.String_String$fromCharCodes(bytes, i, markEnd);
              buffer._contents += t3;
            }
            if (markEnd === end)
              break $label0$0;
            i = i0;
          } else
            i = i0;
        }
      if (single && state > 32)
        if (t2) {
          t1 = A.Primitives_stringFromCharCode(_65533);
          buffer._contents += t1;
        } else {
          _this._convert$_state = 77;
          _this._charOrIndex = end;
          return "";
        }
      _this._convert$_state = state;
      _this._charOrIndex = char;
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  A._BigIntImpl.prototype = {
    $negate(_) {
      var t2, t3, _this = this,
        t1 = _this._used;
      if (t1 === 0)
        return _this;
      t2 = !_this._isNegative;
      t3 = _this._digits;
      t1 = A._BigIntImpl__normalize(t1, t3);
      return new A._BigIntImpl(t1 === 0 ? false : t2, t3, t1);
    },
    _dlShift$1(n) {
      var resultUsed, digits, resultDigits, i, t1, t2, t3,
        used = this._used;
      if (used === 0)
        return $.$get$_BigIntImpl_zero();
      resultUsed = used + n;
      digits = this._digits;
      resultDigits = new Uint16Array(resultUsed);
      for (i = used - 1, t1 = digits.length; i >= 0; --i) {
        t2 = i + n;
        if (!(i < t1))
          return A.ioore(digits, i);
        t3 = digits[i];
        if (!(t2 >= 0 && t2 < resultUsed))
          return A.ioore(resultDigits, t2);
        resultDigits[t2] = t3;
      }
      t1 = this._isNegative;
      t2 = A._BigIntImpl__normalize(resultUsed, resultDigits);
      return new A._BigIntImpl(t2 === 0 ? false : t1, resultDigits, t2);
    },
    _drShift$1(n) {
      var resultUsed, digits, resultDigits, t1, i, t2, t3, result, _this = this,
        used = _this._used;
      if (used === 0)
        return $.$get$_BigIntImpl_zero();
      resultUsed = used - n;
      if (resultUsed <= 0)
        return _this._isNegative ? $.$get$_BigIntImpl__minusOne() : $.$get$_BigIntImpl_zero();
      digits = _this._digits;
      resultDigits = new Uint16Array(resultUsed);
      for (t1 = digits.length, i = n; i < used; ++i) {
        t2 = i - n;
        if (!(i >= 0 && i < t1))
          return A.ioore(digits, i);
        t3 = digits[i];
        if (!(t2 < resultUsed))
          return A.ioore(resultDigits, t2);
        resultDigits[t2] = t3;
      }
      t2 = _this._isNegative;
      t3 = A._BigIntImpl__normalize(resultUsed, resultDigits);
      result = new A._BigIntImpl(t3 === 0 ? false : t2, resultDigits, t3);
      if (t2)
        for (i = 0; i < n; ++i) {
          if (!(i < t1))
            return A.ioore(digits, i);
          if (digits[i] !== 0)
            return result.$sub(0, $.$get$_BigIntImpl_one());
        }
      return result;
    },
    $shl(_, shiftAmount) {
      var t1, digitShift, resultUsed, resultDigits, t2, _this = this;
      if (shiftAmount < 0)
        throw A.wrapException(A.ArgumentError$("shift-amount must be posititve " + shiftAmount, null));
      t1 = _this._used;
      if (t1 === 0)
        return _this;
      digitShift = B.JSInt_methods._tdivFast$1(shiftAmount, 16);
      if (B.JSInt_methods.$mod(shiftAmount, 16) === 0)
        return _this._dlShift$1(digitShift);
      resultUsed = t1 + digitShift + 1;
      resultDigits = new Uint16Array(resultUsed);
      A._BigIntImpl__lsh(_this._digits, t1, shiftAmount, resultDigits);
      t1 = _this._isNegative;
      t2 = A._BigIntImpl__normalize(resultUsed, resultDigits);
      return new A._BigIntImpl(t2 === 0 ? false : t1, resultDigits, t2);
    },
    $shr(_, shiftAmount) {
      var t1, digitShift, bitShift, resultUsed, digits, resultDigits, t2, result, i, _this = this;
      if (shiftAmount < 0)
        throw A.wrapException(A.ArgumentError$("shift-amount must be posititve " + shiftAmount, null));
      t1 = _this._used;
      if (t1 === 0)
        return _this;
      digitShift = B.JSInt_methods._tdivFast$1(shiftAmount, 16);
      bitShift = B.JSInt_methods.$mod(shiftAmount, 16);
      if (bitShift === 0)
        return _this._drShift$1(digitShift);
      resultUsed = t1 - digitShift;
      if (resultUsed <= 0)
        return _this._isNegative ? $.$get$_BigIntImpl__minusOne() : $.$get$_BigIntImpl_zero();
      digits = _this._digits;
      resultDigits = new Uint16Array(resultUsed);
      A._BigIntImpl__rsh(digits, t1, shiftAmount, resultDigits);
      t1 = _this._isNegative;
      t2 = A._BigIntImpl__normalize(resultUsed, resultDigits);
      result = new A._BigIntImpl(t2 === 0 ? false : t1, resultDigits, t2);
      if (t1) {
        t1 = digits.length;
        if (!(digitShift >= 0 && digitShift < t1))
          return A.ioore(digits, digitShift);
        if ((digits[digitShift] & B.JSInt_methods.$shl(1, bitShift) - 1) !== 0)
          return result.$sub(0, $.$get$_BigIntImpl_one());
        for (i = 0; i < digitShift; ++i) {
          if (!(i < t1))
            return A.ioore(digits, i);
          if (digits[i] !== 0)
            return result.$sub(0, $.$get$_BigIntImpl_one());
        }
      }
      return result;
    },
    compareTo$1(_, other) {
      var t1, result;
      type$._BigIntImpl._as(other);
      t1 = this._isNegative;
      if (t1 === other._isNegative) {
        result = A._BigIntImpl__compareDigits(this._digits, this._used, other._digits, other._used);
        return t1 ? 0 - result : result;
      }
      return t1 ? -1 : 1;
    },
    _absAddSetSign$2(other, isNegative) {
      var resultUsed, resultDigits, t1, _this = this,
        used = _this._used,
        otherUsed = other._used;
      if (used < otherUsed)
        return other._absAddSetSign$2(_this, isNegative);
      if (used === 0)
        return $.$get$_BigIntImpl_zero();
      if (otherUsed === 0)
        return _this._isNegative === isNegative ? _this : _this.$negate(0);
      resultUsed = used + 1;
      resultDigits = new Uint16Array(resultUsed);
      A._BigIntImpl__absAdd(_this._digits, used, other._digits, otherUsed, resultDigits);
      t1 = A._BigIntImpl__normalize(resultUsed, resultDigits);
      return new A._BigIntImpl(t1 === 0 ? false : isNegative, resultDigits, t1);
    },
    _absSubSetSign$2(other, isNegative) {
      var otherUsed, resultDigits, t1, _this = this,
        used = _this._used;
      if (used === 0)
        return $.$get$_BigIntImpl_zero();
      otherUsed = other._used;
      if (otherUsed === 0)
        return _this._isNegative === isNegative ? _this : _this.$negate(0);
      resultDigits = new Uint16Array(used);
      A._BigIntImpl__absSub(_this._digits, used, other._digits, otherUsed, resultDigits);
      t1 = A._BigIntImpl__normalize(used, resultDigits);
      return new A._BigIntImpl(t1 === 0 ? false : isNegative, resultDigits, t1);
    },
    _absAndSetSign$2(other, isNegative) {
      var digits, otherDigits, resultDigits, t1, t2, i, t3, t4,
        resultUsed = this._used,
        resultUsed0 = other._used;
      resultUsed = resultUsed < resultUsed0 ? resultUsed : resultUsed0;
      digits = this._digits;
      otherDigits = other._digits;
      resultDigits = new Uint16Array(resultUsed);
      for (t1 = digits.length, t2 = otherDigits.length, i = 0; i < resultUsed; ++i) {
        if (!(i < t1))
          return A.ioore(digits, i);
        t3 = digits[i];
        if (!(i < t2))
          return A.ioore(otherDigits, i);
        t4 = otherDigits[i];
        if (!(i < resultUsed))
          return A.ioore(resultDigits, i);
        resultDigits[i] = t3 & t4;
      }
      t1 = A._BigIntImpl__normalize(resultUsed, resultDigits);
      return new A._BigIntImpl(t1 === 0 ? false : isNegative, resultDigits, t1);
    },
    _absAndNotSetSign$2(other, isNegative) {
      var t1, t2, i, t3, t4,
        resultUsed = this._used,
        digits = this._digits,
        otherDigits = other._digits,
        resultDigits = new Uint16Array(resultUsed),
        m = other._used;
      if (resultUsed < m)
        m = resultUsed;
      for (t1 = digits.length, t2 = otherDigits.length, i = 0; i < m; ++i) {
        if (!(i < t1))
          return A.ioore(digits, i);
        t3 = digits[i];
        if (!(i < t2))
          return A.ioore(otherDigits, i);
        t4 = otherDigits[i];
        if (!(i < resultUsed))
          return A.ioore(resultDigits, i);
        resultDigits[i] = t3 & ~t4;
      }
      for (i = m; i < resultUsed; ++i) {
        if (!(i >= 0 && i < t1))
          return A.ioore(digits, i);
        t2 = digits[i];
        if (!(i < resultUsed))
          return A.ioore(resultDigits, i);
        resultDigits[i] = t2;
      }
      t1 = A._BigIntImpl__normalize(resultUsed, resultDigits);
      return new A._BigIntImpl(t1 === 0 ? false : isNegative, resultDigits, t1);
    },
    _absOrSetSign$2(other, isNegative) {
      var m, l, t1, t2, i, t3, t4, lDigits,
        used = this._used,
        otherUsed = other._used,
        resultUsed = used > otherUsed ? used : otherUsed,
        digits = this._digits,
        otherDigits = other._digits,
        resultDigits = new Uint16Array(resultUsed);
      if (used < otherUsed) {
        m = used;
        l = other;
      } else {
        m = otherUsed;
        l = this;
      }
      for (t1 = digits.length, t2 = otherDigits.length, i = 0; i < m; ++i) {
        if (!(i < t1))
          return A.ioore(digits, i);
        t3 = digits[i];
        if (!(i < t2))
          return A.ioore(otherDigits, i);
        t4 = otherDigits[i];
        if (!(i < resultUsed))
          return A.ioore(resultDigits, i);
        resultDigits[i] = t3 | t4;
      }
      lDigits = l._digits;
      for (t1 = lDigits.length, i = m; i < resultUsed; ++i) {
        if (!(i >= 0 && i < t1))
          return A.ioore(lDigits, i);
        t2 = lDigits[i];
        if (!(i < resultUsed))
          return A.ioore(resultDigits, i);
        resultDigits[i] = t2;
      }
      t1 = A._BigIntImpl__normalize(resultUsed, resultDigits);
      return new A._BigIntImpl(t1 === 0 ? false : isNegative, resultDigits, t1);
    },
    _absXorSetSign$2(other, isNegative) {
      var m, l, t1, t2, i, t3, t4, lDigits,
        used = this._used,
        otherUsed = other._used,
        resultUsed = used > otherUsed ? used : otherUsed,
        digits = this._digits,
        otherDigits = other._digits,
        resultDigits = new Uint16Array(resultUsed);
      if (used < otherUsed) {
        m = used;
        l = other;
      } else {
        m = otherUsed;
        l = this;
      }
      for (t1 = digits.length, t2 = otherDigits.length, i = 0; i < m; ++i) {
        if (!(i < t1))
          return A.ioore(digits, i);
        t3 = digits[i];
        if (!(i < t2))
          return A.ioore(otherDigits, i);
        t4 = otherDigits[i];
        if (!(i < resultUsed))
          return A.ioore(resultDigits, i);
        resultDigits[i] = t3 ^ t4;
      }
      lDigits = l._digits;
      for (t1 = lDigits.length, i = m; i < resultUsed; ++i) {
        if (!(i >= 0 && i < t1))
          return A.ioore(lDigits, i);
        t2 = lDigits[i];
        if (!(i < resultUsed))
          return A.ioore(resultDigits, i);
        resultDigits[i] = t2;
      }
      t1 = A._BigIntImpl__normalize(resultUsed, resultDigits);
      return new A._BigIntImpl(t1 === 0 ? false : isNegative, resultDigits, t1);
    },
    $and(_, other) {
      var t1, n, p, _this = this;
      if (_this._used === 0 || other._used === 0)
        return $.$get$_BigIntImpl_zero();
      t1 = _this._isNegative;
      if (t1 === other._isNegative) {
        if (t1) {
          t1 = $.$get$_BigIntImpl_one();
          return _this._absSubSetSign$2(t1, true)._absOrSetSign$2(other._absSubSetSign$2(t1, true), true)._absAddSetSign$2(t1, true);
        }
        return _this._absAndSetSign$2(other, false);
      }
      if (t1) {
        n = _this;
        p = other;
      } else {
        n = other;
        p = _this;
      }
      return p._absAndNotSetSign$2(n._absSubSetSign$2($.$get$_BigIntImpl_one(), false), false);
    },
    $or(_, other) {
      var t1, n, p, _this = this;
      if (_this._used === 0)
        return other;
      if (other._used === 0)
        return _this;
      t1 = _this._isNegative;
      if (t1 === other._isNegative) {
        if (t1) {
          t1 = $.$get$_BigIntImpl_one();
          return _this._absSubSetSign$2(t1, true)._absAndSetSign$2(other._absSubSetSign$2(t1, true), true)._absAddSetSign$2(t1, true);
        }
        return _this._absOrSetSign$2(other, false);
      }
      if (t1) {
        n = _this;
        p = other;
      } else {
        n = other;
        p = _this;
      }
      t1 = $.$get$_BigIntImpl_one();
      return n._absSubSetSign$2(t1, true)._absAndNotSetSign$2(p, true)._absAddSetSign$2(t1, true);
    },
    $xor(_, other) {
      var t1, n, p, _this = this;
      if (_this._used === 0)
        return other;
      if (other._used === 0)
        return _this;
      t1 = _this._isNegative;
      if (t1 === other._isNegative) {
        if (t1) {
          t1 = $.$get$_BigIntImpl_one();
          return _this._absSubSetSign$2(t1, true)._absXorSetSign$2(other._absSubSetSign$2(t1, true), false);
        }
        return _this._absXorSetSign$2(other, false);
      }
      if (t1) {
        n = _this;
        p = other;
      } else {
        n = other;
        p = _this;
      }
      t1 = $.$get$_BigIntImpl_one();
      return p._absXorSetSign$2(n._absSubSetSign$2(t1, true), true)._absAddSetSign$2(t1, true);
    },
    $not(_) {
      var _this = this;
      if (_this._used === 0)
        return $.$get$_BigIntImpl__minusOne();
      if (_this._isNegative)
        return _this._absSubSetSign$2($.$get$_BigIntImpl_one(), false);
      return _this._absAddSetSign$2($.$get$_BigIntImpl_one(), true);
    },
    $add(_, other) {
      var t2, isNegative, _this = this,
        t1 = _this._used;
      if (t1 === 0)
        return other;
      t2 = other._used;
      if (t2 === 0)
        return _this;
      isNegative = _this._isNegative;
      if (isNegative === other._isNegative)
        return _this._absAddSetSign$2(other, isNegative);
      if (A._BigIntImpl__compareDigits(_this._digits, t1, other._digits, t2) >= 0)
        return _this._absSubSetSign$2(other, isNegative);
      return other._absSubSetSign$2(_this, !isNegative);
    },
    $sub(_, other) {
      var t2, isNegative, _this = this,
        t1 = _this._used;
      if (t1 === 0)
        return other.$negate(0);
      t2 = other._used;
      if (t2 === 0)
        return _this;
      isNegative = _this._isNegative;
      if (isNegative !== other._isNegative)
        return _this._absAddSetSign$2(other, isNegative);
      if (A._BigIntImpl__compareDigits(_this._digits, t1, other._digits, t2) >= 0)
        return _this._absSubSetSign$2(other, isNegative);
      return other._absSubSetSign$2(_this, !isNegative);
    },
    $mul(_, other) {
      var resultUsed, digits, otherDigits, resultDigits, t1, i, t2,
        used = this._used,
        otherUsed = other._used;
      if (used === 0 || otherUsed === 0)
        return $.$get$_BigIntImpl_zero();
      resultUsed = used + otherUsed;
      digits = this._digits;
      otherDigits = other._digits;
      resultDigits = new Uint16Array(resultUsed);
      for (t1 = otherDigits.length, i = 0; i < otherUsed;) {
        if (!(i < t1))
          return A.ioore(otherDigits, i);
        A._BigIntImpl__mulAdd(otherDigits[i], digits, 0, resultDigits, i, used);
        ++i;
      }
      t1 = this._isNegative !== other._isNegative;
      t2 = A._BigIntImpl__normalize(resultUsed, resultDigits);
      return new A._BigIntImpl(t2 === 0 ? false : t1, resultDigits, t2);
    },
    _div$1(other) {
      var lastQuo_used, quo_digits, t1, quo;
      if (this._used < other._used)
        return $.$get$_BigIntImpl_zero();
      this._divRem$1(other);
      lastQuo_used = $._BigIntImpl____lastQuoRemUsed._readField$0() - $._BigIntImpl____lastRemUsed._readField$0();
      quo_digits = A._BigIntImpl__cloneDigits($._BigIntImpl____lastQuoRemDigits._readField$0(), $._BigIntImpl____lastRemUsed._readField$0(), $._BigIntImpl____lastQuoRemUsed._readField$0(), lastQuo_used);
      t1 = A._BigIntImpl__normalize(lastQuo_used, quo_digits);
      quo = new A._BigIntImpl(false, quo_digits, t1);
      return this._isNegative !== other._isNegative && t1 > 0 ? quo.$negate(0) : quo;
    },
    _rem$1(other) {
      var remDigits, t1, rem, _this = this;
      if (_this._used < other._used)
        return _this;
      _this._divRem$1(other);
      remDigits = A._BigIntImpl__cloneDigits($._BigIntImpl____lastQuoRemDigits._readField$0(), 0, $._BigIntImpl____lastRemUsed._readField$0(), $._BigIntImpl____lastRemUsed._readField$0());
      t1 = A._BigIntImpl__normalize($._BigIntImpl____lastRemUsed._readField$0(), remDigits);
      rem = new A._BigIntImpl(false, remDigits, t1);
      if ($._BigIntImpl____lastRem_nsh._readField$0() > 0)
        rem = rem.$shr(0, $._BigIntImpl____lastRem_nsh._readField$0());
      return _this._isNegative && rem._used > 0 ? rem.$negate(0) : rem;
    },
    _divRem$1(other) {
      var yDigits, yUsed, t1, nsh, yDigits0, yUsed0, resultDigits, resultUsed0, topDigitDivisor, j, tmpDigits, tmpUsed, resultUsed1, t2, nyDigits, i, estimatedQuotientDigit, _this = this,
        resultUsed = _this._used;
      if (resultUsed === $._BigIntImpl__lastDividendUsed && other._used === $._BigIntImpl__lastDivisorUsed && _this._digits === $._BigIntImpl__lastDividendDigits && other._digits === $._BigIntImpl__lastDivisorDigits)
        return;
      yDigits = other._digits;
      yUsed = other._used;
      t1 = yUsed - 1;
      if (!(t1 >= 0 && t1 < yDigits.length))
        return A.ioore(yDigits, t1);
      nsh = 16 - B.JSInt_methods.get$bitLength(yDigits[t1]);
      if (nsh > 0) {
        yDigits0 = new Uint16Array(yUsed + 5);
        yUsed0 = A._BigIntImpl__lShiftDigits(yDigits, yUsed, nsh, yDigits0);
        resultDigits = new Uint16Array(resultUsed + 5);
        resultUsed0 = A._BigIntImpl__lShiftDigits(_this._digits, resultUsed, nsh, resultDigits);
      } else {
        resultDigits = A._BigIntImpl__cloneDigits(_this._digits, 0, resultUsed, resultUsed + 2);
        yUsed0 = yUsed;
        yDigits0 = yDigits;
        resultUsed0 = resultUsed;
      }
      t1 = yUsed0 - 1;
      if (!(t1 >= 0 && t1 < yDigits0.length))
        return A.ioore(yDigits0, t1);
      topDigitDivisor = yDigits0[t1];
      j = resultUsed0 - yUsed0;
      tmpDigits = new Uint16Array(resultUsed0);
      tmpUsed = A._BigIntImpl__dlShiftDigits(yDigits0, yUsed0, j, tmpDigits);
      resultUsed1 = resultUsed0 + 1;
      t1 = resultDigits.length;
      if (A._BigIntImpl__compareDigits(resultDigits, resultUsed0, tmpDigits, tmpUsed) >= 0) {
        if (!(resultUsed0 >= 0 && resultUsed0 < t1))
          return A.ioore(resultDigits, resultUsed0);
        resultDigits[resultUsed0] = 1;
        A._BigIntImpl__absSub(resultDigits, resultUsed1, tmpDigits, tmpUsed, resultDigits);
      } else {
        if (!(resultUsed0 >= 0 && resultUsed0 < t1))
          return A.ioore(resultDigits, resultUsed0);
        resultDigits[resultUsed0] = 0;
      }
      t2 = yUsed0 + 2;
      nyDigits = new Uint16Array(t2);
      if (!(yUsed0 >= 0 && yUsed0 < t2))
        return A.ioore(nyDigits, yUsed0);
      nyDigits[yUsed0] = 1;
      A._BigIntImpl__absSub(nyDigits, yUsed0 + 1, yDigits0, yUsed0, nyDigits);
      i = resultUsed0 - 1;
      for (; j > 0;) {
        estimatedQuotientDigit = A._BigIntImpl__estimateQuotientDigit(topDigitDivisor, resultDigits, i);
        --j;
        A._BigIntImpl__mulAdd(estimatedQuotientDigit, nyDigits, 0, resultDigits, j, yUsed0);
        if (!(i >= 0 && i < t1))
          return A.ioore(resultDigits, i);
        if (resultDigits[i] < estimatedQuotientDigit) {
          tmpUsed = A._BigIntImpl__dlShiftDigits(nyDigits, yUsed0, j, tmpDigits);
          A._BigIntImpl__absSub(resultDigits, resultUsed1, tmpDigits, tmpUsed, resultDigits);
          for (; --estimatedQuotientDigit, resultDigits[i] < estimatedQuotientDigit;)
            A._BigIntImpl__absSub(resultDigits, resultUsed1, tmpDigits, tmpUsed, resultDigits);
        }
        --i;
      }
      $._BigIntImpl__lastDividendDigits = _this._digits;
      $._BigIntImpl__lastDividendUsed = resultUsed;
      $._BigIntImpl__lastDivisorDigits = yDigits;
      $._BigIntImpl__lastDivisorUsed = yUsed;
      $._BigIntImpl____lastQuoRemDigits._value = resultDigits;
      $._BigIntImpl____lastQuoRemUsed._value = resultUsed1;
      $._BigIntImpl____lastRemUsed._value = yUsed0;
      $._BigIntImpl____lastRem_nsh._value = nsh;
    },
    get$hashCode(_) {
      var hash, t2, t3, i,
        combine = new A._BigIntImpl_hashCode_combine(),
        t1 = this._used;
      if (t1 === 0)
        return 6707;
      hash = this._isNegative ? 83585 : 429689;
      for (t2 = this._digits, t3 = t2.length, i = 0; i < t1; ++i) {
        if (!(i < t3))
          return A.ioore(t2, i);
        hash = combine.call$2(hash, t2[i]);
      }
      return new A._BigIntImpl_hashCode_finish().call$1(hash);
    },
    $eq(_, other) {
      if (other == null)
        return false;
      return other instanceof A._BigIntImpl && this.compareTo$1(0, other) === 0;
    },
    get$bitLength(_) {
      var t2, t3, t4, highBits, $length, i,
        t1 = this._used;
      if (t1 === 0)
        return 0;
      t2 = this._digits;
      t3 = t1 - 1;
      t4 = t2.length;
      if (!(t3 >= 0 && t3 < t4))
        return A.ioore(t2, t3);
      highBits = t2[t3];
      $length = 16 * t3 + B.JSInt_methods.get$bitLength(highBits);
      if (!this._isNegative)
        return $length;
      if ((highBits & highBits - 1) !== 0)
        return $length;
      for (i = t1 - 2; i >= 0; --i) {
        if (!(i < t4))
          return A.ioore(t2, i);
        if (t2[i] !== 0)
          return $length;
      }
      return $length - 1;
    },
    $tdiv(_, other) {
      if (other._used === 0)
        throw A.wrapException(B.C_IntegerDivisionByZeroException);
      return this._div$1(other);
    },
    remainder$1(_, other) {
      if (other._used === 0)
        throw A.wrapException(B.C_IntegerDivisionByZeroException);
      return this._rem$1(other);
    },
    $mod(_, other) {
      var result;
      if (other._used === 0)
        throw A.wrapException(B.C_IntegerDivisionByZeroException);
      result = this._rem$1(other);
      if (result._isNegative)
        result = other._isNegative ? result.$sub(0, other) : result.$add(0, other);
      return result;
    },
    get$isEven(_) {
      var t1;
      if (this._used !== 0) {
        t1 = this._digits;
        if (0 >= t1.length)
          return A.ioore(t1, 0);
        t1 = (t1[0] & 1) === 0;
      } else
        t1 = true;
      return t1;
    },
    pow$1(exponent) {
      var result, base;
      if (exponent < 0)
        throw A.wrapException(A.ArgumentError$("Exponent must not be negative: " + exponent, null));
      if (exponent === 0)
        return $.$get$_BigIntImpl_one();
      result = $.$get$_BigIntImpl_one();
      for (base = this; exponent !== 0;) {
        if ((exponent & 1) === 1)
          result = result.$mul(0, base);
        exponent = B.JSInt_methods._shrOtherPositive$1(exponent, 1);
        if (exponent !== 0)
          base = base.$mul(0, base);
      }
      return result;
    },
    modPow$2(_, exponent, modulus) {
      var modulusUsed, modulusUsed2p4, exponentBitlen, t1, t2, z, resultDigits, result2Digits, gDigits, gUsed, j, i, resultUsed, result2Used, t0;
      if (exponent._isNegative)
        throw A.wrapException(A.ArgumentError$("exponent must be positive: " + exponent.toString$0(0), null));
      if (modulus.compareTo$1(0, $.$get$_BigIntImpl_zero()) <= 0)
        throw A.wrapException(A.ArgumentError$("modulus must be strictly positive: " + modulus.toString$0(0), null));
      if (exponent._used === 0)
        return $.$get$_BigIntImpl_one();
      modulusUsed = modulus._used;
      modulusUsed2p4 = 2 * modulusUsed + 4;
      exponentBitlen = exponent.get$bitLength(0);
      if (exponentBitlen <= 0)
        return $.$get$_BigIntImpl_one();
      t1 = modulus._digits;
      t2 = modulusUsed - 1;
      if (!(t2 >= 0 && t2 < t1.length))
        return A.ioore(t1, t2);
      z = new A._BigIntClassic(modulus, modulus.$shl(0, 16 - B.JSInt_methods.get$bitLength(t1[t2])));
      resultDigits = new Uint16Array(modulusUsed2p4);
      result2Digits = new Uint16Array(modulusUsed2p4);
      gDigits = new Uint16Array(modulusUsed);
      gUsed = z.convert$2(this, gDigits);
      for (j = gUsed - 1; j >= 0; --j) {
        if (!(j < modulusUsed))
          return A.ioore(gDigits, j);
        t1 = gDigits[j];
        if (!(j < modulusUsed2p4))
          return A.ioore(resultDigits, j);
        resultDigits[j] = t1;
      }
      for (i = exponentBitlen - 2, resultUsed = gUsed; i >= 0; --i) {
        result2Used = z.sqr$3(resultDigits, resultUsed, result2Digits);
        if (exponent.$and(0, $.$get$_BigIntImpl_one().$shl(0, i))._used !== 0)
          resultUsed = z._reduce$2(resultDigits, A._BigIntImpl__mulDigits(result2Digits, result2Used, gDigits, gUsed, resultDigits));
        else {
          resultUsed = result2Used;
          t0 = result2Digits;
          result2Digits = resultDigits;
          resultDigits = t0;
        }
      }
      t1 = A._BigIntImpl__normalize(resultUsed, resultDigits);
      return new A._BigIntImpl(false, resultDigits, t1);
    },
    modInverse$1(_, modulus) {
      var t2, _this = this,
        t1 = $.$get$_BigIntImpl_zero();
      if (modulus.compareTo$1(0, t1) <= 0)
        throw A.wrapException(A.ArgumentError$("Modulus must be strictly positive: " + modulus.toString$0(0), null));
      t2 = modulus.compareTo$1(0, $.$get$_BigIntImpl_one());
      if (t2 === 0)
        return t1;
      return A._BigIntImpl__binaryGcd(modulus, _this._isNegative || A._BigIntImpl__compareDigits(_this._digits, _this._used, modulus._digits, modulus._used) >= 0 ? _this.$mod(0, modulus) : _this, true);
    },
    toSigned$1(_, width) {
      var t1 = $.$get$_BigIntImpl_one(),
        signMask = t1.$shl(0, width - 1);
      return this.$and(0, signMask.$sub(0, t1)).$sub(0, this.$and(0, signMask));
    },
    get$isValidInt() {
      var asInt, t1;
      if (this._used <= 3)
        return true;
      asInt = this.toInt$0(0);
      if (!isFinite(asInt))
        return false;
      t1 = this.compareTo$1(0, A._BigIntImpl__BigIntImpl$_fromInt(asInt));
      return t1 === 0;
    },
    toInt$0(_) {
      var i, t1, t2, result;
      for (i = this._used - 1, t1 = this._digits, t2 = t1.length, result = 0; i >= 0; --i) {
        if (!(i < t2))
          return A.ioore(t1, i);
        result = result * 65536 + t1[i];
      }
      return this._isNegative ? -result : result;
    },
    toString$0(_) {
      var decimalDigitChunks, rest, t2, digits4, t3, _this = this,
        t1 = _this._used;
      if (t1 === 0)
        return "0";
      if (t1 === 1) {
        if (_this._isNegative) {
          t1 = _this._digits;
          if (0 >= t1.length)
            return A.ioore(t1, 0);
          return B.JSInt_methods.toString$0(-t1[0]);
        }
        t1 = _this._digits;
        if (0 >= t1.length)
          return A.ioore(t1, 0);
        return B.JSInt_methods.toString$0(t1[0]);
      }
      decimalDigitChunks = A._setArrayType([], type$.JSArray_String);
      t1 = _this._isNegative;
      rest = t1 ? _this.$negate(0) : _this;
      for (; rest._used > 1;) {
        t2 = $.$get$_BigIntImpl__bigInt10000();
        if (t2._used === 0)
          A.throwExpression(B.C_IntegerDivisionByZeroException);
        digits4 = rest._rem$1(t2).toString$0(0);
        B.JSArray_methods.add$1(decimalDigitChunks, digits4);
        t3 = digits4.length;
        if (t3 === 1)
          B.JSArray_methods.add$1(decimalDigitChunks, "000");
        if (t3 === 2)
          B.JSArray_methods.add$1(decimalDigitChunks, "00");
        if (t3 === 3)
          B.JSArray_methods.add$1(decimalDigitChunks, "0");
        rest = rest._div$1(t2);
      }
      t2 = rest._digits;
      if (0 >= t2.length)
        return A.ioore(t2, 0);
      B.JSArray_methods.add$1(decimalDigitChunks, B.JSInt_methods.toString$0(t2[0]));
      if (t1)
        B.JSArray_methods.add$1(decimalDigitChunks, "-");
      return new A.ReversedListIterable(decimalDigitChunks, type$.ReversedListIterable_String).join$0(0);
    },
    _toRadixCodeUnit$1(digit) {
      if (digit < 10)
        return 48 + digit;
      return 97 + digit - 10;
    },
    toRadixString$1(_, radix) {
      var t1, digitString, base, reversedDigitCodeUnits, rest, t2, digit, _this = this;
      if (radix < 2 || radix > 36)
        throw A.wrapException(A.RangeError$range(radix, 2, 36, null, null));
      t1 = _this._used;
      if (t1 === 0)
        return "0";
      if (t1 === 1) {
        t1 = _this._digits;
        if (0 >= t1.length)
          return A.ioore(t1, 0);
        digitString = B.JSInt_methods.toRadixString$1(t1[0], radix);
        if (_this._isNegative)
          return "-" + digitString;
        return digitString;
      }
      if (radix === 16)
        return _this._toHexString$0();
      base = A._BigIntImpl__BigIntImpl$_fromInt(radix);
      reversedDigitCodeUnits = A._setArrayType([], type$.JSArray_int);
      t1 = _this._isNegative;
      rest = t1 ? _this.$negate(0) : _this;
      for (t2 = base._used === 0; rest._used !== 0;) {
        if (t2)
          A.throwExpression(B.C_IntegerDivisionByZeroException);
        digit = rest._rem$1(base).toInt$0(0);
        rest = rest._div$1(base);
        B.JSArray_methods.add$1(reversedDigitCodeUnits, _this._toRadixCodeUnit$1(digit));
      }
      digitString = A.String_String$fromCharCodes(new A.ReversedListIterable(reversedDigitCodeUnits, type$.ReversedListIterable_int), 0, null);
      if (t1)
        return "-" + digitString;
      return digitString;
    },
    _toHexString$0() {
      var t1, t2, t3, i, chunk, j, msbChunk, _this = this,
        chars = A._setArrayType([], type$.JSArray_int);
      for (t1 = _this._used - 1, t2 = _this._digits, t3 = t2.length, i = 0; i < t1; ++i) {
        if (!(i < t3))
          return A.ioore(t2, i);
        chunk = t2[i];
        for (j = 0; j < 4; ++j) {
          B.JSArray_methods.add$1(chars, _this._toRadixCodeUnit$1(chunk & 15));
          chunk = chunk >>> 4;
        }
      }
      if (!(t1 >= 0 && t1 < t3))
        return A.ioore(t2, t1);
      msbChunk = t2[t1];
      for (; msbChunk !== 0;) {
        B.JSArray_methods.add$1(chars, _this._toRadixCodeUnit$1(msbChunk & 15));
        msbChunk = msbChunk >>> 4;
      }
      if (_this._isNegative)
        B.JSArray_methods.add$1(chars, 45);
      return A.String_String$fromCharCodes(new A.ReversedListIterable(chars, type$.ReversedListIterable_int), 0, null);
    },
    $isBigInt: 1,
    $isComparable: 1
  };
  A._BigIntImpl_hashCode_combine.prototype = {
    call$2(hash, value) {
      hash = hash + value & 536870911;
      hash = hash + ((hash & 524287) << 10) & 536870911;
      return hash ^ hash >>> 6;
    },
    $signature: 19
  };
  A._BigIntImpl_hashCode_finish.prototype = {
    call$1(hash) {
      hash = hash + ((hash & 67108863) << 3) & 536870911;
      hash ^= hash >>> 11;
      return hash + ((hash & 16383) << 15) & 536870911;
    },
    $signature: 13
  };
  A._BigIntClassic.prototype = {
    convert$2(x, resultDigits) {
      var t2, remainder, used, digits, i, t3,
        t1 = x._isNegative;
      if (!t1) {
        t2 = this._modulus;
        t2 = A._BigIntImpl__compareDigits(x._digits, x._used, t2._digits, t2._used) >= 0;
      } else
        t2 = true;
      if (t2) {
        t2 = this._modulus;
        remainder = x._rem$1(t2);
        if (t1 && remainder._used > 0)
          remainder = remainder.$add(0, t2);
        used = remainder._used;
        digits = remainder._digits;
      } else {
        used = x._used;
        digits = x._digits;
      }
      for (t1 = digits.length, t2 = resultDigits.length, i = used; --i, i >= 0;) {
        if (!(i < t1))
          return A.ioore(digits, i);
        t3 = digits[i];
        if (!(i < t2))
          return A.ioore(resultDigits, i);
        resultDigits[i] = t3;
      }
      return used;
    },
    _reduce$2(xDigits, xUsed) {
      var t1;
      if (xUsed < this._modulus._used)
        return xUsed;
      t1 = A._BigIntImpl__normalize(xUsed, xDigits);
      return this.convert$2(new A._BigIntImpl(false, xDigits, t1)._rem$1(this._normalizedModulus), xDigits);
    },
    sqr$3(xDigits, xUsed, resultDigits) {
      var i, t2, t3, i0, t4,
        t1 = A._BigIntImpl__normalize(xUsed, xDigits),
        b = new A._BigIntImpl(false, xDigits, t1),
        b2 = b.$mul(0, b);
      for (i = b2._used, t1 = b2._digits, t2 = t1.length, t3 = resultDigits.length, i0 = 0; i0 < i; ++i0) {
        if (!(i0 < t2))
          return A.ioore(t1, i0);
        t4 = t1[i0];
        if (!(i0 < t3))
          return A.ioore(resultDigits, i0);
        resultDigits[i0] = t4;
      }
      for (t1 = 2 * xUsed; i < t1; ++i) {
        if (!(i >= 0 && i < t3))
          return A.ioore(resultDigits, i);
        resultDigits[i] = 0;
      }
      return this._reduce$2(resultDigits, t1);
    }
  };
  A.NoSuchMethodError_toString_closure.prototype = {
    call$2(key, value) {
      var t1, t2, t3;
      type$.Symbol._as(key);
      t1 = this.sb;
      t2 = this._box_0;
      t3 = t1._contents += t2.comma;
      t3 += key.__internal$_name;
      t1._contents = t3;
      t1._contents = t3 + ": ";
      t3 = A.Error_safeToString(value);
      t1._contents += t3;
      t2.comma = ", ";
    },
    $signature: 91
  };
  A.DateTime.prototype = {
    get$timeZoneOffset() {
      if (this.isUtc)
        return A.Duration$(0);
      return A.Duration$(0 - A.Primitives_lazyAsJsDate(this).getTimezoneOffset());
    },
    $eq(_, other) {
      if (other == null)
        return false;
      return other instanceof A.DateTime && this._core$_value === other._core$_value && this.isUtc === other.isUtc;
    },
    compareTo$1(_, other) {
      return B.JSInt_methods.compareTo$1(this._core$_value, type$.DateTime._as(other)._core$_value);
    },
    get$hashCode(_) {
      var t1 = this._core$_value;
      return (t1 ^ B.JSInt_methods._shrOtherPositive$1(t1, 30)) & 1073741823;
    },
    toLocal$0() {
      if (this.isUtc)
        return A.DateTime$_withValue(this._core$_value, false);
      return this;
    },
    toUtc$0() {
      if (this.isUtc)
        return this;
      return A.DateTime$_withValue(this._core$_value, true);
    },
    toString$0(_) {
      var _this = this,
        y = A.DateTime__fourDigits(A.Primitives_getYear(_this)),
        m = A.DateTime__twoDigits(A.Primitives_getMonth(_this)),
        d = A.DateTime__twoDigits(A.Primitives_getDay(_this)),
        h = A.DateTime__twoDigits(A.Primitives_getHours(_this)),
        min = A.DateTime__twoDigits(A.Primitives_getMinutes(_this)),
        sec = A.DateTime__twoDigits(A.Primitives_getSeconds(_this)),
        ms = A.DateTime__threeDigits(A.Primitives_getMilliseconds(_this)),
        t1 = y + "-" + m;
      if (_this.isUtc)
        return t1 + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z";
      else
        return t1 + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
    },
    toIso8601String$0() {
      var _this = this,
        y = A.Primitives_getYear(_this) >= -9999 && A.Primitives_getYear(_this) <= 9999 ? A.DateTime__fourDigits(A.Primitives_getYear(_this)) : A.DateTime__sixDigits(A.Primitives_getYear(_this)),
        m = A.DateTime__twoDigits(A.Primitives_getMonth(_this)),
        d = A.DateTime__twoDigits(A.Primitives_getDay(_this)),
        h = A.DateTime__twoDigits(A.Primitives_getHours(_this)),
        min = A.DateTime__twoDigits(A.Primitives_getMinutes(_this)),
        sec = A.DateTime__twoDigits(A.Primitives_getSeconds(_this)),
        ms = A.DateTime__threeDigits(A.Primitives_getMilliseconds(_this)),
        t1 = y + "-" + m;
      if (_this.isUtc)
        return t1 + "-" + d + "T" + h + ":" + min + ":" + sec + "." + ms + "Z";
      else
        return t1 + "-" + d + "T" + h + ":" + min + ":" + sec + "." + ms;
    },
    $isComparable: 1
  };
  A.DateTime_parse_parseIntOrZero.prototype = {
    call$1(matched) {
      if (matched == null)
        return 0;
      return A.int_parse(matched, null);
    },
    $signature: 60
  };
  A.DateTime_parse_parseMilliAndMicroseconds.prototype = {
    call$1(matched) {
      var t1, result, i;
      if (matched == null)
        return 0;
      for (t1 = matched.length, result = 0, i = 0; i < 6; ++i) {
        result *= 10;
        if (i < t1) {
          if (!(i < t1))
            return A.ioore(matched, i);
          result += matched.charCodeAt(i) ^ 48;
        }
      }
      return result;
    },
    $signature: 60
  };
  A.Duration.prototype = {
    $eq(_, other) {
      if (other == null)
        return false;
      return other instanceof A.Duration && this._duration === other._duration;
    },
    get$hashCode(_) {
      return B.JSInt_methods.get$hashCode(this._duration);
    },
    compareTo$1(_, other) {
      return B.JSInt_methods.compareTo$1(this._duration, type$.Duration._as(other)._duration);
    },
    toString$0(_) {
      var sign, minutes, minutesPadding, seconds, secondsPadding,
        microseconds = this._duration,
        hours = B.JSInt_methods._tdivFast$1(microseconds, 3600000000),
        microseconds0 = microseconds % 3600000000;
      if (microseconds < 0) {
        hours = 0 - hours;
        microseconds = 0 - microseconds0;
        sign = "-";
      } else {
        microseconds = microseconds0;
        sign = "";
      }
      minutes = B.JSInt_methods._tdivFast$1(microseconds, 60000000);
      microseconds %= 60000000;
      minutesPadding = minutes < 10 ? "0" : "";
      seconds = B.JSInt_methods._tdivFast$1(microseconds, 1000000);
      secondsPadding = seconds < 10 ? "0" : "";
      return sign + hours + ":" + minutesPadding + minutes + ":" + secondsPadding + seconds + "." + B.JSString_methods.padLeft$2(B.JSInt_methods.toString$0(microseconds % 1000000), 6, "0");
    },
    $isComparable: 1
  };
  A._Enum.prototype = {
    toString$0(_) {
      return this._enumToString$0();
    }
  };
  A.Error.prototype = {
    get$stackTrace() {
      return A.Primitives_extractStackTrace(this);
    }
  };
  A.AssertionError.prototype = {
    toString$0(_) {
      var t1 = this.message;
      if (t1 != null)
        return "Assertion failed: " + A.Error_safeToString(t1);
      return "Assertion failed";
    }
  };
  A.TypeError.prototype = {};
  A.ArgumentError.prototype = {
    get$_errorName() {
      return "Invalid argument" + (!this._hasValue ? "(s)" : "");
    },
    get$_errorExplanation() {
      return "";
    },
    toString$0(_) {
      var _this = this,
        $name = _this.name,
        nameString = $name == null ? "" : " (" + $name + ")",
        message = _this.message,
        messageString = message == null ? "" : ": " + A.S(message),
        prefix = _this.get$_errorName() + nameString + messageString;
      if (!_this._hasValue)
        return prefix;
      return prefix + _this.get$_errorExplanation() + ": " + A.Error_safeToString(_this.get$invalidValue());
    },
    get$invalidValue() {
      return this.invalidValue;
    }
  };
  A.RangeError.prototype = {
    get$invalidValue() {
      return A._asNumQ(this.invalidValue);
    },
    get$_errorName() {
      return "RangeError";
    },
    get$_errorExplanation() {
      var explanation,
        start = this.start,
        end = this.end;
      if (start == null)
        explanation = end != null ? ": Not less than or equal to " + A.S(end) : "";
      else if (end == null)
        explanation = ": Not greater than or equal to " + A.S(start);
      else if (end > start)
        explanation = ": Not in inclusive range " + A.S(start) + ".." + A.S(end);
      else
        explanation = end < start ? ": Valid value range is empty" : ": Only valid value is " + A.S(start);
      return explanation;
    }
  };
  A.IndexError.prototype = {
    get$invalidValue() {
      return A._asInt(this.invalidValue);
    },
    get$_errorName() {
      return "RangeError";
    },
    get$_errorExplanation() {
      if (A._asInt(this.invalidValue) < 0)
        return ": index must not be negative";
      var t1 = this.length;
      if (t1 === 0)
        return ": no indices are valid";
      return ": index should be less than " + t1;
    },
    get$length(receiver) {
      return this.length;
    }
  };
  A.NoSuchMethodError.prototype = {
    toString$0(_) {
      var $arguments, t1, _i, t2, t3, argument, receiverText, actualParameters, _this = this, _box_0 = {},
        sb = new A.StringBuffer("");
      _box_0.comma = "";
      $arguments = _this._core$_arguments;
      for (t1 = $arguments.length, _i = 0, t2 = "", t3 = ""; _i < t1; ++_i, t3 = ", ") {
        argument = $arguments[_i];
        sb._contents = t2 + t3;
        t2 = A.Error_safeToString(argument);
        t2 = sb._contents += t2;
        _box_0.comma = ", ";
      }
      _this._namedArguments.forEach$1(0, new A.NoSuchMethodError_toString_closure(_box_0, sb));
      receiverText = A.Error_safeToString(_this._core$_receiver);
      actualParameters = sb.toString$0(0);
      return "NoSuchMethodError: method not found: '" + _this._core$_memberName.__internal$_name + "'\nReceiver: " + receiverText + "\nArguments: [" + actualParameters + "]";
    }
  };
  A.UnsupportedError.prototype = {
    toString$0(_) {
      return "Unsupported operation: " + this.message;
    }
  };
  A.UnimplementedError.prototype = {
    toString$0(_) {
      var message = this.message;
      return message != null ? "UnimplementedError: " + message : "UnimplementedError";
    }
  };
  A.StateError.prototype = {
    toString$0(_) {
      return "Bad state: " + this.message;
    }
  };
  A.ConcurrentModificationError.prototype = {
    toString$0(_) {
      var t1 = this.modifiedObject;
      if (t1 == null)
        return "Concurrent modification during iteration.";
      return "Concurrent modification during iteration: " + A.Error_safeToString(t1) + ".";
    }
  };
  A.OutOfMemoryError.prototype = {
    toString$0(_) {
      return "Out of Memory";
    },
    get$stackTrace() {
      return null;
    },
    $isError: 1
  };
  A.StackOverflowError.prototype = {
    toString$0(_) {
      return "Stack Overflow";
    },
    get$stackTrace() {
      return null;
    },
    $isError: 1
  };
  A._Exception.prototype = {
    toString$0(_) {
      return "Exception: " + this.message;
    },
    $isException: 1
  };
  A.FormatException.prototype = {
    toString$0(_) {
      var t1, lineEnd, lineNum, lineStart, previousCharWasCR, i, char, end, start, prefix, postfix,
        message = this.message,
        report = "" !== message ? "FormatException: " + message : "FormatException",
        offset = this.offset,
        source = this.source;
      if (typeof source == "string") {
        if (offset != null)
          t1 = offset < 0 || offset > source.length;
        else
          t1 = false;
        if (t1)
          offset = null;
        if (offset == null) {
          if (source.length > 78)
            source = B.JSString_methods.substring$2(source, 0, 75) + "...";
          return report + "\n" + source;
        }
        for (lineEnd = source.length, lineNum = 1, lineStart = 0, previousCharWasCR = false, i = 0; i < offset; ++i) {
          if (!(i < lineEnd))
            return A.ioore(source, i);
          char = source.charCodeAt(i);
          if (char === 10) {
            if (lineStart !== i || !previousCharWasCR)
              ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = false;
          } else if (char === 13) {
            ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = true;
          }
        }
        report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + (offset - lineStart + 1) + ")\n") : report + (" (at character " + (offset + 1) + ")\n");
        for (i = offset; i < lineEnd; ++i) {
          if (!(i >= 0))
            return A.ioore(source, i);
          char = source.charCodeAt(i);
          if (char === 10 || char === 13) {
            lineEnd = i;
            break;
          }
        }
        if (lineEnd - lineStart > 78)
          if (offset - lineStart < 75) {
            end = lineStart + 75;
            start = lineStart;
            prefix = "";
            postfix = "...";
          } else {
            if (lineEnd - offset < 75) {
              start = lineEnd - 75;
              end = lineEnd;
              postfix = "";
            } else {
              start = offset - 36;
              end = offset + 36;
              postfix = "...";
            }
            prefix = "...";
          }
        else {
          end = lineEnd;
          start = lineStart;
          prefix = "";
          postfix = "";
        }
        return report + prefix + B.JSString_methods.substring$2(source, start, end) + postfix + "\n" + B.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
      } else
        return offset != null ? report + (" (at offset " + A.S(offset) + ")") : report;
    },
    $isException: 1,
    get$message() {
      return this.message;
    },
    get$source() {
      return this.source;
    },
    get$offset() {
      return this.offset;
    }
  };
  A.IntegerDivisionByZeroException.prototype = {
    get$stackTrace() {
      return null;
    },
    toString$0(_) {
      return "IntegerDivisionByZeroException";
    },
    $isError: 1,
    $isException: 1
  };
  A.Iterable.prototype = {
    map$1$1(_, toElement, $T) {
      var t1 = A._instanceType(this);
      return A.MappedIterable_MappedIterable(this, t1._bind$1($T)._eval$1("1(Iterable.E)")._as(toElement), t1._eval$1("Iterable.E"), $T);
    },
    where$1(_, test) {
      var t1 = A._instanceType(this);
      return new A.WhereIterable(this, t1._eval$1("bool(Iterable.E)")._as(test), t1._eval$1("WhereIterable<Iterable.E>"));
    },
    contains$1(_, element) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (J.$eq$(t1.get$current(), element))
          return true;
      return false;
    },
    fold$1$2(_, initialValue, combine, $T) {
      var t1, value;
      $T._as(initialValue);
      A._instanceType(this)._bind$1($T)._eval$1("1(1,Iterable.E)")._as(combine);
      for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
        value = combine.call$2(value, t1.get$current());
      return value;
    },
    join$1(_, separator) {
      var first, t1,
        iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        return "";
      first = J.toString$0$(iterator.get$current());
      if (!iterator.moveNext$0())
        return first;
      if (separator.length === 0) {
        t1 = first;
        do
          t1 += J.toString$0$(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        t1 = first;
        do
          t1 = t1 + separator + J.toString$0$(iterator.get$current());
        while (iterator.moveNext$0());
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    toList$1$growable(_, growable) {
      return A.List_List$of(this, growable, A._instanceType(this)._eval$1("Iterable.E"));
    },
    toList$0(_) {
      return this.toList$1$growable(0, true);
    },
    get$length(_) {
      var count,
        it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$isNotEmpty(_) {
      return !this.get$isEmpty(this);
    },
    take$1(_, count) {
      return A.TakeIterable_TakeIterable(this, count, A._instanceType(this)._eval$1("Iterable.E"));
    },
    skip$1(_, count) {
      return A.SkipIterable_SkipIterable(this, count, A._instanceType(this)._eval$1("Iterable.E"));
    },
    get$first(_) {
      var it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw A.wrapException(A.IterableElementError_noElement());
      return it.get$current();
    },
    get$last(_) {
      var result,
        it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw A.wrapException(A.IterableElementError_noElement());
      do
        result = it.get$current();
      while (it.moveNext$0());
      return result;
    },
    firstWhere$2$orElse(_, test, orElse) {
      var t1, element;
      A._instanceType(this)._eval$1("bool(Iterable.E)")._as(test);
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = t1.get$current();
        if (A.boolConversionCheck(test.call$1(element)))
          return element;
      }
      throw A.wrapException(A.IterableElementError_noElement());
    },
    firstWhere$1(_, test) {
      return this.firstWhere$2$orElse(0, test, null);
    },
    elementAt$1(_, index) {
      var iterator, skipCount;
      A.RangeError_checkNotNegative(index, "index");
      iterator = this.get$iterator(this);
      for (skipCount = index; iterator.moveNext$0();) {
        if (skipCount === 0)
          return iterator.get$current();
        --skipCount;
      }
      throw A.wrapException(A.IndexError$withLength(index, index - skipCount, this, null, "index"));
    },
    toString$0(_) {
      return A.Iterable_iterableToShortString(this, "(", ")");
    }
  };
  A.MapEntry.prototype = {
    toString$0(_) {
      return "MapEntry(" + A.S(this.key) + ": " + A.S(this.value) + ")";
    },
    get$value() {
      return this.value;
    }
  };
  A.Null.prototype = {
    get$hashCode(_) {
      return A.Object.prototype.get$hashCode.call(this, 0);
    },
    toString$0(_) {
      return "null";
    }
  };
  A.Object.prototype = {$isObject: 1,
    $eq(_, other) {
      return this === other;
    },
    get$hashCode(_) {
      return A.Primitives_objectHashCode(this);
    },
    toString$0(_) {
      return "Instance of '" + A.Primitives_objectTypeName(this) + "'";
    },
    noSuchMethod$1(_, invocation) {
      throw A.wrapException(A.NoSuchMethodError_NoSuchMethodError$withInvocation(this, type$.Invocation._as(invocation)));
    },
    get$runtimeType(_) {
      return A.getRuntimeTypeOfDartObject(this);
    },
    toString() {
      return this.toString$0(this);
    }
  };
  A._StringStackTrace.prototype = {
    toString$0(_) {
      return "";
    },
    $isStackTrace: 1
  };
  A.Runes.prototype = {
    get$iterator(_) {
      return new A.RuneIterator(this.string);
    },
    get$last(_) {
      var t3, code, previousCode,
        t1 = this.string,
        t2 = t1.length;
      if (t2 === 0)
        throw A.wrapException(A.StateError$("No elements."));
      t3 = t2 - 1;
      if (!(t3 >= 0))
        return A.ioore(t1, t3);
      code = t1.charCodeAt(t3);
      if ((code & 64512) === 56320 && t2 > 1) {
        t3 = t2 - 2;
        if (!(t3 >= 0))
          return A.ioore(t1, t3);
        previousCode = t1.charCodeAt(t3);
        if ((previousCode & 64512) === 55296)
          return A._combineSurrogatePair(previousCode, code);
      }
      return code;
    }
  };
  A.RuneIterator.prototype = {
    get$current() {
      return this._currentCodePoint;
    },
    moveNext$0() {
      var codeUnit, nextPosition, nextCodeUnit, _this = this,
        t1 = _this._position = _this._nextPosition,
        t2 = _this.string,
        t3 = t2.length;
      if (t1 === t3) {
        _this._currentCodePoint = -1;
        return false;
      }
      if (!(t1 < t3))
        return A.ioore(t2, t1);
      codeUnit = t2.charCodeAt(t1);
      nextPosition = t1 + 1;
      if ((codeUnit & 64512) === 55296 && nextPosition < t3) {
        if (!(nextPosition < t3))
          return A.ioore(t2, nextPosition);
        nextCodeUnit = t2.charCodeAt(nextPosition);
        if ((nextCodeUnit & 64512) === 56320) {
          _this._nextPosition = nextPosition + 1;
          _this._currentCodePoint = A._combineSurrogatePair(codeUnit, nextCodeUnit);
          return true;
        }
      }
      _this._nextPosition = nextPosition;
      _this._currentCodePoint = codeUnit;
      return true;
    },
    $isIterator: 1
  };
  A.StringBuffer.prototype = {
    get$length(_) {
      return this._contents.length;
    },
    toString$0(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isStringSink: 1
  };
  A.Uri__parseIPv4Address_error.prototype = {
    call$2(msg, position) {
      throw A.wrapException(A.FormatException$("Illegal IPv4 address, " + msg, this.host, position));
    },
    $signature: 100
  };
  A.Uri_parseIPv6Address_error.prototype = {
    call$2(msg, position) {
      throw A.wrapException(A.FormatException$("Illegal IPv6 address, " + msg, this.host, position));
    },
    $signature: 102
  };
  A.Uri_parseIPv6Address_parseHex.prototype = {
    call$2(start, end) {
      var value;
      if (end - start > 4)
        this.error.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
      value = A.int_parse(B.JSString_methods.substring$2(this.host, start, end), 16);
      if (value < 0 || value > 65535)
        this.error.call$2("each part must be in the range of `0x0..0xFFFF`", start);
      return value;
    },
    $signature: 19
  };
  A._Uri.prototype = {
    get$_text() {
      var t1, t2, t3, t4, _this = this,
        value = _this.___Uri__text_FI;
      if (value === $) {
        t1 = _this.scheme;
        t2 = t1.length !== 0 ? "" + t1 + ":" : "";
        t3 = _this._host;
        t4 = t3 == null;
        if (!t4 || t1 === "file") {
          t1 = t2 + "//";
          t2 = _this._userInfo;
          if (t2.length !== 0)
            t1 = t1 + t2 + "@";
          if (!t4)
            t1 += t3;
          t2 = _this._port;
          if (t2 != null)
            t1 = t1 + ":" + A.S(t2);
        } else
          t1 = t2;
        t1 += _this.path;
        t2 = _this._query;
        if (t2 != null)
          t1 = t1 + "?" + t2;
        t2 = _this._fragment;
        if (t2 != null)
          t1 = t1 + "#" + t2;
        value !== $ && A.throwLateFieldADI("_text");
        value = _this.___Uri__text_FI = t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      return value;
    },
    get$pathSegments() {
      var pathToSplit, t1, result, _this = this,
        value = _this.___Uri_pathSegments_FI;
      if (value === $) {
        pathToSplit = _this.path;
        t1 = pathToSplit.length;
        if (t1 !== 0) {
          if (0 >= t1)
            return A.ioore(pathToSplit, 0);
          t1 = pathToSplit.charCodeAt(0) === 47;
        } else
          t1 = false;
        if (t1)
          pathToSplit = B.JSString_methods.substring$1(pathToSplit, 1);
        result = pathToSplit.length === 0 ? B.List_empty1 : A.List_List$unmodifiable(new A.MappedListIterable(A._setArrayType(pathToSplit.split("/"), type$.JSArray_String), type$.dynamic_Function_String._as(A.core_Uri_decodeComponent$closure()), type$.MappedListIterable_String_dynamic), type$.String);
        _this.___Uri_pathSegments_FI !== $ && A.throwLateFieldADI("pathSegments");
        _this.set$___Uri_pathSegments_FI(result);
        value = result;
      }
      return value;
    },
    get$hashCode(_) {
      var result, _this = this,
        value = _this.___Uri_hashCode_FI;
      if (value === $) {
        result = B.JSString_methods.get$hashCode(_this.get$_text());
        _this.___Uri_hashCode_FI !== $ && A.throwLateFieldADI("hashCode");
        _this.___Uri_hashCode_FI = result;
        value = result;
      }
      return value;
    },
    get$userInfo() {
      return this._userInfo;
    },
    get$host() {
      var host = this._host;
      if (host == null)
        return "";
      if (B.JSString_methods.startsWith$1(host, "["))
        return B.JSString_methods.substring$2(host, 1, host.length - 1);
      return host;
    },
    get$port() {
      var t1 = this._port;
      return t1 == null ? A._Uri__defaultPort(this.scheme) : t1;
    },
    get$query() {
      var t1 = this._query;
      return t1 == null ? "" : t1;
    },
    get$fragment() {
      var t1 = this._fragment;
      return t1 == null ? "" : t1;
    },
    isScheme$1(scheme) {
      var thisScheme = this.scheme;
      if (scheme.length !== thisScheme.length)
        return false;
      return A._caseInsensitiveCompareStart(scheme, thisScheme, 0) >= 0;
    },
    replace$1$scheme(scheme) {
      var isFile, userInfo, port, host, currentPath, t1, path, _this = this;
      scheme = A._Uri__makeScheme(scheme, 0, scheme.length);
      isFile = scheme === "file";
      userInfo = _this._userInfo;
      port = _this._port;
      if (scheme !== _this.scheme)
        port = A._Uri__makePort(port, scheme);
      host = _this._host;
      if (!(host != null))
        host = userInfo.length !== 0 || port != null || isFile ? "" : null;
      currentPath = _this.path;
      if (!isFile)
        t1 = host != null && currentPath.length !== 0;
      else
        t1 = true;
      if (t1 && !B.JSString_methods.startsWith$1(currentPath, "/"))
        currentPath = "/" + currentPath;
      path = currentPath;
      return A._Uri$_internal(scheme, userInfo, host, port, path, _this._query, _this._fragment);
    },
    _mergePaths$2(base, reference) {
      var backCount, refStart, baseEnd, t1, newEnd, delta, t2, t3;
      for (backCount = 0, refStart = 0; B.JSString_methods.startsWith$2(reference, "../", refStart);) {
        refStart += 3;
        ++backCount;
      }
      baseEnd = B.JSString_methods.lastIndexOf$1(base, "/");
      t1 = base.length;
      while (true) {
        if (!(baseEnd > 0 && backCount > 0))
          break;
        newEnd = B.JSString_methods.lastIndexOf$2(base, "/", baseEnd - 1);
        if (newEnd < 0)
          break;
        delta = baseEnd - newEnd;
        t2 = delta !== 2;
        if (!t2 || delta === 3) {
          t3 = newEnd + 1;
          if (!(t3 < t1))
            return A.ioore(base, t3);
          if (base.charCodeAt(t3) === 46)
            if (t2) {
              t2 = newEnd + 2;
              if (!(t2 < t1))
                return A.ioore(base, t2);
              t2 = base.charCodeAt(t2) === 46;
            } else
              t2 = true;
          else
            t2 = false;
        } else
          t2 = false;
        if (t2)
          break;
        --backCount;
        baseEnd = newEnd;
      }
      return B.JSString_methods.replaceRange$3(base, baseEnd + 1, null, B.JSString_methods.substring$1(reference, refStart - 3 * backCount));
    },
    resolve$1(reference) {
      return this.resolveUri$1(A.Uri_parse(reference));
    },
    resolveUri$1(reference) {
      var targetScheme, t1, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, packageNameEnd, packageName, mergedPath, fragment, _this = this;
      if (reference.get$scheme().length !== 0)
        return reference;
      else {
        targetScheme = _this.scheme;
        if (reference.get$hasAuthority()) {
          t1 = reference.replace$1$scheme(targetScheme);
          return t1;
        } else {
          targetUserInfo = _this._userInfo;
          targetHost = _this._host;
          targetPort = _this._port;
          targetPath = _this.path;
          if (reference.get$hasEmptyPath())
            targetQuery = reference.get$hasQuery() ? reference.get$query() : _this._query;
          else {
            packageNameEnd = A._Uri__packageNameEnd(_this, targetPath);
            if (packageNameEnd > 0) {
              packageName = B.JSString_methods.substring$2(targetPath, 0, packageNameEnd);
              targetPath = reference.get$hasAbsolutePath() ? packageName + A._Uri__removeDotSegments(reference.get$path()) : packageName + A._Uri__removeDotSegments(_this._mergePaths$2(B.JSString_methods.substring$1(targetPath, packageName.length), reference.get$path()));
            } else if (reference.get$hasAbsolutePath())
              targetPath = A._Uri__removeDotSegments(reference.get$path());
            else if (targetPath.length === 0)
              if (targetHost == null)
                targetPath = targetScheme.length === 0 ? reference.get$path() : A._Uri__removeDotSegments(reference.get$path());
              else
                targetPath = A._Uri__removeDotSegments("/" + reference.get$path());
            else {
              mergedPath = _this._mergePaths$2(targetPath, reference.get$path());
              t1 = targetScheme.length === 0;
              if (!t1 || targetHost != null || B.JSString_methods.startsWith$1(targetPath, "/"))
                targetPath = A._Uri__removeDotSegments(mergedPath);
              else
                targetPath = A._Uri__normalizeRelativePath(mergedPath, !t1 || targetHost != null);
            }
            targetQuery = reference.get$hasQuery() ? reference.get$query() : null;
          }
        }
      }
      fragment = reference.get$hasFragment() ? reference.get$fragment() : null;
      return A._Uri$_internal(targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, fragment);
    },
    get$hasAuthority() {
      return this._host != null;
    },
    get$hasQuery() {
      return this._query != null;
    },
    get$hasFragment() {
      return this._fragment != null;
    },
    get$hasEmptyPath() {
      return this.path.length === 0;
    },
    get$hasAbsolutePath() {
      return B.JSString_methods.startsWith$1(this.path, "/");
    },
    toFilePath$0() {
      var pathSegments, _this = this,
        t1 = _this.scheme;
      if (t1 !== "" && t1 !== "file")
        throw A.wrapException(A.UnsupportedError$("Cannot extract a file path from a " + t1 + " URI"));
      t1 = _this._query;
      if ((t1 == null ? "" : t1) !== "")
        throw A.wrapException(A.UnsupportedError$(string$.Cannotfq));
      t1 = _this._fragment;
      if ((t1 == null ? "" : t1) !== "")
        throw A.wrapException(A.UnsupportedError$(string$.Cannotff));
      if (_this._host != null && _this.get$host() !== "")
        A.throwExpression(A.UnsupportedError$(string$.Cannotn));
      pathSegments = _this.get$pathSegments();
      A._Uri__checkNonWindowsPathReservedCharacters(pathSegments, false);
      t1 = A.StringBuffer__writeAll(B.JSString_methods.startsWith$1(_this.path, "/") ? "" + "/" : "", pathSegments, "/");
      t1 = t1.charCodeAt(0) == 0 ? t1 : t1;
      return t1;
    },
    toString$0(_) {
      return this.get$_text();
    },
    $eq(_, other) {
      var t1, t2, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (type$.Uri._is(other))
        if (_this.scheme === other.get$scheme())
          if (_this._host != null === other.get$hasAuthority())
            if (_this._userInfo === other.get$userInfo())
              if (_this.get$host() === other.get$host())
                if (_this.get$port() === other.get$port())
                  if (_this.path === other.get$path()) {
                    t1 = _this._query;
                    t2 = t1 == null;
                    if (!t2 === other.get$hasQuery()) {
                      if (t2)
                        t1 = "";
                      if (t1 === other.get$query()) {
                        t1 = _this._fragment;
                        t2 = t1 == null;
                        if (!t2 === other.get$hasFragment()) {
                          if (t2)
                            t1 = "";
                          t1 = t1 === other.get$fragment();
                        } else
                          t1 = false;
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  } else
                    t1 = false;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    set$___Uri_pathSegments_FI(___Uri_pathSegments_FI) {
      this.___Uri_pathSegments_FI = type$.List_String._as(___Uri_pathSegments_FI);
    },
    $isUri: 1,
    get$scheme() {
      return this.scheme;
    },
    get$path() {
      return this.path;
    }
  };
  A.UriData.prototype = {
    get$uri() {
      var t2, queryIndex, end, query, _this = this, _null = null,
        t1 = _this._uriCache;
      if (t1 == null) {
        t1 = _this._separatorIndices;
        if (0 >= t1.length)
          return A.ioore(t1, 0);
        t2 = _this._text;
        t1 = t1[0] + 1;
        queryIndex = B.JSString_methods.indexOf$2(t2, "?", t1);
        end = t2.length;
        if (queryIndex >= 0) {
          query = A._Uri__normalizeOrSubstring(t2, queryIndex + 1, end, B.List_42A, false, false);
          end = queryIndex;
        } else
          query = _null;
        t1 = _this._uriCache = new A._DataUri("data", "", _null, _null, A._Uri__normalizeOrSubstring(t2, t1, end, B.List_M2I, false, false), query, _null);
      }
      return t1;
    },
    toString$0(_) {
      var t2,
        t1 = this._separatorIndices;
      if (0 >= t1.length)
        return A.ioore(t1, 0);
      t2 = this._text;
      return t1[0] === -1 ? "data:" + t2 : t2;
    }
  };
  A._createTables_build.prototype = {
    call$2(state, defaultTransition) {
      var t1 = this.tables;
      if (!(state < t1.length))
        return A.ioore(t1, state);
      t1 = t1[state];
      B.NativeUint8List_methods.fillRange$3(t1, 0, 96, defaultTransition);
      return t1;
    },
    $signature: 105
  };
  A._createTables_setChars.prototype = {
    call$3(target, chars, transition) {
      var t1, i, t2;
      for (t1 = chars.length, i = 0; i < t1; ++i) {
        t2 = chars.charCodeAt(i) ^ 96;
        if (!(t2 < 96))
          return A.ioore(target, t2);
        target[t2] = transition;
      }
    },
    $signature: 56
  };
  A._createTables_setRange.prototype = {
    call$3(target, range, transition) {
      var i, n,
        t1 = range.length;
      if (0 >= t1)
        return A.ioore(range, 0);
      i = range.charCodeAt(0);
      if (1 >= t1)
        return A.ioore(range, 1);
      n = range.charCodeAt(1);
      for (; i <= n; ++i) {
        t1 = (i ^ 96) >>> 0;
        if (!(t1 < 96))
          return A.ioore(target, t1);
        target[t1] = transition;
      }
    },
    $signature: 56
  };
  A._SimpleUri.prototype = {
    get$hasAuthority() {
      return this._hostStart > 0;
    },
    get$hasPort() {
      return this._hostStart > 0 && this._portStart + 1 < this._pathStart;
    },
    get$hasQuery() {
      return this._queryStart < this._fragmentStart;
    },
    get$hasFragment() {
      return this._fragmentStart < this._uri.length;
    },
    get$hasAbsolutePath() {
      return B.JSString_methods.startsWith$2(this._uri, "/", this._pathStart);
    },
    get$hasEmptyPath() {
      return this._pathStart === this._queryStart;
    },
    get$scheme() {
      var t1 = this._schemeCache;
      return t1 == null ? this._schemeCache = this._computeScheme$0() : t1;
    },
    _computeScheme$0() {
      var t2, _this = this,
        t1 = _this._schemeEnd;
      if (t1 <= 0)
        return "";
      t2 = t1 === 4;
      if (t2 && B.JSString_methods.startsWith$1(_this._uri, "http"))
        return "http";
      if (t1 === 5 && B.JSString_methods.startsWith$1(_this._uri, "https"))
        return "https";
      if (t2 && B.JSString_methods.startsWith$1(_this._uri, "file"))
        return "file";
      if (t1 === 7 && B.JSString_methods.startsWith$1(_this._uri, "package"))
        return "package";
      return B.JSString_methods.substring$2(_this._uri, 0, t1);
    },
    get$userInfo() {
      var t1 = this._hostStart,
        t2 = this._schemeEnd + 3;
      return t1 > t2 ? B.JSString_methods.substring$2(this._uri, t2, t1 - 1) : "";
    },
    get$host() {
      var t1 = this._hostStart;
      return t1 > 0 ? B.JSString_methods.substring$2(this._uri, t1, this._portStart) : "";
    },
    get$port() {
      var t1, _this = this;
      if (_this.get$hasPort())
        return A.int_parse(B.JSString_methods.substring$2(_this._uri, _this._portStart + 1, _this._pathStart), null);
      t1 = _this._schemeEnd;
      if (t1 === 4 && B.JSString_methods.startsWith$1(_this._uri, "http"))
        return 80;
      if (t1 === 5 && B.JSString_methods.startsWith$1(_this._uri, "https"))
        return 443;
      return 0;
    },
    get$path() {
      return B.JSString_methods.substring$2(this._uri, this._pathStart, this._queryStart);
    },
    get$query() {
      var t1 = this._queryStart,
        t2 = this._fragmentStart;
      return t1 < t2 ? B.JSString_methods.substring$2(this._uri, t1 + 1, t2) : "";
    },
    get$fragment() {
      var t1 = this._fragmentStart,
        t2 = this._uri;
      return t1 < t2.length ? B.JSString_methods.substring$1(t2, t1 + 1) : "";
    },
    _isPort$1(port) {
      var portDigitStart = this._portStart + 1;
      return portDigitStart + port.length === this._pathStart && B.JSString_methods.startsWith$2(this._uri, port, portDigitStart);
    },
    removeFragment$0() {
      var _this = this,
        t1 = _this._fragmentStart,
        t2 = _this._uri;
      if (t1 >= t2.length)
        return _this;
      return new A._SimpleUri(B.JSString_methods.substring$2(t2, 0, t1), _this._schemeEnd, _this._hostStart, _this._portStart, _this._pathStart, _this._queryStart, t1, _this._schemeCache);
    },
    replace$1$scheme(scheme) {
      var schemeChanged, isFile, t1, userInfo, port, host, t2, path, t3, query, fragment, _this = this, _null = null;
      scheme = A._Uri__makeScheme(scheme, 0, scheme.length);
      schemeChanged = !(_this._schemeEnd === scheme.length && B.JSString_methods.startsWith$1(_this._uri, scheme));
      isFile = scheme === "file";
      t1 = _this._hostStart;
      userInfo = t1 > 0 ? B.JSString_methods.substring$2(_this._uri, _this._schemeEnd + 3, t1) : "";
      port = _this.get$hasPort() ? _this.get$port() : _null;
      if (schemeChanged)
        port = A._Uri__makePort(port, scheme);
      t1 = _this._hostStart;
      if (t1 > 0)
        host = B.JSString_methods.substring$2(_this._uri, t1, _this._portStart);
      else
        host = userInfo.length !== 0 || port != null || isFile ? "" : _null;
      t1 = _this._uri;
      t2 = _this._queryStart;
      path = B.JSString_methods.substring$2(t1, _this._pathStart, t2);
      if (!isFile)
        t3 = host != null && path.length !== 0;
      else
        t3 = true;
      if (t3 && !B.JSString_methods.startsWith$1(path, "/"))
        path = "/" + path;
      t3 = _this._fragmentStart;
      query = t2 < t3 ? B.JSString_methods.substring$2(t1, t2 + 1, t3) : _null;
      t2 = _this._fragmentStart;
      fragment = t2 < t1.length ? B.JSString_methods.substring$1(t1, t2 + 1) : _null;
      return A._Uri$_internal(scheme, userInfo, host, port, path, query, fragment);
    },
    resolve$1(reference) {
      return this.resolveUri$1(A.Uri_parse(reference));
    },
    resolveUri$1(reference) {
      if (reference instanceof A._SimpleUri)
        return this._simpleMerge$2(this, reference);
      return this._toNonSimple$0().resolveUri$1(reference);
    },
    _simpleMerge$2(base, ref) {
      var t2, t3, t4, isSimple, delta, refStart, basePathStart, packageNameEnd, basePathStart0, baseStart, baseEnd, baseUri, baseStart0, backCount, refStart0, insert,
        t1 = ref._schemeEnd;
      if (t1 > 0)
        return ref;
      t2 = ref._hostStart;
      if (t2 > 0) {
        t3 = base._schemeEnd;
        if (t3 <= 0)
          return ref;
        t4 = t3 === 4;
        if (t4 && B.JSString_methods.startsWith$1(base._uri, "file"))
          isSimple = ref._pathStart !== ref._queryStart;
        else if (t4 && B.JSString_methods.startsWith$1(base._uri, "http"))
          isSimple = !ref._isPort$1("80");
        else
          isSimple = !(t3 === 5 && B.JSString_methods.startsWith$1(base._uri, "https")) || !ref._isPort$1("443");
        if (isSimple) {
          delta = t3 + 1;
          return new A._SimpleUri(B.JSString_methods.substring$2(base._uri, 0, delta) + B.JSString_methods.substring$1(ref._uri, t1 + 1), t3, t2 + delta, ref._portStart + delta, ref._pathStart + delta, ref._queryStart + delta, ref._fragmentStart + delta, base._schemeCache);
        } else
          return this._toNonSimple$0().resolveUri$1(ref);
      }
      refStart = ref._pathStart;
      t1 = ref._queryStart;
      if (refStart === t1) {
        t2 = ref._fragmentStart;
        if (t1 < t2) {
          t3 = base._queryStart;
          delta = t3 - t1;
          return new A._SimpleUri(B.JSString_methods.substring$2(base._uri, 0, t3) + B.JSString_methods.substring$1(ref._uri, t1), base._schemeEnd, base._hostStart, base._portStart, base._pathStart, t1 + delta, t2 + delta, base._schemeCache);
        }
        t1 = ref._uri;
        if (t2 < t1.length) {
          t3 = base._fragmentStart;
          return new A._SimpleUri(B.JSString_methods.substring$2(base._uri, 0, t3) + B.JSString_methods.substring$1(t1, t2), base._schemeEnd, base._hostStart, base._portStart, base._pathStart, base._queryStart, t2 + (t3 - t2), base._schemeCache);
        }
        return base.removeFragment$0();
      }
      t2 = ref._uri;
      if (B.JSString_methods.startsWith$2(t2, "/", refStart)) {
        basePathStart = base._pathStart;
        packageNameEnd = A._SimpleUri__packageNameEnd(this);
        basePathStart0 = packageNameEnd > 0 ? packageNameEnd : basePathStart;
        delta = basePathStart0 - refStart;
        return new A._SimpleUri(B.JSString_methods.substring$2(base._uri, 0, basePathStart0) + B.JSString_methods.substring$1(t2, refStart), base._schemeEnd, base._hostStart, base._portStart, basePathStart, t1 + delta, ref._fragmentStart + delta, base._schemeCache);
      }
      baseStart = base._pathStart;
      baseEnd = base._queryStart;
      if (baseStart === baseEnd && base._hostStart > 0) {
        for (; B.JSString_methods.startsWith$2(t2, "../", refStart);)
          refStart += 3;
        delta = baseStart - refStart + 1;
        return new A._SimpleUri(B.JSString_methods.substring$2(base._uri, 0, baseStart) + "/" + B.JSString_methods.substring$1(t2, refStart), base._schemeEnd, base._hostStart, base._portStart, baseStart, t1 + delta, ref._fragmentStart + delta, base._schemeCache);
      }
      baseUri = base._uri;
      packageNameEnd = A._SimpleUri__packageNameEnd(this);
      if (packageNameEnd >= 0)
        baseStart0 = packageNameEnd;
      else
        for (baseStart0 = baseStart; B.JSString_methods.startsWith$2(baseUri, "../", baseStart0);)
          baseStart0 += 3;
      backCount = 0;
      while (true) {
        refStart0 = refStart + 3;
        if (!(refStart0 <= t1 && B.JSString_methods.startsWith$2(t2, "../", refStart)))
          break;
        ++backCount;
        refStart = refStart0;
      }
      for (t3 = baseUri.length, insert = ""; baseEnd > baseStart0;) {
        --baseEnd;
        if (!(baseEnd >= 0 && baseEnd < t3))
          return A.ioore(baseUri, baseEnd);
        if (baseUri.charCodeAt(baseEnd) === 47) {
          if (backCount === 0) {
            insert = "/";
            break;
          }
          --backCount;
          insert = "/";
        }
      }
      if (baseEnd === baseStart0 && base._schemeEnd <= 0 && !B.JSString_methods.startsWith$2(baseUri, "/", baseStart)) {
        refStart -= backCount * 3;
        insert = "";
      }
      delta = baseEnd - refStart + insert.length;
      return new A._SimpleUri(B.JSString_methods.substring$2(baseUri, 0, baseEnd) + insert + B.JSString_methods.substring$1(t2, refStart), base._schemeEnd, base._hostStart, base._portStart, baseStart, t1 + delta, ref._fragmentStart + delta, base._schemeCache);
    },
    toFilePath$0() {
      var t2, _this = this,
        t1 = _this._schemeEnd;
      if (t1 >= 0) {
        t2 = !(t1 === 4 && B.JSString_methods.startsWith$1(_this._uri, "file"));
        t1 = t2;
      } else
        t1 = false;
      if (t1)
        throw A.wrapException(A.UnsupportedError$("Cannot extract a file path from a " + _this.get$scheme() + " URI"));
      t1 = _this._queryStart;
      t2 = _this._uri;
      if (t1 < t2.length) {
        if (t1 < _this._fragmentStart)
          throw A.wrapException(A.UnsupportedError$(string$.Cannotfq));
        throw A.wrapException(A.UnsupportedError$(string$.Cannotff));
      }
      if (_this._hostStart < _this._portStart)
        A.throwExpression(A.UnsupportedError$(string$.Cannotn));
      t1 = B.JSString_methods.substring$2(t2, _this._pathStart, t1);
      return t1;
    },
    get$hashCode(_) {
      var t1 = this._hashCodeCache;
      return t1 == null ? this._hashCodeCache = B.JSString_methods.get$hashCode(this._uri) : t1;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return type$.Uri._is(other) && this._uri === other.toString$0(0);
    },
    _toNonSimple$0() {
      var _this = this, _null = null,
        t1 = _this.get$scheme(),
        t2 = _this.get$userInfo(),
        t3 = _this._hostStart > 0 ? _this.get$host() : _null,
        t4 = _this.get$hasPort() ? _this.get$port() : _null,
        t5 = _this._uri,
        t6 = _this._queryStart,
        t7 = B.JSString_methods.substring$2(t5, _this._pathStart, t6),
        t8 = _this._fragmentStart;
      t6 = t6 < t8 ? _this.get$query() : _null;
      return A._Uri$_internal(t1, t2, t3, t4, t7, t6, t8 < t5.length ? _this.get$fragment() : _null);
    },
    toString$0(_) {
      return this._uri;
    },
    $isUri: 1
  };
  A._DataUri.prototype = {};
  A.Expando.prototype = {
    toString$0(_) {
      return "Expando:null";
    }
  };
  A.SecureSocket_connect_closure.prototype = {
    call$1(rawSocket) {
      return A.SecureSocket_SecureSocket$_(rawSocket);
    },
    $signature: 112
  };
  A.RawSecureSocket_connect_closure.prototype = {
    call$1(socket) {
      var t1, t2, address, _this = this;
      socket.set$readEventsEnabled(false);
      socket.set$writeEventsEnabled(false);
      t1 = socket.get$address().get$host();
      t2 = socket.get$port();
      A._RawSecureSocket__verifyFields(t1, t2, false, false);
      address = socket.get$address();
      return A._RawSecureSocket$(address, t2, false, _this.context, socket, null, null, false, false, _this.onBadCertificate, _this.keyLog, _this.supportedProtocols)._handshakeComplete.future;
    },
    $signature: 117
  };
  A._FilterStatus.prototype = {};
  A._RawSecureSocket.prototype = {
    get$_socketSubscription() {
      var t1 = this.___RawSecureSocket__socketSubscription_F;
      t1 === $ && A.throwLateFieldNI("_socketSubscription");
      return t1;
    },
    _RawSecureSocket$12(address, requestedPort, isServer, context, _socket, subscription, _bufferedData, requestClientCertificate, requireClientCertificate, onBadCertificate, keyLog, supportedProtocols) {
      var secureFilter, encodedProtocols, e, s, t3, exception, _this = this,
        t1 = _this._io$_controller,
        t2 = _this.get$_onSubscriptionStateChange();
      t1.set$onListen(t2);
      t3 = _this.get$_onPauseStateChange();
      t1.set$onPause(t3);
      t1.set$onResume(t3);
      t1.set$onCancel(t2);
      t2 = _this._secureFilter;
      t2.toString;
      secureFilter = t2;
      secureFilter.init$0();
      secureFilter.registerHandshakeCompleteCallback$1(_this.get$_secureHandshakeCompleteHandler());
      secureFilter.registerBadCertificateCallback$1(_this.get$_onBadCertificateWrapper());
      t1 = _this._io$_socket;
      t1.set$readEventsEnabled(true);
      t1.set$writeEventsEnabled(false);
      _this.set$___RawSecureSocket__socketSubscription_F(type$.StreamSubscription_RawSocketEvent._as(t1.listen$3$onDone$onError(_this.get$_eventDispatcher(), _this.get$_doneHandler(), _this.get$_reportError())));
      try {
        encodedProtocols = A.SecurityContext__protocolsToLengthEncoding(supportedProtocols);
        t1 = _this.address.get$host();
        secureFilter.connect$6(t1, _this.context, false, false, false, encodedProtocols);
        _this._secureHandshake$0();
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        _this._reportError$2(e, s);
      }
    },
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      var t1;
      type$.nullable_void_Function_RawSocketEvent._as(onData);
      type$.nullable_void_Function._as(onDone);
      this._sendWriteEvent$0();
      t1 = this._io$_controller;
      return new A._ControllerStream(t1, A._instanceType(t1)._eval$1("_ControllerStream<1>")).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$cancelOnError$onDone(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    },
    _completeCloseCompleter$1(dummy) {
      var t1;
      type$.nullable_RawSocket._as(dummy);
      t1 = this._closeCompleter;
      if ((t1.future._state & 30) === 0)
        t1.complete$1(this);
    },
    _completeCloseCompleter$0() {
      return this._completeCloseCompleter$1(null);
    },
    _io$_close$0() {
      var _this = this;
      _this._closedRead = _this._closedWrite = true;
      _this._io$_socket.close$0().then$1$1(_this.get$_completeCloseCompleter(), type$.void);
      _this._socketClosedRead = _this._socketClosedWrite = true;
      _this.get$_socketSubscription();
      _this.get$_socketSubscription().cancel$0();
      _this._io$_controller.close$0();
      _this._io$_status = 203;
    },
    shutdown$1(direction) {
      var _this = this;
      if (direction === B.C_SocketDirection || direction === B.C_SocketDirection0) {
        _this._closedWrite = true;
        if (_this._filterStatus.writeEmpty) {
          _this._io$_socket.shutdown$1(B.C_SocketDirection);
          _this._socketClosedWrite = true;
          if (_this._closedRead)
            _this._io$_close$0();
        }
      }
      if (direction === B.C_SocketDirection1 || direction === B.C_SocketDirection0) {
        _this._socketClosedRead = _this._closedRead = true;
        _this._io$_socket.shutdown$1(B.C_SocketDirection1);
        if (_this._socketClosedWrite)
          _this._io$_close$0();
      }
    },
    _onBadCertificateWrapper$1(certificate) {
      return this.onBadCertificate.call$1(certificate);
    },
    _eventDispatcher$1($event) {
      var e, stackTrace, exception, _this = this;
      type$.RawSocketEvent._as($event);
      try {
        if ($event === B.RawSocketEvent_0) {
          _this._readSocket$0();
          _this._filterPending = true;
          _this._tryFilter$0();
        } else if ($event === B.RawSocketEvent_1) {
          _this._writeSocket$0();
          _this._filterPending = true;
          _this._tryFilter$0();
        } else if ($event === B.RawSocketEvent_2)
          _this._closeHandler$0();
      } catch (exception) {
        e = A.unwrapException(exception);
        stackTrace = A.getTraceFromException(exception);
        _this._reportError$2(e, stackTrace);
      }
    },
    _doneHandler$0() {
      if (this._filterStatus.readEmpty)
        this._io$_close$0();
    },
    _reportError$2(e, stackTrace) {
      var t1, error, t2, _this = this;
      type$.nullable_StackTrace._as(stackTrace);
      if (_this._io$_status === 203)
        return;
      else if (_this._connectPending) {
        t1 = e == null ? type$.Object._as(e) : e;
        _this._handshakeComplete.completeError$2(t1, stackTrace);
      } else {
        t1 = _this._io$_controller;
        error = e == null ? type$.Object._as(e) : e;
        A.checkNotNullable(error, "error", type$.Object);
        if (t1._state >= 4)
          A.throwExpression(t1._badEventState$0());
        if (stackTrace == null)
          stackTrace = A.AsyncError_defaultStackTrace(error);
        t2 = t1._state;
        if ((t2 & 1) !== 0)
          t1._sendError$2(error, stackTrace);
        else if ((t2 & 3) === 0)
          t1._ensurePendingEvents$0().add$1(0, new A._DelayedError(error, stackTrace));
      }
      _this._io$_close$0();
    },
    _reportError$1(e) {
      return this._reportError$2(e, null);
    },
    _closeHandler$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$self = this, t1;
      var $async$_closeHandler$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._io$_status;
              $async$goto = t1 === 202 ? 3 : 5;
              break;
            case 3:
              // then
              if ($async$self._closedRead) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self._socketClosedRead = true;
              $async$goto = $async$self._filterStatus.readEmpty ? 6 : 8;
              break;
            case 6:
              // then
              $async$self._closedRead = true;
              $async$self._io$_controller.add$1(0, B.RawSocketEvent_2);
              if ($async$self._socketClosedWrite)
                $async$self._io$_close$0();
              // goto join
              $async$goto = 7;
              break;
            case 8:
              // else
              $async$self._filterPending = true;
              $async$goto = 9;
              return A._asyncAwait($async$self._tryFilter$0(), $async$_closeHandler$0);
            case 9:
              // returning from await.
            case 7:
              // join
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = t1 === 201 ? 10 : 11;
              break;
            case 10:
              // then
              $async$self._socketClosedRead = true;
              $async$goto = $async$self._filterStatus.readEmpty ? 12 : 14;
              break;
            case 12:
              // then
              $async$self._reportError$2(new A.HandshakeException("HandshakeException", "Connection terminated during handshake", null), null);
              // goto join
              $async$goto = 13;
              break;
            case 14:
              // else
              $async$goto = 15;
              return A._asyncAwait($async$self._secureHandshake$0(), $async$_closeHandler$0);
            case 15:
              // returning from await.
            case 13:
              // join
            case 11:
              // join
            case 4:
              // join
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_closeHandler$0, $async$completer);
    },
    _secureHandshake$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$handler = 1, $async$currentError, $async$self = this, needRetryHandshake, e, stackTrace, exception, $async$exception;
      var $async$_secureHandshake$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 3;
              $async$goto = 6;
              return A._asyncAwait($async$self._secureFilter.handshake$0(), $async$_secureHandshake$0);
            case 6:
              // returning from await.
              needRetryHandshake = $async$result;
              $async$goto = A.boolConversionCheck(needRetryHandshake) ? 7 : 9;
              break;
            case 7:
              // then
              $async$goto = 10;
              return A._asyncAwait($async$self._secureHandshake$0(), $async$_secureHandshake$0);
            case 10:
              // returning from await.
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              $async$self._filterStatus.writeEmpty = false;
              $async$self._readSocket$0();
              $async$self._writeSocket$0();
              $async$self._filterPending = true;
              $async$goto = 11;
              return A._asyncAwait($async$self._tryFilter$0(), $async$_secureHandshake$0);
            case 11:
              // returning from await.
            case 8:
              // join
              $async$handler = 1;
              // goto after finally
              $async$goto = 5;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$currentError;
              e = A.unwrapException($async$exception);
              stackTrace = A.getTraceFromException($async$exception);
              $async$self._reportError$2(e, stackTrace);
              // goto after finally
              $async$goto = 5;
              break;
            case 2:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 5:
              // after finally
              // implicit return
              return A._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return A._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return A._asyncStartSync($async$_secureHandshake$0, $async$completer);
    },
    _secureHandshakeCompleteHandler$0() {
      var error, stack, exception, _this = this;
      _this._io$_status = 202;
      if (_this._connectPending) {
        _this._connectPending = false;
        try {
          _this._secureFilter.selectedProtocol$0();
          A.Timer_Timer(B.Duration_0, new A._RawSecureSocket__secureHandshakeCompleteHandler_closure(_this));
        } catch (exception) {
          error = A.unwrapException(exception);
          stack = A.getTraceFromException(exception);
          _this._handshakeComplete.completeError$2(error, stack);
        }
      }
    },
    _onPauseStateChange$0() {
      var t3, _this = this,
        t1 = _this._io$_controller,
        t2 = t1._state;
      t2 = (t2 & 1) !== 0 ? (t1.get$_subscription()._state & 4) !== 0 : (t2 & 2) === 0;
      t3 = _this._io$_pauseCount;
      if (t2)
        _this._io$_pauseCount = t3 + 1;
      else {
        t2 = t3 - 1;
        _this._io$_pauseCount = t2;
        if (t2 === 0) {
          _this._scheduleReadEvent$0();
          _this._sendWriteEvent$0();
        }
      }
      if (!_this._socketClosedRead || !_this._socketClosedWrite) {
        t2 = t1._state;
        if ((t2 & 1) !== 0 ? (t1.get$_subscription()._state & 4) !== 0 : (t2 & 2) === 0)
          _this.get$_socketSubscription().pause$0();
        else
          _this.get$_socketSubscription().resume$0();
      }
    },
    _onSubscriptionStateChange$0() {
    },
    _tryFilter$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$self = this, e, st, t1, t2, exception, $async$exception;
      var $async$_tryFilter$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              t1 = $async$self._io$_socket;
            case 7:
              // for condition
              // trivial condition
              if ($async$self._io$_status === 203) {
                // goto return
                $async$goto = 1;
                break;
              }
              if (!$async$self._filterPending || $async$self._filterActive) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self._filterActive = true;
              $async$self._filterPending = false;
              $async$goto = 9;
              return A._asyncAwait($async$self._pushAllFilterStages$0(), $async$_tryFilter$0);
            case 9:
              // returning from await.
              $async$self.set$_filterStatus($async$result);
              $async$self._filterActive = false;
              if ($async$self._io$_status === 203) {
                $async$self._secureFilter.destroy$0();
                $async$self._secureFilter = null;
                // goto return
                $async$goto = 1;
                break;
              }
              t1.set$readEventsEnabled(true);
              if ($async$self._filterStatus.writeEmpty && $async$self._closedWrite && !$async$self._socketClosedWrite) {
                $async$self.shutdown$1(B.C_SocketDirection);
                if ($async$self._io$_status === 203) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
              }
              if ($async$self._filterStatus.readEmpty && $async$self._socketClosedRead && !$async$self._closedRead) {
                if ($async$self._io$_status === 201) {
                  $async$self._secureFilter.handshake$0();
                  if ($async$self._io$_status === 201) {
                    t1 = A.HandshakeException$("Connection terminated during handshake");
                    throw A.wrapException(t1);
                  }
                }
                $async$self._closeHandler$0();
              }
              if ($async$self._io$_status === 203) {
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = $async$self._filterStatus;
              $async$goto = t2.progress ? 10 : 11;
              break;
            case 10:
              // then
              $async$self._filterPending = true;
              if (t2.writeEncryptedNoLongerEmpty)
                $async$self._writeSocket$0();
              if ($async$self._filterStatus.writePlaintextNoLongerFull)
                $async$self._sendWriteEvent$0();
              if ($async$self._filterStatus.readEncryptedNoLongerFull)
                $async$self._readSocket$0();
              if ($async$self._filterStatus.readPlaintextNoLongerEmpty)
                $async$self._scheduleReadEvent$0();
              $async$goto = $async$self._io$_status === 201 ? 12 : 13;
              break;
            case 12:
              // then
              $async$goto = 14;
              return A._asyncAwait($async$self._secureHandshake$0(), $async$_tryFilter$0);
            case 14:
              // returning from await.
            case 13:
              // join
            case 11:
              // join
              // goto for condition
              $async$goto = 7;
              break;
            case 8:
              // after for
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              e = A.unwrapException($async$exception);
              st = A.getTraceFromException($async$exception);
              $async$self._reportError$2(e, st);
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return A._asyncStartSync($async$_tryFilter$0, $async$completer);
    },
    _readSocketOrBufferedData$1(bytes) {
      if (!this._socketClosedRead)
        return this._io$_socket.read$1(bytes);
      else
        return null;
    },
    _readSocket$0() {
      var _this = this;
      if (_this._io$_status === 203)
        return;
      if (_this._secureFilter.get$buffers().$index(0, 2).writeFromSource$1(_this.get$_readSocketOrBufferedData()).$gt(0, 0))
        _this._filterStatus.readEmpty = false;
      else
        _this._io$_socket.set$readEventsEnabled(false);
    },
    _writeSocket$0() {
      if (this._socketClosedWrite)
        return;
      var t1 = this._io$_socket;
      if (this._secureFilter.get$buffers().$index(0, 3).readToSocket$1(t1))
        t1.set$writeEventsEnabled(true);
    },
    _scheduleReadEvent$0() {
    },
    _sendWriteEvent$0() {
    },
    _pushAllFilterStages$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$._FilterStatus),
        $async$self = this, bufs, i, t1, args, $async$temp1;
      var $async$_pushAllFilterStages$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._io$_status;
              args = A.List_List$filled(10, null, false, type$.dynamic);
              B.JSArray_methods.$indexSet(args, 0, $async$self._secureFilter._pointer$0());
              B.JSArray_methods.$indexSet(args, 1, t1 !== 202);
              bufs = $async$self._secureFilter.get$buffers();
              for (i = 0; i < 4; ++i) {
                t1 = 2 * i;
                B.JSArray_methods.$indexSet(args, t1 + 2, bufs.$index(0, i).get$start());
                B.JSArray_methods.$indexSet(args, t1 + 3, bufs.$index(0, i).get$end());
              }
              $async$temp1 = type$.List_nullable_Object;
              $async$goto = 2;
              return A._asyncAwait(A._IOService__dispatch(43, args), $async$_pushAllFilterStages$0);
            case 2:
              // returning from await.
              $async$temp1._as($async$result);
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$_pushAllFilterStages$0, $async$completer);
    },
    set$___RawSecureSocket__socketSubscription_F(___RawSecureSocket__socketSubscription_F) {
      this.___RawSecureSocket__socketSubscription_F = type$.StreamSubscription_RawSocketEvent._as(___RawSecureSocket__socketSubscription_F);
    },
    set$_filterStatus(_filterStatus) {
      this._filterStatus = type$._FilterStatus._as(_filterStatus);
    },
    $isRawSecureSocket: 1,
    $isRawSocket: 1
  };
  A._RawSecureSocket__secureHandshakeCompleteHandler_closure.prototype = {
    call$0() {
      var t1 = this.$this;
      return t1._handshakeComplete.complete$1(t1);
    },
    $signature: 0
  };
  A.TlsException.prototype = {
    toString$0(_) {
      var t1 = "" + this.type,
        t2 = this.message;
      if (t2.length !== 0)
        t1 += ": " + t2;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isException: 1
  };
  A.HandshakeException.prototype = {};
  A.SocketDirection.prototype = {};
  A.RawSocketEvent.prototype = {
    toString$0(_) {
      var t1 = this._io$_value;
      if (!(t1 < 4))
        return A.ioore(B.List_5Nm, t1);
      return B.List_5Nm[t1];
    }
  };
  A.jsify__convert.prototype = {
    call$1(o) {
      var t1, convertedMap, key, convertedList;
      if (A._noJsifyRequired(o))
        return o;
      t1 = this._convertedObjects;
      if (t1.containsKey$1(o))
        return t1.$index(0, o);
      if (type$.Map_of_nullable_Object_and_nullable_Object._is(o)) {
        convertedMap = {};
        t1.$indexSet(0, o, convertedMap);
        for (t1 = o.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          key = t1.get$current();
          convertedMap[key] = this.call$1(o.$index(0, key));
        }
        return convertedMap;
      } else if (type$.Iterable_nullable_Object._is(o)) {
        convertedList = [];
        t1.$indexSet(0, o, convertedList);
        B.JSArray_methods.addAll$1(convertedList, J.map$1$1$ax(o, this, type$.dynamic));
        return convertedList;
      } else
        return o;
    },
    $signature: 31
  };
  A.promiseToFuture_closure.prototype = {
    call$1(r) {
      return this.completer.complete$1(this.T._eval$1("0/?")._as(r));
    },
    $signature: 12
  };
  A.promiseToFuture_closure0.prototype = {
    call$1(e) {
      if (e == null)
        return this.completer.completeError$1(new A.NullRejectionException(e === undefined));
      return this.completer.completeError$1(e);
    },
    $signature: 12
  };
  A.dartify_convert.prototype = {
    call$1(o) {
      var t1, proto, t2, dartObject, originalKeys, dartKeys, i, jsKey, dartKey, l, $length;
      if (A._noDartifyRequired(o))
        return o;
      t1 = this._convertedObjects;
      o.toString;
      if (t1.containsKey$1(o))
        return t1.$index(0, o);
      if (o instanceof Date)
        return A.DateTime$fromMillisecondsSinceEpoch(o.getTime(), true);
      if (o instanceof RegExp)
        throw A.wrapException(A.ArgumentError$("structured clone of RegExp", null));
      if (typeof Promise != "undefined" && o instanceof Promise)
        return A.promiseToFuture(o, type$.nullable_Object);
      proto = Object.getPrototypeOf(o);
      if (proto === Object.prototype || proto === null) {
        t2 = type$.nullable_Object;
        dartObject = A.LinkedHashMap_LinkedHashMap$_empty(t2, t2);
        t1.$indexSet(0, o, dartObject);
        originalKeys = Object.keys(o);
        dartKeys = [];
        for (t1 = J.getInterceptor$ax(originalKeys), t2 = t1.get$iterator(originalKeys); t2.moveNext$0();)
          dartKeys.push(A.dartify(t2.get$current()));
        for (i = 0; i < t1.get$length(originalKeys); ++i) {
          jsKey = t1.$index(originalKeys, i);
          if (!(i < dartKeys.length))
            return A.ioore(dartKeys, i);
          dartKey = dartKeys[i];
          if (jsKey != null)
            dartObject.$indexSet(0, dartKey, this.call$1(o[jsKey]));
        }
        return dartObject;
      }
      if (o instanceof Array) {
        l = o;
        dartObject = [];
        t1.$indexSet(0, o, dartObject);
        $length = A._asInt(o.length);
        for (t1 = J.getInterceptor$asx(l), i = 0; i < $length; ++i)
          dartObject.push(this.call$1(t1.$index(l, i)));
        return dartObject;
      }
      return o;
    },
    $signature: 31
  };
  A.NullRejectionException.prototype = {
    toString$0(_) {
      return "Promise was rejected with a value of `" + (this.isUndefined ? "undefined" : "null") + "`.";
    },
    $isException: 1
  };
  A._JSSecureRandom.prototype = {
    _JSSecureRandom$0() {
      var $crypto = self.crypto;
      if ($crypto != null)
        if ($crypto.getRandomValues != null)
          return;
      throw A.wrapException(A.UnsupportedError$("No source of cryptographically secure random numbers available."));
    },
    nextInt$1(max) {
      var byteCount, t1, start, randomLimit, t2, t3, t4, random, result;
      if (max <= 0 || max > 4294967296)
        throw A.wrapException(A.RangeError$("max must be in range 0 < max \u2264 2^32, was " + max));
      if (max > 255)
        if (max > 65535)
          byteCount = max > 16777215 ? 4 : 3;
        else
          byteCount = 2;
      else
        byteCount = 1;
      t1 = this._math$_buffer;
      B.NativeByteData_methods._setUint32$3(t1, 0, 0, false);
      start = 4 - byteCount;
      randomLimit = A._asInt(Math.pow(256, byteCount));
      for (t2 = max - 1, t3 = (max & t2) === 0; true;) {
        t4 = t1.buffer;
        t4 = new Uint8Array(t4, start, byteCount);
        crypto.getRandomValues(t4);
        random = B.NativeByteData_methods._getUint32$2(t1, 0, false);
        if (t3)
          return (random & t2) >>> 0;
        result = random % max;
        if (random - result + max < randomLimit)
          return result;
      }
    }
  };
  A.Endian.prototype = {};
  A.BitcoinAddressType_fromValue_closure.prototype = {
    call$1(element) {
      return type$.BitcoinAddressType._as(element).get$value() === this.value;
    },
    $signature: 238
  };
  A.BitcoinAddressType_fromValue_closure0.prototype = {
    call$0() {
      return A.throwExpression(A.BitcoinBasePluginException$("Invalid BitcoinAddressType: " + this.value));
    },
    $signature: 2
  };
  A.PubKeyAddressType.prototype = {
    get$isP2sh() {
      return false;
    },
    toString$0(_) {
      return "PubKeyAddressType.P2PK";
    },
    $isBitcoinAddressType: 1,
    get$value() {
      return "P2PK";
    }
  };
  A.P2pkhAddressType.prototype = {
    get$isP2sh() {
      return false;
    },
    get$hashLength() {
      return 20;
    },
    toString$0(_) {
      return "P2pkhAddressType." + this.value;
    },
    $isBitcoinAddressType: 1,
    get$value() {
      return this.value;
    }
  };
  A.P2shAddressType.prototype = {
    get$isP2sh() {
      return true;
    },
    toString$0(_) {
      return "P2shAddressType." + this.value;
    },
    $isBitcoinAddressType: 1,
    get$hashLength() {
      return this.hashLength;
    },
    get$value() {
      return this.value;
    }
  };
  A.SegwitAddresType.prototype = {
    get$isP2sh() {
      return false;
    },
    get$hashLength() {
      switch (this) {
        case B.SegwitAddresType_P2WPKH:
          return 20;
        default:
          return 32;
      }
    },
    toString$0(_) {
      return "SegwitAddresType." + this.value;
    },
    $isBitcoinAddressType: 1,
    get$value() {
      return this.value;
    }
  };
  A.LegacyAddress.prototype = {
    LegacyAddress$fromAddress$2$address$network(address, network) {
      var decode = A._BitcoinAddressUtils_decodeLagacyAddressWithNetworkAndType(address, network, this.get$type());
      if (decode == null)
        throw A.wrapException(A.BitcoinBasePluginException$("Invalid " + network.get$conf().coinName.toString$0(0) + " address"));
      this.__LegacyAddress__addressProgram_F !== $ && A.throwLateFieldAI("_addressProgram");
      this.__LegacyAddress__addressProgram_F = decode;
    },
    get$addressProgram() {
      if (this.get$type() === B.C_PubKeyAddressType)
        throw A.wrapException(A.UnimplementedError$(null));
      var t1 = this.__LegacyAddress__addressProgram_F;
      t1 === $ && A.throwLateFieldNI("_addressProgram");
      return t1;
    },
    toAddress$1(network) {
      var t1;
      if (this.get$type() === B.C_PubKeyAddressType)
        A.throwExpression(A.UnimplementedError$(null));
      t1 = this.__LegacyAddress__addressProgram_F;
      t1 === $ && A.throwLateFieldNI("_addressProgram");
      return A._BitcoinAddressUtils_legacyToAddress(t1, network, this.get$type());
    },
    $isBitcoinBaseAddress: 1
  };
  A.P2shAddress.prototype = {
    toAddress$1(network) {
      var t1 = this.type;
      if (!B.JSArray_methods.contains$1(network.get$supportedAddress(), t1))
        throw A.wrapException(A.BitcoinBasePluginException$("network does not support " + t1.value + " address"));
      return this.super$LegacyAddress$toAddress(network);
    },
    get$type() {
      return this.type;
    }
  };
  A.P2pkhAddress.prototype = {
    get$type() {
      return this.type;
    }
  };
  A.P2pkAddress.prototype = {
    toAddress$1(network) {
      var t1 = this.__P2pkAddress_publicHex_F;
      t1 === $ && A.throwLateFieldNI("publicHex");
      return A._BitcoinAddressUtils_legacyToAddress(A.BytesUtils_toHexString(A.RIPEMD160_hash(A.SHA256_hash(A.BytesUtils_fromHexString(t1))), true, null), network, B.C_PubKeyAddressType);
    },
    get$type() {
      return B.C_PubKeyAddressType;
    }
  };
  A.BitcoinNetworkAddress.prototype = {};
  A.BitcoinAddress.prototype = {};
  A.DogeAddress.prototype = {};
  A.PepeAddress.prototype = {};
  A.LitecoinAddress.prototype = {};
  A.BitcoinCashAddress.prototype = {};
  A.DashAddress.prototype = {};
  A.SegwitAddress.prototype = {
    SegwitAddress$fromAddress$3$address$network$segwitVersion(address, network, segwitVersion) {
      var convert, t1, _this = this;
      if (!B.JSArray_methods.contains$1(network.get$supportedAddress(), _this.get$type()))
        throw A.wrapException(A.BitcoinBasePluginException$("network does not support " + _this.get$type().value + " address"));
      convert = A.SegwitBech32Decoder_decode(network.get$p2wpkhHrp(), address);
      if (convert.item1 !== _this.segwitVersion)
        A.throwExpression(B.BitcoinBasePluginException_yXb);
      t1 = A.BytesUtils_toHexString(convert.item2, true, null);
      _this.__SegwitAddress_addressProgram_F !== $ && A.throwLateFieldAI("addressProgram");
      _this.__SegwitAddress_addressProgram_F = t1;
    },
    get$addressProgram() {
      var t1 = this.__SegwitAddress_addressProgram_F;
      t1 === $ && A.throwLateFieldNI("addressProgram");
      return t1;
    },
    toAddress$1(network) {
      var t1, programBytes, t2, _this = this;
      if (!B.JSArray_methods.contains$1(network.get$supportedAddress(), _this.get$type()))
        throw A.wrapException(A.BitcoinBasePluginException$("network does not support " + _this.get$type().value + " address"));
      t1 = _this.__SegwitAddress_addressProgram_F;
      t1 === $ && A.throwLateFieldNI("addressProgram");
      programBytes = A.BytesUtils_fromHexString(t1);
      t1 = network.get$p2wpkhHrp();
      t2 = [_this.segwitVersion];
      B.JSArray_methods.addAll$1(t2, A.Bech32BaseUtils_convertToBase32(programBytes));
      return A.Bech32EncoderBase_encodeBech32(t1, A.List_List$from(t2, true, type$.int), "1", A.segwit_bech32_SegwitBech32Encoder__computeChecksum$closure());
    },
    $isBitcoinBaseAddress: 1
  };
  A.P2wpkhAddress.prototype = {
    get$type() {
      return B.SegwitAddresType_P2WPKH;
    }
  };
  A.P2trAddress.prototype = {
    get$type() {
      return B.SegwitAddresType_P2TR;
    }
  };
  A.P2wshAddress.prototype = {
    get$type() {
      return B.SegwitAddresType_P2WSH;
    }
  };
  A.Script.prototype = {
    toBytes$0() {
      var t3, t4, t5, _i, token, t6,
        t1 = this.script,
        t2 = t1.length;
      if (t2 === 0)
        return A._setArrayType([], type$.JSArray_int);
      t3 = type$.int;
      t4 = J.JSArray_JSArray$growable(0, t3);
      for (t5 = type$.List_int, _i = 0; _i < t2; ++_i) {
        token = t1[_i];
        if (B.Map_8ICny.containsKey$1(token)) {
          t6 = B.Map_8ICny.$index(0, token);
          t6.toString;
          B.JSArray_methods.addAll$1(t4, A.BytesUtils_toBytes(t5._as(t6), false));
        } else {
          t6 = A._isInt(token);
          if (t6 && token >= 0 && token <= 16) {
            t6 = B.Map_8ICny.$index(0, "OP_" + A.S(token));
            t6.toString;
            B.JSArray_methods.addAll$1(t4, A.BytesUtils_toBytes(t5._as(t6), false));
          } else if (t6)
            B.JSArray_methods.addAll$1(t4, A.BytesUtils_toBytes(t5._as(A.pushInteger(token)), false));
          else
            B.JSArray_methods.addAll$1(t4, A.BytesUtils_toBytes(t5._as(A.opPushData(A._asString(token))), false));
        }
      }
      return A.List_List$from(t4, true, t3);
    },
    toString$0(_) {
      return "Script{script: " + B.JSArray_methods.join$1(this.script, ", ") + "}";
    }
  };
  A.ECPublic.prototype = {
    toHex$1$compressed(compressed) {
      var t1 = A.BytesUtils_toHexString(this.publicKey.pubKey.get$compressed(), true, null);
      return t1;
    },
    toHex$0() {
      return this.toHex$1$compressed(true);
    },
    _toHash160$1$compressed(compressed) {
      return A.RIPEMD160_hash(A.SHA256_hash(A.BytesUtils_fromHexString(this.toHex$1$compressed(true))));
    },
    toAddress$1$compressed(compressed) {
      return new A.P2pkhAddress(B.P2pkhAddressType_P2PKH, A._BitcoinAddressUtils_validateAddressProgram(A.BytesUtils_toHexString(this._toHash160$1$compressed(true), true, null), B.P2pkhAddressType_P2PKH));
    },
    toAddress$0() {
      return this.toAddress$1$compressed(true);
    },
    toSegwitAddress$1$compressed(compressed) {
      return new A.P2wpkhAddress(A._BitcoinAddressUtils_validateAddressProgram(A.BytesUtils_toHexString(this._toHash160$1$compressed(true), true, null), B.SegwitAddresType_P2WPKH), 0);
    },
    toSegwitAddress$0() {
      return this.toSegwitAddress$1$compressed(true);
    },
    toP2pkhInP2sh$1$useBCHP2sh32(useBCHP2sh32) {
      var script,
        addr = this.toAddress$1$compressed(true),
        t1 = addr.__LegacyAddress__addressProgram_F;
      t1 === $ && A.throwLateFieldNI("_addressProgram");
      script = new A.Script(A.List_List$unmodifiable(["OP_DUP", "OP_HASH160", t1, "OP_EQUALVERIFY", "OP_CHECKSIG"], type$.dynamic));
      if (useBCHP2sh32)
        return new A.P2shAddress(B.P2shAddressType_hK7, A._BitcoinAddressUtils_validateAddressProgram(A.BytesUtils_toHexString(A.SHA256_hash(A.SHA256_hash(script.toBytes$0())), true, null), B.P2shAddressType_hK7));
      return new A.P2shAddress(B.P2shAddressType_sc9, A._BitcoinAddressUtils_scriptToHash160(script));
    },
    toP2pkInP2sh$1$useBCHP2sh32(useBCHP2sh32) {
      var script = new A.Script(A.List_List$unmodifiable([this.toHex$1$compressed(true), "OP_CHECKSIG"], type$.dynamic));
      if (useBCHP2sh32)
        return new A.P2shAddress(B.P2shAddressType_Q9u, A._BitcoinAddressUtils_validateAddressProgram(A.BytesUtils_toHexString(A.SHA256_hash(A.SHA256_hash(script.toBytes$0())), true, null), B.P2shAddressType_Q9u));
      return new A.P2shAddress(B.P2shAddressType_g2q, A._BitcoinAddressUtils_scriptToHash160(script));
    },
    toP2wshScript$1$compressed(compressed) {
      return new A.Script(A.List_List$unmodifiable(["OP_1", this.toHex$1$compressed(true), "OP_1", "OP_CHECKMULTISIG"], type$.dynamic));
    },
    toTapRotHex$1$script(script) {
      var ySq, y, t4,
        t1 = this.publicKey.pubKey,
        t2 = type$.ProjectiveECCPoint._as(t1.get$point()),
        h = A.P2TRUtils_calculateTweek(t2, null),
        n = $.$get$Curves_generatorSecp256k1().$mul(0, A.BigintUtils_fromBytes(h, B.C_Endian, false)),
        t3 = $.$get$Curves_curveSecp256k1(),
        p = t3.p,
        x = t2.get$x();
      if (x.compareTo$1(0, p) >= 0)
        A.throwExpression(B.AddressConverterException_GJk);
      ySq = x.modPow$2(0, A._BigIntImpl__BigIntImpl$from(3), p).$add(0, A._BigIntImpl__BigIntImpl$from(7)).$mod(0, p);
      t2 = $.$get$_BigIntImpl_one();
      y = ySq.modPow$2(0, p.$add(0, t2).$tdiv(0, A._BigIntImpl__BigIntImpl$from(4)), p);
      t4 = y.modPow$2(0, $.$get$_BigIntImpl_two(), p).compareTo$1(0, ySq);
      if (t4 !== 0)
        A.throwExpression(B.AddressConverterException_GJk);
      t4 = y.$and(0, t2).compareTo$1(0, $.$get$_BigIntImpl_zero());
      return A.BytesUtils_toHexString(A.BigintUtils_toBytes(new A.ProjectiveECCPoint(t3, null, false, B.List_empty3, A._setArrayType([x, t4 === 0 ? y : p.$sub(0, y), t2], type$.JSArray_BigInt)).$add(0, n).get$x(), t1.get$point().get$curve().get$baselen(), B.C_Endian), true, null);
    }
  };
  A.BitcoinBasePluginException.prototype = {
    get$message() {
      return this.message;
    }
  };
  A.BasedUtxoNetwork_fromName_closure.prototype = {
    call$1(element) {
      return type$.BasedUtxoNetwork._as(element).get$value() === this.name;
    },
    $signature: 235
  };
  A.BitcoinSVNetwork.prototype = {
    get$p2pkhNetVer() {
      var t1 = this.conf.params.p2pkhNetVer;
      t1.toString;
      return t1;
    },
    get$p2shNetVer() {
      var t1 = this.conf.params.p2shNetVer;
      t1.toString;
      return t1;
    },
    get$p2wpkhHrp() {
      var t1 = this.conf.params.p2wpkhHrp;
      t1.toString;
      return t1;
    },
    get$isMainnet() {
      return this === B.BitcoinSVNetwork_GZw;
    },
    get$supportedAddress() {
      return A._setArrayType([B.P2pkhAddressType_P2PKH, B.C_PubKeyAddressType], type$.JSArray_BitcoinAddressType);
    },
    $isBasedUtxoNetwork: 1,
    get$conf() {
      return this.conf;
    },
    get$value() {
      return this.value;
    }
  };
  A.BitcoinNetwork.prototype = {
    get$p2pkhNetVer() {
      var t1 = this.conf.params.p2pkhNetVer;
      t1.toString;
      return t1;
    },
    get$p2shNetVer() {
      var t1 = this.conf.params.p2shNetVer;
      t1.toString;
      return t1;
    },
    get$p2wpkhHrp() {
      var t1 = this.conf.params.p2wpkhHrp;
      t1.toString;
      return t1;
    },
    get$isMainnet() {
      return this === B.BitcoinNetwork_qBr;
    },
    get$supportedAddress() {
      return A._setArrayType([B.P2pkhAddressType_P2PKH, B.SegwitAddresType_P2WPKH, B.C_PubKeyAddressType, B.SegwitAddresType_P2TR, B.SegwitAddresType_P2WSH, B.P2shAddressType_qI5, B.P2shAddressType_SfU, B.P2shAddressType_sc9, B.P2shAddressType_g2q], type$.JSArray_BitcoinAddressType);
    },
    $isBasedUtxoNetwork: 1,
    get$conf() {
      return this.conf;
    },
    get$value() {
      return this.value;
    }
  };
  A.LitecoinNetwork.prototype = {
    get$p2pkhNetVer() {
      var t1 = this.conf.params.p2pkhStdNetVer;
      t1.toString;
      return t1;
    },
    get$p2shNetVer() {
      var t1 = this.conf.params.p2shStdNetVer;
      t1.toString;
      return t1;
    },
    get$p2wpkhHrp() {
      var t1 = this.conf.params.p2wpkhHrp;
      t1.toString;
      return t1;
    },
    get$isMainnet() {
      return this === B.LitecoinNetwork_OXY;
    },
    $isBasedUtxoNetwork: 1,
    get$conf() {
      return this.conf;
    },
    get$value() {
      return this.value;
    },
    get$supportedAddress() {
      return B.List_j4A;
    }
  };
  A.DashNetwork.prototype = {
    get$p2pkhNetVer() {
      var t1 = this.conf.params.p2pkhNetVer;
      t1.toString;
      return t1;
    },
    get$p2shNetVer() {
      var t1 = this.conf.params.p2shNetVer;
      t1.toString;
      return t1;
    },
    get$p2wpkhHrp() {
      return A.throwExpression(B.BitcoinBasePluginException_ld1);
    },
    get$isMainnet() {
      return this === B.DashNetwork_XbV;
    },
    $isBasedUtxoNetwork: 1,
    get$conf() {
      return this.conf;
    },
    get$supportedAddress() {
      return B.List_WRr;
    },
    get$value() {
      return this.value;
    }
  };
  A.DogecoinNetwork.prototype = {
    get$p2pkhNetVer() {
      var t1 = this.conf.params.p2pkhNetVer;
      t1.toString;
      return t1;
    },
    get$p2shNetVer() {
      var t1 = this.conf.params.p2shNetVer;
      t1.toString;
      return t1;
    },
    get$p2wpkhHrp() {
      return A.throwExpression(B.BitcoinBasePluginException_ijF);
    },
    get$isMainnet() {
      return this === B.DogecoinNetwork_6L0;
    },
    $isBasedUtxoNetwork: 1,
    get$conf() {
      return this.conf;
    },
    get$value() {
      return this.value;
    },
    get$supportedAddress() {
      return B.List_WRr;
    }
  };
  A.BitcoinCashNetwork.prototype = {
    get$p2pkhNetVer() {
      var t1 = this.conf.params.p2pkhStdNetVer;
      t1.toString;
      return t1;
    },
    get$p2shNetVer() {
      var t1 = this.conf.params.p2shStdNetVer;
      t1.toString;
      return t1;
    },
    get$p2wpkhHrp() {
      return A.throwExpression(B.BitcoinBasePluginException_8Gl0);
    },
    get$isMainnet() {
      return this === B.BitcoinCashNetwork_q9y;
    },
    $isBasedUtxoNetwork: 1,
    get$conf() {
      return this.conf;
    },
    get$value() {
      return this.value;
    },
    get$supportedAddress() {
      return B.List_ab8;
    }
  };
  A.PepeNetwork.prototype = {
    get$p2pkhNetVer() {
      return B.List_56;
    },
    get$p2shNetVer() {
      return B.List_22;
    },
    get$p2wpkhHrp() {
      return A.throwExpression(B.BitcoinBasePluginException_ijF);
    },
    get$isMainnet() {
      return true;
    },
    $isBasedUtxoNetwork: 1,
    get$conf() {
      return B.CoinConf_6ti;
    },
    get$value() {
      return "pepecoinMainnet";
    },
    get$supportedAddress() {
      return B.List_WRr;
    }
  };
  A.ApiProvider.prototype = {};
  A.APIType.prototype = {
    _enumToString$0() {
      return "APIType." + this._core$_name;
    }
  };
  A.APIConfig.prototype = {};
  A.Base58Alphabets.prototype = {
    _enumToString$0() {
      return "Base58Alphabets." + this._core$_name;
    }
  };
  A.Base58ChecksumError.prototype = {
    toString$0(_) {
      return this.message;
    },
    $isException: 1,
    $isBlockchainUtilsException: 1
  };
  A._BchBech32Utils_hrpExpand_closure.prototype = {
    call$1(rune) {
      return A._asInt(rune) & 31;
    },
    $signature: 13
  };
  A.Bech32Encodings.prototype = {
    _enumToString$0() {
      return "Bech32Encodings." + this._core$_name;
    }
  };
  A.Bech32ChecksumError.prototype = {
    toString$0(_) {
      return "Invalid bech32 checksum";
    },
    $isException: 1,
    $isBlockchainUtilsException: 1
  };
  A.Bech32EncoderBase_encodeBech32_closure.prototype = {
    call$1(e) {
      var _s32_ = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
      A._asInt(e);
      if (!(e >= 0 && e < 32))
        return A.ioore(_s32_, e);
      return _s32_[e];
    },
    $signature: 34
  };
  A.Bech32DecoderBase_decodeBech32_closure.prototype = {
    call$1(x) {
      A._asInt(x);
      return x < 33 || x > 126;
    },
    $signature: 35
  };
  A.Bech32DecoderBase_decodeBech32_closure0.prototype = {
    call$1(x) {
      return !B.JSString_methods.contains$1("qpzry9x8gf2tvdw0s3jn54khce6mua7l", A.Primitives_stringFromCharCode(A._asInt(x)));
    },
    $signature: 35
  };
  A.Bech32DecoderBase_decodeBech32_closure1.prototype = {
    call$1(x) {
      return B.JSString_methods.indexOf$1("qpzry9x8gf2tvdw0s3jn54khce6mua7l", A.Primitives_stringFromCharCode(A._asInt(x)));
    },
    $signature: 13
  };
  A.ADAAddressType.prototype = {
    toString$0(_) {
      return "ADAAddressType." + this.name;
    }
  };
  A.ADAAddressType_fromHeader_closure.prototype = {
    call$1(element) {
      return type$.ADAAddressType._as(element).header === this.header;
    },
    $signature: 212
  };
  A.ADAAddressType_fromHeader_closure0.prototype = {
    call$0() {
      return A.throwExpression(B.AddressConverterException_lvx);
    },
    $signature: 2
  };
  A.ADAByronAddrTypes.prototype = {
    toString$0(_) {
      return "ADAByronAddrTypes." + this.name;
    },
    get$value() {
      return this.value;
    }
  };
  A.ADAByronAddrTypes_ADAByronAddrTypes$fromCbor_closure.prototype = {
    call$1(element) {
      return type$.ADAByronAddrTypes._as(element).value === this.value.value;
    },
    $signature: 210
  };
  A.ADAByronAddrAttrs.prototype = {
    toJson$0() {
      var attrs = A.LinkedHashMap_LinkedHashMap$_empty(type$.int, type$.List_int),
        t1 = this.hdPathEncBytes;
      if (t1 != null)
        attrs.$indexSet(0, 1, new A.CborBytesValue(t1).encode$0());
      t1 = this.networkMagic;
      if (t1 != null && t1 !== 764824073) {
        t1.toString;
        attrs.$indexSet(0, 2, new A.CborIntValue(t1).encode$0());
      }
      return attrs;
    }
  };
  A.ADAByronAddrPayload.prototype = {};
  A.ADAByronAddr.prototype = {
    toCbor$0() {
      var t1 = this.payload,
        payloadBytes = new A.CborListValue(A._setArrayType([new A.CborBytesValue(t1.rootHashBytes), t1.attrs.toJson$0(), new A.CborIntValue(t1.type.value)], type$.JSArray_Object), true, type$.CborListValue_Object).encode$0();
      return new A.CborListValue(A._setArrayType([new A.CborTagValue(A.List_List$unmodifiable(A._setArrayType([24], type$.JSArray_int), type$.int), payloadBytes, type$.CborTagValue_List_int), new A.CborIntValue(A.Crc32_quickIntDigest(payloadBytes))], type$.JSArray_CborObject), true, type$.CborListValue_CborObject);
    }
  };
  A.AdaByronIcarusAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.AdaByronLegacyAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.Pointer.prototype = {
    toString$0(_) {
      return "Pointer{slot: " + this.slot.toString$0(0) + ", txIndex: " + this.txIndex.toString$0(0) + ", certIndex: " + this.certIndex.toString$0(0) + "}";
    }
  };
  A.AdaStakeCredType.prototype = {
    toString$0(_) {
      return "AdaStakeCredType." + this.name;
    },
    get$value() {
      return this.value;
    }
  };
  A.AdaStakeCredential.prototype = {};
  A.AdaShelleyAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.AdaShelleyStakingAddrEncoder.prototype = {
    encodeCredential$2(credential, kwargs) {
      var t1,
        netTag = type$.Map_String_dynamic._as(kwargs).$index(0, "net_tag");
      if (netTag == null)
        netTag = B.ADANetwork_1_764824073_mainnet;
      t1 = $.$get$AdaShelleyAddrConst_networkTagToRewardAddrHrp().$index(0, netTag);
      t1.toString;
      return A.AdaShelleyAddrUtils_encode(credential, t1, netTag, null, B.ADAAddressType_14_Reward);
    },
    $isBlockchainAddressEncoder: 1
  };
  A.AdaGenericAddrDecoderResult.prototype = {};
  A.AdaGenericAddrDecoder.prototype = {
    decode$2(addr, kwargs) {
      var addrDecBytes, checkedByron, network, base58Decode, byron, exception, t1, addressBytes, header, networkTag, addressType, hrp, t2, t3, t4, prefixByte, t5, slot, t6, txIndex, t7, _null = null;
      type$.Map_String_dynamic._as(kwargs).$index(0, "net_tag");
      addrDecBytes = null;
      checkedByron = false;
      network = null;
      try {
        addrDecBytes = A.Bech32Decoder_decodeWithoutHRP(addr);
      } catch (exception) {
        base58Decode = A.Base58Decoder_decode(addr, B.Base58Alphabets_0);
        byron = A.ADAByronAddr_ADAByronAddr$deserialize(base58Decode);
        network = A.ADANetwork_fromProtocolMagic(byron.payload.attrs.networkMagic);
        t1 = $.$get$AdaShelleyAddrConst_networkTagToAddrHrp().$index(0, network);
        t1.toString;
        addrDecBytes = new A.Tuple(t1, base58Decode, type$.Tuple_of_String_and_List_int);
        checkedByron = true;
      }
      addressBytes = addrDecBytes.item2;
      t1 = J.getInterceptor$asx(addressBytes);
      if (t1.get$length(addressBytes) < 29)
        throw A.wrapException(B.AddressConverterException_GrX);
      header = t1.$index(addressBytes, 0);
      networkTag = header & 15;
      addressType = A.ADAAddressType_decodeAddressType(header);
      if (network == null)
        if (addressType === B.ADAAddressType_8_Byron)
          network = A.ADANetwork_fromProtocolMagic(A.ADAByronAddr_ADAByronAddr$deserialize(addressBytes).payload.attrs.networkMagic);
        else
          network = A.ADANetwork_fromTag(networkTag);
      hrp = $.$get$AdaShelleyAddrConst_networkTagToAddrHrp().$index(0, network);
      switch (addressType) {
        case B.ADAAddressType_0_Base:
          A.AddrDecUtils_validateBytesLength(addressBytes, 57, _null);
          break;
        case B.ADAAddressType_14_Reward:
          A.AddrDecUtils_validateBytesLength(addressBytes, 29, _null);
          hrp = $.$get$AdaShelleyAddrConst_networkTagToRewardAddrHrp().$index(0, network);
          break;
        case B.ADAAddressType_6_Enterprise:
          A.AddrDecUtils_validateBytesLength(addressBytes, 29, _null);
          break;
        case B.ADAAddressType_4_Pointer:
          A.AddrDecUtils_validateBytesLength(addressBytes, 32, 32);
          break;
        case B.ADAAddressType_8_Byron:
          if (!A.boolConversionCheck(checkedByron))
            A.ADAByronAddr_ADAByronAddr$deserialize(addressBytes);
          break;
        default:
          throw A.wrapException(A.AddressConverterException$("Invalid address prefix " + addressType.toString$0(0), _null));
      }
      t2 = hrp == null;
      if (t2 || !J.$eq$(addrDecBytes.item1, hrp))
        throw A.wrapException(A.AddressConverterException$("Invalid address hrp " + (t2 ? "" : hrp), _null));
      if (addressType === B.ADAAddressType_8_Byron) {
        t1 = network;
        return A.AdaGenericAddrDecoderResult$_(addressBytes, _null, A.ADAByronAddr_ADAByronAddr$deserialize(addressBytes), t1, _null, _null, _null, addressType);
      }
      t2 = (header & 16) === 0;
      t3 = t2 ? B.AdaStakeCredType_Key_0 : B.AdaStakeCredType_Script_1;
      t4 = (header & 32) === 0;
      prefixByte = A.AdaShelleyAddrUtils_encodePrefix(addressType, networkTag, t3, t4 ? B.AdaStakeCredType_Key_0 : B.AdaStakeCredType_Script_1);
      t3 = network;
      t5 = prefixByte.length;
      t5 = t1.sublist$2(addressBytes, t5, t5 + 28);
      t5 = A.AdaStakeCredential_AdaStakeCredential(t5, t2 ? B.AdaStakeCredType_Key_0 : B.AdaStakeCredType_Script_1);
      if (addressType === B.ADAAddressType_0_Base) {
        t2 = t1.sublist$1(addressBytes, prefixByte.length + 28);
        t2 = A.AdaStakeCredential_AdaStakeCredential(t2, t4 ? B.AdaStakeCredType_Key_0 : B.AdaStakeCredType_Script_1);
      } else
        t2 = _null;
      if (addressType === B.ADAAddressType_4_Pointer) {
        t1 = t1.sublist$1(addressBytes, prefixByte.length + 28);
        slot = A.BigintUtils_variableNatDecode(t1);
        t4 = slot.item2;
        t6 = J.getInterceptor$ax(t1);
        txIndex = A.BigintUtils_variableNatDecode(t6.sublist$1(t1, t4));
        t7 = txIndex.item2;
        if (typeof t4 !== "number")
          return t4.$add();
        if (typeof t7 !== "number")
          return A.iae(t7);
        t7 = new A.Pointer(slot.item1, txIndex.item1, A.BigintUtils_variableNatDecode(t6.sublist$1(t1, t4 + t7)).item1);
        t1 = t7;
      } else
        t1 = _null;
      return A.AdaGenericAddrDecoderResult$_(addressBytes, t5, _null, t3, t1, prefixByte, t2, addressType);
    },
    decode$1(addr) {
      return this.decode$2(addr, B.Map_empty0);
    }
  };
  A.ADANetwork.prototype = {
    toString$0(_) {
      return "ADANetwork." + this.name;
    },
    get$value() {
      return this.value;
    }
  };
  A.ADANetwork_fromTag_closure.prototype = {
    call$1(element) {
      return type$.ADANetwork._as(element).value === this.tag;
    },
    $signature: 36
  };
  A.ADANetwork_fromTag_closure0.prototype = {
    call$0() {
      return A.throwExpression(A.AddressConverterException$("Invalid network tag. " + this.tag, null));
    },
    $signature: 2
  };
  A.ADANetwork_fromProtocolMagic_closure.prototype = {
    call$1(element) {
      return type$.ADANetwork._as(element).protocolMagic === this.protocolMagic;
    },
    $signature: 36
  };
  A.ADANetwork_fromProtocolMagic_closure0.prototype = {
    call$0() {
      return A.throwExpression(B.AddressConverterException_X5e);
    },
    $signature: 2
  };
  A.AlgoAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.AptosAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.AtomAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.AtomNist256P1AddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.AvaxPChainAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.AvaxXChainAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.EgldAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.BlockchainAddressEncoder.prototype = {};
  A.EosAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.ErgoNetworkTypes.prototype = {
    get$value() {
      return this.value;
    }
  };
  A.ErgoP2PKHAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.EthAddrUtils__checksumEncode_closure.prototype = {
    call$1(entry) {
      var i, c, t1;
      type$.MapEntry_int_String._as(entry);
      i = entry.key;
      c = entry.value;
      t1 = this.addrHexDigest;
      if (i >>> 0 !== i || i >= t1.length)
        return A.ioore(t1, i);
      return A.int_parse(t1[i], 16) >= 8 ? c.toUpperCase() : c.toLowerCase();
    },
    $signature: 208
  };
  A.EthAddrDecoder.prototype = {
    decodeAddr$2(addr, kwargs) {
      var addrNoPrefix,
        t1 = type$.Map_String_dynamic._as(kwargs).$index(0, "skip_chksum_enc"),
        prefixGot = B.JSString_methods.substring$2(addr, 0, 2);
      if ("0x" !== prefixGot)
        A.throwExpression(A.AddressConverterException$("Invalid prefix (expected 0x, got " + prefixGot + ")", null));
      addrNoPrefix = B.JSString_methods.substring$1(addr, 2);
      A.AddrDecUtils_validateLength(addrNoPrefix, 40);
      if (t1 !== true && addrNoPrefix !== A.EthAddrUtils__checksumEncode(addrNoPrefix))
        throw A.wrapException(B.AddressConverterException_uiu);
      return A.BytesUtils_fromHexString(addrNoPrefix);
    }
  };
  A.EthAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.AddressConverterException.prototype = {$isException: 1, $isBlockchainUtilsException: 1};
  A.FilSecp256k1AddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.IcxAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.InjAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.NanoAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.NearAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.NeoAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.OkexAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.OneAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.P2PKHAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.BchP2PKHAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.P2SHAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.BchP2SHAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.P2TRAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.P2WPKHAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.SolAddrDecoder.prototype = {
    decodeAddr$1(addr) {
      var addrDecBytes = A.Base58Decoder_decode(addr, B.Base58Alphabets_0);
      A.AddrDecUtils_validateBytesLength(addrDecBytes, 32, null);
      return A.List_List$from(addrDecBytes, true, type$.int);
    }
  };
  A.SolAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.SubstrateEd25519AddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.SubstrateSr25519AddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.SubstrateSecp256k1AddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.DecodeAddressResult.prototype = {};
  A.FriendlyAddressFlags.prototype = {};
  A.TonAddrDecoder.prototype = {};
  A.TonAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.TrxAddrDecoder.prototype = {
    decodeAddr$1(addr) {
      var addrDec = A.Base58Decoder_checkDecode(addr, B.Base58Alphabets_0),
        tronPrefix = A.BytesUtils_fromHexString("0x41");
      A.AddrDecUtils_validateBytesLength(addrDec, 20 + tronPrefix.length, null);
      return new A.EthAddrDecoder().decodeAddr$2("0x" + A.BytesUtils_toHexString(A.AddrDecUtils_validateAndRemovePrefixBytes(addrDec, tronPrefix), true, null), A.LinkedHashMap_LinkedHashMap$_literal(["skip_chksum_enc", true], type$.String, type$.dynamic));
    }
  };
  A.TrxAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.XlmAddrTypes.prototype = {
    get$value() {
      return 48;
    }
  };
  A.XlmAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.XmrAddrEncoder.prototype = {};
  A.XRPXAddressDecodeResult.prototype = {};
  A.XrpAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.XtzAddrPrefixes.prototype = {
    get$value() {
      return B.List_6_161_159;
    }
  };
  A.XtzAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.ZilAddrEncoder.prototype = {$isBlockchainAddressEncoder: 1};
  A.Bip32PathError.prototype = {
    toString$0(_) {
      return this.message;
    },
    $isException: 1,
    $isBlockchainUtilsException: 1
  };
  A.Bip32ChainCode.prototype = {};
  A.Bip32FingerPrint.prototype = {};
  A.Bip32KeyIndex.prototype = {
    toString$0(_) {
      return "index: " + this.index;
    }
  };
  A.Bip32KeyData.prototype = {};
  A.Bip32KeyNetVersions.prototype = {
    set$__Bip32KeyNetVersions__pubNetVer_F(__Bip32KeyNetVersions__pubNetVer_F) {
      this.__Bip32KeyNetVersions__pubNetVer_F = type$.List_int._as(__Bip32KeyNetVersions__pubNetVer_F);
    },
    set$__Bip32KeyNetVersions__privNetVer_F(__Bip32KeyNetVersions__privNetVer_F) {
      this.__Bip32KeyNetVersions__privNetVer_F = type$.List_int._as(__Bip32KeyNetVersions__privNetVer_F);
    }
  };
  A.Bip32KeyBase.prototype = {};
  A.Bip32PublicKey.prototype = {};
  A.Bip32Path.prototype = {
    length$0(_) {
      return this.elems.length;
    },
    toList$0(_) {
      var t2, t3, _i,
        t1 = A._setArrayType([], type$.JSArray_int);
      for (t2 = this.elems, t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, A.throwConcurrentModificationError)(t2), ++_i)
        t1.push(t2[_i].index);
      return t1;
    },
    toString$0(_) {
      var t1, t2, _i, t3,
        pathStr = this.isAbsolute ? "m/" : "";
      for (t1 = this.elems, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i) {
        t3 = t1[_i].index;
        if ((t3 & 2147483648) >>> 0 === 0)
          pathStr += "" + t3 + "/";
        else
          pathStr += new A.Bip32KeyIndex(t3 & 2147483647).toString$0(0) + "'/";
      }
      return B.JSString_methods.substring$2(pathStr, 0, pathStr.length - 1);
    }
  };
  A.Bip32PathParser_parse_closure.prototype = {
    call$1(elem) {
      return A._asString(elem).length !== 0;
    },
    $signature: 17
  };
  A.Bip32PathParser__parseElem_closure.prototype = {
    call$1(element) {
      A._asString(element);
      return B.JSString_methods.endsWith$1(this._box_0.pathElem, element);
    },
    $signature: 17
  };
  A.BipCoins.prototype = {
    toString$0(_) {
      return A.getRuntimeTypeOfDartObject(this).toString$0(0) + "." + this.get$coinName();
    },
    $isCryptoCoins: 1
  };
  A.BipProposal.prototype = {
    get$value() {
      return this;
    },
    get$name() {
      return this.name;
    }
  };
  A.Bip44Coins.prototype = {
    get$value() {
      return this;
    },
    get$coinName() {
      return this.name;
    },
    get$conf() {
      var t1 = $.$get$Bip44Coins__coinToConf().$index(0, this);
      t1.toString;
      return t1;
    },
    get$proposal() {
      return B.BipProposal_bip44;
    },
    toString$0(_) {
      return "Bip44Coins." + this.name;
    }
  };
  A.Bip44Coins_fromName_closure.prototype = {
    call$1(element) {
      return type$.Bip44Coins._as(element).name === this.name;
    },
    $signature: 184
  };
  A.Bip44Conf_akashNetwork_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_algorand_closure.prototype = {
    call$1(kwargs) {
      return new A.AlgoAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 183
  };
  A.Bip44Conf_aptos_closure.prototype = {
    call$1(kwargs) {
      return new A.AptosAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 167
  };
  A.Bip44Conf_avaxCChain_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_avaxPChain_closure.prototype = {
    call$1(kwargs) {
      return new A.AvaxPChainAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 157
  };
  A.Bip44Conf_avaxXChain_closure.prototype = {
    call$1(kwargs) {
      return new A.AvaxXChainAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 156
  };
  A.Bip44Conf_axelar_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_bandProtocol_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_binanceChain_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_binanceSmartChain_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_bitcoinMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_bitcoinTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_bitcoinCashMainNet_closure.prototype = {
    call$1(legacy) {
      return new A.BchP2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 9
  };
  A.Bip44Conf_bitcoinCashTestNet_closure.prototype = {
    call$1(legacy) {
      return new A.BchP2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 9
  };
  A.Bip44Conf_bitcoinCashSlpMainNet_closure.prototype = {
    call$1(legacy) {
      return new A.BchP2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 9
  };
  A.Bip44Conf_bitcoinCashSlpTestNet_closure.prototype = {
    call$1(legacy) {
      return new A.BchP2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 9
  };
  A.Bip44Conf_bitcoinSvMainNet_closure.prototype = {
    call$1(legacy) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_bitcoinSvTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_cardanoByronIcarus_closure.prototype = {
    call$1(kwargs) {
      return new A.AdaByronIcarusAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 20
  };
  A.Bip44Conf_cardanoByronLedger_closure.prototype = {
    call$1(kwargs) {
      return new A.AdaByronIcarusAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 20
  };
  A.Bip44Conf_cardanoByronIcarusTestnet_closure.prototype = {
    call$1(kwargs) {
      return new A.AdaByronIcarusAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 20
  };
  A.Bip44Conf_cardanoByronLedgerTestnet_closure.prototype = {
    call$1(kwargs) {
      return new A.AdaByronIcarusAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 20
  };
  A.Bip44Conf_celo_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_certik_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_chihuahua_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_cosmos_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_cosmosTestnet_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_cosmosNist256p1_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomNist256P1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 39
  };
  A.Bip44Conf_cosmosTestnetNist256p1_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomNist256P1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 39
  };
  A.Bip44Conf_dashMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_dashTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_dogecoinMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_dogecoinTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_pepeMainnet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_pepeTestnet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_ecashMainNet_closure.prototype = {
    call$1(legacy) {
      return new A.BchP2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 9
  };
  A.Bip44Conf_ecashTestNet_closure.prototype = {
    call$1(legacy) {
      return new A.BchP2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 9
  };
  A.Bip44Conf_elrond_closure.prototype = {
    call$1(kwargs) {
      return new A.EgldAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 95
  };
  A.Bip44Conf_eos_closure.prototype = {
    call$1(kwargs) {
      return new A.EosAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 92
  };
  A.Bip44Conf_ergoMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.ErgoP2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 40
  };
  A.Bip44Conf_ergoTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.ErgoP2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 40
  };
  A.Bip44Conf_ethereum_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_ethereumTestnet_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_ethereumClassic_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_fantomOpera_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_filecoin_closure.prototype = {
    call$1(kwargs) {
      return new A.FilSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 84
  };
  A.Bip44Conf_harmonyOneMetamask_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_harmonyOneEth_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_harmonyOneAtom_closure.prototype = {
    call$1(kwargs) {
      return new A.OneAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 82
  };
  A.Bip44Conf_huobiChain_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_icon_closure.prototype = {
    call$1(kwargs) {
      return new A.IcxAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 78
  };
  A.Bip44Conf_injective_closure.prototype = {
    call$1(kwargs) {
      return new A.InjAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 76
  };
  A.Bip44Conf_irisNet_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_kava_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_kusamaEd25519Slip_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.Bip44Conf_kusamaTestnetEd25519Slip_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.Bip44Conf_litecoinMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_litecoinTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_moneroEd25519Slip_closure.prototype = {
    call$1(kwargs) {
      return new A.XmrAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 42
  };
  A.Bip44Conf_moneroSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.XmrAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 42
  };
  A.Bip44Conf_nano_closure.prototype = {
    call$1(kwargs) {
      return new A.NanoAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 74
  };
  A.Bip44Conf_nearProtocol_closure.prototype = {
    call$1(kwargs) {
      return new A.NearAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 73
  };
  A.Bip44Conf_neo_closure.prototype = {
    call$1(kwargs) {
      return new A.NeoAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 43
  };
  A.Bip44Conf_nineChroniclesGold_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_okexChainEth_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_okexChainAtom_closure.prototype = {
    call$1(kwargs) {
      return new A.OkexAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 44
  };
  A.Bip44Conf_okexChainAtomOld_closure.prototype = {
    call$1(kwargs) {
      return new A.OkexAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 44
  };
  A.Bip44Conf_ontology_closure.prototype = {
    call$1(kwargs) {
      return new A.NeoAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 43
  };
  A.Bip44Conf_osmosis_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_piNetwork_closure.prototype = {
    call$1(kwargs) {
      return new A.XlmAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 45
  };
  A.Bip44Conf_polkadotEd25519Slip_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.Bip44Conf_polkadotTestnetEd25519Slip_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.Bip44Conf_polygon_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_ripple_closure.prototype = {
    call$1(kwargs) {
      return new A.XrpAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 22
  };
  A.Bip44Conf_rippleTestnet_closure.prototype = {
    call$1(kwargs) {
      return new A.XrpAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 22
  };
  A.Bip44Conf_rippleEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.XrpAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 22
  };
  A.Bip44Conf_rippleTestnetEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.XrpAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 22
  };
  A.Bip44Conf_secretNetworkOld_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_secretNetworkNew_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_solana_closure.prototype = {
    call$1(kwargs) {
      return new A.SolAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 68
  };
  A.Bip44Conf_solanaTestnet_closure.prototype = {
    call$1(kwargs) {
      return new A.SolAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 68
  };
  A.Bip44Conf_stellar_closure.prototype = {
    call$1(kwargs) {
      return new A.XlmAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 45
  };
  A.Bip44Conf_terra_closure.prototype = {
    call$1(kwargs) {
      return new A.AtomAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 5
  };
  A.Bip44Conf_tezos_closure.prototype = {
    call$1(kwargs) {
      return new A.XtzAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 75
  };
  A.Bip44Conf_theta_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_tron_closure.prototype = {
    call$1(kwargs) {
      return new A.TrxAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 65
  };
  A.Bip44Conf_tronTestnet_closure.prototype = {
    call$1(kwargs) {
      return new A.TrxAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 65
  };
  A.Bip44Conf_vechain_closure.prototype = {
    call$1(kwargs) {
      return new A.EthAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 4
  };
  A.Bip44Conf_verge_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_zcashMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_zcashTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2PKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 3
  };
  A.Bip44Conf_zilliqa_closure.prototype = {
    call$1(kwargs) {
      return new A.ZilAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 77
  };
  A.Bip44Conf_tonMainnet_closure.prototype = {
    call$1(kwargs) {
      return new A.TonAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 64
  };
  A.Bip44Conf_tonTestnet_closure.prototype = {
    call$1(kwargs) {
      return new A.TonAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 64
  };
  A.Bip49Coins.prototype = {
    get$value() {
      return this;
    },
    get$coinName() {
      return this.name;
    },
    get$conf() {
      var t1 = $.$get$Bip49Coins__coinToConf().$index(0, this);
      t1.toString;
      return t1;
    },
    get$proposal() {
      return B.BipProposal_bip49;
    }
  };
  A.Bip49Coins_fromName_closure.prototype = {
    call$1(element) {
      return type$.Bip49Coins._as(element).name === this.name;
    },
    $signature: 79
  };
  A.Bip49Conf_dashMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_dashTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_dogecoinMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_dogecoinTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_litecoinMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_litecoinTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_zcashMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_zcashTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_bitcoinMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_bitcoinTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_bitcoinSvMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_bitcoinSvTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_bitcoinCashMainNet_closure.prototype = {
    call$1(legacy) {
      return new A.BchP2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 9
  };
  A.Bip49Conf_bitcoinCashTestNet_closure.prototype = {
    call$1(legacy) {
      return new A.BchP2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 9
  };
  A.Bip49Conf_bitcoinCashSlpMainNet_closure.prototype = {
    call$1(legacy) {
      return new A.BchP2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 9
  };
  A.Bip49Conf_bitcoinCashSlpTestNet_closure.prototype = {
    call$1(legacy) {
      return new A.BchP2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 9
  };
  A.Bip49Conf_ecashMainNet_closure.prototype = {
    call$1(legacy) {
      return new A.BchP2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 9
  };
  A.Bip49Conf_ecashTestNet_closure.prototype = {
    call$1(legacy) {
      return new A.BchP2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 9
  };
  A.Bip49Conf_pepeMainnet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip49Conf_pepeTestnet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2SHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 6
  };
  A.Bip84Coins.prototype = {
    get$value() {
      return this;
    },
    get$coinName() {
      return this.name;
    },
    get$conf() {
      var t1 = $.$get$Bip84Coins__coinToConf().$index(0, this);
      t1.toString;
      return t1;
    },
    get$proposal() {
      return B.BipProposal_bip84;
    }
  };
  A.Bip84Coins_fromName_closure.prototype = {
    call$1(element) {
      return type$.Bip84Coins._as(element).name === this.name;
    },
    $signature: 81
  };
  A.Bip84Conf_bitcoinMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2WPKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 24
  };
  A.Bip84Conf_bitcoinTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2WPKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 24
  };
  A.Bip84Conf_litecoinMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2WPKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 24
  };
  A.Bip84Conf_litecoinTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2WPKHAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 24
  };
  A.Bip86Coins.prototype = {
    get$value() {
      return this;
    },
    get$coinName() {
      return this.name;
    },
    get$conf() {
      var t1 = $.$get$Bip86Coins__coinToConf().$index(0, this);
      t1.toString;
      return t1;
    },
    get$proposal() {
      return B.BipProposal_bip86;
    }
  };
  A.Bip86Coins_fromName_closure.prototype = {
    call$1(element) {
      return type$.Bip86Coins._as(element).name === this.name;
    },
    $signature: 83
  };
  A.Bip86Conf_bitcoinMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2TRAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 62
  };
  A.Bip86Conf_bitcoinTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.P2TRAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 62
  };
  A.BipBitcoinCashConf.prototype = {};
  A.BipCoinConfig.prototype = {$isCoinConfig: 1,
    get$type() {
      return this.type;
    }
  };
  A.BipLitecoinConf.prototype = {};
  A.CoinProposal_fromName_closure.prototype = {
    call$1(element) {
      return type$.BipProposal._as(element).get$name() === this.name;
    },
    $signature: 85
  };
  A.CoinProposal_fromName_closure0.prototype = {
    call$0() {
      return A.throwExpression(A.MessageException$("Unable to locate a proposal with the given name.", A.LinkedHashMap_LinkedHashMap$_literal(["Name", this.name], type$.String, type$.dynamic)));
    },
    $signature: 2
  };
  A.Cip1852Coins.prototype = {
    get$value() {
      return this;
    },
    get$coinName() {
      return this.name;
    },
    get$conf() {
      var t1 = $.$get$Cip1852Coins__coinToConf().$index(0, this);
      t1.toString;
      return t1;
    },
    get$proposal() {
      return B.C_CipProposal;
    }
  };
  A.Cip1852Coins_fromName_closure.prototype = {
    call$1(element) {
      return type$.Cip1852Coins._as(element).name === this.name;
    },
    $signature: 86
  };
  A.CipProposal.prototype = {
    get$value() {
      return this;
    },
    $isBipProposal: 1,
    get$name() {
      return "cip1852";
    }
  };
  A.Cip1852Conf_cardanoIcarusMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.AdaShelleyAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 23
  };
  A.Cip1852Conf_cardanoIcarusTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.AdaShelleyAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 23
  };
  A.Cip1852Conf_cardanoLedgerMainNet_closure.prototype = {
    call$1(kwargs) {
      return new A.AdaShelleyAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 23
  };
  A.Cip1852Conf_cardanoLedgerTestNet_closure.prototype = {
    call$1(kwargs) {
      return new A.AdaShelleyAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 23
  };
  A.CoinConf.prototype = {
    toString$0(_) {
      return this.coinName.name;
    }
  };
  A.CoinParams.prototype = {};
  A.CoinNames.prototype = {
    toString$0(_) {
      return this.name;
    }
  };
  A.EllipticCurveTypes.prototype = {
    toString$0(_) {
      return "EllipticCurveTypes." + this.name;
    }
  };
  A.EllipticCurveTypes_fromName_closure.prototype = {
    call$1(element) {
      return type$.EllipticCurveTypes._as(element).name === this.name;
    },
    $signature: 88
  };
  A.Ed25519Blake2bPublicKey.prototype = {
    get$curve() {
      return B.EllipticCurveTypes_ed25519Blake2b;
    },
    get$length(_) {
      return 33;
    },
    get$point() {
      return this._publicKey._point;
    },
    get$compressed() {
      var t1 = A.List_List$of(B.List_00, true, type$.dynamic);
      B.JSArray_methods.addAll$1(t1, this._publicKey._point.toBytes$0());
      return A.List_List$from(t1, true, type$.int);
    },
    $isIPublicKey: 1
  };
  A.Ed25519PublicKey.prototype = {
    get$curve() {
      return B.EllipticCurveTypes_ed25519;
    },
    get$length(_) {
      return 33;
    },
    get$point() {
      return this._ed25519_keys$_publicKey._point;
    },
    get$compressed() {
      var t1 = A.List_List$of(B.List_00, true, type$.dynamic);
      B.JSArray_methods.addAll$1(t1, this._ed25519_keys$_publicKey._point.toBytes$0());
      return A.List_List$from(t1, true, type$.int);
    },
    $isIPublicKey: 1
  };
  A.Ed25519KholawPublicKey.prototype = {
    get$point() {
      return this._ed25519_kholaw_keys$_publicKey._point;
    },
    get$length(_) {
      return 33;
    },
    get$curve() {
      return B.EllipticCurveTypes_ed25519Kholaw;
    },
    get$compressed() {
      var t1 = A.List_List$of(B.List_00, true, type$.dynamic);
      B.JSArray_methods.addAll$1(t1, this._ed25519_kholaw_keys$_publicKey._point.toBytes$0());
      return A.List_List$from(t1, true, type$.int);
    },
    $isIPublicKey: 1
  };
  A.Ed25519MoneroPublicKey.prototype = {
    get$curve() {
      return B.EllipticCurveTypes_ed25519Monero;
    },
    get$length(_) {
      return 32;
    },
    get$point() {
      return this._ed25519_monero_keys$_publicKey._point;
    },
    get$compressed() {
      var t1 = A.List_List$of(B.List_00, true, type$.dynamic);
      B.JSArray_methods.addAll$1(t1, this._ed25519_monero_keys$_publicKey._point.toBytes$0());
      return A.List_List$from(t1, true, type$.int);
    },
    $isIPublicKey: 1
  };
  A.Nist256p1PublicKey.prototype = {
    get$length(_) {
      return 33;
    },
    get$curve() {
      return B.EllipticCurveTypes_nist256p1;
    },
    get$point() {
      return this.publicKey.point;
    },
    get$compressed() {
      return this.publicKey.point.toBytes$1(B.EncodeType_0);
    },
    $isIPublicKey: 1
  };
  A.Secp256k1PublicKeyEcdsa.prototype = {
    get$length(_) {
      return 33;
    },
    get$curve() {
      return B.EllipticCurveTypes_secp256k1;
    },
    get$point() {
      return this.publicKey.point;
    },
    get$compressed() {
      return this.publicKey.point.toBytes$1(B.EncodeType_0);
    },
    $isIPublicKey: 1
  };
  A.Sr25519PublicKey.prototype = {
    get$length(_) {
      return 32;
    },
    get$curve() {
      return B.EllipticCurveTypes_sr25519;
    },
    get$point() {
      return A.RistrettoPoint_RistrettoPoint$fromBytes(A.List_List$from(this.publicKey._keys$_publicKey, true, type$.int));
    },
    get$compressed() {
      return A.List_List$from(this.publicKey._keys$_publicKey, true, type$.int);
    },
    $isIPublicKey: 1
  };
  A.MoneroCoinConf.prototype = {
    get$type() {
      return B.EllipticCurveTypes_ed25519Monero;
    },
    $isCoinConfig: 1
  };
  A.MoneroCoins.prototype = {
    get$value() {
      return this;
    },
    get$conf() {
      var t1 = $.$get$MoneroCoins__coinToConf().$index(0, this);
      t1.toString;
      return t1;
    },
    get$proposal() {
      return B.C_MoneroProposal;
    },
    $isCryptoCoins: 1
  };
  A.MoneroCoins_fromName_closure.prototype = {
    call$1(element) {
      return type$.MoneroCoins._as(element).name === this.name;
    },
    $signature: 89
  };
  A.MoneroProposal.prototype = {
    get$value() {
      return this;
    }
  };
  A.MoneroKeyError.prototype = {
    toString$0(_) {
      return "Invalid public key";
    },
    $isException: 1,
    $isBlockchainUtilsException: 1
  };
  A.MoneroPublicKey.prototype = {
    get$compressed() {
      return this.pubKey._ed25519_monero_keys$_publicKey._point.toBytes$0();
    },
    get$length(_) {
      return 32;
    },
    get$curve() {
      return B.EllipticCurveTypes_ed25519Monero;
    },
    get$point() {
      return this.pubKey._ed25519_monero_keys$_publicKey._point;
    },
    $isIPublicKey: 1
  };
  A.SubstrateCoinConf.prototype = {$isCoinConfig: 1,
    get$type() {
      return this.type;
    }
  };
  A.SubstrateCoins.prototype = {
    get$value() {
      return this;
    },
    get$conf() {
      var t1 = $.$get$SubstrateCoins__coinToConf().$index(0, this);
      t1.toString;
      return t1;
    },
    get$proposal() {
      return B.C_SubstratePropoosal;
    },
    $isCryptoCoins: 1
  };
  A.SubstrateCoins_fromName_closure.prototype = {
    call$1(element) {
      return type$.SubstrateCoins._as(element).name === this.name;
    },
    $signature: 90
  };
  A.SubstratePropoosal.prototype = {
    get$value() {
      return this;
    }
  };
  A.SubstrateConf_acalaEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_acalaSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_acalaSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_bifrostEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_bifrostSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_bifrostSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_chainXEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_chainXSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_chainXSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_edgewareEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_edgewareSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_edgewareSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_genericEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_genericSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_genericSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_karuraEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_karuraSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_karuraSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_kusamaEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_kusamaSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_kusamaSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_moonbeamEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_moonbeamSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_moonbeamSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_moonriverEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_moonriverSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_moonriverSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_phalaEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_phalaSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_phalaSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_plasmEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_plasmSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_plasmSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_polkadotEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_polkadotSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_polkadotSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_soraEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_soraSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_soraSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.SubstrateConf_stafiEd25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateEd25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 1
  };
  A.SubstrateConf_stafiSecp256k1_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSecp256k1AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 8
  };
  A.SubstrateConf_stafiSr25519_closure.prototype = {
    call$1(kwargs) {
      return new A.SubstrateSr25519AddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 7
  };
  A.CborObject_CborObject$fromDynamic_closure.prototype = {
    call$1(e) {
      return A.CborObject_CborObject$fromDynamic(e);
    },
    $signature: 93
  };
  A.CborBase64Types.prototype = {};
  A.CborBaseUrlValue.prototype = {
    encode$0() {
      var t3,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1);
      new A.CborBytesTracker(new A.DynamicByteTracker(t2)).pushTags$1(this.type.tag);
      t3 = type$.List_int._as(new A.CborStringValue(this.value)._encode$0());
      A.BytesUtils_validateBytes(t3, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return this.value;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.CborBaseUrlValue))
        return false;
      return this.value === other.value && this.type.tag === other.type.tag;
    },
    get$hashCode(_) {
      return B.JSString_methods.get$hashCode(this.value) ^ B.JSInt_methods.get$hashCode(B.JSArray_methods.get$first(this.type.tag));
    },
    $isCborObject: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborBigFloatValue.prototype = {
    get$value() {
      return A._setArrayType([this.exponent, this.mantissa], type$.JSArray_BigInt);
    },
    encode$0() {
      var t3, t4, _this = this,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        bytes = new A.CborBytesTracker(new A.DynamicByteTracker(t2));
      bytes.pushTags$1(B.List_5);
      bytes.pushInt$2(4, 2);
      t3 = type$.List_int;
      t4 = t3._as(_this._encodeValue$1(_this.exponent));
      A.BytesUtils_validateBytes(t4, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t4, false));
      t3 = t3._as(_this._encodeValue$1(_this.mantissa));
      A.BytesUtils_validateBytes(t3, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      return A.List_List$from(t2, true, t1);
    },
    _encodeValue$1(value) {
      if (value.get$bitLength(0) > 64)
        return new A.CborBigIntValue(value).encode$0();
      return new A.CborSafeIntValue(value).encode$0();
    },
    toString$0(_) {
      return this.exponent.toString$0(0) + ", " + this.mantissa.toString$0(0);
    },
    $eq(_, other) {
      var t1;
      if (other == null)
        return false;
      if (!(other instanceof A.CborBigFloatValue))
        return false;
      t1 = type$.JSArray_BigInt;
      return A.CompareUtils_iterableIsEqual(A._setArrayType([this.exponent, this.mantissa], t1), A._setArrayType([other.exponent, other.mantissa], t1), type$.BigInt);
    },
    get$hashCode(_) {
      return A.Primitives_objectHashCode(A._setArrayType([this.exponent, this.mantissa], type$.JSArray_BigInt));
    },
    $isCborObject: 1
  };
  A.CborBigIntValue.prototype = {
    encode$0() {
      var toBytes,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        bytes = new A.CborBytesTracker(new A.DynamicByteTracker(t2)),
        v = this.value;
      if (v._isNegative) {
        bytes.pushTags$1(B.List_3);
        v = v.$not(0);
      } else
        bytes.pushTags$1(B.List_2);
      toBytes = A.BigintUtils_toBytes(v, B.JSInt_methods._tdivFast$1((v._isNegative ? v.$negate(0) : v).get$bitLength(0) + 7, 8), B.C_Endian);
      bytes.pushInt$2(2, toBytes.length);
      type$.List_int._as(toBytes);
      A.BytesUtils_validateBytes(toBytes, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(toBytes, false));
      return A.List_List$from(t2, true, t1);
    },
    toBigInt$0() {
      return this.value;
    },
    toString$0(_) {
      return this.value.toString$0(0);
    },
    $eq(_, other) {
      var t1;
      if (other == null)
        return false;
      if (!(other instanceof A.CborBigIntValue))
        return false;
      t1 = this.value.compareTo$1(0, other.value);
      return t1 === 0;
    },
    get$hashCode(_) {
      return this.value.get$hashCode(0);
    },
    $isCborObject: 1,
    $isCborNumeric: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborBoleanValue.prototype = {
    encode$0() {
      var t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        t3 = this.value ? 21 : 20;
      new A.CborBytesTracker(new A.DynamicByteTracker(t2)).pushInt$2(7, t3);
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return B.JSBool_methods.toString$0(this.value);
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.CborBoleanValue))
        return false;
      return this.value === other.value;
    },
    get$hashCode(_) {
      return B.JSBool_methods.get$hashCode(this.value);
    },
    $isCborObject: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborBytesValue.prototype = {
    encode$0() {
      var t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        t3 = this.value;
      new A.CborBytesTracker(new A.DynamicByteTracker(t2)).pushInt$2(2, J.get$length$asx(t3));
      type$.List_int._as(t3);
      A.BytesUtils_validateBytes(t3, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      return A.List_List$from(t2, true, t1);
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.CborBytesValue))
        return false;
      return A.BytesUtils_bytesEqual(other.value, this.value);
    },
    get$hashCode(_) {
      return J.get$hashCode$(this.value);
    },
    $isCborObject: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborDynamicBytesValue.prototype = {
    encode$0() {
      var t3, t4, t5,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        bytes = new A.CborBytesTracker(new A.DynamicByteTracker(t2));
      bytes.pushIndefinite$1(2);
      for (t3 = J.get$iterator$ax(this.value), t4 = type$.List_int; t3.moveNext$0();) {
        t5 = t3.get$current();
        bytes.pushInt$2(2, J.get$length$asx(t5));
        t4._as(t5);
        A.BytesUtils_validateBytes(t5, null);
        B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t5, false));
      }
      t3 = t4._as(A._setArrayType([255], type$.JSArray_int));
      A.BytesUtils_validateBytes(t3, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return J.toString$0$(this.value);
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.CborDynamicBytesValue))
        return false;
      return this.value === other.value;
    },
    get$hashCode(_) {
      return J.get$hashCode$(this.value);
    },
    $isCborObject: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborTagValue.prototype = {
    encode$0() {
      var t3,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1);
      new A.CborBytesTracker(new A.DynamicByteTracker(t2)).pushTags$1(this.tags);
      t3 = type$.List_int._as(A.CborObject_CborObject$fromDynamic(this.value).encode$0());
      A.BytesUtils_validateBytes(t3, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return J.toString$0$(this.value);
    },
    $isCborObject: 1,
    get$value() {
      return this.value;
    }
  };
  A._CborDate.prototype = {
    _getTags$0() {
      if (this instanceof A.CborStringDateValue)
        return B.List_00;
      return B.List_1;
    },
    encode$0() {
      var t3,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1);
      new A.CborBytesTracker(new A.DynamicByteTracker(t2)).pushTags$1(this._getTags$0());
      t3 = type$.List_int._as(this._datetime$_encode$0());
      A.BytesUtils_validateBytes(t3, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return this.get$value().toIso8601String$0();
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A._CborDate))
        return false;
      if (A.getRuntimeTypeOfDartObject(other) !== A.getRuntimeTypeOfDartObject(this))
        return false;
      return 1000 * this.get$value()._core$_value === 1000 * other.get$value()._core$_value;
    },
    get$hashCode(_) {
      return this.get$value().get$hashCode(0);
    },
    $isCborObject: 1
  };
  A.CborStringDateValue.prototype = {
    _datetime$_encode$0() {
      var timeZoneOffsetSign, timeZoneOffsetMinutes, timeZoneOffsetFormatted, _s1_ = "0",
        t1 = this.value,
        year = B.JSString_methods.padLeft$2(B.JSInt_methods.toString$0(A.Primitives_getYear(t1)), 4, _s1_),
        month = B.JSString_methods.padLeft$2(B.JSInt_methods.toString$0(A.Primitives_getMonth(t1)), 2, _s1_),
        day = B.JSString_methods.padLeft$2(B.JSInt_methods.toString$0(A.Primitives_getDay(t1)), 2, _s1_),
        hour = B.JSString_methods.padLeft$2(B.JSInt_methods.toString$0(A.Primitives_getHours(t1)), 2, _s1_),
        minute = B.JSString_methods.padLeft$2(B.JSInt_methods.toString$0(A.Primitives_getMinutes(t1)), 2, _s1_),
        second = B.JSString_methods.padLeft$2(B.JSInt_methods.toString$0(A.Primitives_getSeconds(t1)), 2, _s1_),
        t2 = B.JSString_methods.padLeft$2(B.JSInt_methods.toString$0(A.Primitives_getMilliseconds(t1)), 3, _s1_),
        t3 = A.RegExp_RegExp("0*$", true),
        millisecond = A.stringReplaceAllUnchecked(t2, t3, "");
      t2 = t1.isUtc;
      t1 = (t2 ? B.Duration_0 : t1.get$timeZoneOffset())._duration;
      timeZoneOffsetSign = t1 < 0 ? "-" : "+";
      t3 = B.JSInt_methods._tdivFast$1(t1, 3600000000);
      timeZoneOffsetMinutes = B.JSInt_methods.$mod(Math.abs(B.JSInt_methods._tdivFast$1(t1, 60000000)), 60);
      timeZoneOffsetFormatted = t2 ? "Z" : timeZoneOffsetSign + B.JSString_methods.padLeft$2(B.JSInt_methods.toString$0(Math.abs(t3)), 2, _s1_) + ":" + B.JSString_methods.padLeft$2(B.JSInt_methods.toString$0(timeZoneOffsetMinutes), 2, _s1_);
      return new A.CborStringValue(year + "-" + month + "-" + day + "T" + hour + ":" + minute + ":" + second + "." + millisecond + timeZoneOffsetFormatted)._encode$0();
    },
    get$value() {
      return this.value;
    }
  };
  A.CborEpochFloatValue.prototype = {
    _datetime$_encode$0() {
      return new A.CborFloatValue(this.value._core$_value / 1000).encode$0();
    },
    get$value() {
      return this.value;
    }
  };
  A.CborEpochIntValue.prototype = {
    _datetime$_encode$0() {
      return new A.CborIntValue(B.JSNumber_methods.round$0(this.value._core$_value / 1000)).encode$0();
    },
    get$value() {
      return this.value;
    }
  };
  A.CborDecimalFracValue.prototype = {
    get$value() {
      return A._setArrayType([this.exponent, this.mantissa], type$.JSArray_BigInt);
    },
    encode$0() {
      var t3, t4, _this = this,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        bytes = new A.CborBytesTracker(new A.DynamicByteTracker(t2));
      bytes.pushTags$1(B.List_4);
      bytes.pushInt$2(4, 2);
      t3 = type$.List_int;
      t4 = t3._as(_this._decimal$_encodeValue$1(_this.exponent));
      A.BytesUtils_validateBytes(t4, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t4, false));
      t3 = t3._as(_this._decimal$_encodeValue$1(_this.mantissa));
      A.BytesUtils_validateBytes(t3, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      return A.List_List$from(t2, true, t1);
    },
    _decimal$_encodeValue$1(value) {
      if (value.get$bitLength(0) > 64)
        return new A.CborBigIntValue(value).encode$0();
      return new A.CborSafeIntValue(value).encode$0();
    },
    toString$0(_) {
      return B.JSArray_methods.join$1(A._setArrayType([this.exponent, this.mantissa], type$.JSArray_BigInt), ", ");
    },
    $eq(_, other) {
      var t1;
      if (other == null)
        return false;
      if (!(other instanceof A.CborDecimalFracValue))
        return false;
      t1 = type$.JSArray_BigInt;
      return A.CompareUtils_iterableIsEqual(A._setArrayType([this.exponent, this.mantissa], t1), A._setArrayType([other.exponent, other.mantissa], t1), type$.BigInt);
    },
    get$hashCode(_) {
      return A.Primitives_objectHashCode(A._setArrayType([this.exponent, this.mantissa], type$.JSArray_BigInt));
    },
    $isCborObject: 1
  };
  A.CborFloatValue.prototype = {
    encode$0() {
      var value, toBytes,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        bytes = new A.CborBytesTracker(new A.DynamicByteTracker(t2)),
        t3 = this.value;
      if (isNaN(t3)) {
        bytes.pushMajorTag$2(7, 25);
        t3 = type$.List_int._as(A._setArrayType([126, 0], type$.JSArray_int));
        A.BytesUtils_validateBytes(t3, null);
        B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
        return A.List_List$from(t2, true, t1);
      }
      value = this.__CborFloatValue__decodFloat_FI;
      if (value === $) {
        value !== $ && A.throwLateFieldADI("_decodFloat");
        value = this.__CborFloatValue__decodFloat_FI = new A.FloatUtils(t3);
      }
      toBytes = value.toBytes$1(null);
      bytes.pushMajorTag$2(7, toBytes.item2.get$numBytes());
      t3 = type$.List_int._as(toBytes.item1);
      A.BytesUtils_validateBytes(t3, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return B.JSNumber_methods.toString$0(this.value);
    },
    $eq(_, other) {
      var t1;
      if (other == null)
        return false;
      if (!(other instanceof A.CborFloatValue))
        return false;
      t1 = other.value;
      return this.value === t1;
    },
    get$hashCode(_) {
      return B.JSNumber_methods.get$hashCode(this.value);
    },
    $isCborObject: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborIntValue.prototype = {
    encode$0() {
      var t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        t3 = this.value,
        t4 = B.JSInt_methods.get$isNegative(t3) ? 1 : 0;
      if (B.JSInt_methods.get$isNegative(t3))
        t3 = ~t3 >>> 0;
      new A.CborBytesTracker(new A.DynamicByteTracker(t2)).pushInt$2(t4, t3);
      return A.List_List$from(t2, true, t1);
    },
    toBigInt$0() {
      return A._BigIntImpl__BigIntImpl$from(this.value);
    },
    toInt$0(_) {
      return this.value;
    },
    toString$0(_) {
      return B.JSInt_methods.toString$0(this.value);
    },
    $eq(_, other) {
      var t1;
      if (other == null)
        return false;
      if (!type$.CborNumeric._is(other))
        return false;
      if (other instanceof A.CborBigIntValue)
        return false;
      t1 = A._BigIntImpl__BigIntImpl$from(this.value).compareTo$1(0, other.toBigInt$0());
      return t1 === 0;
    },
    get$hashCode(_) {
      return B.JSInt_methods.get$hashCode(this.value);
    },
    $isCborObject: 1,
    $isCborNumeric: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborSafeIntValue.prototype = {
    encode$0() {
      var t2, t3, t4, t5,
        t1 = this.value;
      if (t1.get$isValidInt())
        return new A.CborIntValue(t1.toInt$0(0)).encode$0();
      t2 = type$.int;
      t3 = J.JSArray_JSArray$growable(0, t2);
      t4 = t1._isNegative;
      t5 = t4 ? 1 : 0;
      new A.CborBytesTracker(new A.DynamicByteTracker(t3)).pushMajorTag$2(t5, 27);
      t1 = type$.List_int._as(A.BigintUtils_toBytes(t4 ? t1.$not(0) : t1, 8, B.C_Endian));
      A.BytesUtils_validateBytes(t1, null);
      B.JSArray_methods.addAll$1(t3, A.BytesUtils_toBytes(t1, false));
      return A.List_List$from(t3, true, t2);
    },
    toBigInt$0() {
      return this.value;
    },
    toInt$0(_) {
      return this.value.toInt$0(0);
    },
    toString$0(_) {
      return this.value.toString$0(0);
    },
    $eq(_, other) {
      var t1;
      if (other == null)
        return false;
      if (!type$.CborNumeric._is(other))
        return false;
      if (other instanceof A.CborBigIntValue)
        return false;
      t1 = this.value.compareTo$1(0, other.toBigInt$0());
      return t1 === 0;
    },
    get$hashCode(_) {
      return this.value.get$hashCode(0);
    },
    $isCborObject: 1,
    $isCborNumeric: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborListValue.prototype = {
    encode$0() {
      var t4, t5, t6, _i, t7,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        bytes = new A.CborBytesTracker(new A.DynamicByteTracker(t2)),
        t3 = this._isFixedLength;
      if (t3)
        bytes.pushInt$2(4, this.value.length);
      else
        bytes.pushIndefinite$1(4);
      for (t4 = this.value, t5 = t4.length, t6 = type$.List_int, _i = 0; _i < t4.length; t4.length === t5 || (0, A.throwConcurrentModificationError)(t4), ++_i) {
        t7 = t6._as(A.CborObject_CborObject$fromDynamic(t4[_i]).encode$0());
        A.BytesUtils_validateBytes(t7, null);
        B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t7, false));
      }
      if (!t3) {
        t3 = t6._as(A._setArrayType([255], type$.JSArray_int));
        A.BytesUtils_validateBytes(t3, null);
        B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      }
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return B.JSArray_methods.join$1(this.value, ",");
    },
    $isCborObject: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborMapValue.prototype = {
    encode$0() {
      var t4, t5, t6, t7,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        bytes = new A.CborBytesTracker(new A.DynamicByteTracker(t2)),
        t3 = this._map$_isFixedLength;
      if (t3) {
        t4 = this.value;
        bytes.pushInt$2(5, t4.get$length(t4));
      } else
        bytes.pushIndefinite$1(5);
      for (t4 = this.value.get$entries(), t4 = t4.get$iterator(t4), t5 = type$.List_int; t4.moveNext$0();) {
        t6 = t4.get$current();
        t7 = t5._as(A.CborObject_CborObject$fromDynamic(t6.key).encode$0());
        A.BytesUtils_validateBytes(t7, null);
        B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t7, false));
        t6 = t5._as(A.CborObject_CborObject$fromDynamic(t6.value).encode$0());
        A.BytesUtils_validateBytes(t6, null);
        B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t6, false));
      }
      if (!t3) {
        t3 = t5._as(A._setArrayType([255], type$.JSArray_int));
        A.BytesUtils_validateBytes(t3, null);
        B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      }
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return this.value.toString$0(0);
    },
    $isCborObject: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborMimeValue.prototype = {
    encode$0() {
      var t3,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1);
      new A.CborBytesTracker(new A.DynamicByteTracker(t2)).pushTags$1(B.List_36);
      t3 = type$.List_int._as(new A.CborStringValue(this.value)._encode$0());
      A.BytesUtils_validateBytes(t3, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return this.value;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.CborMimeValue))
        return false;
      return this.value === other.value;
    },
    get$hashCode(_) {
      return B.JSString_methods.get$hashCode(this.value);
    },
    $isCborObject: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborNullValue.prototype = {
    get$value() {
      return null;
    },
    encode$0() {
      var t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1);
      new A.CborBytesTracker(new A.DynamicByteTracker(t2)).pushInt$2(7, 22);
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return "null";
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.CborNullValue))
        return false;
      return true;
    },
    get$hashCode(_) {
      return B.JSString_methods.get$hashCode("null");
    },
    $isCborObject: 1
  };
  A.CborUndefinedValue.prototype = {
    get$value() {
      return null;
    },
    encode$0() {
      var t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1);
      new A.CborBytesTracker(new A.DynamicByteTracker(t2)).pushInt$2(7, 23);
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return "undefined";
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.CborUndefinedValue))
        return false;
      return true;
    },
    get$hashCode(_) {
      return B.JSString_methods.get$hashCode("undefined");
    },
    $isCborObject: 1
  };
  A.CborRegxpValue.prototype = {
    encode$0() {
      var t3,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1);
      new A.CborBytesTracker(new A.DynamicByteTracker(t2)).pushTags$1(B.List_35);
      t3 = type$.List_int._as(new A.CborStringValue(this.value)._encode$0());
      A.BytesUtils_validateBytes(t3, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return this.value;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.CborRegxpValue))
        return false;
      return this.value === other.value;
    },
    get$hashCode(_) {
      return B.JSString_methods.get$hashCode(this.value);
    },
    $isCborObject: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborSetValue.prototype = {
    encode$0() {
      var t3, t4, t5, v, t6,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        bytes = new A.CborBytesTracker(new A.DynamicByteTracker(t2));
      bytes.pushTags$1(B.List_258);
      t3 = this.value;
      bytes.pushInt$2(4, t3._collection$_length);
      for (t3 = A._LinkedHashSetIterator$(t3, t3._collection$_modifications, A._instanceType(t3)._precomputed1), t4 = type$.List_int, t5 = t3.$ti._precomputed1; t3.moveNext$0();) {
        v = t3._collection$_current;
        t6 = t4._as(A.CborObject_CborObject$fromDynamic(v == null ? t5._as(v) : v).encode$0());
        A.BytesUtils_validateBytes(t6, null);
        B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t6, false));
      }
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return this.value.join$1(0, ",");
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.CborSetValue))
        return false;
      return A.CompareUtils_iterableIsEqual(this.value, other.value, type$.dynamic);
    },
    get$hashCode(_) {
      return A.Primitives_objectHashCode(this.value);
    },
    $isCborObject: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborString.prototype = {
    encode$0() {
      return this._encode$0();
    },
    $isCborObject: 1
  };
  A.CborStringValue.prototype = {
    _encode$0() {
      var t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        toBytes = A.StringUtils_encode(this.value, B.StringEncoding_1);
      new A.CborBytesTracker(new A.DynamicByteTracker(t2)).pushInt$2(3, toBytes.length);
      type$.List_int._as(toBytes);
      A.BytesUtils_validateBytes(toBytes, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(toBytes, false));
      return A.List_List$from(t2, true, t1);
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.CborStringValue))
        return false;
      return this.value === other.value;
    },
    get$hashCode(_) {
      return B.JSString_methods.get$hashCode(this.value);
    },
    get$value() {
      return this.value;
    }
  };
  A.CborIndefiniteStringValue.prototype = {
    _encode$0() {
      var t3, t4, toBytes,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1),
        bytes = new A.CborBytesTracker(new A.DynamicByteTracker(t2));
      bytes.pushIndefinite$1(3);
      for (t3 = J.get$iterator$ax(this.value), t4 = type$.List_int; t3.moveNext$0();) {
        toBytes = A.StringUtils_encode(t3.get$current(), B.StringEncoding_1);
        bytes.pushInt$2(3, toBytes.length);
        t4._as(toBytes);
        A.BytesUtils_validateBytes(toBytes, null);
        B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(toBytes, false));
      }
      t3 = t4._as(A._setArrayType([255], type$.JSArray_int));
      A.BytesUtils_validateBytes(t3, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return J.join$1$ax(this.value, ", ");
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.CborIndefiniteStringValue))
        return false;
      return A.CompareUtils_iterableIsEqual(this.value, other.value, type$.String);
    },
    get$hashCode(_) {
      return J.get$hashCode$(this.value);
    },
    get$value() {
      return this.value;
    }
  };
  A.CborUriValue.prototype = {
    encode$0() {
      var t3,
        t1 = type$.int,
        t2 = J.JSArray_JSArray$growable(0, t1);
      new A.CborBytesTracker(new A.DynamicByteTracker(t2)).pushTags$1(B.List_32);
      t3 = type$.List_int._as(new A.CborStringValue(this.value)._encode$0());
      A.BytesUtils_validateBytes(t3, null);
      B.JSArray_methods.addAll$1(t2, A.BytesUtils_toBytes(t3, false));
      return A.List_List$from(t2, true, t1);
    },
    toString$0(_) {
      return this.value;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.CborUriValue))
        return false;
      return this.value === other.value;
    },
    get$hashCode(_) {
      return B.JSString_methods.get$hashCode(this.value);
    },
    $isCborObject: 1,
    get$value() {
      return this.value;
    }
  };
  A.CborUtils__decodeUtf8String_closure.prototype = {
    call$1(e) {
      return type$.CborStringValue._as(e).value;
    },
    $signature: 94
  };
  A.CborUtils__toStringObject_closure.prototype = {
    call$1(element) {
      return A.BytesUtils_bytesEqual(this.tags, type$.CborBase64Types._as(element).tag);
    },
    $signature: 59
  };
  A.CborUtils__toStringObject_closure0.prototype = {
    call$1(element) {
      return A.BytesUtils_bytesEqual(this.tags, type$.CborBase64Types._as(element).tag);
    },
    $signature: 59
  };
  A.CborUtils__decodeBytesString_closure.prototype = {
    call$1(e) {
      return type$.CborBytesValue._as(e).value;
    },
    $signature: 96
  };
  A.CborBytesTracker.prototype = {
    pushTags$1(tags) {
      var t1, _i;
      type$.List_int._as(tags);
      for (t1 = tags.length, _i = 0; _i < t1; ++_i)
        this.pushInt$2(6, tags[_i]);
    },
    pushIndefinite$1(majorTag) {
      var t1 = type$.List_int._as(A._setArrayType([(majorTag << 5 | 31) >>> 0], type$.JSArray_int));
      A.BytesUtils_validateBytes(t1, null);
      B.JSArray_methods.addAll$1(this._dynamic_bytes$_buffer._bytes_tracker$_buffer, A.BytesUtils_toBytes(t1, false));
    },
    pushMajorTag$2(majorTag, value) {
      var t1 = type$.List_int._as(A._setArrayType([(majorTag << 5 | value) >>> 0], type$.JSArray_int));
      A.BytesUtils_validateBytes(t1, null);
      B.JSArray_methods.addAll$1(this._dynamic_bytes$_buffer._bytes_tracker$_buffer, A.BytesUtils_toBytes(t1, false));
    },
    pushInt$2(majorTag, value) {
      var t4, len,
        $length = this.bytesLength$1(value),
        t1 = $length == null,
        t2 = t1 ? value : $length,
        t3 = type$.List_int;
      t2 = t3._as(A._setArrayType([(majorTag << 5 | t2) >>> 0], type$.JSArray_int));
      A.BytesUtils_validateBytes(t2, null);
      t4 = this._dynamic_bytes$_buffer._bytes_tracker$_buffer;
      B.JSArray_methods.addAll$1(t4, A.BytesUtils_toBytes(t2, false));
      if (t1)
        return;
      len = B.JSInt_methods.$shl(1, $length - 24);
      if (len <= 4) {
        t1 = t3._as(A.IntUtils_toBytes(value, B.C_Endian, len));
        A.BytesUtils_validateBytes(t1, null);
        B.JSArray_methods.addAll$1(t4, A.BytesUtils_toBytes(t1, false));
      } else {
        t1 = t3._as(A.BigintUtils_toBytes(A._BigIntImpl__BigIntImpl$from(value), 8, B.C_Endian));
        A.BytesUtils_validateBytes(t1, null);
        B.JSArray_methods.addAll$1(t4, A.BytesUtils_toBytes(t1, false));
      }
    },
    bytesLength$1(value) {
      if (value < 24)
        return null;
      else if (value <= 255)
        return 24;
      else if (value <= 65535)
        return 25;
      else if (value <= 4294967295)
        return 26;
      else
        return 27;
    }
  };
  A.FloatLength.prototype = {
    get$numBytes() {
      switch (this) {
        case B.FloatLength_11_52:
          return 27;
        case B.FloatLength_8_23:
          return 26;
        default:
          return 25;
      }
    }
  };
  A.FloatUtils.prototype = {
    get$_isLess() {
      var result, _this = this,
        value = _this.__FloatUtils__isLess_FI;
      if (value === $) {
        result = A.FloatUtils__isLessThan(_this.value);
        _this.__FloatUtils__isLess_FI !== $ && A.throwLateFieldADI("_isLess");
        _this.set$__FloatUtils__isLess_FI(result);
        value = result;
      }
      return value;
    },
    _encodeFloat16$1(endianness) {
      var t1, $length, float32Bits, sign, exponent, fraction, newExponent, uint8List,
        float16View = new Uint16Array(1),
        float32View = new Float32Array(1);
      float32View[0] = this.value;
      t1 = A.NativeUint8List_NativeUint8List$view(float32View.buffer, 0, null).buffer;
      A._checkViewArguments(t1, 0, null);
      $length = B.JSInt_methods._tdivFast$1(t1.byteLength - 0, 4);
      t1 = new Uint32Array(t1, 0, $length);
      if (0 >= t1.length)
        return A.ioore(t1, 0);
      float32Bits = t1[0];
      sign = float32Bits >>> 31 & 1;
      exponent = float32Bits >>> 23 & 255;
      fraction = float32Bits & 8388607;
      if (exponent === 0)
        float16View[0] = sign << 15 | fraction >>> 13 & 1023;
      else if (exponent === 255)
        float16View[0] = sign << 15 | 31744;
      else {
        newExponent = exponent - 127 + 15;
        if (newExponent < 0)
          float16View[0] = sign << 15;
        else {
          t1 = sign << 15;
          if (newExponent > 31)
            float16View[0] = t1 | 31744;
          else
            float16View[0] = (t1 | newExponent << 10 | fraction >>> 13 & 1023) >>> 0;
        }
      }
      uint8List = A.NativeUint8List_NativeUint8List$view(float16View.buffer, 0, null);
      if (1 >= uint8List.length)
        return A.ioore(uint8List, 1);
      t1 = A.List_List$from([uint8List[1], uint8List[0]], true, type$.int);
      return t1;
    },
    _encodeFloat64$1(endianness) {
      var byteData = new DataView(new ArrayBuffer(8));
      B.NativeByteData_methods._setFloat64$3(byteData, 0, this.value, false);
      return A.NativeUint8List_NativeUint8List$view(byteData.buffer, 0, null);
    },
    _encodeFloat32$1(endianness) {
      var byteData = new DataView(new ArrayBuffer(4));
      B.NativeByteData_methods._setFloat32$3(byteData, 0, this.value, false);
      return A.NativeUint8List_NativeUint8List$view(byteData.buffer, 0, null);
    },
    toBytes$1(decodFloatType) {
      var _this = this;
      if (_this.get$_isLess().item1)
        return new A.Tuple(_this._encodeFloat16$1(null), B.FloatLength_5_10, type$.Tuple_of_List_int_and_FloatLength);
      else if (_this.get$_isLess().item2)
        return new A.Tuple(_this._encodeFloat32$1(null), B.FloatLength_8_23, type$.Tuple_of_List_int_and_FloatLength);
      return new A.Tuple(_this._encodeFloat64$1(null), B.FloatLength_11_52, type$.Tuple_of_List_int_and_FloatLength);
    },
    set$__FloatUtils__isLess_FI(__FloatUtils__isLess_FI) {
      this.__FloatUtils__isLess_FI = type$.Tuple_bool_bool._as(__FloatUtils__isLess_FI);
    },
    get$value() {
      return this.value;
    }
  };
  A.AES.prototype = {
    setKey$2(key, noDecryption) {
      var t1, t2, _this = this;
      type$.List_int._as(key);
      t1 = _this.__AES__keyLen_A;
      t1 === $ && A.throwLateFieldNI("_keyLen");
      if (t1 !== 32)
        throw A.wrapException(B.ArgumentException_RsV);
      if (_this._encKey == null)
        _this.set$_encKey(A.List_List$filled(60, 0, false, type$.int));
      if (_this._decKey == null)
        _this.set$_decKey(A.List_List$filled(60, 0, false, type$.int));
      t1 = $.$get$AES__lib();
      t2 = _this._encKey;
      t2.toString;
      t1.expandKey$3(key, t2, _this._decKey);
      return _this;
    },
    set$_encKey(_encKey) {
      this._encKey = type$.nullable_List_int._as(_encKey);
    },
    set$_decKey(_decKey) {
      this._decKey = type$.nullable_List_int._as(_decKey);
    },
    $isBlockCipher: 1
  };
  A.AESLib.prototype = {
    initialize$0() {
      var t1, t2, t3, t4, t5, i, s, t6, t7, w, t8, t9, _this = this,
        mul = new A.AESLib_initialize_mul(),
        _rot24 = new A.AESLib_initialize__rot24();
      for (t1 = _this._sbox0, t2 = _this._te0, t3 = _this._te1, t4 = _this._te2, t5 = _this._te3, i = 0; i < 256; ++i) {
        if (!(i < t1.length))
          return A.ioore(t1, i);
        s = t1[i];
        t6 = mul.call$2(s, 2);
        if (typeof t6 !== "number")
          return t6.$shl();
        t7 = mul.call$2(s, 3);
        if (typeof t7 !== "number")
          return A.iae(t7);
        w = (t6 << 24 | s << 16 | s << 8 | t7) >>> 0;
        B.JSArray_methods.$indexSet(t2, i, w);
        w = _rot24.call$1(w);
        B.JSArray_methods.$indexSet(t3, i, w);
        w = _rot24.call$1(w);
        B.JSArray_methods.$indexSet(t4, i, w);
        w = _rot24.call$1(w);
        B.JSArray_methods.$indexSet(t5, i, w);
        _rot24.call$1(w);
      }
      for (t1 = _this._sbox1, t2 = _this._td0, t3 = _this._td1, t4 = _this._td2, t5 = _this._td3, i = 0; i < 256; ++i) {
        if (!(i < t1.length))
          return A.ioore(t1, i);
        s = t1[i];
        t6 = mul.call$2(s, 14);
        if (typeof t6 !== "number")
          return t6.$shl();
        t7 = mul.call$2(s, 9);
        if (typeof t7 !== "number")
          return t7.$shl();
        t8 = mul.call$2(s, 13);
        if (typeof t8 !== "number")
          return t8.$shl();
        t9 = mul.call$2(s, 11);
        if (typeof t9 !== "number")
          return A.iae(t9);
        w = (t6 << 24 | t7 << 16 | t8 << 8 | t9) >>> 0;
        B.JSArray_methods.$indexSet(t2, i, w);
        w = _rot24.call$1(w);
        B.JSArray_methods.$indexSet(t3, i, w);
        w = _rot24.call$1(w);
        B.JSArray_methods.$indexSet(t4, i, w);
        w = _rot24.call$1(w);
        B.JSArray_methods.$indexSet(t5, i, w);
        _rot24.call$1(w);
      }
    },
    _subw$1(w) {
      var t4, t5, t6,
        t1 = this._sbox0,
        t2 = w >>> 24 & 255,
        t3 = t1.length;
      if (!(t2 < t3))
        return A.ioore(t1, t2);
      t2 = t1[t2];
      if (typeof t2 !== "number")
        return t2.$shl();
      t4 = w >>> 16 & 255;
      if (!(t4 < t3))
        return A.ioore(t1, t4);
      t4 = t1[t4];
      if (typeof t4 !== "number")
        return t4.$shl();
      t5 = w >>> 8 & 255;
      if (!(t5 < t3))
        return A.ioore(t1, t5);
      t5 = t1[t5];
      if (typeof t5 !== "number")
        return t5.$shl();
      t6 = w & 255;
      if (!(t6 < t3))
        return A.ioore(t1, t6);
      t6 = t1[t6];
      if (typeof t6 !== "number")
        return A.iae(t6);
      return (t2 << 24 | t4 << 16 | t5 << 8 | t6) >>> 0;
    },
    expandKey$3(key, encKey, decKey) {
      var n, i, t, t2, t3, t4, t5, ei, t6, i0, t7, j, t8, x, t9, t10, t11, _this = this,
        t1 = type$.List_int;
      t1._as(key);
      t1._as(encKey);
      type$.nullable_List_int._as(decKey);
      n = encKey.length;
      for (i = 0; i < 8; ++i)
        B.JSArray_methods.$indexSet(encKey, i, A.readUint32BE(key, i * 4));
      for (t1 = _this._powx, i = 8; i < n; ++i) {
        t = encKey[i - 1];
        t2 = B.JSInt_methods.$mod(i, 8);
        if (t2 === 0) {
          t2 = _this._subw$1((t << 8 | t >>> 24) >>> 0);
          t3 = B.JSInt_methods._tdivFast$1(i, 8) - 1;
          if (!(t3 >= 0 && t3 < t1.length))
            return A.ioore(t1, t3);
          t3 = t1[t3];
          if (typeof t3 !== "number")
            return t3.$shl();
          t = t2 ^ t3 << 24;
        } else if (t2 === 4)
          t = _this._subw$1(t);
        B.JSArray_methods.$indexSet(encKey, i, (encKey[i - 8] ^ t) >>> 0);
      }
      if (decKey != null)
        for (t1 = _this._td0, t2 = _this._sbox0, t3 = _this._td1, t4 = _this._td2, t5 = _this._td3, i = 0; i < n; i = i0) {
          ei = n - i - 4;
          for (t6 = i > 0, i0 = i + 4, t7 = i0 < n, j = 0; j < 4; ++j) {
            t8 = ei + j;
            if (!(t8 >= 0))
              return A.ioore(encKey, t8);
            x = encKey[t8];
            if (t6 && t7) {
              t8 = x >>> 24 & 255;
              if (!(t8 < t2.length))
                return A.ioore(t2, t8);
              t8 = B.JSArray_methods.$index(t1, t2[t8]);
              t9 = x >>> 16 & 255;
              if (!(t9 < t2.length))
                return A.ioore(t2, t9);
              t9 = B.JSArray_methods.$index(t3, t2[t9]);
              t10 = x >>> 8 & 255;
              if (!(t10 < t2.length))
                return A.ioore(t2, t10);
              t10 = B.JSArray_methods.$index(t4, t2[t10]);
              t11 = x & 255;
              if (!(t11 < t2.length))
                return A.ioore(t2, t11);
              x = (t8 ^ t9 ^ t10 ^ B.JSArray_methods.$index(t5, t2[t11])) >>> 0;
            }
            B.JSArray_methods.$indexSet(decKey, i + j, x);
          }
        }
    },
    encryptBlock$3(xk, src, dst) {
      var s0, s1, s2, s3, nr, t2, t3, t4, t5, t00, t10, t20, t30, k, r, t6, t7, t8, t9, t11, t12, t13, t14, t15, t16, t17, t18, _this = this,
        t1 = type$.List_int;
      t1._as(xk);
      t1._as(src);
      t1._as(dst);
      s0 = A.readUint32BE(src, 0);
      s1 = A.readUint32BE(src, 4);
      s2 = A.readUint32BE(src, 8);
      s3 = A.readUint32BE(src, 12);
      t1 = xk.length;
      if (0 >= t1)
        return A.ioore(xk, 0);
      s0 ^= xk[0];
      if (1 >= t1)
        return A.ioore(xk, 1);
      s1 ^= xk[1];
      if (2 >= t1)
        return A.ioore(xk, 2);
      s2 ^= xk[2];
      if (3 >= t1)
        return A.ioore(xk, 3);
      s3 ^= xk[3];
      nr = (t1 / 4 | 0) - 2;
      for (t2 = _this._te0, t3 = _this._te1, t4 = _this._te2, t5 = _this._te3, t00 = 0, t10 = 0, t20 = 0, t30 = 0, k = 4, r = 0; r < nr; ++r, s3 = t30, s2 = t20, s1 = t10, s0 = t00) {
        if (!(k < t1))
          return A.ioore(xk, k);
        t00 = xk[k] ^ t2[s0 >>> 24 & 255] ^ t3[s1 >>> 16 & 255] ^ t4[s2 >>> 8 & 255] ^ t5[s3 & 255];
        t6 = k + 1;
        if (!(t6 < t1))
          return A.ioore(xk, t6);
        t10 = xk[t6] ^ t2[s1 >>> 24 & 255] ^ t3[s2 >>> 16 & 255] ^ t4[s3 >>> 8 & 255] ^ t5[s0 & 255];
        t6 = k + 2;
        if (!(t6 < t1))
          return A.ioore(xk, t6);
        t20 = xk[t6] ^ t2[s2 >>> 24 & 255] ^ t3[s3 >>> 16 & 255] ^ t4[s0 >>> 8 & 255] ^ t5[s1 & 255];
        t6 = k + 3;
        if (!(t6 < t1))
          return A.ioore(xk, t6);
        t30 = xk[t6] ^ t2[s3 >>> 24 & 255] ^ t3[s0 >>> 16 & 255] ^ t4[s1 >>> 8 & 255] ^ t5[s2 & 255];
        k += 4;
      }
      t2 = _this._sbox0;
      t3 = t00 >>> 24;
      t4 = t2.length;
      if (!(t3 < t4))
        return A.ioore(t2, t3);
      t3 = t2[t3];
      if (typeof t3 !== "number")
        return t3.$shl();
      t5 = t10 >>> 16 & 255;
      if (!(t5 < t4))
        return A.ioore(t2, t5);
      t5 = t2[t5];
      if (typeof t5 !== "number")
        return t5.$shl();
      t6 = t20 >>> 8 & 255;
      if (!(t6 < t4))
        return A.ioore(t2, t6);
      t6 = t2[t6];
      if (typeof t6 !== "number")
        return t6.$shl();
      t7 = t30 & 255;
      if (!(t7 < t4))
        return A.ioore(t2, t7);
      t7 = t2[t7];
      if (typeof t7 !== "number")
        return A.iae(t7);
      t8 = t10 >>> 24;
      if (!(t8 < t4))
        return A.ioore(t2, t8);
      t8 = t2[t8];
      if (typeof t8 !== "number")
        return t8.$shl();
      t9 = t20 >>> 16 & 255;
      if (!(t9 < t4))
        return A.ioore(t2, t9);
      t9 = t2[t9];
      if (typeof t9 !== "number")
        return t9.$shl();
      t11 = t30 >>> 8 & 255;
      if (!(t11 < t4))
        return A.ioore(t2, t11);
      t11 = t2[t11];
      if (typeof t11 !== "number")
        return t11.$shl();
      t12 = t00 & 255;
      if (!(t12 < t4))
        return A.ioore(t2, t12);
      t12 = t2[t12];
      if (typeof t12 !== "number")
        return A.iae(t12);
      t13 = t20 >>> 24;
      if (!(t13 < t4))
        return A.ioore(t2, t13);
      t13 = t2[t13];
      if (typeof t13 !== "number")
        return t13.$shl();
      t14 = t30 >>> 16 & 255;
      if (!(t14 < t4))
        return A.ioore(t2, t14);
      t14 = t2[t14];
      if (typeof t14 !== "number")
        return t14.$shl();
      t15 = t00 >>> 8 & 255;
      if (!(t15 < t4))
        return A.ioore(t2, t15);
      t15 = t2[t15];
      if (typeof t15 !== "number")
        return t15.$shl();
      t16 = t10 & 255;
      if (!(t16 < t4))
        return A.ioore(t2, t16);
      t16 = t2[t16];
      if (typeof t16 !== "number")
        return A.iae(t16);
      t30 = t30 >>> 24;
      if (!(t30 < t4))
        return A.ioore(t2, t30);
      t30 = t2[t30];
      if (typeof t30 !== "number")
        return t30.$shl();
      t00 = t00 >>> 16 & 255;
      if (!(t00 < t4))
        return A.ioore(t2, t00);
      t00 = t2[t00];
      if (typeof t00 !== "number")
        return t00.$shl();
      t10 = t10 >>> 8 & 255;
      if (!(t10 < t4))
        return A.ioore(t2, t10);
      t10 = t2[t10];
      if (typeof t10 !== "number")
        return t10.$shl();
      t20 &= 255;
      if (!(t20 < t4))
        return A.ioore(t2, t20);
      t20 = t2[t20];
      if (typeof t20 !== "number")
        return A.iae(t20);
      if (!(k < t1))
        return A.ioore(xk, k);
      t2 = xk[k];
      t4 = k + 1;
      if (!(t4 < t1))
        return A.ioore(xk, t4);
      t4 = xk[t4];
      t17 = k + 2;
      if (!(t17 < t1))
        return A.ioore(xk, t17);
      t17 = xk[t17];
      t18 = k + 3;
      if (!(t18 < t1))
        return A.ioore(xk, t18);
      t18 = xk[t18];
      A.writeUint32BE(((t3 << 24 | t5 << 16 | t6 << 8 | t7) ^ t2) >>> 0, dst, 0);
      A.writeUint32BE(((t8 << 24 | t9 << 16 | t11 << 8 | t12) ^ t4) >>> 0, dst, 4);
      A.writeUint32BE(((t13 << 24 | t14 << 16 | t15 << 8 | t16) ^ t17) >>> 0, dst, 8);
      A.writeUint32BE(((t30 << 24 | t00 << 16 | t10 << 8 | t20) ^ t18) >>> 0, dst, 12);
    }
  };
  A.AESLib_initialize_mul.prototype = {
    call$2(b, c) {
      var j = c,
        i = b,
        s = 0, k = 1;
      while (true) {
        if (!(k < 256 && j !== 0))
          break;
        if ((j & k) >>> 0 !== 0) {
          s = (s ^ i) >>> 0;
          j = (j ^ k) >>> 0;
        }
        i = i << 1;
        if ((i & 256) !== 0)
          i ^= 283;
        k = k << 1 >>> 0;
      }
      return s;
    },
    $signature: 19
  };
  A.AESLib_initialize__rot24.prototype = {
    call$1(x) {
      return A.rotl32(x, 24);
    },
    $signature: 13
  };
  A.CurveFp.prototype = {
    $eq(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (other instanceof A.CurveFp) {
        t1 = _this.p.compareTo$1(0, other.p);
        if (t1 === 0) {
          t1 = _this.a.compareTo$1(0, other.a);
          if (t1 === 0) {
            t1 = _this.b.compareTo$1(0, other.b);
            if (t1 === 0)
              t1 = _this.h.compareTo$1(0, other.h) === 0;
            else
              t1 = false;
          } else
            t1 = false;
        } else
          t1 = false;
        return t1;
      }
      return false;
    },
    get$hashCode(_) {
      var _this = this;
      return _this.p.get$hashCode(0) ^ _this.a.get$hashCode(0) ^ _this.b.get$hashCode(0) ^ _this.h.get$hashCode(0);
    },
    get$baselen() {
      return A.BigintUtils_orderLen(this.p);
    },
    get$p() {
      return this.p;
    }
  };
  A.CurveED.prototype = {
    $eq(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (other instanceof A.CurveED) {
        t1 = _this.p.compareTo$1(0, other.p);
        if (t1 === 0) {
          t1 = _this.a.compareTo$1(0, other.a);
          if (t1 === 0) {
            t1 = _this.d.compareTo$1(0, other.d);
            if (t1 === 0)
              t1 = _this.h.compareTo$1(0, other.h) === 0;
            else
              t1 = false;
          } else
            t1 = false;
        } else
          t1 = false;
        return t1;
      }
      return false;
    },
    get$hashCode(_) {
      var _this = this;
      return _this.p.get$hashCode(0) ^ _this.d.get$hashCode(0) ^ _this.h.get$hashCode(0) ^ _this.a.get$hashCode(0);
    },
    get$baselen() {
      return B.JSInt_methods._tdivFast$1(this.p.get$bitLength(0) + 1 + 7, 8);
    },
    get$p() {
      return this.p;
    }
  };
  A.Curve.prototype = {};
  A.ECDSAPublicKey.prototype = {
    $eq(_, other) {
      if (other == null)
        return false;
      if (other instanceof A.ECDSAPublicKey)
        return this.generator.curve.$eq(0, other.generator.curve) && this.point.$eq(0, other.point);
      return false;
    },
    get$hashCode(_) {
      return this.generator.get$hashCode(0) ^ this.point.get$hashCode(0);
    }
  };
  A.EDDSAPublicKey.prototype = {
    $eq(_, other) {
      if (other == null)
        return false;
      if (other instanceof A.EDDSAPublicKey)
        return this.generator.curve.$eq(0, other.generator.curve) && A.BytesUtils_bytesEqual(this._encoded, other._encoded);
      return false;
    },
    get$hashCode(_) {
      return (this.generator.curve.get$hashCode(0) ^ A.Primitives_objectHashCode(this._encoded)) >>> 0;
    }
  };
  A.EncodeType.prototype = {
    _enumToString$0() {
      return "EncodeType." + this._core$_name;
    }
  };
  A.AbstractPoint.prototype = {
    toBytes$1(encodeType) {
      var encLen, yStr, t1, t2, raw, prefix, result, xStr, _this = this;
      if (_this instanceof A.EDPoint) {
        _this.scale$0();
        encLen = B.JSInt_methods._tdivFast$1(_this.curve.p.get$bitLength(0) + 1 + 7, 8);
        yStr = A.BigintUtils_toBytes(_this.get$y(), encLen, B.C_Endian0);
        t1 = _this.get$x().$mod(0, $.$get$_BigIntImpl_two()).compareTo$1(0, $.$get$_BigIntImpl_one());
        if (t1 === 0) {
          t1 = yStr.length;
          t2 = t1 - 1;
          if (!(t2 >= 0))
            return A.ioore(yStr, t2);
          t1 = yStr[t2];
          if (typeof t1 !== "number")
            return t1.$or();
          B.JSArray_methods.$indexSet(yStr, t2, (t1 | 128) >>> 0);
        }
        return yStr;
      }
      switch (encodeType) {
        case B.EncodeType_2:
          return _this._base$_encode$0();
        case B.EncodeType_3:
          t1 = [4];
          B.JSArray_methods.addAll$1(t1, _this._base$_encode$0());
          return A.List_List$from(t1, true, type$.int);
        case B.EncodeType_1:
          raw = _this._base$_encode$0();
          t1 = type$.int;
          prefix = !_this.get$y().get$isEven(0) ? A.List_List$from([7], true, t1) : A.List_List$from([6], true, t1);
          result = A.List_List$filled(prefix.length + raw.length, 0, false, t1);
          B.JSArray_methods.setAll$2(result, 0, prefix);
          B.JSArray_methods.setAll$2(result, prefix.length, raw);
          return result;
        default:
          xStr = A.BigintUtils_toBytes(_this.get$x(), A.BigintUtils_orderLen(_this.get$curve().get$p()), B.C_Endian);
          t1 = _this.get$y().$and(0, $.$get$_BigIntImpl_one()).compareTo$1(0, $.$get$_BigIntImpl_zero());
          t2 = type$.int;
          prefix = t1 !== 0 ? A.List_List$from([3], true, t2) : A.List_List$from([2], true, t2);
          result = A.List_List$filled(prefix.length + xStr.length, 0, false, t2);
          B.JSArray_methods.setAll$2(result, 0, prefix);
          B.JSArray_methods.setAll$2(result, prefix.length, xStr);
          return result;
      }
    },
    toBytes$0() {
      return this.toBytes$1(B.EncodeType_0);
    },
    _base$_encode$0() {
      var _this = this,
        xBytes = A.BigintUtils_toBytes(_this.get$x(), A.BigintUtils_orderLen(_this.get$curve().get$p()), B.C_Endian),
        yBytes = A.BigintUtils_toBytes(_this.get$y(), A.BigintUtils_orderLen(_this.get$curve().get$p()), B.C_Endian),
        t1 = A.List_List$of(xBytes, true, type$.dynamic);
      B.JSArray_methods.addAll$1(t1, yBytes);
      return A.List_List$from(t1, true, type$.int);
    },
    toString$0(_) {
      return "(" + this.get$x().toString$0(0) + ", " + this.get$y().toString$0(0) + ")";
    }
  };
  A.ProjectiveECCPoint.prototype = {
    get$isInfinity() {
      var t1 = this._ec_projective_point$_coords,
        t2 = t1.length;
      if (t2 !== 0) {
        if (0 >= t2)
          return A.ioore(t1, 0);
        t1 = t1[0];
        t2 = $.$get$_BigIntImpl_zero();
        t1 = J.compareTo$1$ns(t1, t2);
        if (t1 === 0) {
          t1 = this._ec_projective_point$_coords;
          if (1 >= t1.length)
            return A.ioore(t1, 1);
          t1 = J.compareTo$1$ns(t1[1], t2) === 0;
        } else
          t1 = false;
      } else
        t1 = true;
      return t1;
    },
    _precomputeIfNeeded$0() {
      var t1, precomputedPoints, i, t2, newOrder, t3, t4, xCoord, yCoord, doubler, _this = this;
      if (!_this.generator || _this._precompute.length !== 0)
        return;
      t1 = _this.order;
      t1.toString;
      precomputedPoints = A._setArrayType([], type$.JSArray_List_BigInt);
      i = $.$get$_BigIntImpl_one();
      t2 = $.$get$_BigIntImpl_two();
      newOrder = t1.$mul(0, t2);
      t3 = _this._ec_projective_point$_coords;
      t4 = t3.length;
      if (0 >= t4)
        return A.ioore(t3, 0);
      xCoord = t3[0];
      if (1 >= t4)
        return A.ioore(t3, 1);
      yCoord = t3[1];
      if (2 >= t4)
        return A.ioore(t3, 2);
      t4 = type$.JSArray_BigInt;
      doubler = new A.ProjectiveECCPoint(_this.curve, t1, false, B.List_empty3, A._setArrayType([xCoord, yCoord, t3[2]], t4));
      newOrder = newOrder.$mul(0, t2);
      B.JSArray_methods.add$1(precomputedPoints, A._setArrayType([doubler.get$x(), doubler.get$y()], t4));
      for (; i.compareTo$1(0, newOrder) < 0;) {
        i = i.$mul(0, t2);
        doubler = doubler.doublePoint$0().scale$0();
        B.JSArray_methods.add$1(precomputedPoints, A._setArrayType([doubler.get$x(), doubler.get$y()], t4));
      }
      _this.set$_precompute(precomputedPoints);
    },
    $eq(_, other) {
      var t1, t2, x1, y1, z1, p, zz1, t3, x2, y2, z2, zz2;
      if (other == null)
        return false;
      if (!(other instanceof A.AbstractPoint))
        return false;
      t1 = this._ec_projective_point$_coords;
      t2 = t1.length;
      if (0 >= t2)
        return A.ioore(t1, 0);
      x1 = t1[0];
      if (1 >= t2)
        return A.ioore(t1, 1);
      y1 = t1[1];
      if (2 >= t2)
        return A.ioore(t1, 2);
      z1 = t1[2];
      t1 = this.curve;
      p = t1.p;
      zz1 = z1.$mul(0, z1).$mod(0, p);
      if (!(other instanceof A.ProjectiveECCPoint))
        return false;
      if (other.get$isInfinity()) {
        t1 = $.$get$_BigIntImpl_zero();
        t2 = y1.compareTo$1(0, t1);
        if (t2 !== 0)
          t1 = z1.compareTo$1(0, t1) === 0;
        else
          t1 = true;
        return t1;
      }
      t2 = other._ec_projective_point$_coords;
      t3 = t2.length;
      if (0 >= t3)
        return A.ioore(t2, 0);
      x2 = t2[0];
      if (1 >= t3)
        return A.ioore(t2, 1);
      y2 = t2[1];
      if (2 >= t3)
        return A.ioore(t2, 2);
      z2 = t2[2];
      if (!t1.$eq(0, other.curve))
        return false;
      zz2 = z2.$mul(0, z2).$mod(0, p);
      t1 = x1.$mul(0, zz2).$sub(0, x2.$mul(0, zz1)).$mod(0, p);
      t2 = $.$get$_BigIntImpl_zero();
      t1 = t1.compareTo$1(0, t2);
      if (t1 === 0)
        t1 = y1.$mul(0, zz2).$mul(0, z2).$sub(0, y2.$mul(0, zz1).$mul(0, z1)).$mod(0, p).compareTo$1(0, t2) === 0;
      else
        t1 = false;
      return t1;
    },
    get$x() {
      var xCoordinate, zCoordinate, p, zInverse,
        t1 = this._ec_projective_point$_coords,
        t2 = t1.length;
      if (0 >= t2)
        return A.ioore(t1, 0);
      xCoordinate = t1[0];
      if (2 >= t2)
        return A.ioore(t1, 2);
      zCoordinate = t1[2];
      t1 = zCoordinate.compareTo$1(0, $.$get$_BigIntImpl_one());
      if (t1 === 0)
        return xCoordinate;
      p = this.curve.p;
      zInverse = A.BigintUtils_inverseMod(zCoordinate, p);
      return xCoordinate.$mul(0, zInverse).$mul(0, zInverse).$mod(0, p);
    },
    get$y() {
      var yCoordinate, zCoordinate, primeField, zInverse,
        t1 = this._ec_projective_point$_coords,
        t2 = t1.length;
      if (1 >= t2)
        return A.ioore(t1, 1);
      yCoordinate = t1[1];
      if (2 >= t2)
        return A.ioore(t1, 2);
      zCoordinate = t1[2];
      primeField = this.curve.p;
      t1 = zCoordinate.compareTo$1(0, $.$get$_BigIntImpl_one());
      if (t1 === 0)
        return yCoordinate;
      zInverse = A.BigintUtils_inverseMod(zCoordinate, primeField);
      return yCoordinate.$mul(0, zInverse).$mul(0, zInverse).$mul(0, zInverse).$mod(0, primeField);
    },
    scale$0() {
      var currentZ, t2, currentY, currentX, primeField, zInverse, zInverseSquared, _this = this,
        t1 = _this._ec_projective_point$_coords;
      if (2 >= t1.length)
        return A.ioore(t1, 2);
      currentZ = t1[2];
      t1 = $.$get$_BigIntImpl_one();
      t2 = currentZ.compareTo$1(0, t1);
      if (t2 === 0)
        return _this;
      t2 = _this._ec_projective_point$_coords;
      if (1 >= t2.length)
        return A.ioore(t2, 1);
      currentY = t2[1];
      currentX = t2[0];
      primeField = _this.curve.p;
      zInverse = A.BigintUtils_inverseMod(currentZ, primeField);
      zInverseSquared = zInverse.$mul(0, zInverse).$mod(0, primeField);
      _this.set$_ec_projective_point$_coords(A._setArrayType([currentX.$mul(0, zInverseSquared).$mod(0, primeField), currentY.$mul(0, zInverseSquared).$mul(0, zInverse).$mod(0, primeField), t1], type$.JSArray_BigInt));
      return _this;
    },
    _doubleWithZ1$4(x1, y1, p, a) {
      var ySquaredSquared, s, m, t,
        xSquared = x1.$mul(0, x1).$mod(0, p),
        ySquared = y1.$mul(0, y1).$mod(0, p),
        t1 = $.$get$_BigIntImpl_zero(),
        t2 = ySquared.compareTo$1(0, t1);
      if (t2 === 0)
        return A._setArrayType([t1, t1, $.$get$_BigIntImpl_one()], type$.JSArray_BigInt);
      ySquaredSquared = ySquared.$mul(0, ySquared).$mod(0, p);
      t1 = $.$get$_BigIntImpl_two();
      s = t1.$mul(0, x1.$add(0, ySquared).$mul(0, x1.$add(0, ySquared)).$sub(0, xSquared).$sub(0, ySquaredSquared)).$mod(0, p);
      m = A._BigIntImpl__BigIntImpl$from(3).$mul(0, xSquared).$add(0, a).$mod(0, p);
      t = m.$mul(0, m).$sub(0, A._BigIntImpl__BigIntImpl$from(2).$mul(0, s)).$mod(0, p);
      return A._setArrayType([t, m.$mul(0, s.$sub(0, t)).$sub(0, A._BigIntImpl__BigIntImpl$from(8).$mul(0, ySquaredSquared)).$mod(0, p), t1.$mul(0, y1).$mod(0, p)], type$.JSArray_BigInt);
    },
    _double$5(x1, y1, z1, p, a) {
      var t3, xSquared, ySquared, ySquaredSquared, zSquared, s, m, t,
        t1 = $.$get$_BigIntImpl_one(),
        t2 = z1.compareTo$1(0, t1);
      if (t2 === 0)
        return this._doubleWithZ1$4(x1, y1, p, a);
      t2 = $.$get$_BigIntImpl_zero();
      t3 = y1.compareTo$1(0, t2);
      if (t3 !== 0)
        t3 = z1.compareTo$1(0, t2) === 0;
      else
        t3 = true;
      if (t3)
        return A._setArrayType([t2, t2, t1], type$.JSArray_BigInt);
      xSquared = x1.$mul(0, x1).$mod(0, p);
      ySquared = y1.$mul(0, y1).$mod(0, p);
      t3 = ySquared.compareTo$1(0, t2);
      if (t3 === 0)
        return A._setArrayType([t2, t2, t1], type$.JSArray_BigInt);
      ySquaredSquared = ySquared.$mul(0, ySquared).$mod(0, p);
      zSquared = z1.$mul(0, z1).$mod(0, p);
      s = $.$get$_BigIntImpl_two().$mul(0, x1.$add(0, ySquared).$mul(0, x1.$add(0, ySquared)).$sub(0, xSquared).$sub(0, ySquaredSquared)).$mod(0, p);
      m = A._BigIntImpl__BigIntImpl$from(3).$mul(0, xSquared).$add(0, a.$mul(0, zSquared).$mul(0, zSquared)).$mod(0, p);
      t = m.$mul(0, m).$sub(0, A._BigIntImpl__BigIntImpl$from(2).$mul(0, s)).$mod(0, p);
      return A._setArrayType([t, m.$mul(0, s.$sub(0, t)).$sub(0, A._BigIntImpl__BigIntImpl$from(8).$mul(0, ySquaredSquared)).$mod(0, p), y1.$add(0, z1).$mul(0, y1.$add(0, z1)).$sub(0, ySquared).$sub(0, zSquared).$mod(0, p)], type$.JSArray_BigInt);
    },
    doublePoint$0() {
      var x1, y1, z1, result, t3, _this = this,
        t1 = _this._ec_projective_point$_coords,
        t2 = t1.length;
      if (0 >= t2)
        return A.ioore(t1, 0);
      x1 = t1[0];
      if (1 >= t2)
        return A.ioore(t1, 1);
      y1 = t1[1];
      if (2 >= t2)
        return A.ioore(t1, 2);
      z1 = t1[2];
      t1 = $.$get$_BigIntImpl_zero();
      t2 = y1.compareTo$1(0, t1);
      if (t2 === 0)
        return new A.ProjectiveECCPoint(_this.curve, null, false, B.List_empty3, A._setArrayType([t1, t1, t1], type$.JSArray_BigInt));
      t2 = _this.curve;
      result = _this._double$5(x1, y1, z1, t2.p, t2.a);
      t3 = result[1].compareTo$1(0, t1);
      if (t3 !== 0)
        t3 = result[2].compareTo$1(0, t1) === 0;
      else
        t3 = true;
      if (t3)
        return new A.ProjectiveECCPoint(t2, null, false, B.List_empty3, A._setArrayType([t1, t1, t1], type$.JSArray_BigInt));
      return new A.ProjectiveECCPoint(t2, _this.order, false, B.List_empty3, A._setArrayType([result[0], result[1], result[2]], type$.JSArray_BigInt));
    },
    _addPointsWithZ1$5(x1, y1, x2, y2, p) {
      var $V, x3,
        diff = x2.$sub(0, x1),
        I = diff.$mul(0, diff).$mul(0, A._BigIntImpl__BigIntImpl$from(4)).$mod(0, p),
        $J = diff.$mul(0, I),
        scaledYDifference = y2.$sub(0, y1).$mul(0, A._BigIntImpl__BigIntImpl$from(2)),
        t1 = $.$get$_BigIntImpl_zero(),
        t2 = diff.compareTo$1(0, t1);
      if (t2 === 0)
        t1 = scaledYDifference.compareTo$1(0, t1) === 0;
      else
        t1 = false;
      if (t1)
        return this._doubleWithZ1$4(x1, y1, p, this.curve.a);
      $V = x1.$mul(0, I);
      x3 = scaledYDifference.$mul(0, scaledYDifference).$sub(0, $J).$sub(0, $V.$mul(0, A._BigIntImpl__BigIntImpl$from(2))).$mod(0, p);
      return A._setArrayType([x3, scaledYDifference.$mul(0, $V.$sub(0, x3)).$sub(0, y1.$mul(0, $J).$mul(0, A._BigIntImpl__BigIntImpl$from(2))).$mod(0, p), diff.$mul(0, A._BigIntImpl__BigIntImpl$from(2)).$mod(0, p)], type$.JSArray_BigInt);
    },
    _addPointsWithCommonZ$6(x1, y1, z1, x2, y2, p) {
      var x3,
        $A = x2.$sub(0, x1).modPow$2(0, A._BigIntImpl__BigIntImpl$from(2), p),
        $B = x1.$mul(0, $A).$mod(0, p),
        $C = x2.$mul(0, $A),
        $D = y2.$sub(0, y1).modPow$2(0, A._BigIntImpl__BigIntImpl$from(2), p),
        t1 = $.$get$_BigIntImpl_zero(),
        t2 = $A.compareTo$1(0, t1);
      if (t2 === 0)
        t1 = $D.compareTo$1(0, t1) === 0;
      else
        t1 = false;
      if (t1)
        return this._double$5(x1, y1, z1, p, this.curve.a);
      x3 = $D.$sub(0, $B).$sub(0, $C).$mod(0, p);
      return A._setArrayType([x3, y2.$sub(0, y1).$mul(0, $B.$sub(0, x3)).$sub(0, y1.$mul(0, $C.$sub(0, $B))).$mod(0, p), z1.$mul(0, x2.$sub(0, x1)).$mod(0, p)], type$.JSArray_BigInt);
    },
    _addPointsWithZ2EqualOne$6(x1, y1, z1, x2, y2, p) {
      var v, x3,
        z1z1 = z1.$mul(0, z1).$mod(0, p),
        u2 = x2.$mul(0, z1z1).$mod(0, p),
        s2 = y2.$mul(0, z1).$mul(0, z1z1).$mod(0, p),
        h = u2.$sub(0, x1).$mod(0, p),
        hh = h.$mul(0, h).$mod(0, p),
        i = A._BigIntImpl__BigIntImpl$from(4).$mul(0, hh).$mod(0, p),
        j = h.$mul(0, i).$mod(0, p),
        r = A._BigIntImpl__BigIntImpl$from(2).$mul(0, s2.$sub(0, y1)).$mod(0, p),
        t1 = $.$get$_BigIntImpl_zero(),
        t2 = r.compareTo$1(0, t1);
      if (t2 === 0)
        t1 = h.compareTo$1(0, t1) === 0;
      else
        t1 = false;
      if (t1)
        return this._doubleWithZ1$4(x2, y2, p, this.curve.a);
      v = x1.$mul(0, i).$mod(0, p);
      x3 = r.$mul(0, r).$sub(0, j).$sub(0, A._BigIntImpl__BigIntImpl$from(2).$mul(0, v)).$mod(0, p);
      return A._setArrayType([x3, r.$mul(0, v.$sub(0, x3)).$sub(0, A._BigIntImpl__BigIntImpl$from(2).$mul(0, y1).$mul(0, j)).$mod(0, p), z1.$add(0, h).modPow$2(0, A._BigIntImpl__BigIntImpl$from(2), p).$sub(0, z1z1).$sub(0, hh).$mod(0, p)], type$.JSArray_BigInt);
    },
    _addPointsWithZNotEqual$7(x1, y1, z1, x2, y2, z2, p) {
      var v, x3,
        z1z1 = z1.$mul(0, z1).$mod(0, p),
        z2z2 = z2.$mul(0, z2).$mod(0, p),
        u1 = x1.$mul(0, z2z2).$mod(0, p),
        u2 = x2.$mul(0, z1z1).$mod(0, p),
        s1 = y1.$mul(0, z2).$mul(0, z2z2).$mod(0, p),
        s2 = y2.$mul(0, z1).$mul(0, z1z1).$mod(0, p),
        h = u2.$sub(0, u1).$mod(0, p),
        i = A._BigIntImpl__BigIntImpl$from(4).$mul(0, h).$mul(0, h).$mod(0, p),
        j = h.$mul(0, i).$mod(0, p),
        r = A._BigIntImpl__BigIntImpl$from(2).$mul(0, s2.$sub(0, s1)).$mod(0, p),
        t1 = $.$get$_BigIntImpl_zero(),
        t2 = h.compareTo$1(0, t1);
      if (t2 === 0)
        t1 = r.compareTo$1(0, t1) === 0;
      else
        t1 = false;
      if (t1)
        return this._double$5(x1, y1, z1, p, this.curve.a);
      v = u1.$mul(0, i).$mod(0, p);
      x3 = r.$mul(0, r).$sub(0, j).$sub(0, A._BigIntImpl__BigIntImpl$from(2).$mul(0, v)).$mod(0, p);
      return A._setArrayType([x3, r.$mul(0, v.$sub(0, x3)).$sub(0, A._BigIntImpl__BigIntImpl$from(2).$mul(0, s1).$mul(0, j)).$mod(0, p), z1.$add(0, z2).modPow$2(0, A._BigIntImpl__BigIntImpl$from(2), p).$sub(0, z1z1).$sub(0, z2z2).$mul(0, h).$mod(0, p)], type$.JSArray_BigInt);
    },
    _addPoints$7(x1, y1, z1, x2, y2, z2, p) {
      var _this = this,
        t1 = $.$get$_BigIntImpl_zero(),
        t2 = y1.compareTo$1(0, t1);
      if (t2 !== 0)
        t2 = z1.compareTo$1(0, t1) === 0;
      else
        t2 = true;
      if (t2)
        return A._setArrayType([x2, y2, z2], type$.JSArray_BigInt);
      t2 = y2.compareTo$1(0, t1);
      if (t2 !== 0)
        t1 = z2.compareTo$1(0, t1) === 0;
      else
        t1 = true;
      if (t1)
        return A._setArrayType([x1, y1, z1], type$.JSArray_BigInt);
      t1 = z1.compareTo$1(0, z2);
      if (t1 === 0) {
        t1 = z1.compareTo$1(0, $.$get$_BigIntImpl_one());
        if (t1 === 0)
          return _this._addPointsWithZ1$5(x1, y1, x2, y2, p);
        return _this._addPointsWithCommonZ$6(x1, y1, z1, x2, y2, p);
      }
      t1 = $.$get$_BigIntImpl_one();
      t2 = z1.compareTo$1(0, t1);
      if (t2 === 0)
        return _this._addPointsWithZ2EqualOne$6(x2, y2, z2, x1, y1, p);
      t1 = z2.compareTo$1(0, t1);
      if (t1 === 0)
        return _this._addPointsWithZ2EqualOne$6(x1, y1, z1, x2, y2, p);
      return _this._addPointsWithZNotEqual$7(x1, y1, z1, x2, y2, z2, p);
    },
    $add(_, other) {
      var t1, t2, t3, x1, y1, z1, x2, y2, result, x3, y3, z3, _this = this;
      if (_this.get$isInfinity())
        return other;
      if (other.get$isInfinity())
        return _this;
      t1 = _this.curve;
      if (!t1.$eq(0, other.curve))
        throw A.wrapException(B.ArgumentException_MYu);
      t2 = _this._ec_projective_point$_coords;
      t3 = t2.length;
      if (0 >= t3)
        return A.ioore(t2, 0);
      x1 = t2[0];
      if (1 >= t3)
        return A.ioore(t2, 1);
      y1 = t2[1];
      if (2 >= t3)
        return A.ioore(t2, 2);
      z1 = t2[2];
      t2 = other._ec_projective_point$_coords;
      t3 = t2.length;
      if (0 >= t3)
        return A.ioore(t2, 0);
      x2 = t2[0];
      if (1 >= t3)
        return A.ioore(t2, 1);
      y2 = t2[1];
      if (2 >= t3)
        return A.ioore(t2, 2);
      result = _this._addPoints$7(x1, y1, z1, x2, y2, t2[2], t1.p);
      x3 = result[0];
      y3 = result[1];
      z3 = result[2];
      t2 = $.$get$_BigIntImpl_zero();
      t3 = y3.compareTo$1(0, t2);
      if (t3 !== 0)
        t3 = z3.compareTo$1(0, t2) === 0;
      else
        t3 = true;
      if (t3)
        return new A.ProjectiveECCPoint(t1, null, false, B.List_empty3, A._setArrayType([t2, t2, t2], type$.JSArray_BigInt));
      return new A.ProjectiveECCPoint(t1, _this.order, false, B.List_empty3, A._setArrayType([x3, y3, z3], type$.JSArray_BigInt));
    },
    _multiplyWithPrecompute$1(scalar) {
      var resultY, i, t2, t3, x2, y2, t4, addResult, _this = this,
        resultX = $.$get$_BigIntImpl_zero(),
        resultZ = $.$get$_BigIntImpl_one(),
        t1 = _this.curve,
        primeField = t1.p,
        precompute = A.List_List$from(_this._precompute, true, type$.List_BigInt);
      for (resultY = resultX, i = 0; i < precompute.length; ++i) {
        t2 = precompute[i];
        t3 = J.getInterceptor$asx(t2);
        x2 = t3.$index(t2, 0);
        y2 = t3.$index(t2, 1);
        t2 = scalar._used !== 0;
        if (t2) {
          t3 = scalar._digits;
          if (0 >= t3.length)
            return A.ioore(t3, 0);
          t3 = (t3[0] & 1) === 0;
        } else
          t3 = true;
        if (!t3) {
          if (t2) {
            t3 = scalar._digits;
            if (0 >= t3.length)
              return A.ioore(t3, 0);
            t3 = (t3[0] & 1) === 0;
          } else
            t3 = true;
          if (!t3)
            if (t2) {
              t2 = scalar._digits;
              if (0 >= t2.length)
                return A.ioore(t2, 0);
              t2 = (t2[0] & 1) === 0;
            } else
              t2 = true;
          else
            t2 = false;
          if (t2) {
            t2 = $.$get$_BigIntImpl_one();
            t3 = scalar.$add(0, t2);
            t4 = $.$get$_BigIntImpl_two();
            if (t4._used === 0)
              A.throwExpression(B.C_IntegerDivisionByZeroException);
            scalar = t3._div$1(t4);
            addResult = _this._addPoints$7(resultX, resultY, resultZ, x2, y2.$negate(0), t2, primeField);
            resultX = addResult[0];
            resultY = addResult[1];
            resultZ = addResult[2];
          } else {
            t2 = $.$get$_BigIntImpl_one();
            t3 = scalar.$sub(0, t2);
            t4 = $.$get$_BigIntImpl_two();
            if (t4._used === 0)
              A.throwExpression(B.C_IntegerDivisionByZeroException);
            scalar = t3._div$1(t4);
            addResult = _this._addPoints$7(resultX, resultY, resultZ, x2, y2, t2, primeField);
            resultX = addResult[0];
            resultY = addResult[1];
            resultZ = addResult[2];
          }
        } else {
          t2 = $.$get$_BigIntImpl_two();
          if (t2._used === 0)
            A.throwExpression(B.C_IntegerDivisionByZeroException);
          scalar = scalar._div$1(t2);
        }
      }
      t2 = $.$get$_BigIntImpl_zero();
      t3 = resultY.compareTo$1(0, t2);
      if (t3 !== 0)
        t3 = resultZ.compareTo$1(0, t2) === 0;
      else
        t3 = true;
      if (t3)
        return new A.ProjectiveECCPoint(t1, null, false, B.List_empty3, A._setArrayType([t2, t2, t2], type$.JSArray_BigInt));
      return new A.ProjectiveECCPoint(t1, _this.order, false, B.List_empty3, A._setArrayType([resultX, resultY, resultZ], type$.JSArray_BigInt));
    },
    $mul(_, scalar) {
      var x3, z3, t2, t3, x2, y2, primeField, curveA, nafList, i, y3, x30, double, add, _this = this,
        t1 = _this._ec_projective_point$_coords;
      if (1 >= t1.length)
        return A.ioore(t1, 1);
      t1 = t1[1];
      x3 = $.$get$_BigIntImpl_zero();
      t1 = J.compareTo$1$ns(t1, x3);
      if (t1 !== 0)
        t1 = scalar.compareTo$1(0, x3) === 0;
      else
        t1 = true;
      if (t1)
        return new A.ProjectiveECCPoint(_this.curve, null, false, B.List_empty3, A._setArrayType([x3, x3, x3], type$.JSArray_BigInt));
      z3 = $.$get$_BigIntImpl_one();
      t1 = scalar.compareTo$1(0, z3);
      if (t1 === 0)
        return _this;
      t1 = _this.order;
      if (t1 != null)
        scalar = scalar.$mod(0, t1.$mul(0, $.$get$_BigIntImpl_two()));
      _this._precomputeIfNeeded$0();
      if (_this._precompute.length !== 0)
        return _this._multiplyWithPrecompute$1(scalar);
      _this.scale$0();
      t2 = _this._ec_projective_point$_coords;
      t3 = t2.length;
      if (0 >= t3)
        return A.ioore(t2, 0);
      x2 = t2[0];
      if (1 >= t3)
        return A.ioore(t2, 1);
      y2 = t2[1];
      t2 = _this.curve;
      primeField = t2.p;
      curveA = t2.a;
      nafList = A.BigintUtils_computeNAF(scalar);
      for (i = nafList.length - 1, y3 = x3, x30 = y3; i >= 0; --i) {
        double = _this._double$5(x30, y3, z3, primeField, curveA);
        x30 = double[0];
        y3 = double[1];
        z3 = double[2];
        if (!(i < nafList.length))
          return A.ioore(nafList, i);
        if (nafList[i].compareTo$1(0, x3) < 0) {
          add = _this._addPoints$7(x30, y3, z3, x2, y2.$negate(0), $.$get$_BigIntImpl_one(), primeField);
          x30 = add[0];
          y3 = add[1];
          z3 = add[2];
        } else {
          if (!(i < nafList.length))
            return A.ioore(nafList, i);
          if (nafList[i].compareTo$1(0, x3) > 0) {
            add = _this._addPoints$7(x30, y3, z3, x2, y2, $.$get$_BigIntImpl_one(), primeField);
            x30 = add[0];
            y3 = add[1];
            z3 = add[2];
          }
        }
      }
      t3 = y3.compareTo$1(0, x3);
      if (t3 !== 0)
        t3 = z3.compareTo$1(0, x3) === 0;
      else
        t3 = true;
      if (t3)
        return new A.ProjectiveECCPoint(t2, null, false, B.List_empty3, A._setArrayType([x3, x3, x3], type$.JSArray_BigInt));
      return new A.ProjectiveECCPoint(t2, t1, false, B.List_empty3, A._setArrayType([x30, y3, z3], type$.JSArray_BigInt));
    },
    get$hashCode(_) {
      return this.curve.get$hashCode(0) ^ this.get$x().get$hashCode(0) ^ this.get$y().get$hashCode(0);
    },
    set$_precompute(_precompute) {
      this._precompute = type$.List_List_BigInt._as(_precompute);
    },
    set$_ec_projective_point$_coords(_coords) {
      this._ec_projective_point$_coords = type$.List_BigInt._as(_coords);
    },
    get$curve() {
      return this.curve;
    }
  };
  A.EDPoint.prototype = {
    get$x() {
      var p,
        t1 = this._coords,
        x1 = t1[0],
        z1 = t1[2];
      t1 = z1.compareTo$1(0, $.$get$_BigIntImpl_one());
      if (t1 === 0)
        return x1;
      p = this.curve.p;
      return x1.$mul(0, A.BigintUtils_inverseMod(z1, p)).$mod(0, p);
    },
    get$y() {
      var p,
        t1 = this._coords,
        y1 = t1[1],
        z1 = t1[2];
      t1 = z1.compareTo$1(0, $.$get$_BigIntImpl_one());
      if (t1 === 0)
        return y1;
      p = this.curve.p;
      return y1.$mul(0, A.BigintUtils_inverseMod(z1, p)).$mod(0, p);
    },
    scale$0() {
      var x1, y1, p, zInv, x, y, t, _this = this,
        t1 = _this._coords,
        z1 = t1[2],
        t2 = $.$get$_BigIntImpl_one(),
        t3 = z1.compareTo$1(0, t2);
      if (t3 === 0)
        return _this;
      x1 = t1[0];
      y1 = t1[1];
      p = _this.curve.p;
      zInv = A.BigintUtils_inverseMod(z1, p);
      x = x1.$mul(0, zInv).$mod(0, p);
      y = y1.$mul(0, zInv).$mod(0, p);
      t = x.$mul(0, y).$mod(0, p);
      B.JSArray_methods.$indexSet(t1, 0, x);
      B.JSArray_methods.$indexSet(t1, 1, y);
      B.JSArray_methods.$indexSet(t1, 2, t2);
      B.JSArray_methods.$indexSet(t1, 3, t);
      return _this;
    },
    $eq(_, other) {
      var t1, otherCoords, t2, x1, y1, z1, t10, x2, y2, z2, t3, p, xn1, xn2, yn1, yn2;
      if (other == null)
        return false;
      if (other instanceof A.EDPoint) {
        t1 = other._coords;
        otherCoords = A.List_List$from(t1, true, type$.BigInt);
        t2 = this._coords;
        x1 = t2[0];
        y1 = t2[1];
        z1 = t2[2];
        t10 = t2[3];
        t2 = otherCoords.length;
        if (0 >= t2)
          return A.ioore(otherCoords, 0);
        x2 = otherCoords[0];
        if (1 >= t2)
          return A.ioore(otherCoords, 1);
        y2 = otherCoords[1];
        if (2 >= t2)
          return A.ioore(otherCoords, 2);
        z2 = otherCoords[2];
        t2 = t1[0];
        t3 = $.$get$_BigIntImpl_zero();
        t2 = t2.compareTo$1(0, t3);
        if (t2 === 0)
          t1 = t1[1].compareTo$1(0, t3) === 0;
        else
          t1 = false;
        if (t1) {
          t1 = $.$get$_BigIntImpl_zero();
          t2 = x1.compareTo$1(0, t1);
          if (t2 !== 0)
            t1 = t10.compareTo$1(0, t1) === 0;
          else
            t1 = true;
          return t1;
        }
        t1 = this.curve;
        if (!t1.$eq(0, other.curve))
          return false;
        p = t1.p;
        xn1 = x1.$mul(0, z2).$mod(0, p);
        xn2 = x2.$mul(0, z1).$mod(0, p);
        yn1 = y1.$mul(0, z2).$mod(0, p);
        yn2 = y2.$mul(0, z1).$mod(0, p);
        t1 = xn1.compareTo$1(0, xn2);
        if (t1 === 0)
          t1 = yn1.compareTo$1(0, yn2) === 0;
        else
          t1 = false;
        return t1;
      }
      return false;
    },
    get$hashCode(_) {
      return this.get$x().get$hashCode(0) ^ this.get$y().get$hashCode(0) ^ J.get$hashCode$(this.order);
    },
    get$curve() {
      return this.curve;
    }
  };
  A.RistrettoPoint.prototype = {};
  A.SquareRootError.prototype = {
    toString$0(_) {
      return this.message;
    },
    $isException: 1,
    $isBlockchainUtilsException: 1
  };
  A.JacobiError.prototype = {
    toString$0(_) {
      return this.message;
    },
    $isException: 1,
    $isBlockchainUtilsException: 1
  };
  A.ChaCha20Poly1305.prototype = {
    encrypt$3$associatedData(nonce, plaintext, associatedData) {
      var t2, counter, authKey, resultLength, result, calculatedTag,
        t1 = type$.List_int;
      t1._as(nonce);
      t1._as(plaintext);
      type$.nullable_List_int._as(associatedData);
      t1 = J.getInterceptor$asx(nonce);
      if (t1.get$length(nonce) > 16)
        throw A.wrapException(B.ArgumentException_1Sg);
      t2 = type$.int;
      counter = A.List_List$filled(16, 0, false, t2);
      B.JSArray_methods.setRange$3(counter, 16 - t1.get$length(nonce), 16, A.BytesUtils_toBytes(nonce, false));
      authKey = A.List_List$filled(32, 0, false, t2);
      t1 = this.__ChaCha20Poly1305__key_A;
      t1 === $ && A.throwLateFieldNI("_key");
      A.zero(authKey);
      A.ChaCha20_streamXOR(t1, counter, authKey, authKey, 4);
      resultLength = plaintext.length + 16;
      result = A.List_List$filled(resultLength, 0, false, t2);
      A.ChaCha20_streamXOR(this.__ChaCha20Poly1305__key_A, counter, A.BytesUtils_toBytes(plaintext, false), result, 4);
      calculatedTag = A.List_List$filled(16, 0, false, t2);
      t1 = resultLength - 16;
      this._authenticate$4(calculatedTag, authKey, B.JSArray_methods.sublist$2(result, 0, t1), associatedData);
      B.JSArray_methods.setRange$3(result, t1, resultLength, calculatedTag);
      A.zero(counter);
      return result;
    },
    encrypt$2(nonce, plaintext) {
      return this.encrypt$3$associatedData(nonce, plaintext, null);
    },
    decrypt$2(nonce, sealed) {
      var t2, counter, authKey, t3, calculatedTag, result,
        t1 = type$.List_int;
      t1._as(nonce);
      t1._as(sealed);
      if (nonce.length > 16)
        throw A.wrapException(B.ArgumentException_1Sg);
      t1 = J.getInterceptor$asx(sealed);
      if (t1.get$length(sealed) < 16)
        return null;
      t2 = type$.int;
      counter = A.List_List$filled(16, 0, false, t2);
      B.JSArray_methods.setRange$3(counter, 16 - nonce.length, 16, nonce);
      authKey = A.List_List$filled(32, 0, false, t2);
      t3 = this.__ChaCha20Poly1305__key_A;
      t3 === $ && A.throwLateFieldNI("_key");
      A.zero(authKey);
      A.ChaCha20_streamXOR(t3, counter, authKey, authKey, 4);
      calculatedTag = A.List_List$filled(16, 0, false, t2);
      this._authenticate$4(calculatedTag, authKey, t1.sublist$2(sealed, 0, t1.get$length(sealed) - 16), null);
      if (!A.BytesUtils_bytesEqual(calculatedTag, t1.sublist$1(sealed, t1.get$length(sealed) - 16)))
        return null;
      result = A.List_List$filled(t1.get$length(sealed) - 16, 0, false, t2);
      A.ChaCha20_streamXOR(this.__ChaCha20Poly1305__key_A, counter, t1.sublist$2(sealed, 0, t1.get$length(sealed) - 16), result, 4);
      A.zero(counter);
      return result;
    },
    _authenticate$4(tagOut, authKey, ciphertext, associatedData) {
      var t2, t3, t4, t5, h, t00, t10, t30, t50, t6, t7, $length, mac, i,
        t1 = type$.List_int;
      t1._as(tagOut);
      t1._as(authKey);
      t1._as(ciphertext);
      type$.nullable_List_int._as(associatedData);
      t1 = type$.int;
      t2 = A.List_List$filled(16, 0, false, t1);
      t3 = A.List_List$filled(10, 0, false, t1);
      t4 = A.List_List$filled(10, 0, false, t1);
      t5 = A.List_List$filled(8, 0, false, t1);
      h = new A.Poly1305(t2, t3, t4, t5);
      t00 = authKey[0] | authKey[1] << 8;
      B.JSArray_methods.$indexSet(t3, 0, t00 & 8191);
      t10 = authKey[2] | authKey[3] << 8;
      B.JSArray_methods.$indexSet(t3, 1, (t00 >>> 13 | t10 << 3) & 8191);
      t2 = authKey[4] | authKey[5] << 8;
      B.JSArray_methods.$indexSet(t3, 2, (t10 >>> 10 | t2 << 6) & 7939);
      t30 = authKey[6] | authKey[7] << 8;
      B.JSArray_methods.$indexSet(t3, 3, (t2 >>> 7 | t30 << 9) & 8191);
      t4 = authKey[8] | authKey[9] << 8;
      B.JSArray_methods.$indexSet(t3, 4, (t30 >>> 4 | t4 << 12) & 255);
      B.JSArray_methods.$indexSet(t3, 5, t4 >>> 1 & 8190);
      t50 = authKey[10] | authKey[11] << 8;
      B.JSArray_methods.$indexSet(t3, 6, (t4 >>> 14 | t50 << 2) & 8191);
      t6 = authKey[12] | authKey[13] << 8;
      B.JSArray_methods.$indexSet(t3, 7, (t50 >>> 11 | t6 << 5) & 8065);
      t7 = authKey[14] | authKey[15] << 8;
      B.JSArray_methods.$indexSet(t3, 8, (t6 >>> 8 | t7 << 8) & 8191);
      B.JSArray_methods.$indexSet(t3, 9, t7 >>> 5 & 127);
      B.JSArray_methods.$indexSet(t5, 0, (authKey[16] | authKey[17] << 8) >>> 0);
      B.JSArray_methods.$indexSet(t5, 1, (authKey[18] | authKey[19] << 8) >>> 0);
      B.JSArray_methods.$indexSet(t5, 2, (authKey[20] | authKey[21] << 8) >>> 0);
      B.JSArray_methods.$indexSet(t5, 3, (authKey[22] | authKey[23] << 8) >>> 0);
      B.JSArray_methods.$indexSet(t5, 4, (authKey[24] | authKey[25] << 8) >>> 0);
      B.JSArray_methods.$indexSet(t5, 5, (authKey[26] | authKey[27] << 8) >>> 0);
      B.JSArray_methods.$indexSet(t5, 6, (authKey[28] | authKey[29] << 8) >>> 0);
      B.JSArray_methods.$indexSet(t5, 7, (authKey[30] | authKey[31] << 8) >>> 0);
      t2 = associatedData != null;
      if (t2)
        h.update$1(associatedData);
      h.update$1(ciphertext);
      t4 = B.JSInt_methods.$mod(ciphertext.length, 16);
      if (t4 > 0)
        h.update$1(A.List_List$filled(16 - t4, 0, false, t1));
      $length = A.List_List$filled(8, 0, false, t1);
      if (t2)
        A.writeUint64LE(0, $length);
      h.update$1($length);
      A.writeUint64LE(ciphertext.length, $length);
      h.update$1($length);
      if (h._finished)
        A.throwExpression(B.MessageException_kKo);
      mac = A.List_List$filled(16, 0, false, t1);
      h.finish$1(mac);
      for (i = 0; i < 16; ++i)
        B.JSArray_methods.$indexSet(tagOut, i, mac[i]);
      A.zero(h._buffer);
      A.zero(t3);
      A.zero(h._h);
      A.zero(t5);
      h._fin = h._leftover = 0;
      h._finished = true;
      A.zero(mac);
      A.zero($length);
    },
    set$__ChaCha20Poly1305__key_A(__ChaCha20Poly1305__key_A) {
      this.__ChaCha20Poly1305__key_A = type$.List_int._as(__ChaCha20Poly1305__key_A);
    }
  };
  A.CTR.prototype = {
    setCipher$2(cipher, iv) {
      var t1, _this = this;
      type$.nullable_List_int._as(iv);
      _this._cipher = null;
      t1 = _this.__CTR__counter_F;
      t1 === $ && A.throwLateFieldNI("_counter");
      if (16 !== t1.length)
        throw A.wrapException(B.ArgumentException_oWp);
      _this._cipher = cipher;
      B.JSArray_methods.setAll$2(t1, 0, iv);
      t1 = _this.__CTR__buffer_F;
      t1 === $ && A.throwLateFieldNI("_buffer");
      _this._bufpos = t1.length;
      return _this;
    },
    streamXOR$2(src, dst) {
      var t2, i, t3, t4, t5, t6, t7, _this = this,
        t1 = type$.List_int;
      t1._as(src);
      t1._as(dst);
      for (t2 = type$.nullable_List_int, i = 0; i < 16; ++i) {
        t3 = _this._bufpos;
        t4 = _this.__CTR__buffer_F;
        t4 === $ && A.throwLateFieldNI("_buffer");
        t5 = t4.length;
        if (t3 === t5) {
          t3 = _this._cipher;
          t3.toString;
          t6 = _this.__CTR__counter_F;
          t6 === $ && A.throwLateFieldNI("_counter");
          t1._as(t6);
          t2._as(t4);
          if (t6.length !== 16)
            A.throwExpression(B.ArgumentException_o91);
          if (t5 !== 16)
            A.throwExpression(B.ArgumentException_Jwp);
          t3 = t3._encKey;
          if (t3 == null)
            A.throwExpression(B.MessageException_Q5s);
          t7 = $.$get$AES__lib();
          t3.toString;
          t7.encryptBlock$3(t3, t6, t4);
          _this._bufpos = 0;
          A._incrementCounter(t6);
        }
        t3 = src[i];
        t6 = _this._bufpos++;
        if (!(t6 < t5))
          return A.ioore(t4, t6);
        B.JSArray_methods.$indexSet(dst, i, t3 & 255 ^ t4[t6]);
      }
    },
    set$__CTR__counter_F(__CTR__counter_F) {
      this.__CTR__counter_F = type$.List_int._as(__CTR__counter_F);
    },
    set$__CTR__buffer_F(__CTR__buffer_F) {
      this.__CTR__buffer_F = type$.List_int._as(__CTR__buffer_F);
    }
  };
  A.BLAKE2b.prototype = {
    update$1(data) {
      var left, dataLength, t1, i, t2, t3, dataPos, _this = this;
      type$.List_int._as(data);
      if (_this._hash$_finished)
        throw A.wrapException(B.ArgumentException_deg);
      left = 128 - _this._bufferLength;
      dataLength = data.length;
      if (dataLength === 0)
        return _this;
      if (dataLength > left) {
        for (t1 = _this._hash$_buffer, i = 0; i < left; ++i) {
          t2 = _this._bufferLength;
          if (!(i < data.length))
            return A.ioore(data, i);
          t3 = data[i];
          if (typeof t3 !== "number")
            return t3.$and();
          B.JSArray_methods.$indexSet(t1, t2 + i, t3 & 255);
        }
        _this._processBlock$1(128);
        dataLength -= left;
        _this._bufferLength = 0;
        dataPos = left;
      } else
        dataPos = 0;
      for (t1 = _this._hash$_buffer; dataLength > 128;) {
        for (i = 0; i < 128; ++i) {
          t2 = dataPos + i;
          if (!(t2 >= 0 && t2 < data.length))
            return A.ioore(data, t2);
          t2 = data[t2];
          if (typeof t2 !== "number")
            return t2.$and();
          B.JSArray_methods.$indexSet(t1, i, t2 & 255);
        }
        _this._processBlock$1(128);
        dataPos += 128;
        dataLength -= 128;
        _this._bufferLength = 0;
      }
      for (i = 0; i < dataLength; ++i) {
        t2 = _this._bufferLength;
        t3 = dataPos + i;
        if (!(t3 >= 0 && t3 < data.length))
          return A.ioore(data, t3);
        t3 = data[t3];
        if (typeof t3 !== "number")
          return t3.$and();
        B.JSArray_methods.$indexSet(t1, t2 + i, t3 & 255);
      }
      _this._bufferLength += dataLength;
      return _this;
    },
    finish$1(out) {
      var i, t1, tmp, t2, _this = this, _4294967295 = 4294967295;
      type$.List_int._as(out);
      if (!_this._hash$_finished) {
        for (i = _this._bufferLength, t1 = _this._hash$_buffer; i < 128; ++i)
          B.JSArray_methods.$indexSet(t1, i, 0);
        t1 = _this._flag;
        B.JSArray_methods.$indexSet(t1, 0, _4294967295);
        B.JSArray_methods.$indexSet(t1, 1, _4294967295);
        _this._processBlock$1(_this._bufferLength);
        _this._hash$_finished = true;
      }
      tmp = A.List_List$filled(64, 0, false, type$.int);
      for (t1 = _this._hash$_state, t2 = t1.length, i = 0; i < 16; ++i) {
        if (!(i < t2))
          return A.ioore(t1, i);
        A.writeUint32LE(t1[i], tmp, i * 4);
      }
      B.JSArray_methods.setRange$3(out, 0, out.length, tmp);
      return _this;
    },
    _g$13(v, al, bl, cl, dl, ah, bh, ch, dh, ml0, mh0, ml1, mh1) {
      var vla, vha, vlb, vhb, vlc, vhc, vld, vhd, t1, t2, w, x, y, w0, vld0, w1;
      type$.List_int._as(v);
      if (!(al < 32))
        return A.ioore(v, al);
      vla = v[al];
      if (!(ah < 32))
        return A.ioore(v, ah);
      vha = v[ah];
      if (!(bl < 32))
        return A.ioore(v, bl);
      vlb = v[bl];
      if (!(bh < 32))
        return A.ioore(v, bh);
      vhb = v[bh];
      if (!(cl < 32))
        return A.ioore(v, cl);
      vlc = v[cl];
      if (!(ch < 32))
        return A.ioore(v, ch);
      vhc = v[ch];
      if (!(dl < 32))
        return A.ioore(v, dl);
      vld = v[dl];
      if (!(dh < 32))
        return A.ioore(v, dh);
      vhd = v[dh];
      t1 = B.JSInt_methods._shrOtherPositive$1(vla, 16);
      t2 = B.JSInt_methods._shrOtherPositive$1(vha, 16);
      w = (vla & 65535) + (vlb & 65535);
      x = (t1 & 65535) + (B.JSInt_methods._shrOtherPositive$1(vlb, 16) & 65535) + (w >>> 16 & 65535);
      y = (vha & 65535) + (vhb & 65535) + (x >>> 16 & 65535);
      vha = y & 65535 | (t2 & 65535) + (B.JSInt_methods._shrOtherPositive$1(vhb, 16) & 65535) + (y >>> 16 & 65535) << 16;
      vla = w & 65535 | x << 16;
      w = (vla & 65535) + (ml0 & 65535);
      x = (vla >>> 16 & 65535) + (ml0 >>> 16 & 65535) + (w >>> 16 & 65535);
      y = (vha & 65535) + (mh0 & 65535) + (x >>> 16 & 65535);
      vha = y & 65535 | (vha >>> 16 & 65535) + (mh0 >>> 16 & 65535) + (y >>> 16 & 65535) << 16;
      vla = w & 65535 | x << 16;
      vld ^= vla;
      vhd ^= vha;
      w = (vlc & 65535) + (vhd & 65535);
      x = (B.JSInt_methods._shrOtherPositive$1(vlc, 16) & 65535) + (vhd >>> 16 & 65535) + (w >>> 16 & 65535);
      y = (vhc & 65535) + (vld & 65535) + (x >>> 16 & 65535);
      vhc = y & 65535 | (B.JSInt_methods._shrOtherPositive$1(vhc, 16) & 65535) + (vld >>> 16 & 65535) + (y >>> 16 & 65535) << 16;
      vlc = w & 65535 | x << 16;
      vlb ^= vlc;
      vhb ^= vhc;
      w = vlb << 8 | vhb >>> 24;
      vlb = vhb << 8 | vlb >>> 24;
      w0 = (vla & 65535) + (vlb & 65535);
      x = (vla >>> 16 & 65535) + (vlb >>> 16 & 65535) + (w0 >>> 16 & 65535);
      y = (vha & 65535) + (w & 65535) + (x >>> 16 & 65535);
      vha = y & 65535 | (vha >>> 16 & 65535) + (w >>> 16 & 65535) + (y >>> 16 & 65535) << 16;
      vla = w0 & 65535 | x << 16;
      w0 = (vla & 65535) + (ml1 & 65535);
      x = (vla >>> 16 & 65535) + (ml1 >>> 16 & 65535) + (w0 >>> 16 & 65535);
      y = (vha & 65535) + (mh1 & 65535) + (x >>> 16 & 65535);
      vha = (y & 65535 | (vha >>> 16 & 65535) + (mh1 >>> 16 & 65535) + (y >>> 16 & 65535) << 16) >>> 0;
      vla = (w0 & 65535 | x << 16) >>> 0;
      vld0 = vhd ^ vla;
      vhd = vld ^ vha;
      w0 = (vld0 << 16 | vhd >>> 16) >>> 0;
      vld = (vhd << 16 | vld0 >>> 16) >>> 0;
      w1 = (vlc & 65535) + (vld & 65535);
      x = (vlc >>> 16 & 65535) + (vld >>> 16 & 65535) + (w1 >>> 16 & 65535);
      y = (vhc & 65535) + (w0 & 65535) + (x >>> 16 & 65535);
      vhc = (y & 65535 | (vhc >>> 16 & 65535) + (w0 >>> 16 & 65535) + (y >>> 16 & 65535) << 16) >>> 0;
      vlc = (w1 & 65535 | x << 16) >>> 0;
      vlb ^= vlc;
      vhb = w ^ vhc;
      B.JSArray_methods.$indexSet(v, al, vla);
      B.JSArray_methods.$indexSet(v, ah, vha);
      B.JSArray_methods.$indexSet(v, bl, (vlb << 1 | vhb >>> 31) >>> 0);
      B.JSArray_methods.$indexSet(v, bh, (vhb << 1 | vlb >>> 31) >>> 0);
      B.JSArray_methods.$indexSet(v, cl, vlc);
      B.JSArray_methods.$indexSet(v, ch, vhc);
      B.JSArray_methods.$indexSet(v, dl, vld);
      B.JSArray_methods.$indexSet(v, dh, w0);
    },
    _processBlock$1($length) {
      var v, t1, t2, t3, t4, m, i, r, t5, _this = this;
      _this._incrementCounter$1($length);
      v = _this._vtmp;
      t1 = _this._hash$_state;
      B.JSArray_methods.setAll$2(v, 0, t1);
      B.JSArray_methods.setAll$2(v, 16, $.$get$_iv());
      t2 = v[24];
      t3 = _this._ctr;
      t4 = t3[0];
      if (typeof t2 !== "number")
        return t2.$xor();
      B.JSArray_methods.$indexSet(v, 24, (t2 ^ t4) >>> 0);
      t4 = v[25];
      t2 = t3[1];
      if (typeof t4 !== "number")
        return t4.$xor();
      B.JSArray_methods.$indexSet(v, 25, (t4 ^ t2) >>> 0);
      t2 = v[26];
      t4 = t3[2];
      if (typeof t2 !== "number")
        return t2.$xor();
      B.JSArray_methods.$indexSet(v, 26, (t2 ^ t4) >>> 0);
      t4 = v[27];
      t3 = t3[3];
      if (typeof t4 !== "number")
        return t4.$xor();
      B.JSArray_methods.$indexSet(v, 27, (t4 ^ t3) >>> 0);
      t3 = v[28];
      t4 = _this._flag;
      t2 = t4[0];
      if (typeof t3 !== "number")
        return t3.$xor();
      B.JSArray_methods.$indexSet(v, 28, (t3 ^ t2) >>> 0);
      t2 = v[29];
      t3 = t4[1];
      if (typeof t2 !== "number")
        return t2.$xor();
      B.JSArray_methods.$indexSet(v, 29, (t2 ^ t3) >>> 0);
      t3 = v[30];
      t2 = t4[2];
      if (typeof t3 !== "number")
        return t3.$xor();
      B.JSArray_methods.$indexSet(v, 30, (t3 ^ t2) >>> 0);
      t2 = v[31];
      t4 = t4[3];
      if (typeof t2 !== "number")
        return t2.$xor();
      B.JSArray_methods.$indexSet(v, 31, (t2 ^ t4) >>> 0);
      m = _this._mtmp;
      for (t2 = _this._hash$_buffer, i = 0; i < 32; ++i)
        B.JSArray_methods.$indexSet(m, i, A.readUint32LE(t2, i * 4));
      for (r = 0; r < 12; ++r) {
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t2 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 0));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t3 = J.$index$asx($._sigma[r], 0);
        if (typeof t3 !== "number")
          return t3.$add();
        t3 = B.JSArray_methods.$index(m, t3 + 1);
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t4 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 1));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t5 = J.$index$asx($._sigma[r], 1);
        if (typeof t5 !== "number")
          return t5.$add();
        _this._g$13(v, 0, 8, 16, 24, 1, 9, 17, 25, t2, t3, t4, B.JSArray_methods.$index(m, t5 + 1));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t5 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 2));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t4 = J.$index$asx($._sigma[r], 2);
        if (typeof t4 !== "number")
          return t4.$add();
        t4 = B.JSArray_methods.$index(m, t4 + 1);
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t3 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 3));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t2 = J.$index$asx($._sigma[r], 3);
        if (typeof t2 !== "number")
          return t2.$add();
        _this._g$13(v, 2, 10, 18, 26, 3, 11, 19, 27, t5, t4, t3, B.JSArray_methods.$index(m, t2 + 1));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t2 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 4));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t3 = J.$index$asx($._sigma[r], 4);
        if (typeof t3 !== "number")
          return t3.$add();
        t3 = B.JSArray_methods.$index(m, t3 + 1);
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t4 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 5));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t5 = J.$index$asx($._sigma[r], 5);
        if (typeof t5 !== "number")
          return t5.$add();
        _this._g$13(v, 4, 12, 20, 28, 5, 13, 21, 29, t2, t3, t4, B.JSArray_methods.$index(m, t5 + 1));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t5 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 6));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t4 = J.$index$asx($._sigma[r], 6);
        if (typeof t4 !== "number")
          return t4.$add();
        t4 = B.JSArray_methods.$index(m, t4 + 1);
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t3 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 7));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t2 = J.$index$asx($._sigma[r], 7);
        if (typeof t2 !== "number")
          return t2.$add();
        _this._g$13(v, 6, 14, 22, 30, 7, 15, 23, 31, t5, t4, t3, B.JSArray_methods.$index(m, t2 + 1));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t2 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 8));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t3 = J.$index$asx($._sigma[r], 8);
        if (typeof t3 !== "number")
          return t3.$add();
        t3 = B.JSArray_methods.$index(m, t3 + 1);
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t4 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 9));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t5 = J.$index$asx($._sigma[r], 9);
        if (typeof t5 !== "number")
          return t5.$add();
        _this._g$13(v, 0, 10, 20, 30, 1, 11, 21, 31, t2, t3, t4, B.JSArray_methods.$index(m, t5 + 1));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t5 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 10));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t4 = J.$index$asx($._sigma[r], 10);
        if (typeof t4 !== "number")
          return t4.$add();
        t4 = B.JSArray_methods.$index(m, t4 + 1);
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t3 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 11));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t2 = J.$index$asx($._sigma[r], 11);
        if (typeof t2 !== "number")
          return t2.$add();
        _this._g$13(v, 2, 12, 22, 24, 3, 13, 23, 25, t5, t4, t3, B.JSArray_methods.$index(m, t2 + 1));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t2 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 12));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t3 = J.$index$asx($._sigma[r], 12);
        if (typeof t3 !== "number")
          return t3.$add();
        t3 = B.JSArray_methods.$index(m, t3 + 1);
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t4 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 13));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t5 = J.$index$asx($._sigma[r], 13);
        if (typeof t5 !== "number")
          return t5.$add();
        _this._g$13(v, 4, 14, 16, 26, 5, 15, 17, 27, t2, t3, t4, B.JSArray_methods.$index(m, t5 + 1));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t5 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 14));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t4 = J.$index$asx($._sigma[r], 14);
        if (typeof t4 !== "number")
          return t4.$add();
        t4 = B.JSArray_methods.$index(m, t4 + 1);
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t3 = B.JSArray_methods.$index(m, J.$index$asx($._sigma[r], 15));
        if (!(r < $._sigma.length))
          return A.ioore($._sigma, r);
        t2 = J.$index$asx($._sigma[r], 15);
        if (typeof t2 !== "number")
          return t2.$add();
        _this._g$13(v, 6, 8, 18, 28, 7, 9, 19, 29, t5, t4, t3, B.JSArray_methods.$index(m, t2 + 1));
      }
      for (t2 = t1.length, i = 0; i < 16; ++i) {
        if (!(i < t2))
          return A.ioore(t1, i);
        t3 = t1[i];
        t4 = v[i];
        t5 = v[i + 16];
        if (typeof t4 !== "number")
          return t4.$xor();
        if (typeof t5 !== "number")
          return A.iae(t5);
        if (typeof t3 !== "number")
          return t3.$xor();
        B.JSArray_methods.$indexSet(t1, i, (t3 ^ t4 ^ t5) >>> 0);
      }
    },
    _incrementCounter$1($length) {
      var t1, i, a;
      for (t1 = this._ctr, i = 0; i < 3; ++i, $length = 1) {
        a = t1[i] + $length;
        B.JSArray_methods.$indexSet(t1, i, a >>> 0);
        if (t1[i] === a)
          return;
      }
    },
    set$__BLAKE2b__initialState_A(__BLAKE2b__initialState_A) {
      this.__BLAKE2b__initialState_A = type$.List_int._as(__BLAKE2b__initialState_A);
    }
  };
  A._Keccack.prototype = {
    _Keccack$1(capacity) {
      if (capacity <= 0 || capacity > 128)
        throw A.wrapException(B.ArgumentException_sav);
      this.___Keccack_blockSize_F !== $ && A.throwLateFieldAI("blockSize");
      this.___Keccack_blockSize_F = 200 - capacity;
    },
    reset$0() {
      var _this = this;
      A.zero(_this._sh);
      A.zero(_this._sl);
      A.zero(_this._hash$_state);
      _this._pos = 0;
      _this._hash$_finished = false;
      return _this;
    },
    update$1(data) {
      var t1, t2, t3, t4, i, t5, t6, t7, _this = this;
      type$.List_int._as(data);
      if (_this._hash$_finished)
        throw A.wrapException(B.MessageException_GVQ);
      for (t1 = J.getInterceptor$asx(data), t2 = _this._hash$_state, t3 = _this._sh, t4 = _this._sl, i = 0; i < t1.get$length(data); ++i) {
        t5 = _this._pos++;
        if (!(t5 < 200))
          return A.ioore(t2, t5);
        t6 = t2[t5];
        t7 = t1.$index(data, i);
        if (typeof t7 !== "number")
          return t7.$and();
        B.JSArray_methods.$indexSet(t2, t5, t6 ^ t7 & 255);
        t5 = _this._pos;
        t6 = _this.___Keccack_blockSize_F;
        t6 === $ && A.throwLateFieldNI("blockSize");
        if (t5 >= t6) {
          A._keccakf(t3, t4, t2);
          _this._pos = 0;
        }
      }
      return _this;
    },
    _padAndPermute$1(paddingByte) {
      var _this = this,
        t1 = _this._hash$_state,
        t2 = _this._pos;
      if (!(t2 < 200))
        return A.ioore(t1, t2);
      B.JSArray_methods.$indexSet(t1, t2, t1[t2] ^ paddingByte);
      t2 = _this.___Keccack_blockSize_F;
      t2 === $ && A.throwLateFieldNI("blockSize");
      --t2;
      if (!(t2 >= 0 && t2 < 200))
        return A.ioore(t1, t2);
      B.JSArray_methods.$indexSet(t1, t2, t1[t2] ^ 128);
      A._keccakf(_this._sh, _this._sl, t1);
      _this._hash$_finished = true;
      _this._pos = 0;
    },
    _squeeze$1(dst) {
      var t1, t2, t3, t4, i, t5, t6, _this = this;
      type$.List_int._as(dst);
      if (!_this._hash$_finished)
        throw A.wrapException(B.MessageException_66y);
      for (t1 = dst.length, t2 = _this._hash$_state, t3 = _this._sh, t4 = _this._sl, i = 0; i < t1; ++i) {
        t5 = _this._pos;
        t6 = _this.___Keccack_blockSize_F;
        t6 === $ && A.throwLateFieldNI("blockSize");
        if (t5 === t6) {
          A._keccakf(t3, t4, t2);
          t5 = _this._pos = 0;
        }
        _this._pos = t5 + 1;
        if (!(t5 < 200))
          return A.ioore(t2, t5);
        B.JSArray_methods.$indexSet(dst, i, t2[t5]);
      }
    }
  };
  A.Keccack.prototype = {
    reset$0() {
      this.super$_Keccack$reset();
      return this;
    }
  };
  A.SHA3.prototype = {
    reset$0() {
      this.super$_Keccack$reset();
      return this;
    }
  };
  A.SHA3256.prototype = {};
  A.SHAKE.prototype = {
    reset$0() {
      this.super$_Keccack$reset();
      return this;
    }
  };
  A.SHAKE256.prototype = {};
  A.RIPEMD160.prototype = {};
  A._RIPEMD.prototype = {
    finish$1(out) {
      var i, t1, _this = this;
      type$.List_int._as(out);
      if (!_this._hash$_finished) {
        _this._finalize$0();
        _this._iterate$0();
        _this._hash$_finished = true;
      }
      i = 0;
      while (true) {
        t1 = _this.___RIPEMD__state_F;
        t1 === $ && A.throwLateFieldNI("_state");
        if (!(i < t1.length))
          break;
        A.writeUint32LE(t1[i], out, i * 4);
        ++i;
      }
      return _this;
    },
    _finalize$0() {
      var contentsLength, t2, i, lengthInBits, offset, highBits,
        t1 = this._hash$_buffer;
      B.JSArray_methods.add$1(t1, 128);
      contentsLength = this._lengthInBytes + 1 + 8;
      for (t2 = ((contentsLength + 64 - 1 & -64) >>> 0) - contentsLength, i = 0; i < t2; ++i)
        B.JSArray_methods.add$1(t1, 0);
      lengthInBits = this._lengthInBytes * 8;
      offset = t1.length;
      B.JSArray_methods.addAll$1(t1, A.List_List$filled(8, 0, false, type$.int));
      highBits = B.JSInt_methods._tdivFast$1(lengthInBits, 4294967296);
      A.writeUint32LE(lengthInBits >>> 0, t1, offset);
      A.writeUint32LE(highBits, t1, offset + 4);
    },
    reset$0() {
      var _this = this,
        t1 = _this.___RIPEMD__state_F;
      t1 === $ && A.throwLateFieldNI("_state");
      B.JSArray_methods.setAll$2(t1, 0, A._RidempUtils_readState(t1.length * 4));
      _this._hash$_finished = false;
      _this._lengthInBytes = 0;
      return _this;
    },
    _iterate$0() {
      var t2, i, t3, j,
        t1 = this._hash$_buffer,
        pendingDataChunks = t1.length / 64 | 0;
      for (t2 = this._currentChunk, i = 0; i < pendingDataChunks; ++i) {
        for (t3 = i * 64, j = 0; j < 16; ++j)
          B.JSArray_methods.$indexSet(t2, j, A.readUint32LE(t1, t3 + j * 4));
        this._proccess$1(t2);
      }
      B.JSArray_methods.removeRange$2(t1, 0, pendingDataChunks * 64);
    },
    _proccess$1(chunk) {
      var t1, _this = this;
      type$.List_int._as(chunk);
      t1 = _this.___RIPEMD__state_F;
      t1 === $ && A.throwLateFieldNI("_state");
      switch (t1.length * 4) {
        case 16:
          return _this._proccess128$1(chunk);
        case 20:
          return _this._proccess160$1(chunk);
        case 32:
          return _this._proccess256$1(chunk);
        default:
          return _this._proccess320$1(chunk);
      }
    },
    _proccess128$1(chunk) {
      var t1, t2, al, bl, cl, dl, dr, cr, br, ar, cl0, bl0, i, t, modShift;
      type$.List_int._as(chunk);
      t1 = this.___RIPEMD__state_F;
      t1 === $ && A.throwLateFieldNI("_state");
      t2 = t1.length;
      if (0 >= t2)
        return A.ioore(t1, 0);
      al = t1[0];
      if (1 >= t2)
        return A.ioore(t1, 1);
      bl = t1[1];
      if (2 >= t2)
        return A.ioore(t1, 2);
      cl = t1[2];
      if (3 >= t2)
        return A.ioore(t1, 3);
      dl = t1[3];
      for (dr = dl, cr = cl, br = bl, ar = al, cl0 = cr, bl0 = br, i = 0; i < 64; ++i, ar = dr, dr = cr, cr = br, br = t2, al = dl, dl = cl0, cl0 = bl0, bl0 = t) {
        t2 = B.List_Vul[i];
        if (!(t2 < 16))
          return A.ioore(chunk, t2);
        t = (al + chunk[t2] >>> 0) + A._RidempUtils_T(i, bl0, cl0, dl) >>> 0;
        modShift = B.List_Vul0[i] & 31;
        t = (t << modShift | B.JSInt_methods._shrReceiverPositive$1(t, 32 - modShift)) >>> 0;
        t2 = B.List_Vul1[i];
        if (!(t2 < 16))
          return A.ioore(chunk, t2);
        t2 = (ar + chunk[t2] >>> 0) + A._RidempUtils_t64(i, br, cr, dr) >>> 0;
        modShift = B.List_Vul2[i] & 31;
        t2 = (t2 << modShift | B.JSInt_methods._shrReceiverPositive$1(t2, 32 - modShift)) >>> 0;
      }
      B.JSArray_methods.$indexSet(t1, 1, (cl + dl >>> 0) + ar >>> 0);
      if (3 >= t1.length)
        return A.ioore(t1, 3);
      B.JSArray_methods.$indexSet(t1, 2, (t1[3] + al >>> 0) + br >>> 0);
      if (0 >= t1.length)
        return A.ioore(t1, 0);
      B.JSArray_methods.$indexSet(t1, 3, (t1[0] + bl0 >>> 0) + cr >>> 0);
      B.JSArray_methods.$indexSet(t1, 0, (bl + cl0 >>> 0) + dr >>> 0);
    },
    _proccess320$1(chunk) {
      var t1, t2, al, bl, cl, dl, el, ar, br, cr, dr, er, al0, i, t, modShift, dl0, dr0;
      type$.List_int._as(chunk);
      t1 = this.___RIPEMD__state_F;
      t1 === $ && A.throwLateFieldNI("_state");
      t2 = t1.length;
      if (0 >= t2)
        return A.ioore(t1, 0);
      al = t1[0];
      if (1 >= t2)
        return A.ioore(t1, 1);
      bl = t1[1];
      if (2 >= t2)
        return A.ioore(t1, 2);
      cl = t1[2];
      if (3 >= t2)
        return A.ioore(t1, 3);
      dl = t1[3];
      if (4 >= t2)
        return A.ioore(t1, 4);
      el = t1[4];
      if (5 >= t2)
        return A.ioore(t1, 5);
      ar = t1[5];
      if (6 >= t2)
        return A.ioore(t1, 6);
      br = t1[6];
      if (7 >= t2)
        return A.ioore(t1, 7);
      cr = t1[7];
      if (8 >= t2)
        return A.ioore(t1, 8);
      dr = t1[8];
      if (9 >= t2)
        return A.ioore(t1, 9);
      er = t1[9];
      for (al0 = al, i = 0; i < 80; ++i) {
        t2 = B.List_Vul[i];
        if (!(t2 < 16))
          return A.ioore(chunk, t2);
        t = (al0 + chunk[t2] >>> 0) + A._RidempUtils_T(i, bl, cl, dl) >>> 0;
        modShift = B.List_Vul0[i] & 31;
        t = ((t << modShift | B.JSInt_methods._shrReceiverPositive$1(t, 32 - modShift)) >>> 0) + el >>> 0;
        dl0 = (cl << 10 | cl >>> 0 >>> 22) >>> 0;
        t2 = B.List_Vul1[i];
        if (!(t2 < 16))
          return A.ioore(chunk, t2);
        t2 = (ar + chunk[t2] >>> 0) + A._RidempUtils_t80(i, br, cr, dr) >>> 0;
        modShift = B.List_Vul2[i] & 31;
        t2 = ((t2 << modShift | B.JSInt_methods._shrReceiverPositive$1(t2, 32 - modShift)) >>> 0) + er >>> 0;
        dr0 = (cr << 10 | cr >>> 0 >>> 22) >>> 0;
        switch (i) {
          case 15:
            cr = br;
            br = t;
            ar = er;
            er = dr;
            dr = dr0;
            cl = bl;
            bl = t2;
            al0 = el;
            el = dl;
            dl = dl0;
            break;
          case 31:
            cr = br;
            br = t2;
            ar = er;
            er = dr;
            dr = dl0;
            cl = bl;
            bl = t;
            al0 = el;
            el = dl;
            dl = dr0;
            break;
          case 47:
            cr = br;
            br = t2;
            ar = el;
            el = dl;
            dl = dl0;
            cl = bl;
            bl = t;
            al0 = er;
            er = dr;
            dr = dr0;
            break;
          case 63:
            cr = bl;
            bl = t;
            ar = er;
            er = dr;
            dr = dr0;
            cl = br;
            br = t2;
            al0 = el;
            el = dl;
            dl = dl0;
            break;
          case 79:
            cr = br;
            br = t2;
            ar = er;
            er = dl;
            dl = dl0;
            cl = bl;
            bl = t;
            al0 = el;
            el = dr;
            dr = dr0;
            break;
          default:
            cr = br;
            br = t2;
            ar = er;
            er = dr;
            dr = dr0;
            cl = bl;
            bl = t;
            al0 = el;
            el = dl;
            dl = dl0;
        }
      }
      B.JSArray_methods.$indexSet(t1, 0, al + al0 >>> 0);
      if (1 >= t1.length)
        return A.ioore(t1, 1);
      B.JSArray_methods.$indexSet(t1, 1, t1[1] + bl >>> 0);
      if (2 >= t1.length)
        return A.ioore(t1, 2);
      B.JSArray_methods.$indexSet(t1, 2, t1[2] + cl >>> 0);
      if (3 >= t1.length)
        return A.ioore(t1, 3);
      B.JSArray_methods.$indexSet(t1, 3, t1[3] + dl >>> 0);
      if (4 >= t1.length)
        return A.ioore(t1, 4);
      B.JSArray_methods.$indexSet(t1, 4, t1[4] + el >>> 0);
      if (5 >= t1.length)
        return A.ioore(t1, 5);
      B.JSArray_methods.$indexSet(t1, 5, t1[5] + ar >>> 0);
      if (6 >= t1.length)
        return A.ioore(t1, 6);
      B.JSArray_methods.$indexSet(t1, 6, t1[6] + br >>> 0);
      if (7 >= t1.length)
        return A.ioore(t1, 7);
      B.JSArray_methods.$indexSet(t1, 7, t1[7] + cr >>> 0);
      if (8 >= t1.length)
        return A.ioore(t1, 8);
      B.JSArray_methods.$indexSet(t1, 8, t1[8] + dr >>> 0);
      if (9 >= t1.length)
        return A.ioore(t1, 9);
      B.JSArray_methods.$indexSet(t1, 9, t1[9] + er >>> 0);
    },
    _proccess256$1(chunk) {
      var t1, t2, al, bl, cl, dl, ar, br, cr, dr, al0, i, t, modShift;
      type$.List_int._as(chunk);
      t1 = this.___RIPEMD__state_F;
      t1 === $ && A.throwLateFieldNI("_state");
      t2 = t1.length;
      if (0 >= t2)
        return A.ioore(t1, 0);
      al = t1[0];
      if (1 >= t2)
        return A.ioore(t1, 1);
      bl = t1[1];
      if (2 >= t2)
        return A.ioore(t1, 2);
      cl = t1[2];
      if (3 >= t2)
        return A.ioore(t1, 3);
      dl = t1[3];
      if (4 >= t2)
        return A.ioore(t1, 4);
      ar = t1[4];
      if (5 >= t2)
        return A.ioore(t1, 5);
      br = t1[5];
      if (6 >= t2)
        return A.ioore(t1, 6);
      cr = t1[6];
      if (7 >= t2)
        return A.ioore(t1, 7);
      dr = t1[7];
      for (al0 = al, i = 0; i < 64; ++i) {
        t2 = B.List_Vul[i];
        if (!(t2 < 16))
          return A.ioore(chunk, t2);
        t = (al0 + chunk[t2] >>> 0) + A._RidempUtils_T(i, bl, cl, dl) >>> 0;
        modShift = B.List_Vul0[i] & 31;
        t = (t << modShift | B.JSInt_methods._shrReceiverPositive$1(t, 32 - modShift)) >>> 0;
        t2 = B.List_Vul1[i];
        if (!(t2 < 16))
          return A.ioore(chunk, t2);
        t2 = (ar + chunk[t2] >>> 0) + A._RidempUtils_t64(i, br, cr, dr) >>> 0;
        modShift = B.List_Vul2[i] & 31;
        t2 = (t2 << modShift | B.JSInt_methods._shrReceiverPositive$1(t2, 32 - modShift)) >>> 0;
        switch (i) {
          case 15:
            ar = dl;
            dl = cl;
            cl = bl;
            bl = t;
            al0 = dr;
            dr = cr;
            cr = br;
            br = t2;
            break;
          case 31:
            ar = dr;
            dr = cr;
            cr = br;
            br = t;
            al0 = dl;
            dl = cl;
            cl = bl;
            bl = t2;
            break;
          case 47:
            ar = dr;
            dr = cr;
            cr = bl;
            bl = t;
            al0 = dl;
            dl = cl;
            cl = br;
            br = t2;
            break;
          case 63:
            ar = dr;
            dr = cl;
            cl = bl;
            bl = t;
            al0 = dl;
            dl = cr;
            cr = br;
            br = t2;
            break;
          default:
            ar = dr;
            dr = cr;
            cr = br;
            br = t2;
            al0 = dl;
            dl = cl;
            cl = bl;
            bl = t;
        }
      }
      B.JSArray_methods.$indexSet(t1, 0, al + al0 >>> 0);
      if (1 >= t1.length)
        return A.ioore(t1, 1);
      B.JSArray_methods.$indexSet(t1, 1, t1[1] + bl >>> 0);
      if (2 >= t1.length)
        return A.ioore(t1, 2);
      B.JSArray_methods.$indexSet(t1, 2, t1[2] + cl >>> 0);
      if (3 >= t1.length)
        return A.ioore(t1, 3);
      B.JSArray_methods.$indexSet(t1, 3, t1[3] + dl >>> 0);
      if (4 >= t1.length)
        return A.ioore(t1, 4);
      B.JSArray_methods.$indexSet(t1, 4, t1[4] + ar >>> 0);
      if (5 >= t1.length)
        return A.ioore(t1, 5);
      B.JSArray_methods.$indexSet(t1, 5, t1[5] + br >>> 0);
      if (6 >= t1.length)
        return A.ioore(t1, 6);
      B.JSArray_methods.$indexSet(t1, 6, t1[6] + cr >>> 0);
      if (7 >= t1.length)
        return A.ioore(t1, 7);
      B.JSArray_methods.$indexSet(t1, 7, t1[7] + dr >>> 0);
    },
    _proccess160$1(chunk) {
      var t1, t2, al, bl, cl, dl, el, er, dr, cr, br, ar, cl0, bl0, i, t, modShift, dl0, dr0;
      type$.List_int._as(chunk);
      t1 = this.___RIPEMD__state_F;
      t1 === $ && A.throwLateFieldNI("_state");
      t2 = t1.length;
      if (0 >= t2)
        return A.ioore(t1, 0);
      al = t1[0];
      if (1 >= t2)
        return A.ioore(t1, 1);
      bl = t1[1];
      if (2 >= t2)
        return A.ioore(t1, 2);
      cl = t1[2];
      if (3 >= t2)
        return A.ioore(t1, 3);
      dl = t1[3];
      if (4 >= t2)
        return A.ioore(t1, 4);
      el = t1[4];
      for (er = el, dr = dl, cr = cl, br = bl, ar = al, cl0 = cr, bl0 = br, i = 0; i < 80; ++i, cr = br, br = t2, ar = er, er = dr, dr = dr0, cl0 = bl0, bl0 = t, al = el, el = dl, dl = dl0) {
        t2 = B.List_Vul[i];
        if (!(t2 < 16))
          return A.ioore(chunk, t2);
        t = (al + chunk[t2] >>> 0) + A._RidempUtils_T(i, bl0, cl0, dl) >>> 0;
        modShift = B.List_Vul0[i] & 31;
        t = ((t << modShift | B.JSInt_methods._shrReceiverPositive$1(t, 32 - modShift)) >>> 0) + el >>> 0;
        dl0 = (cl0 << 10 | cl0 >>> 0 >>> 22) >>> 0;
        t2 = B.List_Vul1[i];
        if (!(t2 < 16))
          return A.ioore(chunk, t2);
        t2 = (ar + chunk[t2] >>> 0) + A._RidempUtils_t80(i, br, cr, dr);
        modShift = B.List_Vul2[i] & 31;
        t2 = ((t2 << modShift | B.JSInt_methods._shrReceiverPositive$1(t2 >>> 0, 32 - modShift)) >>> 0) + er >>> 0;
        dr0 = (cr << 10 | cr >>> 0 >>> 22) >>> 0;
      }
      B.JSArray_methods.$indexSet(t1, 1, (cl + dl >>> 0) + er >>> 0);
      if (3 >= t1.length)
        return A.ioore(t1, 3);
      B.JSArray_methods.$indexSet(t1, 2, (t1[3] + el >>> 0) + ar >>> 0);
      if (4 >= t1.length)
        return A.ioore(t1, 4);
      B.JSArray_methods.$indexSet(t1, 3, (t1[4] + al >>> 0) + br >>> 0);
      if (0 >= t1.length)
        return A.ioore(t1, 0);
      B.JSArray_methods.$indexSet(t1, 4, (t1[0] + bl0 >>> 0) + cr >>> 0);
      B.JSArray_methods.$indexSet(t1, 0, (bl + cl0 >>> 0) + dr >>> 0);
    },
    set$___RIPEMD__state_F(___RIPEMD__state_F) {
      this.___RIPEMD__state_F = type$.List_int._as(___RIPEMD__state_F);
    }
  };
  A.SHA256.prototype = {
    update$1(data) {
      var dataLength, t1, dataPos, t2, dataPos0, t3, _this = this;
      type$.List_int._as(data);
      if (_this._hash$_finished)
        throw A.wrapException(B.MessageException_QW6);
      dataLength = data.length;
      _this._bytesHashed += dataLength;
      if (_this._bufferLength > 0) {
        t1 = _this._hash$_buffer;
        dataPos = 0;
        while (true) {
          t2 = _this._bufferLength;
          if (!(t2 < 64 && dataLength > 0))
            break;
          _this._bufferLength = t2 + 1;
          dataPos0 = dataPos + 1;
          if (!(dataPos < data.length))
            return A.ioore(data, dataPos);
          t3 = data[dataPos];
          if (typeof t3 !== "number")
            return t3.$and();
          B.JSArray_methods.$indexSet(t1, t2, t3 & 255);
          --dataLength;
          dataPos = dataPos0;
        }
        if (t2 === 64) {
          _this._hashBlocks$5(_this._temp, _this._hash$_state, t1, 0, 64);
          _this._bufferLength = 0;
        }
      } else
        dataPos = 0;
      if (dataLength >= 64) {
        dataPos = _this._hashBlocks$5(_this._temp, _this._hash$_state, data, dataPos, dataLength);
        dataLength = B.JSInt_methods.$mod(dataLength, 64);
      }
      for (t1 = _this._hash$_buffer; dataLength > 0; dataPos = dataPos0) {
        t2 = _this._bufferLength++;
        dataPos0 = dataPos + 1;
        if (!(dataPos < data.length))
          return A.ioore(data, dataPos);
        t3 = data[dataPos];
        if (typeof t3 !== "number")
          return t3.$and();
        B.JSArray_methods.$indexSet(t1, t2, t3 & 255);
        --dataLength;
      }
      return _this;
    },
    finish$1(out) {
      var bytesHashed, left, t1, padLength, t2, i, t3, _this = this;
      type$.List_int._as(out);
      if (!_this._hash$_finished) {
        bytesHashed = _this._bytesHashed;
        left = _this._bufferLength;
        t1 = B.JSInt_methods._tdivFast$1(bytesHashed, 536870912);
        padLength = B.JSInt_methods.$mod(bytesHashed, 64) < 56 ? 64 : 128;
        t2 = _this._hash$_buffer;
        B.JSArray_methods.$indexSet(t2, left, 128);
        for (i = left + 1, t3 = padLength - 8; i < t3; ++i)
          B.JSArray_methods.$indexSet(t2, i, 0);
        A.writeUint32BE(t1 >>> 0, t2, t3);
        A.writeUint32BE(bytesHashed << 3 >>> 0, t2, padLength - 4);
        _this._hashBlocks$5(_this._temp, _this._hash$_state, t2, 0, padLength);
        _this._hash$_finished = true;
      }
      for (t1 = _this._hash$_state, i = 0; i < 8; ++i)
        A.writeUint32BE(t1[i], out, i * 4);
      return _this;
    },
    reset$0() {
      var _this = this,
        t1 = _this._hash$_state;
      B.JSArray_methods.$indexSet(t1, 0, 1779033703);
      B.JSArray_methods.$indexSet(t1, 1, 3144134277);
      B.JSArray_methods.$indexSet(t1, 2, 1013904242);
      B.JSArray_methods.$indexSet(t1, 3, 2773480762);
      B.JSArray_methods.$indexSet(t1, 4, 1359893119);
      B.JSArray_methods.$indexSet(t1, 5, 2600822924);
      B.JSArray_methods.$indexSet(t1, 6, 528734635);
      B.JSArray_methods.$indexSet(t1, 7, 1541459225);
      _this._bytesHashed = _this._bufferLength = 0;
      _this._hash$_finished = false;
      return _this;
    },
    _hashBlocks$5(w, v, p, pos, len) {
      var t2, a, b, c, d, e, f, g, h, i, u, u0, t10, e0, a0,
        t1 = type$.List_int;
      t1._as(w);
      t1._as(v);
      t1._as(p);
      for (t1 = this._k, t2 = t1.length; len >= 64;) {
        a = v[0];
        b = v[1];
        c = v[2];
        d = v[3];
        e = v[4];
        f = v[5];
        g = v[6];
        h = v[7];
        for (i = 0; i < 16; ++i)
          B.JSArray_methods.$indexSet(w, i, A.readUint32BE(p, pos + i * 4));
        for (i = 16; i < 64; ++i) {
          u = w[i - 2];
          u0 = w[i - 15];
          B.JSArray_methods.$indexSet(w, i, (((((u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10) >>> 0) + w[i - 7] >>> 0) + (((u0 >>> 7 | u0 << 25) ^ (u0 >>> 18 | u0 << 14) ^ u0 >>> 3) >>> 0) >>> 0) + w[i - 16] >>> 0);
        }
        for (i = 0; i < 64; ++i, h = g, g = f, f = e, e = e0, d = c, c = b, b = a, a = a0) {
          if (!(i < t2))
            return A.ioore(t1, i);
          t10 = ((((e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7)) >>> 0) + ((e & f ^ ~e & g) >>> 0) >>> 0) + ((h + t1[i] >>> 0) + w[i] >>> 0) >>> 0;
          e0 = d + t10 >>> 0;
          a0 = t10 + ((((a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10)) >>> 0) + ((a & b ^ a & c ^ b & c) >>> 0) >>> 0) >>> 0;
        }
        B.JSArray_methods.$indexSet(v, 0, v[0] + a >>> 0);
        B.JSArray_methods.$indexSet(v, 1, v[1] + b >>> 0);
        B.JSArray_methods.$indexSet(v, 2, v[2] + c >>> 0);
        B.JSArray_methods.$indexSet(v, 3, v[3] + d >>> 0);
        B.JSArray_methods.$indexSet(v, 4, v[4] + e >>> 0);
        B.JSArray_methods.$indexSet(v, 5, v[5] + f >>> 0);
        B.JSArray_methods.$indexSet(v, 6, v[6] + g >>> 0);
        B.JSArray_methods.$indexSet(v, 7, v[7] + h >>> 0);
        pos += 64;
        len -= 64;
      }
      return pos;
    }
  };
  A.Poly1305.prototype = {
    _blocks$3(m, mpos, bytes) {
      var hibit, t1, h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, t2, r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t00, t20, t30, t40, t50, t60, t70, d0, d00, d1, d10, d2, d20, d21, d3, d30, d31, d4, d40, d41, d5, d50, d51, d6, d60, d61, d7, d70, d71, d8, d80, d81, d9, d90, c;
      type$.List_int._as(m);
      hibit = this._fin !== 0 ? 0 : 2048;
      t1 = this._h;
      h0 = t1[0];
      h1 = t1[1];
      h2 = t1[2];
      h3 = t1[3];
      h4 = t1[4];
      h5 = t1[5];
      h6 = t1[6];
      h7 = t1[7];
      h8 = t1[8];
      h9 = t1[9];
      t2 = this._r;
      r0 = t2[0];
      r1 = t2[1];
      r2 = t2[2];
      r3 = t2[3];
      r4 = t2[4];
      r5 = t2[5];
      r6 = t2[6];
      r7 = t2[7];
      r8 = t2[8];
      r9 = t2[9];
      for (t2 = m.length, t3 = 5 * r9, t4 = 5 * r8, t5 = 5 * r7, t6 = 5 * r6, t7 = 5 * r5, t8 = 5 * r4, t9 = 5 * r3, t10 = 5 * r2, t11 = 5 * r1; bytes >= 16; h9 = d9, h8 = d81, h7 = d71, h6 = d61, h5 = d51, h4 = d41, h3 = d31, h2 = d21, h1 = d1, h0 = d0) {
        if (!(mpos >= 0 && mpos < t2))
          return A.ioore(m, mpos);
        t12 = m[mpos];
        t13 = mpos + 1;
        if (!(t13 < t2))
          return A.ioore(m, t13);
        t13 = m[t13];
        if (typeof t13 !== "number")
          return t13.$shl();
        if (typeof t12 !== "number")
          return t12.$or();
        t00 = t12 | t13 << 8;
        h0 += t00 & 8191;
        t13 = mpos + 2;
        if (!(t13 < t2))
          return A.ioore(m, t13);
        t13 = m[t13];
        t12 = mpos + 3;
        if (!(t12 < t2))
          return A.ioore(m, t12);
        t12 = m[t12];
        if (typeof t12 !== "number")
          return t12.$shl();
        if (typeof t13 !== "number")
          return t13.$or();
        t12 = t13 | t12 << 8;
        h1 += (t00 >>> 13 | t12 << 3) & 8191;
        t00 = mpos + 4;
        if (!(t00 < t2))
          return A.ioore(m, t00);
        t00 = m[t00];
        t13 = mpos + 5;
        if (!(t13 < t2))
          return A.ioore(m, t13);
        t13 = m[t13];
        if (typeof t13 !== "number")
          return t13.$shl();
        if (typeof t00 !== "number")
          return t00.$or();
        t20 = t00 | t13 << 8;
        h2 += (t12 >>> 10 | t20 << 6) & 8191;
        t12 = mpos + 6;
        if (!(t12 < t2))
          return A.ioore(m, t12);
        t12 = m[t12];
        t13 = mpos + 7;
        if (!(t13 < t2))
          return A.ioore(m, t13);
        t13 = m[t13];
        if (typeof t13 !== "number")
          return t13.$shl();
        if (typeof t12 !== "number")
          return t12.$or();
        t30 = t12 | t13 << 8;
        h3 += (t20 >>> 7 | t30 << 9) & 8191;
        t20 = mpos + 8;
        if (!(t20 < t2))
          return A.ioore(m, t20);
        t20 = m[t20];
        t13 = mpos + 9;
        if (!(t13 < t2))
          return A.ioore(m, t13);
        t13 = m[t13];
        if (typeof t13 !== "number")
          return t13.$shl();
        if (typeof t20 !== "number")
          return t20.$or();
        t40 = t20 | t13 << 8;
        h4 += (t30 >>> 4 | t40 << 12) & 8191;
        h5 += t40 >>> 1 & 8191;
        t30 = mpos + 10;
        if (!(t30 < t2))
          return A.ioore(m, t30);
        t30 = m[t30];
        t13 = mpos + 11;
        if (!(t13 < t2))
          return A.ioore(m, t13);
        t13 = m[t13];
        if (typeof t13 !== "number")
          return t13.$shl();
        if (typeof t30 !== "number")
          return t30.$or();
        t50 = t30 | t13 << 8;
        h6 += (t40 >>> 14 | t50 << 2) & 8191;
        t40 = mpos + 12;
        if (!(t40 < t2))
          return A.ioore(m, t40);
        t40 = m[t40];
        t13 = mpos + 13;
        if (!(t13 < t2))
          return A.ioore(m, t13);
        t13 = m[t13];
        if (typeof t13 !== "number")
          return t13.$shl();
        if (typeof t40 !== "number")
          return t40.$or();
        t60 = t40 | t13 << 8;
        h7 += (t50 >>> 11 | t60 << 5) & 8191;
        t50 = mpos + 14;
        if (!(t50 < t2))
          return A.ioore(m, t50);
        t50 = m[t50];
        t13 = mpos + 15;
        if (!(t13 < t2))
          return A.ioore(m, t13);
        t13 = m[t13];
        if (typeof t13 !== "number")
          return t13.$shl();
        if (typeof t50 !== "number")
          return t50.$or();
        t70 = t50 | t13 << 8;
        h8 += (t60 >>> 8 | t70 << 8) & 8191;
        h9 += (t70 >>> 5 | hibit) >>> 0;
        d0 = h0 * r0 + h1 * t3 + h2 * t4 + h3 * t5 + h4 * t6;
        d00 = (d0 & 8191) + h5 * t7 + h6 * t8 + h7 * t9 + h8 * t10 + h9 * t11;
        d1 = B.JSInt_methods._shrOtherPositive$1(d0, 13) + B.JSInt_methods._shrOtherPositive$1(d00, 13) + h0 * r1 + h1 * r0 + h2 * t3 + h3 * t4 + h4 * t5;
        d10 = (d1 & 8191) + h5 * t6 + h6 * t7 + h7 * t8 + h8 * t9 + h9 * t10;
        d2 = B.JSInt_methods._shrOtherPositive$1(d1, 13) + B.JSInt_methods._shrOtherPositive$1(d10, 13) + h0 * r2 + h1 * r1 + h2 * r0 + h3 * t3 + h4 * t4;
        d20 = (d2 & 8191) + h5 * t5 + h6 * t6 + h7 * t7 + h8 * t8 + h9 * t9;
        d21 = d20 & 8191;
        d3 = B.JSInt_methods._shrOtherPositive$1(d2, 13) + B.JSInt_methods._shrOtherPositive$1(d20, 13) + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * t3;
        d30 = (d3 & 8191) + h5 * t4 + h6 * t5 + h7 * t6 + h8 * t7 + h9 * t8;
        d31 = d30 & 8191;
        d4 = B.JSInt_methods._shrOtherPositive$1(d3, 13) + B.JSInt_methods._shrOtherPositive$1(d30, 13) + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
        d40 = (d4 & 8191) + h5 * t3 + h6 * t4 + h7 * t5 + h8 * t6 + h9 * t7;
        d41 = d40 & 8191;
        d5 = B.JSInt_methods._shrOtherPositive$1(d4, 13) + B.JSInt_methods._shrOtherPositive$1(d40, 13) + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
        d50 = (d5 & 8191) + h5 * r0 + h6 * t3 + h7 * t4 + h8 * t5 + h9 * t6;
        d51 = d50 & 8191;
        d6 = B.JSInt_methods._shrOtherPositive$1(d5, 13) + B.JSInt_methods._shrOtherPositive$1(d50, 13) + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
        d60 = (d6 & 8191) + h5 * r1 + h6 * r0 + h7 * t3 + h8 * t4 + h9 * t5;
        d61 = d60 & 8191;
        d7 = B.JSInt_methods._shrOtherPositive$1(d6, 13) + B.JSInt_methods._shrOtherPositive$1(d60, 13) + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
        d70 = (d7 & 8191) + h5 * r2 + h6 * r1 + h7 * r0 + h8 * t3 + h9 * t4;
        d71 = d70 & 8191;
        d8 = B.JSInt_methods._shrOtherPositive$1(d7, 13) + B.JSInt_methods._shrOtherPositive$1(d70, 13) + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
        d80 = (d8 & 8191) + h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * t3;
        d81 = d80 & 8191;
        d9 = B.JSInt_methods._shrOtherPositive$1(d8, 13) + B.JSInt_methods._shrOtherPositive$1(d80, 13) + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
        d90 = (d9 & 8191) + h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
        c = B.JSInt_methods._shrOtherPositive$1(d9, 13) + B.JSInt_methods._shrOtherPositive$1(d90, 13);
        d9 = d90 & 8191;
        c = (((c << 2 >>> 0) + c | 0) >>> 0) + (d00 & 8191) | 0;
        d0 = c & 8191;
        d1 = (d10 & 8191) + (c >>> 13);
        mpos += 16;
        bytes -= 16;
      }
      B.JSArray_methods.$indexSet(t1, 0, h0);
      B.JSArray_methods.$indexSet(t1, 1, h1);
      B.JSArray_methods.$indexSet(t1, 2, h2);
      B.JSArray_methods.$indexSet(t1, 3, h3);
      B.JSArray_methods.$indexSet(t1, 4, h4);
      B.JSArray_methods.$indexSet(t1, 5, h5);
      B.JSArray_methods.$indexSet(t1, 6, h6);
      B.JSArray_methods.$indexSet(t1, 7, h7);
      B.JSArray_methods.$indexSet(t1, 8, h8);
      B.JSArray_methods.$indexSet(t1, 9, h9);
    },
    finish$1(mac) {
      var g, t1, t2, i, c, mask, t3, t4, f, _this = this;
      type$.List_int._as(mac);
      g = A.List_List$filled(10, 0, false, type$.int);
      t1 = _this._leftover;
      if (t1 !== 0) {
        t2 = _this._buffer;
        i = t1 + 1;
        B.JSArray_methods.$indexSet(t2, t1, 1);
        for (; i < 16; ++i)
          B.JSArray_methods.$indexSet(t2, i, 0);
        _this._fin = 1;
        _this._blocks$3(t2, 0, 16);
      }
      t1 = _this._h;
      t2 = t1[1];
      if (typeof t2 !== "number")
        return t2.$shr();
      c = B.JSNumber_methods._shrOtherPositive$1(t2, 13);
      B.JSArray_methods.$indexSet(t1, 1, t2 & 8191);
      for (i = 2; i < 10; ++i) {
        t2 = t1[i];
        if (typeof t2 !== "number")
          return t2.$add();
        B.JSArray_methods.$indexSet(t1, i, t2 + c);
        t2 = t1[i];
        if (typeof t2 !== "number")
          return t2.$shr();
        c = B.JSNumber_methods._shrOtherPositive$1(t2, 13);
        B.JSArray_methods.$indexSet(t1, i, t2 & 8191);
      }
      t2 = t1[0];
      if (typeof t2 !== "number")
        return t2.$add();
      B.JSArray_methods.$indexSet(t1, 0, t2 + c * 5);
      t2 = t1[0];
      if (typeof t2 !== "number")
        return t2.$shr();
      c = B.JSNumber_methods._shrOtherPositive$1(t2, 13);
      B.JSArray_methods.$indexSet(t1, 0, t2 & 8191);
      t2 = t1[1];
      if (typeof t2 !== "number")
        return t2.$add();
      B.JSArray_methods.$indexSet(t1, 1, t2 + c);
      t2 = t1[1];
      if (typeof t2 !== "number")
        return t2.$shr();
      c = B.JSNumber_methods._shrOtherPositive$1(t2, 13);
      B.JSArray_methods.$indexSet(t1, 1, t2 & 8191);
      t2 = t1[2];
      if (typeof t2 !== "number")
        return t2.$add();
      B.JSArray_methods.$indexSet(t1, 2, t2 + c);
      t2 = t1[0];
      if (typeof t2 !== "number")
        return t2.$add();
      B.JSArray_methods.$indexSet(g, 0, t2 + 5);
      t2 = g[0];
      c = B.JSInt_methods._shrOtherPositive$1(t2, 13);
      B.JSArray_methods.$indexSet(g, 0, t2 & 8191);
      for (i = 1; i < 10; ++i) {
        t2 = t1[i];
        if (typeof t2 !== "number")
          return t2.$add();
        B.JSArray_methods.$indexSet(g, i, t2 + c);
        t2 = g[i];
        c = B.JSInt_methods._shrOtherPositive$1(t2, 13);
        B.JSArray_methods.$indexSet(g, i, t2 & 8191);
      }
      B.JSArray_methods.$indexSet(g, 9, g[9] - 8192);
      mask = ((c ^ 1) >>> 0) - 1;
      for (i = 0; i < 10; ++i)
        B.JSArray_methods.$indexSet(g, i, (g[i] & mask) >>> 0);
      mask = ~mask;
      for (i = 0; i < 10; ++i) {
        t2 = t1[i];
        if (typeof t2 !== "number")
          return t2.$and();
        B.JSArray_methods.$indexSet(t1, i, (t2 & mask | g[i]) >>> 0);
      }
      t2 = t1[0];
      t3 = t1[1];
      if (typeof t3 !== "number")
        return t3.$shl();
      if (typeof t2 !== "number")
        return t2.$or();
      B.JSArray_methods.$indexSet(t1, 0, (t2 | t3 << 13) & 65535);
      t3 = t1[1];
      if (typeof t3 !== "number")
        return t3.$shr();
      t3 = B.JSNumber_methods._shrOtherPositive$1(t3, 3);
      t2 = t1[2];
      if (typeof t2 !== "number")
        return t2.$shl();
      B.JSArray_methods.$indexSet(t1, 1, (t3 | t2 << 10) & 65535);
      t2 = t1[2];
      if (typeof t2 !== "number")
        return t2.$shr();
      t2 = B.JSNumber_methods._shrOtherPositive$1(t2, 6);
      t3 = t1[3];
      if (typeof t3 !== "number")
        return t3.$shl();
      B.JSArray_methods.$indexSet(t1, 2, (t2 | t3 << 7) & 65535);
      t3 = t1[3];
      if (typeof t3 !== "number")
        return t3.$shr();
      t3 = B.JSNumber_methods._shrOtherPositive$1(t3, 9);
      t2 = t1[4];
      if (typeof t2 !== "number")
        return t2.$shl();
      B.JSArray_methods.$indexSet(t1, 3, (t3 | t2 << 4) & 65535);
      t2 = t1[4];
      if (typeof t2 !== "number")
        return t2.$shr();
      t2 = B.JSNumber_methods._shrOtherPositive$1(t2, 12);
      t3 = t1[5];
      if (typeof t3 !== "number")
        return t3.$shl();
      t4 = t1[6];
      if (typeof t4 !== "number")
        return t4.$shl();
      B.JSArray_methods.$indexSet(t1, 4, (t2 | t3 << 1 | t4 << 14) & 65535);
      t4 = t1[6];
      if (typeof t4 !== "number")
        return t4.$shr();
      t4 = B.JSNumber_methods._shrOtherPositive$1(t4, 2);
      t3 = t1[7];
      if (typeof t3 !== "number")
        return t3.$shl();
      B.JSArray_methods.$indexSet(t1, 5, (t4 | t3 << 11) & 65535);
      t3 = t1[7];
      if (typeof t3 !== "number")
        return t3.$shr();
      t3 = B.JSNumber_methods._shrOtherPositive$1(t3, 5);
      t4 = t1[8];
      if (typeof t4 !== "number")
        return t4.$shl();
      B.JSArray_methods.$indexSet(t1, 6, (t3 | t4 << 8) & 65535);
      t4 = t1[8];
      if (typeof t4 !== "number")
        return t4.$shr();
      t4 = B.JSNumber_methods._shrOtherPositive$1(t4, 8);
      t3 = t1[9];
      if (typeof t3 !== "number")
        return t3.$shl();
      B.JSArray_methods.$indexSet(t1, 7, (t4 | t3 << 5) & 65535);
      t3 = t1[0];
      t4 = _this._pad;
      t2 = t4[0];
      if (typeof t3 !== "number")
        return t3.$add();
      f = t3 + t2;
      B.JSArray_methods.$indexSet(t1, 0, f & 65535);
      for (i = 1; i < 8; ++i) {
        t2 = t1[i];
        t3 = t4[i];
        if (typeof t2 !== "number")
          return t2.$add();
        f = (((t2 + t3 | 0) >>> 0) + B.JSInt_methods._shrOtherPositive$1(f, 16) | 0) >>> 0;
        B.JSArray_methods.$indexSet(t1, i, f & 65535);
      }
      for (i = 0; i < 8; ++i) {
        t2 = t1[i];
        t3 = i * 2;
        B.JSArray_methods.$indexSet(mac, t3, t2 & 255);
        B.JSArray_methods.$indexSet(mac, t3 + 1, B.JSInt_methods._shrOtherPositive$1(t2, 8) & 255);
      }
      _this._finished = true;
      return _this;
    },
    update$1(data) {
      var bytes, t1, want, i, t2, t3, mpos, _this = this;
      type$.List_int._as(data);
      bytes = data.length;
      t1 = _this._leftover;
      if (t1 !== 0) {
        want = 16 - t1;
        if (want > bytes)
          want = bytes;
        for (t1 = _this._buffer, i = 0; i < want; ++i) {
          t2 = _this._leftover;
          if (!(i < data.length))
            return A.ioore(data, i);
          t3 = data[i];
          if (typeof t3 !== "number")
            return t3.$and();
          B.JSArray_methods.$indexSet(t1, t2 + i, t3 & 255);
        }
        bytes -= want;
        t2 = _this._leftover += want;
        if (t2 < 16)
          return _this;
        _this._blocks$3(t1, 0, 16);
        _this._leftover = 0;
        mpos = want;
      } else
        mpos = 0;
      if (bytes >= 16) {
        want = bytes - B.JSInt_methods.$mod(bytes, 16);
        _this._blocks$3(data, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes > 0) {
        for (t1 = _this._buffer, i = 0; i < bytes; ++i) {
          t2 = _this._leftover;
          t3 = mpos + i;
          if (!(t3 >= 0 && t3 < data.length))
            return A.ioore(data, t3);
          t3 = data[t3];
          if (typeof t3 !== "number")
            return t3.$and();
          B.JSArray_methods.$indexSet(t1, t2 + i, t3 & 255);
        }
        _this._leftover += bytes;
      }
      return _this;
    }
  };
  A.FortunaPRNG.prototype = {
    get$_key() {
      var result,
        value = this.__FortunaPRNG__key_FI;
      if (value === $) {
        result = A.List_List$filled(32, 0, false, type$.int);
        this.__FortunaPRNG__key_FI !== $ && A.throwLateFieldADI("_key");
        this.set$__FortunaPRNG__key_FI(result);
        value = result;
      }
      return value;
    },
    get$_counter() {
      var result,
        value = this.__FortunaPRNG__counter_FI;
      if (value === $) {
        result = A.List_List$filled(16, 0, false, type$.int);
        this.__FortunaPRNG__counter_FI !== $ && A.throwLateFieldADI("_counter");
        this.set$__FortunaPRNG__counter_FI(result);
        value = result;
      }
      return value;
    },
    _generateBlocks$2(out, n) {
      var t2, tempBlock, t3, i, t4, t5, t6, ctr, newKey, _this = this,
        t1 = type$.List_int;
      t1._as(out);
      if (n === 0)
        return;
      if (n > 65536)
        throw A.wrapException(B.MessageException_Zgr);
      t2 = type$.int;
      tempBlock = A.List_List$filled(32, 0, false, t2);
      for (t3 = _this._zeroBlock, i = 0; i < n; ++i) {
        t4 = _this.get$_counter();
        t5 = _this.get$_key();
        t1._as(t4);
        t1._as(t3);
        t1._as(t5);
        t1._as(tempBlock);
        t6 = new A.AES();
        t6.__AES__keyLen_A = 32;
        t6.setKey$2(t5, false);
        ctr = new A.CTR();
        ctr.set$__CTR__counter_F(t1._as(A.List_List$filled(16, 0, false, t2)));
        t5 = t1._as(A.List_List$filled(16, 0, false, t2));
        ctr.__CTR__buffer_F !== $ && A.throwLateFieldAI("_buffer");
        ctr.set$__CTR__buffer_F(t5);
        ctr.setCipher$2(t6, t3);
        ctr.streamXOR$2(t4, tempBlock);
        t4 = i * 16;
        B.JSArray_methods.setRange$3(out, t4, t4 + 16, tempBlock);
        _this._count$0();
      }
      newKey = A.List_List$filled(32, 0, false, t2);
      t2 = _this.get$_counter();
      t4 = _this.get$_key();
      t1._as(t2);
      t1._as(t3);
      t1._as(t4);
      t1._as(tempBlock);
      A.CTR$(A.AES$(t4), t3).streamXOR$2(t2, tempBlock);
      B.JSArray_methods.setRange$3(newKey, 0, 16, tempBlock);
      _this._count$0();
      t2 = _this.get$_counter();
      t4 = _this.get$_key();
      t1._as(t2);
      A.CTR$(A.AES$(t1._as(t4)), t3).streamXOR$2(t2, tempBlock);
      B.JSArray_methods.setRange$3(newKey, 16, 32, tempBlock);
      _this._count$0();
      B.JSArray_methods.setAll$2(_this.get$_key(), 0, newKey);
    },
    _count$0() {
      var i, t1;
      for (i = 0; this.get$_counter(), i < 16; ++i) {
        t1 = this.get$_counter();
        B.JSArray_methods.$indexSet(t1, i, t1[i] + 1);
      }
    },
    nextBytes$1($length) {
      var t2, i, t3, out0, _this = this,
        t1 = type$.int,
        out = A.List_List$filled($length, 0, false, t1);
      for (t2 = _this._out, i = 0; i < $length; ++i) {
        t3 = _this._c;
        if (t3 === 16) {
          out0 = A.List_List$filled(16, 0, false, t1);
          _this._generateBlocks$2(out0, 1);
          B.JSArray_methods.setAll$2(t2, 0, out0);
          t3 = _this._c = 0;
        }
        _this._c = t3 + 1;
        if (!(t3 < 16))
          return A.ioore(t2, t3);
        B.JSArray_methods.$indexSet(out, i, t2[t3]);
      }
      return out;
    },
    set$__FortunaPRNG__key_FI(__FortunaPRNG__key_FI) {
      this.__FortunaPRNG__key_FI = type$.List_int._as(__FortunaPRNG__key_FI);
    },
    set$__FortunaPRNG__counter_FI(__FortunaPRNG__counter_FI) {
      this.__FortunaPRNG__counter_FI = type$.List_int._as(__FortunaPRNG__counter_FI);
    }
  };
  A.SchnorrkelPublicKey.prototype = {};
  A.QuickCrypto__generateRandom_closure.prototype = {
    call$1($length) {
      var t2, t3, k, t4, t5, out,
        t1 = $.QuickCrypto__randomGenerator;
      if (t1 == null) {
        t1 = type$.int;
        t2 = A.List_List$filled(16, 0, false, t1);
        t3 = A.List_List$filled(16, 0, false, t1);
        t2 = new A.FortunaPRNG(t2, t3);
        k = new A.SHAKE256(A.List_List$filled(25, 0, false, t1), A.List_List$filled(25, 0, false, t1), A.List_List$filled(200, 0, false, t1));
        k._Keccack$1(64);
        t4 = A._setArrayType([], type$.JSArray_int);
        t5 = type$.List_int;
        k.super$_Keccack$update(t5._as(t4));
        k.super$_Keccack$update(t5._as(A.FortunaPRNG__generateSeed(32)));
        t4 = t2.get$_key();
        out = A.List_List$filled(32, 0, false, t1);
        t5._as(out);
        if (!k._hash$_finished)
          k._padAndPermute$1(31);
        k._squeeze$1(out);
        B.JSArray_methods.setAll$2(t4, 0, out);
        k.reset$0();
        t2._generateBlocks$2(t3, 1);
        $.QuickCrypto__randomGenerator = t2;
        t1 = t2;
      }
      return t1.nextBytes$1($length);
    },
    $signature: 97
  };
  A.BlockchainUtilsException.prototype = {
    toString$0(_) {
      return this.get$message();
    },
    $isException: 1
  };
  A.ArgumentException.prototype = {
    toString$0(_) {
      return this.message;
    },
    $isException: 1,
    $isBlockchainUtilsException: 1
  };
  A.MessageException.prototype = {
    toString$0(_) {
      var t1 = this.details;
      t1 = t1 == null ? "" : " " + t1.toString$0(0);
      return this.message + t1;
    },
    $isException: 1,
    $isBlockchainUtilsException: 1
  };
  A._Hex.prototype = {
    encode$2$lowerCase(data, lowerCase) {
      var t1, $length, result, i, byte, t2, t3;
      type$.List_int._as(data);
      A.BytesUtils_validateBytes(data, "Invalid hex bytes");
      t1 = J.getInterceptor$asx(data);
      $length = t1.get$length(data);
      result = A.List_List$filled($length * 2, "", false, type$.String);
      for (i = 0; i < $length; ++i) {
        byte = t1.$index(data, i);
        t2 = i * 2;
        t3 = B.JSInt_methods._shrOtherPositive$1(byte, 4);
        if (!(t3 < 16))
          return A.ioore(B.List_bdS, t3);
        B.JSArray_methods.$indexSet(result, t2, B.List_bdS[t3]);
        t3 = byte & 15;
        if (!(t3 < 16))
          return A.ioore(B.List_bdS, t3);
        B.JSArray_methods.$indexSet(result, t2 + 1, B.List_bdS[t3]);
      }
      return B.JSArray_methods.join$0(result);
    },
    decode$1(hex) {
      var result, haveBad, i, t2, v0, v1,
        t1 = hex.length;
      if (t1 === 0) {
        t1 = J.JSArray_JSArray$fixed(0, type$.int);
        return t1;
      }
      if ((t1 & 1) !== 0)
        throw A.wrapException(B.ArgumentException_23B);
      result = A.List_List$filled(B.JSInt_methods._tdivFast$1(t1, 2), 0, false, type$.int);
      for (haveBad = false, i = 0; i < t1; i += 2) {
        t2 = hex.charCodeAt(i);
        v0 = t2 < 128 ? B.List_s8b[t2] : 256;
        t2 = i + 1;
        if (!(t2 < t1))
          return A.ioore(hex, t2);
        t2 = hex.charCodeAt(t2);
        v1 = t2 < 128 ? B.List_s8b[t2] : 256;
        B.JSArray_methods.$indexSet(result, B.JSInt_methods._tdivFast$1(i, 2), (v0 << 4 | v1) & 255);
        haveBad = B.JSBool_methods.$or(haveBad, B.JSBool_methods.$or(v0 === 256, v1 === 256));
      }
      if (haveBad)
        throw A.wrapException(B.ArgumentException_qpm);
      return result;
    }
  };
  A.SS58ChecksumError.prototype = {
    toString$0(_) {
      return this.message;
    },
    $isException: 1,
    $isBlockchainUtilsException: 1
  };
  A.DynamicByteTracker.prototype = {};
  A.BytesUtils_toBytes_closure.prototype = {
    call$1(e) {
      return A._asInt(e) & 255;
    },
    $signature: 13
  };
  A.BigRational.prototype = {
    $mul(_, other) {
      return A.BigRational__reduce(this.numerator.$mul(0, other.numerator), this.denominator.$mul(0, other.denominator));
    },
    $div(_, other) {
      return A.BigRational__reduce(this.numerator.$mul(0, other.denominator), this.denominator.$mul(0, other.numerator));
    },
    $not(_) {
      var t1 = this.denominator;
      if (t1._isNegative)
        return new A.BigRational(this.numerator, t1.$negate(0));
      return new A.BigRational(this.numerator.$negate(0), t1);
    },
    toDecimal$1$digits(digits) {
      var t2, nDive, nReminder, intPart, shiftedRemainder, t3, t4, decPart, decPartStr, _this = this,
        t1 = _this._inDecimal;
      if (t1 != null)
        return t1;
      if (digits == null)
        digits = _this.get$scale();
      t1 = _this.numerator;
      t2 = _this.denominator;
      nDive = t1.$tdiv(0, t2);
      nReminder = t1.remainder$1(0, t2);
      intPart = (nDive._isNegative ? nDive.$negate(0) : nDive).toString$0(0);
      shiftedRemainder = A.BigRational__reduce(nReminder._isNegative ? nReminder.$negate(0) : nReminder, t2).$mul(0, new A.BigRational($.$get$BigRational__ten().pow$1(digits), $.$get$BigRational__one()));
      t3 = shiftedRemainder.numerator;
      t4 = shiftedRemainder.denominator;
      decPart = t3.$tdiv(0, t4);
      if (t1._isNegative !== t2._isNegative) {
        t1 = t1.compareTo$1(0, $.$get$BigRational__zero());
        t1 = t1 !== 0;
      } else
        t1 = false;
      if (t1)
        intPart = "-" + intPart;
      t1 = $.$get$BigRational__zero();
      t2 = decPart.compareTo$1(0, t1);
      if (t2 === 0)
        return intPart;
      decPartStr = (decPart._isNegative ? decPart.$negate(0) : decPart).toString$0(0);
      t2 = decPartStr.length;
      if (t2 < digits)
        decPartStr = B.JSString_methods.$mul("0", digits - t2) + decPartStr;
      t1 = t3.$mod(0, t4).compareTo$1(0, t1);
      if (t1 === 0)
        for (; B.JSString_methods.endsWith$1(decPartStr, "0");)
          decPartStr = B.JSString_methods.substring$2(decPartStr, 0, decPartStr.length - 1);
      if (digits < 1)
        return intPart;
      return intPart + (decPart.compareTo$1(0, $.$get$BigRational__zero()) < 0 ? "" : ".") + decPartStr;
    },
    toDecimal$0() {
      return this.toDecimal$1$digits(null);
    },
    toString$0(_) {
      var t1 = this._inDecimal;
      return t1 == null ? this._inDecimal = this.toDecimal$0() : t1;
    },
    get$scale() {
      var t1, t2, scale = 0, r = this;
      while (true) {
        t1 = r.denominator;
        t2 = t1.compareTo$1(0, $.$get$_BigIntImpl_one());
        if (!(t2 !== 0))
          break;
        ++scale;
        t2 = $.$get$BigRational_ten();
        r = A.BigRational__reduce(r.numerator.$mul(0, t2.numerator), t1.$mul(0, t2.denominator));
      }
      return scale;
    },
    $eq(_, other) {
      var t1;
      if (other == null)
        return false;
      if (other instanceof A.BigRational) {
        t1 = other.denominator.compareTo$1(0, this.denominator);
        if (t1 === 0)
          t1 = other.numerator.compareTo$1(0, this.numerator) === 0;
        else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode(_) {
      return this.numerator.get$hashCode(0) ^ this.denominator.get$hashCode(0);
    }
  };
  A.StringEncoding.prototype = {
    _enumToString$0() {
      return "StringEncoding." + this._core$_name;
    }
  };
  A.Tuple.prototype = {};
  A.UUID_generateUUIDv4_closure.prototype = {
    call$1(i) {
      var t1;
      if (i === 6)
        return this.random.nextInt$1(16) & 15 | 64;
      else {
        t1 = this.random;
        if (i === 8)
          return t1.nextInt$1(4) & 3 | 8;
        else
          return t1.nextInt$1(256);
      }
    },
    $signature: 13
  };
  A.UUID_generateUUIDv4_closure0.prototype = {
    call$1(byte) {
      return B.JSString_methods.padLeft$2(B.JSInt_methods.toRadixString$1(A._asInt(byte), 16), 2, "0");
    },
    $signature: 34
  };
  A.CanonicalizedMap.prototype = {
    $index(_, key) {
      var pair, _this = this;
      if (!_this._isValidKey$1(key))
        return null;
      pair = _this._base.$index(0, _this._canonicalize.call$1(_this.$ti._eval$1("CanonicalizedMap.K")._as(key)));
      return pair == null ? null : pair.value;
    },
    $indexSet(_, key, value) {
      var t2, _this = this,
        t1 = _this.$ti;
      t1._eval$1("CanonicalizedMap.K")._as(key);
      t2 = t1._eval$1("CanonicalizedMap.V");
      t2._as(value);
      if (!_this._isValidKey$1(key))
        return;
      _this._base.$indexSet(0, _this._canonicalize.call$1(key), new A.MapEntry(key, value, t1._eval$1("@<CanonicalizedMap.K>")._bind$1(t2)._eval$1("MapEntry<1,2>")));
    },
    addAll$1(_, other) {
      this.$ti._eval$1("Map<CanonicalizedMap.K,CanonicalizedMap.V>")._as(other).forEach$1(0, new A.CanonicalizedMap_addAll_closure(this));
    },
    cast$2$0(_, K2, V2) {
      return this._base.cast$2$0(0, K2, V2);
    },
    containsKey$1(key) {
      var _this = this;
      if (!_this._isValidKey$1(key))
        return false;
      return _this._base.containsKey$1(_this._canonicalize.call$1(_this.$ti._eval$1("CanonicalizedMap.K")._as(key)));
    },
    get$entries() {
      return this._base.get$entries().map$1$1(0, new A.CanonicalizedMap_entries_closure(this), this.$ti._eval$1("MapEntry<CanonicalizedMap.K,CanonicalizedMap.V>"));
    },
    forEach$1(_, f) {
      this._base.forEach$1(0, new A.CanonicalizedMap_forEach_closure(this, this.$ti._eval$1("~(CanonicalizedMap.K,CanonicalizedMap.V)")._as(f)));
    },
    get$isEmpty(_) {
      return this._base.__js_helper$_length === 0;
    },
    get$isNotEmpty(_) {
      return this._base.__js_helper$_length !== 0;
    },
    get$keys() {
      var t1 = this._base.get$values(),
        t2 = this.$ti._eval$1("CanonicalizedMap.K"),
        t3 = A._instanceType(t1);
      return A.MappedIterable_MappedIterable(t1, t3._bind$1(t2)._eval$1("1(Iterable.E)")._as(new A.CanonicalizedMap_keys_closure(this)), t3._eval$1("Iterable.E"), t2);
    },
    get$length(_) {
      return this._base.__js_helper$_length;
    },
    toString$0(_) {
      return A.MapBase_mapToString(this);
    },
    _isValidKey$1(key) {
      return this.$ti._eval$1("CanonicalizedMap.K")._is(key);
    },
    $isMap: 1
  };
  A.CanonicalizedMap_addAll_closure.prototype = {
    call$2(key, value) {
      var t1 = this.$this,
        t2 = t1.$ti;
      t2._eval$1("CanonicalizedMap.K")._as(key);
      t2._eval$1("CanonicalizedMap.V")._as(value);
      t1.$indexSet(0, key, value);
      return value;
    },
    $signature() {
      return this.$this.$ti._eval$1("~(CanonicalizedMap.K,CanonicalizedMap.V)");
    }
  };
  A.CanonicalizedMap_entries_closure.prototype = {
    call$1(e) {
      var t1 = this.$this.$ti,
        t2 = t1._eval$1("MapEntry<CanonicalizedMap.C,MapEntry<CanonicalizedMap.K,CanonicalizedMap.V>>")._as(e).value;
      return new A.MapEntry(t2.key, t2.value, t1._eval$1("@<CanonicalizedMap.K>")._bind$1(t1._eval$1("CanonicalizedMap.V"))._eval$1("MapEntry<1,2>"));
    },
    $signature() {
      return this.$this.$ti._eval$1("MapEntry<CanonicalizedMap.K,CanonicalizedMap.V>(MapEntry<CanonicalizedMap.C,MapEntry<CanonicalizedMap.K,CanonicalizedMap.V>>)");
    }
  };
  A.CanonicalizedMap_forEach_closure.prototype = {
    call$2(key, pair) {
      var t1 = this.$this.$ti;
      t1._eval$1("CanonicalizedMap.C")._as(key);
      t1._eval$1("MapEntry<CanonicalizedMap.K,CanonicalizedMap.V>")._as(pair);
      return this.f.call$2(pair.key, pair.value);
    },
    $signature() {
      return this.$this.$ti._eval$1("~(CanonicalizedMap.C,MapEntry<CanonicalizedMap.K,CanonicalizedMap.V>)");
    }
  };
  A.CanonicalizedMap_keys_closure.prototype = {
    call$1(pair) {
      return this.$this.$ti._eval$1("MapEntry<CanonicalizedMap.K,CanonicalizedMap.V>")._as(pair).key;
    },
    $signature() {
      return this.$this.$ti._eval$1("CanonicalizedMap.K(MapEntry<CanonicalizedMap.K,CanonicalizedMap.V>)");
    }
  };
  A.CosmosBaseAddress.prototype = {
    toString$0(_) {
      return this.address;
    }
  };
  A.BaseClient.prototype = {
    _sendUnstreamed$5(method, url, headers, body, encoding) {
      return this._sendUnstreamed$body$BaseClient(method, url, type$.nullable_Map_String_String._as(headers), body, encoding);
    },
    _sendUnstreamed$body$BaseClient(method, url, headers, body, encoding) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Response),
        $async$returnValue, $async$self = this, request, $async$temp1;
      var $async$_sendUnstreamed$5 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              request = A.Request$(method, url);
              request.headers.addAll$1(0, headers);
              request.set$body(body);
              $async$temp1 = A;
              $async$goto = 3;
              return A._asyncAwait($async$self.send$1(request), $async$_sendUnstreamed$5);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.Response_fromStream($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$_sendUnstreamed$5, $async$completer);
    }
  };
  A.BaseRequest.prototype = {
    finalize$0() {
      if (this._finalized)
        throw A.wrapException(A.StateError$("Can't finalize a finalized Request."));
      this._finalized = true;
      return B.ByteStream__EmptyStream;
    },
    toString$0(_) {
      return this.method + " " + this.url.toString$0(0);
    }
  };
  A.BaseRequest_closure.prototype = {
    call$2(key1, key2) {
      return A._asString(key1).toLowerCase() === A._asString(key2).toLowerCase();
    },
    $signature: 98
  };
  A.BaseRequest_closure0.prototype = {
    call$1(key) {
      return B.JSString_methods.get$hashCode(A._asString(key).toLowerCase());
    },
    $signature: 99
  };
  A.BaseResponse.prototype = {
    BaseResponse$7$contentLength$headers$isRedirect$persistentConnection$reasonPhrase$request(statusCode, contentLength, headers, isRedirect, persistentConnection, reasonPhrase, request) {
      var t1 = this.statusCode;
      if (t1 < 100)
        throw A.wrapException(A.ArgumentError$("Invalid status code " + t1 + ".", null));
    }
  };
  A.BrowserClient.prototype = {
    send$1(request) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.StreamedResponse),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, xhr, completer, bytes, t1, t2, t3;
      var $async$send$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              request.super$BaseRequest$finalize();
              $async$goto = 3;
              return A._asyncAwait(new A.ByteStream(A.Stream_Stream$value(request._bodyBytes, type$.List_int)).toBytes$0(), $async$send$1);
            case 3:
              // returning from await.
              bytes = $async$result;
              xhr = type$.JSObject._as(new self.XMLHttpRequest());
              t1 = $async$self._xhrs;
              t1.add$1(0, xhr);
              t2 = xhr;
              t2.open(request.method, request.url.toString$0(0), true);
              t2.responseType = "arraybuffer";
              t2.withCredentials = false;
              for (t2 = request.headers.get$entries(), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
                t3 = t2.get$current();
                xhr.setRequestHeader(t3.key, t3.value);
              }
              completer = new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_StreamedResponse), type$._AsyncCompleter_StreamedResponse);
              t2 = type$._EventStream_JSObject;
              t3 = type$.void;
              new A._EventStream(xhr, "load", false, t2).get$first(0).then$1$1(new A.BrowserClient_send_closure(xhr, completer, request), t3);
              new A._EventStream(xhr, "error", false, t2).get$first(0).then$1$1(new A.BrowserClient_send_closure0(completer, request), t3);
              xhr.send(bytes);
              $async$handler = 4;
              $async$goto = 7;
              return A._asyncAwait(completer.future, $async$send$1);
            case 7:
              // returning from await.
              t2 = $async$result;
              $async$returnValue = t2;
              $async$next = [1];
              // goto finally
              $async$goto = 5;
              break;
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // uncaught
              $async$next = [2];
            case 5:
              // finally
              $async$handler = 2;
              t1.remove$1(0, xhr);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return A._asyncStartSync($async$send$1, $async$completer);
    }
  };
  A.BrowserClient_send_closure.prototype = {
    call$1(_) {
      var t1, _0_0, t2, body, responseUrl, t3, t4, t5, t6, _this = this;
      type$.JSObject._as(_);
      t1 = _this.xhr;
      _0_0 = A._extension_0_get_responseHeaders(t1).$index(0, "content-length");
      if (_0_0 != null) {
        t2 = $.$get$_digitRegex();
        t2 = !t2._nativeRegExp.test(_0_0);
      } else
        t2 = false;
      if (t2) {
        _this.completer.completeError$1(new A.ClientException("Invalid content-length header [" + A.S(_0_0) + "].", _this.request.url));
        return;
      }
      body = A.NativeUint8List_NativeUint8List$view(type$.NativeByteBuffer._as(t1.response), 0, null);
      responseUrl = A._asString(t1.responseURL);
      if (responseUrl.length !== 0)
        A.Uri_parse(responseUrl);
      t2 = A.Stream_Stream$value(body, type$.List_int);
      t3 = A._asInt(t1.status);
      t4 = body.length;
      t5 = _this.request;
      t6 = A._extension_0_get_responseHeaders(t1);
      t1 = A._asString(t1.statusText);
      t2 = new A.StreamedResponseV2(A.toByteStream(new A.ByteStream(t2)), t5, t3, t1, t4, t6, false, true);
      t2.BaseResponse$7$contentLength$headers$isRedirect$persistentConnection$reasonPhrase$request(t3, t4, t6, false, true, t1, t5);
      _this.completer.complete$1(t2);
    },
    $signature: 25
  };
  A.BrowserClient_send_closure0.prototype = {
    call$1(_) {
      type$.JSObject._as(_);
      this.completer.completeError$2(new A.ClientException("XMLHttpRequest error.", this.request.url), A.StackTrace_current());
    },
    $signature: 25
  };
  A.ByteStream.prototype = {
    toBytes$0() {
      var t1 = new A._Future($.Zone__current, type$._Future_Uint8List),
        completer = new A._AsyncCompleter(t1, type$._AsyncCompleter_Uint8List),
        sink = new A._ByteCallbackSink(new A.ByteStream_toBytes_closure(completer), new Uint8Array(1024));
      this.listen$4$cancelOnError$onDone$onError(type$.void_Function_List_int._as(sink.get$add(sink)), true, sink.get$close(), completer.get$completeError());
      return t1;
    }
  };
  A.ByteStream_toBytes_closure.prototype = {
    call$1(bytes) {
      return this.completer.complete$1(new Uint8Array(A._ensureNativeList(type$.List_int._as(bytes))));
    },
    $signature: 101
  };
  A.ClientException.prototype = {
    toString$0(_) {
      var t1 = this.uri.toString$0(0);
      return "ClientException: " + this.message + ", uri=" + t1;
    },
    $isException: 1
  };
  A.Request.prototype = {
    get$encoding() {
      var t1, t2, _this = this;
      if (_this.get$_contentType() == null || !_this.get$_contentType().parameters._collection$_map.containsKey$1("charset"))
        return _this._defaultEncoding;
      t1 = _this.get$_contentType().parameters._collection$_map.$index(0, "charset");
      t1.toString;
      t2 = A.Encoding_getByName(t1);
      return t2 == null ? A.throwExpression(A.FormatException$('Unsupported encoding "' + t1 + '".', null, null)) : t2;
    },
    set$body(value) {
      var contentType, _this = this,
        t1 = type$.List_int._as(_this.get$encoding().encode$1(value));
      _this._checkFinalized$0();
      _this._bodyBytes = A.toUint8List(t1);
      contentType = _this.get$_contentType();
      if (contentType == null) {
        t1 = type$.String;
        _this.set$_contentType(A.MediaType$("text", "plain", A.LinkedHashMap_LinkedHashMap$_literal(["charset", _this.get$encoding().get$name()], t1, t1)));
      } else if (!contentType.parameters._collection$_map.containsKey$1("charset")) {
        t1 = type$.String;
        _this.set$_contentType(contentType.change$1$parameters(A.LinkedHashMap_LinkedHashMap$_literal(["charset", _this.get$encoding().get$name()], t1, t1)));
      }
    },
    get$_contentType() {
      var contentType = this.headers.$index(0, "content-type");
      if (contentType == null)
        return null;
      return A.MediaType_MediaType$parse(contentType);
    },
    set$_contentType(value) {
      this.headers.$indexSet(0, "content-type", value.toString$0(0));
    },
    _checkFinalized$0() {
      if (!this._finalized)
        return;
      throw A.wrapException(A.StateError$("Can't modify a finalized Request."));
    }
  };
  A.Response.prototype = {
    get$body() {
      return A.encodingForCharset(A._contentTypeForHeaders(this.headers).parameters._collection$_map.$index(0, "charset")).decode$1(this.bodyBytes);
    }
  };
  A.StreamedResponse.prototype = {};
  A.StreamedResponseV2.prototype = {};
  A.CaseInsensitiveMap.prototype = {};
  A.CaseInsensitiveMap$from_closure.prototype = {
    call$1(key) {
      return A._asString(key).toLowerCase();
    },
    $signature: 16
  };
  A.MediaType.prototype = {
    change$1$parameters(parameters) {
      var t1, parameters0;
      type$.nullable_Map_String_String._as(parameters);
      t1 = type$.String;
      parameters0 = A.LinkedHashMap_LinkedHashMap$from(this.parameters, t1, t1);
      parameters0.addAll$1(0, parameters);
      return A.MediaType$(this.type, this.subtype, parameters0);
    },
    toString$0(_) {
      var buffer = new A.StringBuffer(""),
        t1 = "" + this.type;
      buffer._contents = t1;
      t1 += "/";
      buffer._contents = t1;
      buffer._contents = t1 + this.subtype;
      t1 = this.parameters;
      t1._collection$_map.forEach$1(0, t1.$ti._eval$1("~(1,2)")._as(new A.MediaType_toString_closure(buffer)));
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  A.MediaType_MediaType$parse_closure.prototype = {
    call$0() {
      var t3, t4, t5, t6, parameters, t7, success, t8, value,
        t1 = this.mediaType,
        scanner = new A.StringScanner(null, t1),
        t2 = $.$get$whitespace();
      scanner.scan$1(t2);
      t3 = $.$get$token();
      scanner.expect$1(t3);
      t4 = scanner.get$lastMatch().$index(0, 0);
      t4.toString;
      scanner.expect$1("/");
      scanner.expect$1(t3);
      t5 = scanner.get$lastMatch().$index(0, 0);
      t5.toString;
      scanner.scan$1(t2);
      t6 = type$.String;
      parameters = A.LinkedHashMap_LinkedHashMap$_empty(t6, t6);
      while (true) {
        t6 = scanner._lastMatch = B.JSString_methods.matchAsPrefix$2(";", t1, scanner._string_scanner$_position);
        t7 = scanner._lastMatchPosition = scanner._string_scanner$_position;
        success = t6 != null;
        t6 = success ? scanner._lastMatchPosition = scanner._string_scanner$_position = t6.get$end() : t7;
        if (!success)
          break;
        t6 = scanner._lastMatch = t2.matchAsPrefix$2(0, t1, t6);
        scanner._lastMatchPosition = scanner._string_scanner$_position;
        if (t6 != null)
          scanner._lastMatchPosition = scanner._string_scanner$_position = t6.get$end();
        scanner.expect$1(t3);
        if (scanner._string_scanner$_position !== scanner._lastMatchPosition)
          scanner._lastMatch = null;
        t6 = scanner._lastMatch.$index(0, 0);
        t6.toString;
        scanner.expect$1("=");
        t7 = scanner._lastMatch = t3.matchAsPrefix$2(0, t1, scanner._string_scanner$_position);
        t8 = scanner._lastMatchPosition = scanner._string_scanner$_position;
        success = t7 != null;
        if (success) {
          t7 = scanner._lastMatchPosition = scanner._string_scanner$_position = t7.get$end();
          t8 = t7;
        } else
          t7 = t8;
        if (success) {
          if (t7 !== t8)
            scanner._lastMatch = null;
          t7 = scanner._lastMatch.$index(0, 0);
          t7.toString;
          value = t7;
        } else
          value = A.expectQuotedString(scanner);
        t7 = scanner._lastMatch = t2.matchAsPrefix$2(0, t1, scanner._string_scanner$_position);
        scanner._lastMatchPosition = scanner._string_scanner$_position;
        if (t7 != null)
          scanner._lastMatchPosition = scanner._string_scanner$_position = t7.get$end();
        parameters.$indexSet(0, t6, value);
      }
      scanner.expectDone$0();
      return A.MediaType$(t4, t5, parameters);
    },
    $signature: 103
  };
  A.MediaType_toString_closure.prototype = {
    call$2(attribute, value) {
      var t1, t2, t3;
      A._asString(attribute);
      A._asString(value);
      t1 = this.buffer;
      t1._contents += "; " + attribute + "=";
      t2 = $.$get$nonToken();
      t2 = t2._nativeRegExp.test(value);
      t3 = t1._contents;
      if (t2) {
        t1._contents = t3 + '"';
        t2 = A.stringReplaceAllFuncUnchecked(value, $.$get$_escapedChar(), type$.nullable_String_Function_Match._as(type$.String_Function_Match._as(new A.MediaType_toString__closure())), null);
        t2 = t1._contents += t2;
        t1._contents = t2 + '"';
      } else
        t1._contents = t3 + value;
    },
    $signature: 104
  };
  A.MediaType_toString__closure.prototype = {
    call$1(match) {
      return "\\" + A.S(match.$index(0, 0));
    },
    $signature: 27
  };
  A.expectQuotedString_closure.prototype = {
    call$1(match) {
      var t1 = match.$index(0, 1);
      t1.toString;
      return t1;
    },
    $signature: 27
  };
  A.AppPlatform.prototype = {
    _enumToString$0() {
      return "AppPlatform." + this._core$_name;
    }
  };
  A.MrtPlatformInterface.prototype = {};
  A.JSWebSocket_constructor_create_closure.prototype = {
    call$1(e) {
      return A._asString(e);
    },
    $signature: 16
  };
  A.WebEventStream_stream_closure.prototype = {
    call$1($event) {
      var t1 = type$.JSObject._as($event).data;
      t1 = t1 == null ? null : A.dartify(t1);
      this.controller.add$1(0, this.T._as(t1));
    },
    $signature: 25
  };
  A.WebEventStream_stream_closure0.prototype = {
    call$0() {
      this._this.removeEventListener(this.type, this.callback);
    },
    $signature: 11
  };
  A.MrtNativeWeb.prototype = {};
  A.ApiProviderException.prototype = {
    toString$0(_) {
      var t2,
        t1 = this.message;
      if (t1 != null)
        return t1;
      t1 = this.responseData;
      t2 = t1 == null;
      if ((t2 ? null : t1.$index(0, "error")) != null)
        return J.toString$0$(t1.$index(0, "error"));
      if ((t2 ? null : t1.$index(0, "message")) != null)
        return J.toString$0$(t1.$index(0, "message"));
      t1 = this.statusCode;
      if (t1 != null && B.JSArray_methods.contains$1(B.List_cL3, t1))
        return "http_error_" + A.S(t1);
      return "request_error";
    },
    $isException: 1
  };
  A.WalletException.prototype = {
    toString$0(_) {
      if (this._argruments != null)
        return "invalid_request";
      return this.message;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.WalletException))
        return false;
      return other.message === this.message && A.CompareUtils_iterableIsEqual(this._argruments, other._argruments, type$.String);
    },
    get$hashCode(_) {
      return A.Object_hash(this.message, this._argruments, B.C_SentinelValue);
    },
    $isException: 1
  };
  A.Equatable.prototype = {
    $eq(_, other) {
      var t1, t2, i, t3, vi, oI, t4, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!type$.Equatable._is(other))
        return false;
      if (A.getRuntimeTypeOfDartObject(other) !== A.getRuntimeTypeOfDartObject(_this))
        return false;
      if (_this.get$variabels().length !== other.get$variabels().length)
        return false;
      for (t1 = type$.Iterable_dynamic, t2 = type$.dynamic, i = 0; i < _this.get$variabels().length; ++i) {
        t3 = _this.get$variabels();
        if (!(i < t3.length))
          return A.ioore(t3, i);
        vi = t3[i];
        t3 = other.get$variabels();
        if (!(i < t3.length))
          return A.ioore(t3, i);
        oI = t3[i];
        if (t1._is(vi) && t1._is(oI)) {
          if (!A.CompareUtils_iterableIsEqual(vi, oI, t2))
            return false;
        } else {
          t3 = _this.get$variabels();
          if (!(i < t3.length))
            return A.ioore(t3, i);
          t3 = t3[i];
          t4 = other.get$variabels();
          if (!(i < t4.length))
            return A.ioore(t4, i);
          if (!J.$eq$(t3, t4[i]))
            return false;
        }
      }
      return true;
    },
    get$hashCode(_) {
      var t1, t2, result, _i;
      for (t1 = this.get$variabels(), t2 = t1.length, result = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i)
        result = (result ^ J.get$hashCode$(t1[_i])) >>> 0;
      return result;
    }
  };
  A._Live.prototype = {
    toString$0(_) {
      A.LiveListenable__addListener(this);
      return J.toString$0$(this._live$_value);
    },
    $eq(_, o) {
      var t1, _this = this;
      if (o == null)
        return false;
      t1 = _this.$ti;
      if (t1._precomputed1._is(o)) {
        A.LiveListenable__addListener(_this);
        return J.$eq$(_this._live$_value, o);
      }
      if (t1._eval$1("LiveListenable<1>")._is(o)) {
        A.LiveListenable__addListener(_this);
        t1 = _this._live$_value;
        A.LiveListenable__addListener(o);
        return J.$eq$(t1, o._live$_value);
      }
      return false;
    },
    get$hashCode(_) {
      A.LiveListenable__addListener(this);
      return J.get$hashCode$(this._live$_value);
    }
  };
  A.Live.prototype = {};
  A._LiveListenable.prototype = {
    notify$0() {
      var t1, t2, _i;
      for (t1 = A.List_List$of(this._LiveListenable__noneIdsListeners, true, type$.void_Function), t2 = t1.length, _i = 0; _i < t2; ++_i)
        t1[_i].call$0();
    }
  };
  A.LiveListenable.prototype = {
    get$value() {
      return this._live$_value;
    },
    set$value(newValue) {
      var _this = this;
      _this.$ti._precomputed1._as(newValue);
      if (J.$eq$(_this._live$_value, newValue))
        return;
      _this.set$_live$_value(newValue);
      _this.notify$0();
    },
    set$_live$_value(_value) {
      this._live$_value = this.$ti._precomputed1._as(_value);
    }
  };
  A._LiveListenable_Object__LiveListenable.prototype = {};
  A.ContentType.prototype = {
    _enumToString$0() {
      return "ContentType." + this._core$_name;
    },
    get$value() {
      return this.value;
    }
  };
  A.ContentType_fromValue_closure.prototype = {
    call$1(element) {
      return type$.ContentType._as(element).value === this.value;
    },
    $signature: 106
  };
  A.ContentType_fromValue_closure0.prototype = {
    call$0() {
      throw A.wrapException($.$get$WalletExceptionConst_dataVerificationFailed());
    },
    $signature: 107
  };
  A.APPImage.prototype = {};
  A._APPImage_Object_CborSerializable.prototype = {};
  A.CborSerializable.prototype = {};
  A.ExtractCborMap_toMap_closure.prototype = {
    call$1(e) {
      var t1, t2;
      type$.MapEntry_CborObject_CborObject._as(e);
      t1 = this.K;
      t2 = this.V;
      return new A.MapEntry(A.QuickCborObject_getValue(e.key, t1), A.QuickCborObject_getValue(e.value, t2), t1._eval$1("@<0>")._bind$1(t2)._eval$1("MapEntry<1,2>"));
    },
    $signature() {
      return this.K._eval$1("@<0>")._bind$1(this.V)._eval$1("MapEntry<1,2>(MapEntry<CborObject,CborObject>)");
    }
  };
  A.JsonSerialization.prototype = {};
  A.SynchronizedLock.prototype = {
    synchronized$1$1(func, $T) {
      var timeout = null;
      return this.synchronized$body$SynchronizedLock($T._eval$1("0/()")._as(func), $T, $T);
    },
    synchronized$body$SynchronizedLock(func, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, result, complete, t1, t2, timeout, prev, completer;
      var $async$synchronized$1$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              timeout = null;
              prev = $async$self.last;
              completer = new A._SyncCompleter(new A._Future($.Zone__current, type$._Future_void), type$._SyncCompleter_void);
              $async$self.last = completer.future;
              $async$handler = 3;
              $async$goto = prev != null ? 6 : 7;
              break;
            case 6:
              // then
              $async$goto = timeout != null ? 8 : 10;
              break;
            case 8:
              // then
              $async$goto = 11;
              return A._asyncAwait(prev.timeout$1(timeout), $async$synchronized$1$1);
            case 11:
              // returning from await.
              // goto join
              $async$goto = 9;
              break;
            case 10:
              // else
              $async$goto = 12;
              return A._asyncAwait(prev, $async$synchronized$1$1);
            case 12:
              // returning from await.
            case 9:
              // join
            case 7:
              // join
              result = func.call$0();
              $async$goto = result instanceof A._Future ? 13 : 15;
              break;
            case 13:
              // then
              t1 = result;
              if (!$T._eval$1("Future<0>")._is(t1)) {
                $T._as(t1);
                t2 = new A._Future($.Zone__current, $T._eval$1("_Future<0>"));
                t2._state = 8;
                t2._resultOrListeners = t1;
                t1 = t2;
              }
              $async$goto = 16;
              return A._asyncAwait(t1, $async$synchronized$1$1);
            case 16:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              $async$next = [1];
              // goto finally
              $async$goto = 4;
              break;
              // goto join
              $async$goto = 14;
              break;
            case 15:
              // else
              $async$returnValue = result;
              $async$next = [1];
              // goto finally
              $async$goto = 4;
              break;
            case 14:
              // join
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              complete = new A.SynchronizedLock_synchronized_complete($async$self, completer);
              if (prev != null && timeout != null)
                prev.then$1$1(new A.SynchronizedLock_synchronized_closure(complete), type$.Null);
              else
                complete.call$0();
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return A._asyncStartSync($async$synchronized$1$1, $async$completer);
    }
  };
  A.SynchronizedLock_synchronized_complete.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = this.completer;
      if (t1.last === t2.future)
        t1.last = null;
      t2.complete$0();
    },
    $signature: 0
  };
  A.SynchronizedLock_synchronized_closure.prototype = {
    call$1(_) {
      this.complete.call$0();
    },
    $signature: 21
  };
  A.MethodUtils_call_closure.prototype = {
    call$1$0($T) {
      return this.completer;
    },
    call$0() {
      return this.call$1$0(type$.dynamic);
    },
    $signature() {
      return this.T._eval$1("Completer<0>()<Object?>");
    }
  };
  A.MethodResult.prototype = {
    get$error() {
      var t2,
        t1 = this.exception;
      if (t1 == null)
        return null;
      if (!(t1 instanceof A.WalletException))
        if (!type$.BlockchainUtilsException._is(t1))
          if (!(t1 instanceof A.ApiProviderException))
            t2 = t1 instanceof A.ArgumentError;
          else
            t2 = true;
        else
          t2 = true;
      else
        t2 = true;
      if (t2)
        return J.toString$0$(t1);
      return "somthing_wrong";
    },
    toString$0(_) {
      var t1;
      if (this.exception != null)
        return "Error " + A.S(this.get$error());
      t1 = this.__MethodResult__result_F;
      t1 === $ && A.throwLateFieldNI("_result");
      return "Success " + A.S(t1);
    }
  };
  A.StrUtils_toSnakeCase_closure.prototype = {
    call$1(match) {
      return "_" + match.group$1(0).toLowerCase();
    },
    $signature: 27
  };
  A.WebsocketWeb.prototype = {
    WebsocketWeb$_$1(_socket) {
      var _this = this,
        t1 = _this._web$_socket,
        t2 = type$.dynamic;
      _this._onOpen = A.WebEventStream_stream(t1, "open", t2).listen$1(new A.WebsocketWeb$__closure(_this));
      _this._onMessage = A.WebEventStream_stream(t1, "message", t2).listen$1(new A.WebsocketWeb$__closure0(_this));
      _this._web$_onClose = A.WebEventStream_stream(t1, "close", t2).listen$1(new A.WebsocketWeb$__closure1(_this));
    },
    $isPlatformWebScoket: 1
  };
  A.WebsocketWeb$__closure.prototype = {
    call$1($event) {
      var t2,
        t1 = this.$this;
      t1._connectedCompleter.complete$0();
      t2 = t1._onOpen;
      if (t2 != null)
        t2.cancel$0();
      t1._onOpen = null;
    },
    $signature: 12
  };
  A.WebsocketWeb$__closure0.prototype = {
    call$1($event) {
      this.$this._streamController.add$1(0, $event);
    },
    $signature: 12
  };
  A.WebsocketWeb$__closure1.prototype = {
    call$1($event) {
      this.$this._streamController.close$0();
    },
    $signature: 12
  };
  A.WebsocketWeb_connect_closure.prototype = {
    call$1(_) {
      this.completer.complete$1(A.WebsocketWeb$_(this.socket));
    },
    $signature: 108
  };
  A.BaseRepository.prototype = {};
  A.NodeClientStatus.prototype = {
    _enumToString$0() {
      return "NodeClientStatus." + this._core$_name;
    }
  };
  A.NetworkClient.prototype = {
    toString$0(_) {
      return "Client: " + this.get$network().get$coinParam().token.name;
    }
  };
  A._NetworkClient_Object_BaseRepository.prototype = {};
  A.BitcoinElectrumClient.prototype = {
    get$network() {
      return this.network;
    }
  };
  A.BitcoinExplorerApiProvider.prototype = {
    get$network() {
      return this.network;
    }
  };
  A.BitcoinClient.prototype = {};
  A.CardanoClient.prototype = {
    get$network() {
      return this.network;
    }
  };
  A.CosmosClient.prototype = {
    get$network() {
      return this.network;
    }
  };
  A.EthereumClient.prototype = {
    get$network() {
      return this.network;
    }
  };
  A.RippleClient.prototype = {
    get$network() {
      return this.network;
    }
  };
  A.SolanaClient.prototype = {
    get$network() {
      return this.network;
    }
  };
  A.SubstrateClient.prototype = {
    get$network() {
      return this.network;
    }
  };
  A._SubstrateClient_NetworkClient_SubstrateRepository.prototype = {};
  A.SubstrateRepository.prototype = {};
  A.TonClient.prototype = {
    get$network() {
      return this.network;
    }
  };
  A.TronClient.prototype = {
    get$network() {
      return this.network;
    }
  };
  A.ProvidersConst_getDefaultService_closure.prototype = {
    call$1(element) {
      var t1 = type$.APIProvider._as(element).get$protocol().get$platforms();
      $.$get$PlatformInterface_instance();
      return B.JSArray_methods.contains$1(t1, B.AppPlatform_1);
    },
    $signature: 57
  };
  A.ProvidersConst_getDefaultService_closure0.prototype = {
    call$1(element) {
      var t1;
      type$.APIProvider._as(element);
      t1 = this.service;
      return element.serviceName === t1.serviceName && element.get$protocol() === t1.get$protocol();
    },
    $signature: 57
  };
  A.ProvidersConst_getDefaultService_closure1.prototype = {
    call$0() {
      return B.JSArray_methods.get$first(this.networkServices);
    },
    $signature: 28
  };
  A.APIProvider.prototype = {
    toProvider$1$0($T) {
      A.checkTypeBound($T, type$.APIProvider, "T", "toProvider");
      if (!$T._is(this))
        throw A.wrapException($.$get$WalletExceptionConst_invalidProviderInformation());
      return $T._as(this);
    },
    get$variabels() {
      return [this.serviceName, this.websiteUri, this.get$protocol()];
    },
    get$protocol() {
      return this.protocol;
    }
  };
  A._APIProvider_Object_Equatable.prototype = {};
  A._APIProvider_Object_Equatable_CborSerializable.prototype = {};
  A.BitcoinExplorerProviderType.prototype = {
    _enumToString$0() {
      return "BitcoinExplorerProviderType." + this._core$_name;
    },
    get$type() {
      if (this === B.BitcoinExplorerProviderType_0)
        return B.APIType_1;
      return B.APIType_0;
    }
  };
  A.BitcoinExplorerProviderType_fromName_closure.prototype = {
    call$1(element) {
      return type$.BitcoinExplorerProviderType._as(element)._core$_name === this.name;
    },
    $signature: 111
  };
  A.BitcoinExplorerProviderType_fromName_closure0.prototype = {
    call$0() {
      return A.throwExpression($.$get$WalletExceptionConst_invalidProviderInformation());
    },
    $signature: 2
  };
  A.BitcoinExplorerAPIProvider.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.serviceName, _this.websiteUri, _this.uri, _this.protocol];
    }
  };
  A.BitcoinExplorerAPIProvider_BitcoinExplorerAPIProvider$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.ProviderAuth_ProviderAuth$fromCborBytesOrObject(type$.CborTagValue_dynamic._as(e));
    },
    $signature: 10
  };
  A.ElectrumAPIProvider.prototype = {
    get$protocol() {
      if (this.websocket != null)
        return B.ServiceProtocol_WebSocket_3_websocket;
      else if (this.tcp != null)
        return B.ServiceProtocol_TCP_2_tcp;
      return B.ServiceProtocol_SSL_1_ssl;
    },
    get$endpoint() {
      var t1 = this.websocket;
      if (t1 != null)
        return t1;
      else {
        t1 = this.tcp;
        if (t1 != null)
          return t1;
      }
      t1 = this.ssl;
      t1.toString;
      return t1;
    }
  };
  A.ElectrumAPIProvider_ElectrumAPIProvider$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.ProviderAuth_ProviderAuth$fromCborBytesOrObject(type$.CborTagValue_dynamic._as(e));
    },
    $signature: 10
  };
  A.BaseBitcoinAPIProvider.prototype = {};
  A.CardanoAPIProvider.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.serviceName, _this.websiteUri, _this.uri, _this.protocol];
    }
  };
  A.CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.ProviderAuth_ProviderAuth$fromCborBytesOrObject(type$.CborTagValue_dynamic._as(e));
    },
    $signature: 10
  };
  A.CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject_closure0.prototype = {
    call$1(e) {
      return new A.ProviderAuth(A._asString(e));
    },
    $signature: 113
  };
  A.CosmosAPIProvider.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.serviceName, _this.websiteUri, _this.uri, _this.protocol];
    }
  };
  A.CosmosAPIProvider_CosmosAPIProvider$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.ProviderAuth_ProviderAuth$fromCborBytesOrObject(type$.CborTagValue_dynamic._as(e));
    },
    $signature: 10
  };
  A.EthereumAPIProvider.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.serviceName, _this.websiteUri, _this.uri, _this.protocol];
    }
  };
  A.EthereumAPIProvider_EthereumAPIProvider$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.ProviderAuth_ProviderAuth$fromCborBytesOrObject(type$.CborTagValue_dynamic._as(e));
    },
    $signature: 10
  };
  A.RippleAPIProvider.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.serviceName, _this.websiteUri, _this.uri, _this.protocol];
    }
  };
  A.RippleAPIProvider_RippleAPIProvider$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.ProviderAuth_ProviderAuth$fromCborBytesOrObject(type$.CborTagValue_dynamic._as(e));
    },
    $signature: 10
  };
  A.SolanaAPIProvider.prototype = {};
  A.SolanaAPIProvider_SolanaAPIProvider$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.ProviderAuth_ProviderAuth$fromCborBytesOrObject(type$.CborTagValue_dynamic._as(e));
    },
    $signature: 10
  };
  A.SubstrateAPIProvider.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.serviceName, _this.websiteUri, _this.uri, _this.protocol];
    }
  };
  A.SubstrateAPIProvider_SubstrateAPIProvider$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.ProviderAuth_ProviderAuth$fromCborBytesOrObject(type$.CborTagValue_dynamic._as(e));
    },
    $signature: 10
  };
  A.TonAPIProvider.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.serviceName, _this.websiteUri, _this.uri, _this.protocol];
    }
  };
  A.TonAPIProvider_TonAPIProvider$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.ProviderAuth_ProviderAuth$fromCborBytesOrObject(type$.CborTagValue_dynamic._as(e));
    },
    $signature: 10
  };
  A.TronAPIProvider.prototype = {};
  A.TronAPIProvider_TronAPIProvider$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.ProviderAuth_ProviderAuth$fromCborBytesOrObject(type$.CborTagValue_dynamic._as(e));
    },
    $signature: 10
  };
  A.APIServiceTracker.prototype = {
    _checkStatus$0() {
      var t3,
        t1 = this._requests,
        t2 = A._arrayInstanceType(t1);
      t2 = this._totalSuccess = new A.WhereIterable(t1, t2._eval$1("bool(1)")._as(new A.APIServiceTracker__checkStatus_closure()), t2._eval$1("WhereIterable<1>")).get$length(0);
      t1 = t1.length;
      t3 = t1 - t2;
      this._totalError = t3;
      if (t1 === 0 || t2 === t1)
        return B.APIServiceStatus_0;
      if (t3 === t1)
        return B.APIServiceStatus_2;
      return B.APIServiceStatus_1;
    },
    _updateStatus$0() {
      var updateStatus = this._checkStatus$0(),
        t1 = this._tracker$_status;
      A.LiveListenable__addListener(t1);
      if (t1._live$_value !== updateStatus)
        t1.super$LiveListenable$value(t1.$ti._precomputed1._as(updateStatus));
    }
  };
  A.APIServiceTracker__checkStatus_closure.prototype = {
    call$1(element) {
      return type$.ApiRequest._as(element).error == null;
    },
    $signature: 114
  };
  A.HTTPService.prototype = {
    providerPOST$1$4$headers$timeout(url, params, headers, timeout, $T) {
      var allowStatus = B.List_200;
      return this.providerPOST$body$HTTPService(url, params, type$.nullable_Map_String_String._as(headers), timeout, $T, $T);
    },
    providerPOST$1$2(url, params, $T) {
      return this.providerPOST$1$4$headers$timeout(url, params, null, null, $T);
    },
    providerPOST$body$HTTPService(url, params, headers, timeout, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, e, t1, exception, allowStatus, response, $async$exception;
      var $async$providerPOST$1$4$headers$timeout = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              allowStatus = B.List_200;
              response = null;
              $async$handler = 4;
              $async$goto = 7;
              return A._asyncAwait($async$self._onException$1$2$allowStatus(new A.HTTPService_providerPOST_closure($async$self, url, headers, params, timeout), allowStatus, $T), $async$providerPOST$1$4$headers$timeout);
            case 7:
              // returning from await.
              response = $async$result;
              t1 = response;
              t1.toString;
              $async$returnValue = t1;
              $async$next = [1];
              // goto finally
              $async$goto = 5;
              break;
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t1 = A.unwrapException($async$exception);
              if (t1 instanceof A.ApiProviderException) {
                e = t1;
                t1 = $async$self.tracker;
                new A.DateTime(Date.now(), false).toLocal$0();
                B.JSArray_methods.add$1(t1._requests, new A.ApiRequest(e));
                t1._updateStatus$0();
                throw $async$exception;
              } else
                throw $async$exception;
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 5:
              // finally
              $async$handler = 2;
              if (response != null) {
                t1 = $async$self.tracker;
                J.toString$0$(response);
                new A.DateTime(Date.now(), false).toLocal$0();
                B.JSArray_methods.add$1(t1._requests, new A.ApiRequest(null));
                t1._updateStatus$0();
              }
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return A._asyncStartSync($async$providerPOST$1$4$headers$timeout, $async$completer);
    },
    _onException$1$2$allowStatus(t, allowStatus, $T) {
      return this._onException$body$HTTPService(type$.Future_Response_Function._as(t), type$.List_int._as(allowStatus), $T, $T);
    },
    _onException$body$HTTPService(t, allowStatus, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$self = this, response, decode, map, e, t1, t2, exception, $async$exception;
      var $async$_onException$1$2$allowStatus = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              $async$goto = 7;
              return A._asyncAwait(t.call$0(), $async$_onException$1$2$allowStatus);
            case 7:
              // returning from await.
              response = $async$result;
              if (!B.JSArray_methods.contains$1(allowStatus, response.statusCode)) {
                t1 = response;
                decode = A.StringUtils_tryToJson(A.encodingForCharset(A._contentTypeForHeaders(t1.headers).parameters._collection$_map.$index(0, "charset")).decode$1(t1.bodyBytes), type$.dynamic);
                map = type$.nullable_Map_String_dynamic._is(decode) ? decode : null;
                t1 = response.statusCode;
                t2 = map == null ? response.get$body() : null;
                t1 = A.ApiProviderException$(null, t2, null, map, t1);
                throw A.wrapException(t1);
              }
              t1 = $async$self._readResponse$1$1(response, $T);
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t1 = A.unwrapException($async$exception);
              if (t1 instanceof A.ClientException)
                throw A.wrapException(B.ApiProviderException_api_http_client_error_null_null);
              else if (t1 instanceof A.ApiProviderException)
                throw $async$exception;
              else if (t1 instanceof A.TimeoutException)
                throw A.wrapException(B.ApiProviderException_api_http_timeout_error_null_null);
              else if (type$.FormatException._is(t1))
                throw A.wrapException(B.ApiProviderException_invalid_json_response_null_null);
              else if (t1 instanceof A.ArgumentError) {
                e = t1;
                throw A.wrapException(A.ApiProviderException$(null, J.toString$0$(e.message), null, null, null));
              } else
                throw A.wrapException(B.ApiProviderException_api_unknown_error_null_null);
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return A._asyncStartSync($async$_onException$1$2$allowStatus, $async$completer);
    },
    _readResponse$1$1(response, $T) {
      var t1, exception,
        $toString = A.StringUtils_decode(response.bodyBytes, false, B.StringEncoding_1),
        _0_0 = A.createRuntimeType($T);
      if (B.Type_String_J2O === _0_0)
        return $T._as($toString);
      if (B.Type_List_qco === _0_0 || B.Type_Map_G6F === _0_0)
        return $T._as(A.StringUtils_toJson($toString, type$.dynamic));
      try {
        t1 = $T._as(A.StringUtils_toJson($toString, type$.dynamic));
        return t1;
      } catch (exception) {
        throw A.wrapException(B.ApiProviderException_invalid_request_type_null_null);
      }
    }
  };
  A.HTTPService_providerPOST_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Response),
        $async$returnValue, $async$self = this, t1, t2, t3;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $.$get$HTTPService__client();
              t2 = A.Uri_parse($async$self.url);
              t3 = $async$self.headers;
              if (t3 == null) {
                t3 = type$.String;
                t3 = A.LinkedHashMap_LinkedHashMap$_literal(["Content-Type", "application/json"], t3, t3);
              }
              t3 = t1._sendUnstreamed$5("POST", t2, type$.nullable_Map_String_String._as(t3), $async$self.params, null);
              t2 = $async$self.timeout;
              $async$goto = 3;
              return A._asyncAwait(t3.timeout$1(t2 == null ? $async$self.$this.get$defaultTimeOut() : t2), $async$call$0);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 115
  };
  A.BaseSocketService.prototype = {
    providerCaller$2(t, param) {
      return this.providerCaller$body$BaseSocketService(type$.Future_Map_String_dynamic_Function._as(t), param);
    },
    providerCaller$body$BaseSocketService(t, param) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, e, t1, exception, response, $async$exception;
      var $async$providerCaller$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              response = null;
              $async$handler = 4;
              $async$goto = 7;
              return A._asyncAwait($async$self._socket_provider$_onException$1(t), $async$providerCaller$2);
            case 7:
              // returning from await.
              response = $async$result;
              t1 = response;
              $async$returnValue = t1;
              $async$next = [1];
              // goto finally
              $async$goto = 5;
              break;
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t1 = A.unwrapException($async$exception);
              if (t1 instanceof A.ApiProviderException) {
                e = t1;
                t1 = $async$self.get$tracker();
                new A.DateTime(Date.now(), false).toLocal$0();
                B.JSArray_methods.add$1(t1._requests, new A.ApiRequest(e));
                t1._updateStatus$0();
                throw $async$exception;
              } else
                throw $async$exception;
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 5:
              // finally
              $async$handler = 2;
              if (response != null) {
                t1 = $async$self.get$tracker();
                J.toString$0$(response);
                new A.DateTime(Date.now(), false).toLocal$0();
                B.JSArray_methods.add$1(t1._requests, new A.ApiRequest(null));
                t1._updateStatus$0();
              }
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return A._asyncStartSync($async$providerCaller$2, $async$completer);
    },
    _socket_provider$_onException$1(t) {
      return this._onException$body$BaseSocketService(type$.Future_Map_String_dynamic_Function._as(t));
    },
    _onException$body$BaseSocketService(t) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$self = this, response, e, exception, t1, $async$exception;
      var $async$_socket_provider$_onException$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              $async$goto = 7;
              return A._asyncAwait($async$self.connect$0().timeout$1(B.Duration_30000000), $async$_socket_provider$_onException$1);
            case 7:
              // returning from await.
              if (!$async$self.get$isConnected())
                throw A.wrapException(B.ApiProviderException_node_connection_error_null_null);
              $async$goto = 8;
              return A._asyncAwait(t.call$0(), $async$_socket_provider$_onException$1);
            case 8:
              // returning from await.
              response = $async$result;
              $async$returnValue = response;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              t1 = A.unwrapException($async$exception);
              if (t1 instanceof A.ApiProviderException)
                throw $async$exception;
              else if (t1 instanceof A.TimeoutException)
                throw A.wrapException(B.ApiProviderException_api_http_timeout_error_null_null);
              else if (t1 instanceof A.ArgumentError) {
                e = t1;
                throw A.wrapException(A.ApiProviderException$(null, J.toString$0$(e.message), null, null, null));
              } else
                throw A.wrapException(B.ApiProviderException_api_unknown_error_null_null);
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return A._asyncStartSync($async$_socket_provider$_onException$1, $async$completer);
    }
  };
  A.SSLService.prototype = {
    get$isConnected() {
      return this._ssl$_status === B.SocketStatus_0;
    },
    connect$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this;
      var $async$connect$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return A._asyncAwait($async$self._ssl$_lock.synchronized$1$1(new A.SSLService_connect_closure($async$self), type$.Null), $async$connect$0);
            case 2:
              // returning from await.
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$connect$0, $async$completer);
    },
    post$2(message, timeout) {
      return this.post$body$SSLService(message, timeout);
    },
    post$body$SSLService(message, timeout) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$next = [], $async$self = this, t1;
      var $async$post$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              try {
                t1 = $async$self.providerCaller$2(new A.SSLService_post_closure($async$self, message, timeout), message);
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
              } finally {
                $async$self._ssl$_requests.remove$1(0, message.id);
              }
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$post$2, $async$completer);
    },
    set$_ssl$_socket(_socket) {
      this._ssl$_socket = type$.nullable_SecureSocket._as(_socket);
    },
    set$_ssl$_subscription(_subscription) {
      this._ssl$_subscription = type$.nullable_StreamSubscription_List_int._as(_subscription);
    },
    get$tracker() {
      return this.tracker;
    }
  };
  A.SSLService_connect_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Null),
        $async$returnValue, $async$self = this, result, t2, t1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              if (t1._ssl$_status !== B.SocketStatus_1) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return A._asyncAwait(A.MethodUtils_call(new A.SSLService_connect__closure(t1), type$.SecureSocket), $async$call$0);
            case 3:
              // returning from await.
              result = $async$result;
              if (result.exception == null) {
                t1._ssl$_status = B.SocketStatus_0;
                t2 = result.__MethodResult__result_F;
                t2 === $ && A.throwLateFieldNI("_result");
                t1.set$_ssl$_socket(t2);
                t1.set$_ssl$_subscription(null);
              } else
                t1._ssl$_status = B.SocketStatus_1;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 18
  };
  A.SSLService_connect__closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.SecureSocket),
        $async$returnValue, $async$self = this, result, t1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              result = $async$self.$this.url.split(":");
              t1 = B.JSArray_methods.get$first(result);
              if (1 >= result.length) {
                $async$returnValue = A.ioore(result, 1);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return A._asyncAwait(A.SecureSocket_connect(t1, A.int_parse(result[1], null), A.SecurityContext_defaultContext(), new A.SSLService_connect___closure()), $async$call$0);
            case 3:
              // returning from await.
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 116
  };
  A.SSLService_connect___closure.prototype = {
    call$1(certificate) {
      return true;
    },
    $signature: 61
  };
  A.SSLService_post_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$self = this, result, t1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.message;
              $async$self.$this._ssl$_requests.$indexSet(0, t1.id, t1);
              type$.List_int._as(A.StringUtils_encode(t1.params + "\n", B.StringEncoding_1));
              $async$goto = 3;
              return A._asyncAwait(t1.completer.future.timeout$1($async$self.timeout), $async$call$0);
            case 3:
              // returning from await.
              result = $async$result;
              $async$returnValue = type$.FutureOr_Map_String_dynamic._as(result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 30
  };
  A.TCPService.prototype = {
    get$isConnected() {
      return this._tcp$_status === B.SocketStatus_0;
    },
    connect$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this;
      var $async$connect$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return A._asyncAwait($async$self._tcp$_lock.synchronized$1$1(new A.TCPService_connect_closure($async$self), type$.Null), $async$connect$0);
            case 2:
              // returning from await.
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$connect$0, $async$completer);
    },
    post$2(message, timeout) {
      return this.post$body$TCPService(message, timeout);
    },
    post$body$TCPService(message, timeout) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$next = [], $async$self = this, t1;
      var $async$post$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              try {
                t1 = $async$self.providerCaller$2(new A.TCPService_post_closure($async$self, message, timeout), message);
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
              } finally {
                $async$self._tcp$_requests.remove$1(0, message.id);
              }
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$post$2, $async$completer);
    },
    set$_tcp$_socket(_socket) {
      this._tcp$_socket = type$.nullable_Socket._as(_socket);
    },
    set$_tcp$_subscription(_subscription) {
      this._tcp$_subscription = type$.nullable_StreamSubscription_List_int._as(_subscription);
    },
    get$tracker() {
      return this.tracker;
    }
  };
  A.TCPService_connect_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Null),
        $async$returnValue, $async$self = this, result, t2, t1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              if (t1._tcp$_status !== B.SocketStatus_1) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return A._asyncAwait(A.MethodUtils_call(new A.TCPService_connect__closure(t1), type$.Socket), $async$call$0);
            case 3:
              // returning from await.
              result = $async$result;
              if (result.exception == null) {
                t1._tcp$_status = B.SocketStatus_0;
                t2 = result.__MethodResult__result_F;
                t2 === $ && A.throwLateFieldNI("_result");
                t1.set$_tcp$_socket(t2);
                t1.set$_tcp$_subscription(null);
              } else
                t1._tcp$_status = B.SocketStatus_1;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 18
  };
  A.TCPService_connect__closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Socket),
        $async$returnValue, $async$self = this, result, t1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              result = $async$self.$this.url.split(":");
              t1 = B.JSArray_methods.get$first(result);
              if (1 >= result.length) {
                $async$returnValue = A.ioore(result, 1);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return A._asyncAwait(A.Socket_connect(t1, A.int_parse(result[1], null)), $async$call$0);
            case 3:
              // returning from await.
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 118
  };
  A.TCPService_post_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$self = this, result, t1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.message;
              $async$self.$this._tcp$_requests.$indexSet(0, t1.id, t1);
              type$.List_int._as(A.StringUtils_encode(t1.params + "\n", B.StringEncoding_1));
              $async$goto = 3;
              return A._asyncAwait(t1.completer.future.timeout$1($async$self.timeout), $async$call$0);
            case 3:
              // returning from await.
              result = $async$result;
              $async$returnValue = type$.FutureOr_Map_String_dynamic._as(result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 30
  };
  A.WebSocketService.prototype = {
    get$isConnected() {
      return this._websocket$_status === B.SocketStatus_0;
    },
    _onClose$0() {
      var t1, t2, _this = this;
      _this._websocket$_status = B.SocketStatus_1;
      t1 = _this._socket;
      if (t1 != null) {
        t2 = t1._web$_socket;
        if (A._asInt(t2.readyState) !== 3)
          t2.close(1000, null);
        t2 = t1._onOpen;
        if (t2 != null)
          t2.cancel$0();
        t2 = t1._onMessage;
        if (t2 != null)
          t2.cancel$0();
        t2 = t1._web$_onClose;
        if (t2 != null)
          t2.cancel$0();
        t1._onOpen = t1._onMessage = t1._web$_onClose = null;
      }
      t1 = _this._websocket$_subscription;
      if (t1 != null)
        t1._source.cancel$0().catchError$1(new A.WebSocketService__onClose_closure());
      _this.set$_websocket$_subscription(null);
      _this._socket = null;
    },
    _onMessge$1($event) {
      var t1, request,
        decode = A.StringUtils_toJson(A._asString($event), type$.Map_String_dynamic);
      if (decode.containsKey$1("id")) {
        t1 = decode.$index(0, "id");
        t1.toString;
        request = this._websocket$_requests.remove$1(0, A.int_parse(J.toString$0$(t1), null));
        if (request != null)
          request.completer.complete$1(decode);
      }
    },
    connect$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this;
      var $async$connect$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return A._asyncAwait($async$self._websocket$_lock.synchronized$1$1(new A.WebSocketService_connect_closure($async$self), type$.Null), $async$connect$0);
            case 2:
              // returning from await.
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$connect$0, $async$completer);
    },
    addMessage$2(message, timeout) {
      return this.addMessage$body$WebSocketService(message, timeout);
    },
    addMessage$body$WebSocketService(message, timeout) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$next = [], $async$self = this, t1;
      var $async$addMessage$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              try {
                t1 = $async$self.providerCaller$2(new A.WebSocketService_addMessage_closure($async$self, message, timeout), message);
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
              } finally {
                $async$self._websocket$_requests.remove$1(0, message.id);
              }
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$addMessage$2, $async$completer);
    },
    set$_socket(_socket) {
      this._socket = type$.nullable_PlatformWebScoket._as(_socket);
    },
    set$_websocket$_subscription(_subscription) {
      this._websocket$_subscription = type$.nullable_StreamSubscription_String._as(_subscription);
    },
    get$tracker() {
      return this.tracker;
    }
  };
  A.WebSocketService__onClose_closure.prototype = {
    call$1(e) {
    },
    $signature: 21
  };
  A.WebSocketService_connect_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Null),
        $async$returnValue, $async$self = this, result, t2, t3, t1;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              if (t1._websocket$_status !== B.SocketStatus_1) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return A._asyncAwait(A.MethodUtils_call(new A.WebSocketService_connect__closure(t1), type$.PlatformWebScoket), $async$call$0);
            case 3:
              // returning from await.
              result = $async$result;
              t2 = result.exception;
              if (t2 == null) {
                t1._websocket$_status = B.SocketStatus_0;
                t2 = result.__MethodResult__result_F;
                t2 === $ && A.throwLateFieldNI("_result");
                t1.set$_socket(t2);
                t2 = t1._socket;
                if (t2 == null)
                  t2 = null;
                else {
                  t2 = t2._streamController;
                  t3 = A._instanceType(t2)._eval$1("_ControllerStream<1>");
                  t3 = new A.CastStream(new A._ControllerStream(t2, t3), t3._eval$1("CastStream<Stream.T,String>")).listen$2$onDone(t1.get$_onMessge(), t1.get$_onClose());
                  t2 = t3;
                }
                t1.set$_websocket$_subscription(t2);
              } else {
                t1._websocket$_status = B.SocketStatus_1;
                throw A.wrapException(t2);
              }
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 18
  };
  A.WebSocketService_connect__closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.PlatformWebScoket),
        $async$returnValue, $async$self = this;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return A._asyncAwait(A.PlatformWebScoket_connect($async$self.$this.url), $async$call$0);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 120
  };
  A.WebSocketService_addMessage_closure.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$self = this, result, t3, t1, t2;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = $async$self.message;
              t1._websocket$_requests.$indexSet(0, t2.id, t2);
              t3 = type$.List_int._as(A.StringUtils_encode(t2.params, B.StringEncoding_1));
              t1 = t1._socket;
              if (t1 != null)
                t1._web$_socket.send(new Uint8Array(A._ensureNativeList(t3)).buffer);
              $async$goto = 3;
              return A._asyncAwait(t2.completer.future.timeout$1($async$self.timeout), $async$call$0);
            case 3:
              // returning from await.
              result = $async$result;
              $async$returnValue = type$.FutureOr_Map_String_dynamic._as(result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 30
  };
  A.ProviderAuthType.prototype = {
    _enumToString$0() {
      return "ProviderAuthType." + this._core$_name;
    }
  };
  A.ProviderAuthType_fromName_closure.prototype = {
    call$1(e) {
      return type$.ProviderAuthType._as(e)._core$_name === this.name;
    },
    $signature: 121
  };
  A.ProviderAuthType_fromName_closure0.prototype = {
    call$0() {
      return A.throwExpression($.$get$WalletExceptionConst_invalidProviderInformation());
    },
    $signature: 2
  };
  A.ProviderAuth.prototype = {
    get$value() {
      return this.value;
    }
  };
  A._ProviderAuth_Object_CborSerializable.prototype = {};
  A.ServiceProtocol.prototype = {
    _enumToString$0() {
      return "ServiceProtocol." + this._core$_name;
    },
    get$platforms() {
      switch (this) {
        case B.ServiceProtocol_HTTP_0_http:
        case B.ServiceProtocol_WebSocket_3_websocket:
          return B.List_adS;
        default:
          return A._setArrayType([B.AppPlatform_2, B.AppPlatform_0, B.AppPlatform_3, B.AppPlatform_4], type$.JSArray_AppPlatform);
      }
    },
    toString$0(_) {
      return this.value;
    },
    get$value() {
      return this.value;
    }
  };
  A.ServiceProtocol_fromID_closure.prototype = {
    call$1(element) {
      return type$.ServiceProtocol._as(element).id === this.id;
    },
    $signature: 122
  };
  A.ApiRequest.prototype = {};
  A.SocketRequestCompeleter.prototype = {};
  A.SocketStatus.prototype = {
    _enumToString$0() {
      return "SocketStatus." + this._core$_name;
    }
  };
  A.APIServiceStatus.prototype = {
    _enumToString$0() {
      return "APIServiceStatus." + this._core$_name;
    }
  };
  A.ElectrumSSLSocketService.prototype = {
    call$2(params, timeout) {
      return this.$call$body$ElectrumSSLSocketService(type$.ElectrumRequestDetails._as(params), type$.nullable_Duration._as(timeout));
    },
    call$1(params) {
      return this.call$2(params, null);
    },
    $call$body$ElectrumSSLSocketService(params, timeout) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$self = this, t1, t2, t3, t4;
      var $async$call$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = B.C_JsonCodec.encode$2$toEncodable(params.get$params(), null);
              t2 = params.get$id();
              t3 = $.Zone__current;
              t4 = timeout == null ? B.Duration_30000000 : timeout;
              $async$goto = 3;
              return A._asyncAwait($async$self.post$2(new A.SocketRequestCompeleter(new A._AsyncCompleter(new A._Future(t3, type$._Future_dynamic), type$._AsyncCompleter_dynamic), t1, t2), t4), $async$call$2);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$2, $async$completer);
    }
  };
  A.ElectrumSocketService.prototype = {
    call$2(params, timeout) {
      return this.$call$body$ElectrumSocketService(type$.ElectrumRequestDetails._as(params), type$.nullable_Duration._as(timeout));
    },
    call$1(params) {
      return this.call$2(params, null);
    },
    $call$body$ElectrumSocketService(params, timeout) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$self = this, t1, t2, t3, t4;
      var $async$call$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = B.C_JsonCodec.encode$2$toEncodable(params.get$params(), null);
              t2 = params.get$id();
              t3 = $.Zone__current;
              t4 = timeout == null ? B.Duration_30000000 : timeout;
              $async$goto = 3;
              return A._asyncAwait($async$self.post$2(new A.SocketRequestCompeleter(new A._AsyncCompleter(new A._Future(t3, type$._Future_dynamic), type$._AsyncCompleter_dynamic), t1, t2), t4), $async$call$2);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$2, $async$completer);
    }
  };
  A.ElectrumWebsocketService.prototype = {
    call$2(params, timeout) {
      return this.$call$body$ElectrumWebsocketService(type$.ElectrumRequestDetails._as(params), type$.nullable_Duration._as(timeout));
    },
    call$1(params) {
      return this.call$2(params, null);
    },
    $call$body$ElectrumWebsocketService(params, timeout) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$self = this, t1, t2, t3, t4;
      var $async$call$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = B.C_JsonCodec.encode$2$toEncodable(params.get$params(), null);
              t2 = params.get$id();
              t3 = $.Zone__current;
              t4 = timeout == null ? B.Duration_30000000 : timeout;
              $async$goto = 3;
              return A._asyncAwait($async$self.addMessage$2(new A.SocketRequestCompeleter(new A._AsyncCompleter(new A._Future(t3, type$._Future_dynamic), type$._AsyncCompleter_dynamic), t1, t2), t4), $async$call$2);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$2, $async$completer);
    }
  };
  A.RippleHTTPService.prototype = {
    call$1(params) {
      return this.$call$body$RippleHTTPService(type$.RPCRequestDetails._as(params));
    },
    $call$body$RippleHTTPService(params) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$self = this;
      var $async$call$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return A._asyncAwait($async$self.providerPOST$1$2($async$self.url, B.C_JsonCodec.encode$2$toEncodable(params.toJsonRpcParams$0(), null), type$.Map_String_dynamic), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$1, $async$completer);
    },
    get$defaultTimeOut() {
      return B.Duration_30000000;
    }
  };
  A.RippleWebsocketService.prototype = {
    call$2(params, timeout) {
      return this.$call$body$RippleWebsocketService(type$.RPCRequestDetails._as(params), type$.nullable_Duration._as(timeout));
    },
    call$1(params) {
      return this.call$2(params, null);
    },
    $call$body$RippleWebsocketService(params, timeout) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.Map_String_dynamic),
        $async$returnValue, $async$self = this, t1, t2, t3, t4;
      var $async$call$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = B.C_JsonCodec.encode$2$toEncodable(params.toWebsocketParams$0(), null);
              t2 = params.get$id();
              t3 = $.Zone__current;
              t4 = timeout == null ? B.Duration_30000000 : timeout;
              $async$goto = 3;
              return A._asyncAwait($async$self.addMessage$2(new A.SocketRequestCompeleter(new A._AsyncCompleter(new A._Future(t3, type$._Future_dynamic), type$._AsyncCompleter_dynamic), t1, t2), t4), $async$call$2);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$2, $async$completer);
    }
  };
  A.Chain.prototype = {$isBaseChain: 1};
  A.Chain_Chain$fromCborBytesOrObject_closure.prototype = {
    call$0() {
      return A.WalletNetwork_fromCborBytesOrObject(A.ExtractCborList_getCborTag(this.values, 0));
    },
    $signature: 55
  };
  A.Chain_Chain$fromCborBytesOrObject_closure0.prototype = {
    call$0() {
      var t1 = this._box_0.network;
      t1.toString;
      return A.APIProvider_APIProvider$fromCborBytesOrObject(t1, A.ExtractCborList_getCborTag(this.values, 1));
    },
    $signature: 28
  };
  A.Chain_Chain$fromCborBytesOrObject_closure1.prototype = {
    call$0() {
      return A.WalletNetwork_fromCborBytesOrObject(A.ExtractCborList_getCborTag(this.values, 6));
    },
    $signature: 55
  };
  A.Chain_Chain$fromCborBytesOrObject_closure2.prototype = {
    call$0() {
      var t1 = this._box_0.network;
      t1.toString;
      return A.APIProvider_APIProvider$fromCborBytesOrObject(t1, A.ExtractCborList_getCborTag(this.values, 7));
    },
    $signature: 28
  };
  A.ADAChain.prototype = {};
  A.ADAChain_ADAChain$deserialize_closure.prototype = {
    call$0() {
      return A.CryptoAddress_fromCbor(this.network, this.i).cast$1$0(0, type$.ICardanoAddress);
    },
    $signature: 124
  };
  A.ADAChain_ADAChain$deserialize_closure0.prototype = {
    call$1(e) {
      return A.ContactCore_fromCborBytesOrObject(this.network, type$.nullable_CborObject._as(e), type$.ADAAddress);
    },
    $signature: 125
  };
  A.ADAChain_ADAChain$deserialize_closure1.prototype = {
    call$1(e) {
      return A.Web3Permission_Web3Permission$deserialize(type$.nullable_CborObject._as(e), type$.ADAAddress);
    },
    $signature: 126
  };
  A.BitcoinChain.prototype = {};
  A.BitcoinChain_BitcoinChain$deserialize_closure.prototype = {
    call$0() {
      return A.CryptoAddress_fromCbor(this.network, this.i).cast$1$0(0, type$.IBitcoinAddress);
    },
    $signature: 127
  };
  A.BitcoinChain_BitcoinChain$deserialize_closure0.prototype = {
    call$1(e) {
      return A.ContactCore_fromCborBytesOrObject(this.network, type$.nullable_CborObject._as(e), type$.BitcoinBaseAddress);
    },
    $signature: 128
  };
  A.BitcoinChain_BitcoinChain$deserialize_closure1.prototype = {
    call$1(e) {
      return A.Web3Permission_Web3Permission$deserialize(type$.nullable_CborObject._as(e), type$.BitcoinBaseAddress);
    },
    $signature: 129
  };
  A.CosmosChain.prototype = {};
  A.CosmosChain_CosmosChain$deserialize_closure.prototype = {
    call$0() {
      return A.CryptoAddress_fromCbor(this.network, this.i).cast$1$0(0, type$.ICosmosAddress);
    },
    $signature: 130
  };
  A.CosmosChain_CosmosChain$deserialize_closure0.prototype = {
    call$1(e) {
      return A.ContactCore_fromCborBytesOrObject(this.network, type$.nullable_CborObject._as(e), type$.CosmosBaseAddress);
    },
    $signature: 131
  };
  A.CosmosChain_CosmosChain$deserialize_closure1.prototype = {
    call$1(e) {
      return A.Web3Permission_Web3Permission$deserialize(type$.nullable_CborObject._as(e), type$.CosmosBaseAddress);
    },
    $signature: 132
  };
  A.EthereumChain.prototype = {};
  A.EthereumChain_EthereumChain$deserialize_closure.prototype = {
    call$0() {
      return A.CryptoAddress_fromCbor(this.network, this.i).cast$1$0(0, type$.IEthAddress);
    },
    $signature: 133
  };
  A.EthereumChain_EthereumChain$deserialize_closure0.prototype = {
    call$1(e) {
      return A.ContactCore_fromCborBytesOrObject(this.network, type$.nullable_CborObject._as(e), type$.ETHAddress);
    },
    $signature: 134
  };
  A.EthereumChain_EthereumChain$deserialize_closure1.prototype = {
    call$1(e) {
      return A.Web3Permission_Web3Permission$deserialize(type$.nullable_CborObject._as(e), type$.ETHAddress);
    },
    $signature: 135
  };
  A.SolanaChain.prototype = {};
  A.SolanaChain_SolanaChain$deserialize_closure.prototype = {
    call$0() {
      return A.CryptoAddress_fromCbor(this.network, this.i).cast$1$0(0, type$.ISolanaAddress);
    },
    $signature: 136
  };
  A.SolanaChain_SolanaChain$deserialize_closure0.prototype = {
    call$1(e) {
      return A.ContactCore_fromCborBytesOrObject(this.network, type$.nullable_CborObject._as(e), type$.SolAddress);
    },
    $signature: 137
  };
  A.SolanaChain_SolanaChain$deserialize_closure1.prototype = {
    call$1(e) {
      return A.Web3Permission_Web3Permission$deserialize(type$.nullable_CborObject._as(e), type$.SolAddress);
    },
    $signature: 138
  };
  A.SubstrateChain.prototype = {};
  A.SubstrateChain_SubstrateChain$deserialize_closure.prototype = {
    call$0() {
      return A.CryptoAddress_fromCbor(this.network, this.i).cast$1$0(0, type$.ISubstrateAddress);
    },
    $signature: 139
  };
  A.SubstrateChain_SubstrateChain$deserialize_closure0.prototype = {
    call$1(e) {
      return A.ContactCore_fromCborBytesOrObject(this.network, type$.nullable_CborObject._as(e), type$.SubstrateAddress);
    },
    $signature: 140
  };
  A.SubstrateChain_SubstrateChain$deserialize_closure1.prototype = {
    call$1(e) {
      return A.Web3Permission_Web3Permission$deserialize(type$.nullable_CborObject._as(e), type$.SubstrateAddress);
    },
    $signature: 141
  };
  A.TonChain.prototype = {};
  A.TonChain_TonChain$deserialize_closure.prototype = {
    call$0() {
      return A.CryptoAddress_fromCbor(this.network, this.i).cast$1$0(0, type$.ITonAddress);
    },
    $signature: 142
  };
  A.TonChain_TonChain$deserialize_closure0.prototype = {
    call$1(e) {
      return A.ContactCore_fromCborBytesOrObject(this.network, type$.nullable_CborObject._as(e), type$.TonAddress);
    },
    $signature: 143
  };
  A.TonChain_TonChain$deserialize_closure1.prototype = {
    call$1(e) {
      return A.Web3Permission_Web3Permission$deserialize(type$.nullable_CborObject._as(e), type$.TonAddress);
    },
    $signature: 144
  };
  A.TronChain.prototype = {};
  A.TronChain_TronChain$deserialize_closure.prototype = {
    call$0() {
      return A.CryptoAddress_fromCbor(this.network, this.i).cast$1$0(0, type$.ITronAddress);
    },
    $signature: 145
  };
  A.TronChain_TronChain$deserialize_closure0.prototype = {
    call$1(e) {
      return A.ContactCore_fromCborBytesOrObject(this.network, type$.nullable_CborObject._as(e), type$.TronAddress);
    },
    $signature: 146
  };
  A.TronChain_TronChain$deserialize_closure1.prototype = {
    call$1(e) {
      return A.Web3Permission_Web3Permission$deserialize(type$.nullable_CborObject._as(e), type$.TronAddress);
    },
    $signature: 147
  };
  A.RippleChain.prototype = {};
  A.RippleChain_RippleChain$deserialize_closure.prototype = {
    call$0() {
      return A.CryptoAddress_fromCbor(this.network, this.i).cast$1$0(0, type$.IXRPAddress);
    },
    $signature: 148
  };
  A.RippleChain_RippleChain$deserialize_closure0.prototype = {
    call$1(e) {
      return A.ContactCore_fromCborBytesOrObject(this.network, type$.nullable_CborObject._as(e), type$.XRPAddress);
    },
    $signature: 149
  };
  A.RippleChain_RippleChain$deserialize_closure1.prototype = {
    call$1(e) {
      return A.Web3Permission_Web3Permission$deserialize(type$.nullable_CborObject._as(e), type$.XRPAddress);
    },
    $signature: 150
  };
  A._Chain_Object_CborSerializable.prototype = {};
  A.AccountBalance.prototype = {$isAddressBalanceCore: 1};
  A.ChainAccount.prototype = {};
  A.CryptoAddress.prototype = {
    cast$1$0(_, $T) {
      A.checkTypeBound($T, type$.ChainAccount_of_dynamic_and_TokenCore_dynamic, "T", "cast");
      if ($T._is(this))
        return $T._as(this);
      throw A.wrapException(A.WalletExceptionConst_invalidArgruments(A.getRuntimeTypeOfDartObject(this).toString$0(0), A.createRuntimeType($T).toString$0(0)));
    }
  };
  A._CryptoAddress_Object_CborSerializable.prototype = {};
  A.IBitcoinCashAddress.prototype = {};
  A.IBitcoinCashMultiSigAddress.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.addressType, _this.keyIndex, _this.network, A.BytesUtils_toHexString(_this.multiSignatureAddress.multiSigScript.toBytes$0(), true, null)];
    }
  };
  A._IBitcoinCashMultiSigAddress_IBitcoinCashAddress_BitcoinMultiSigBase.prototype = {};
  A.IBitcoinAddress.prototype = {
    get$variabels() {
      return [this.addressType, this.keyIndex, this.network];
    }
  };
  A.IBitcoinMultiSigAddress.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.addressType, _this.keyIndex, _this.network, A.BytesUtils_toHexString(_this.multiSignatureAddress.multiSigScript.toBytes$0(), true, null)];
    }
  };
  A._IBitcoinAddress_ChainAccount_Equatable.prototype = {};
  A._IBitcoinMultiSigAddress_IBitcoinAddress_BitcoinMultiSigBase.prototype = {};
  A.BitcoinMultiSigBase.prototype = {};
  A.BitcoinMultiSigSignerDetais.prototype = {
    get$variabels() {
      return [this.publicKey, this._wieght, this.keyIndex];
    }
  };
  A.BitcoinMultiSignatureAddress.prototype = {
    toP2shAddress$1(addressType) {
      if (!B.JSArray_methods.contains$1(B.List_ah9, addressType))
        throw A.wrapException(A.WalletException$("invalid p2sh type please use one of them " + B.JSArray_methods.map$1$1(B.List_ah9, new A.BitcoinMultiSignatureAddress_toP2shAddress_closure(), type$.String).join$1(0, ", ")));
      if (addressType.hashLength === 32)
        return new A.P2shAddress(addressType, A._BitcoinAddressUtils_validateAddressProgram(A.BytesUtils_toHexString(A.SHA256_hash(A.SHA256_hash(this.multiSigScript.toBytes$0())), true, null), addressType));
      return new A.P2shAddress(addressType, A._BitcoinAddressUtils_scriptToHash160(this.multiSigScript));
    },
    fromType$2$addressType$network(addressType, network) {
      switch (addressType) {
        case B.SegwitAddresType_P2WSH:
          return new A.P2wshAddress(A._BitcoinAddressUtils_segwitScriptToSHA256(this.multiSigScript), 0);
        case B.P2shAddressType_qI5:
          return new A.P2shAddress(B.P2shAddressType_qI5, A._BitcoinAddressUtils_scriptToHash160(new A.Script(A.List_List$unmodifiable(["OP_0", A._BitcoinAddressUtils_segwitScriptToSHA256(this.multiSigScript)], type$.dynamic))));
        case B.P2shAddressType_sc9:
        case B.P2shAddressType_hK7:
        case B.P2shAddressType_lhG:
        case B.P2shAddressType_0:
          return this.toP2shAddress$1(type$.P2shAddressType._as(addressType));
        default:
          throw A.wrapException(A.ArgumentError$("invalid multisig address type. use of of them [BitcoinAddressType.p2wsh, BitcoinAddressType.p2wshInP2sh, BitcoinAddressType.p2pkhInP2sh]", null));
      }
    }
  };
  A.BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      var t1,
        cbor = A.CborSerializable_decodeCborTags(null, type$.nullable_CborObject._as(e), B.List_Cpl1, type$.CborListValue_dynamic),
        publicKey = A.ExtractCborList_elementAt(cbor, 0, type$.List_int),
        weight = A.ExtractCborList_elementAt(cbor, 1, type$.int),
        keyIndex = A.Bip32AddressIndex_Bip32AddressIndex$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      A.Bip32KeyData$();
      $.$get$Bip32Const_mainNetKeyNetVersions();
      t1 = A.IPublicKey_IPublicKey$fromBytes(publicKey, B.EllipticCurveTypes_secp256k1);
      t1.get$curve();
      if (!A.BytesUtils_bytesEqual(t1.get$compressed(), publicKey))
        A.throwExpression($.$get$WalletExceptionConst_invalidAccountDetails());
      if (weight < 1 || weight > 16)
        A.throwExpression($.$get$WalletExceptionConst_invalidAccountDetails());
      return new A.BitcoinMultiSigSignerDetais(A.BytesUtils_toHexString(publicKey, true, null), weight, keyIndex);
    },
    $signature: 151
  };
  A.BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject_closure0.prototype = {
    call$1(e) {
      return A._asString(e.get$value());
    },
    $signature: 152
  };
  A.BitcoinMultiSignatureAddress_toP2shAddress_closure.prototype = {
    call$1(e) {
      return type$.P2shAddressType._as(e).toString$0(0);
    },
    $signature: 153
  };
  A._BitcoinMultiSigSignerDetais_Object_Equatable.prototype = {};
  A._BitcoinMultiSigSignerDetais_Object_Equatable_CborSerializable.prototype = {};
  A._BitcoinMultiSignatureAddress_Object_CborSerializable.prototype = {};
  A.ICardanoAddress.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.keyIndex, _this.network, _this.networkAddress.get$addressType(), _this.addressDetails];
    }
  };
  A._ICardanoAddress_ChainAccount_Equatable.prototype = {};
  A.ICosmosAddress.prototype = {
    get$variabels() {
      return [this.keyIndex, this.network];
    }
  };
  A._ICosmosAddress_ChainAccount_Equatable.prototype = {};
  A.IEthAddress.prototype = {
    get$variabels() {
      return [this.keyIndex, this.network];
    }
  };
  A._IEthAddress_ChainAccount_Equatable.prototype = {};
  A.ISolanaAddress.prototype = {
    get$variabels() {
      return [this.keyIndex, this.network];
    }
  };
  A._ISolanaAddress_ChainAccount_Equatable.prototype = {};
  A.ISubstrateAddress.prototype = {
    get$variabels() {
      return [this.keyIndex, this.network];
    }
  };
  A._ISubstrateAddress_ChainAccount_Equatable.prototype = {};
  A.ITonAddress.prototype = {
    get$variabels() {
      return [this.keyIndex, this.network];
    }
  };
  A.ITonAddress_ITonAddress$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.TonJettonToken_TonJettonToken$fromCborBytesOrObject(type$.nullable_CborObject._as(e));
    },
    $signature: 154
  };
  A._ITonAddress_ChainAccount_Equatable.prototype = {};
  A.TronMultiSigSignerDetais.prototype = {
    get$variabels() {
      return [this.publicKey, this.weight, this.keyIndex];
    }
  };
  A.TronMultiSignatureAddress.prototype = {
    get$variabels() {
      return [this.threshold, this.signers, this.permissionID];
    }
  };
  A.TronMultiSignatureAddress_TronMultiSignatureAddress$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      var cbor = A.CborSerializable_decodeCborTags(null, type$.nullable_CborObject._as(e), B.List_Cpl, type$.CborListValue_dynamic),
        publicKey = A.ExtractCborList_elementAt(cbor, 0, type$.List_int),
        weight = A.ExtractCborList_elementAt(cbor, 1, type$.BigInt),
        keyIndex = A.Bip32AddressIndex_Bip32AddressIndex$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      return new A.TronMultiSigSignerDetais(A.BytesUtils_toHexString(publicKey, true, null), weight, keyIndex);
    },
    $signature: 155
  };
  A._TronMultiSigSignerDetais_Object_Equatable.prototype = {};
  A._TronMultiSigSignerDetais_Object_Equatable_CborSerializable.prototype = {};
  A._TronMultiSignatureAddress_Object_Equatable.prototype = {};
  A._TronMultiSignatureAddress_Object_Equatable_CborSerializable.prototype = {};
  A.ITronAddress.prototype = {
    get$variabels() {
      return [this.keyIndex, this.network];
    }
  };
  A.ITronAddress_ITronAddress$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.TronTRC20Token_TronTRC20Token$fromCborBytesOrObject(type$.nullable_CborObject._as(e));
    },
    $signature: 54
  };
  A.ITronAddress_ITronAddress$fromCborBytesOrObject_closure0.prototype = {
    call$1(e) {
      return A.TronTRC10Token_TronTRC10Token$fromCborBytesOrObject(type$.nullable_CborObject._as(e));
    },
    $signature: 53
  };
  A.ITronMultisigAddress.prototype = {
    get$variabels() {
      return [this.keyIndex, this.network, this.multiSignatureAccount];
    }
  };
  A.ITronMultisigAddress_ITronMultisigAddress$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.TronTRC20Token_TronTRC20Token$fromCborBytesOrObject(type$.nullable_CborObject._as(e));
    },
    $signature: 54
  };
  A.ITronMultisigAddress_ITronMultisigAddress$fromCborBytesOrObject_closure0.prototype = {
    call$1(e) {
      return A.TronTRC10Token_TronTRC10Token$fromCborBytesOrObject(type$.nullable_CborObject._as(e));
    },
    $signature: 53
  };
  A._ITronAddress_ChainAccount_Equatable.prototype = {};
  A.RippleMultiSigSignerDetais.prototype = {
    get$variabels() {
      return [this.publicKey, this.weight, this.keyIndex];
    }
  };
  A.RippleMultiSignatureAddress.prototype = {
    get$variabels() {
      return [this.threshold, this.signers];
    }
  };
  A.RippleMultiSignatureAddress_RippleMultiSignatureAddress$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      var cbor = A.CborSerializable_decodeCborTags(null, type$.nullable_CborObject._as(e), B.List_Cpl0, type$.CborListValue_dynamic),
        publicKey = A.ExtractCborList_elementAt(cbor, 0, type$.List_int),
        weight = A.ExtractCborList_elementAt(cbor, 1, type$.int),
        keyIndex = A.Bip32AddressIndex_Bip32AddressIndex$fromCborBytesOrObject(A.ExtractCborList_getCborTag(cbor, 2));
      return new A.RippleMultiSigSignerDetais(A.BytesUtils_toHexString(publicKey, true, null), weight, keyIndex);
    },
    $signature: 158
  };
  A._RippleMultiSigSignerDetais_Object_Equatable.prototype = {};
  A._RippleMultiSigSignerDetais_Object_Equatable_CborSerializable.prototype = {};
  A._RippleMultiSignatureAddress_Object_Equatable.prototype = {};
  A._RippleMultiSignatureAddress_Object_Equatable_CborSerializable.prototype = {};
  A.IXRPAddress.prototype = {
    get$variabels() {
      return [this.tag, this.keyIndex, this.network];
    }
  };
  A.IXRPAddress_IXRPAddress$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.RippleIssueToken_RippleIssueToken$fromCborBytesOrObject(type$.nullable_CborObject._as(e));
    },
    $signature: 159
  };
  A.IXRPAddress_IXRPAddress$fromCborBytesOrObject_closure0.prototype = {
    call$1(e) {
      return A.RippleNFToken_RippleNFToken$fromCborBytesOrObject(type$.nullable_CborObject._as(e));
    },
    $signature: 160
  };
  A.IXRPMultisigAddress.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.tag, _this.keyIndex, _this.network, _this.multiSignatureAccount];
    }
  };
  A._IXRPAddress_ChainAccount_Equatable.prototype = {};
  A.Web3PermissionActivities.prototype = {};
  A.Web3AccountPermission.prototype = {
    get$variabels() {
      return ["Ethereum", this.addressIndex, this.address];
    }
  };
  A.Web3Permission.prototype = {};
  A.Web3Permission_Web3Permission$deserialize_closure.prototype = {
    call$1(e) {
      return A.Web3AccountPermission_Web3AccountPermission$deserialize(type$.nullable_CborObject._as(e), this.NETWORKADDRESS);
    },
    $signature() {
      return this.NETWORKADDRESS._eval$1("Web3AccountPermission<0>(@)");
    }
  };
  A.Web3Permission_Web3Permission$deserialize_closure0.prototype = {
    call$1(e) {
      return A.APPImage_APPImage$fromCborBytesOrObject(type$.CborTagValue_dynamic._as(e));
    },
    $signature: 161
  };
  A.Web3Permission_Web3Permission$deserialize_closure1.prototype = {
    call$1(e) {
      var t2,
        values = A.CborSerializable_cborTagValue(null, null, type$.nullable_CborObject._as(e), B.List_0_0_2_1, type$.CborListValue_dynamic),
        t1 = type$.String;
      A.ExtractCborList_elementAt(values, 0, t1);
      t2 = A.ExtractCborList_elementAt(values, 1, type$.nullable_DateTime);
      A.ExtractCborList_elementAt(values, 2, t1);
      A.ExtractCborList_elementAt(values, 3, type$.nullable_String);
      if (t2 == null)
        Date.now();
      return new A.Web3PermissionActivities();
    },
    $signature: 244
  };
  A._Web3AccountPermission_Object_CborSerializable.prototype = {};
  A._Web3AccountPermission_Object_CborSerializable_Equatable.prototype = {};
  A._Web3Permission_Object_CborSerializable.prototype = {};
  A._Web3PermissionActivities_Object_CborSerializable.prototype = {};
  A.Web3EthereumPermission.prototype = {};
  A.DecimalBalance.prototype = {
    toString$0(_) {
      var t1 = this.__DecimalBalance__price_A;
      t1 === $ && A.throwLateFieldNI("_price");
      return t1;
    }
  };
  A.IntegerBalance.prototype = {
    toString$0(_) {
      var t1 = this.__IntegerBalance__price_A;
      t1 === $ && A.throwLateFieldNI("_price");
      return t1;
    },
    $eq(_, other) {
      var t1, t2, _this = this,
        _s11_ = "showDecimal";
      if (other == null)
        return false;
      if (_this !== other)
        if (other instanceof A.IntegerBalance) {
          t1 = other._balance.compareTo$1(0, _this._balance);
          if (t1 === 0)
            if (other.currencyDecimal === _this.currencyDecimal) {
              t1 = other.__IntegerBalance_showDecimal_F;
              t1 === $ && A.throwLateFieldNI(_s11_);
              t2 = _this.__IntegerBalance_showDecimal_F;
              t2 === $ && A.throwLateFieldNI(_s11_);
              t2 = t1 === t2;
              t1 = t2;
            } else
              t1 = false;
          else
            t1 = false;
        } else
          t1 = false;
      else
        t1 = true;
      return t1;
    },
    get$hashCode(_) {
      var t1 = this._balance.get$hashCode(0),
        t2 = B.JSInt_methods.get$hashCode(this.currencyDecimal),
        t3 = this.__IntegerBalance_showDecimal_F;
      t3 === $ && A.throwLateFieldNI("showDecimal");
      return t1 ^ t2 ^ B.JSInt_methods.get$hashCode(t3);
    }
  };
  A.BitcoinContact.prototype = {
    get$variabels() {
      return [this.address, this.name];
    },
    $isContactCore: 1
  };
  A._BitcoinContact_Object_Equatable.prototype = {};
  A.CardanoContact.prototype = {
    get$variabels() {
      return [this.addressObject.get$address(), this.name];
    },
    $isContactCore: 1
  };
  A._CardanoContact_Object_Equatable.prototype = {};
  A.CosmosContact.prototype = {
    get$variabels() {
      return [this.addressObject.address, this.name];
    },
    $isContactCore: 1
  };
  A._CosmosContact_Object_Equatable.prototype = {};
  A.EthereumContract.prototype = {
    get$variabels() {
      return [this.addressObject.address, this.name];
    },
    $isContactCore: 1
  };
  A._EthereumContract_Object_Equatable.prototype = {};
  A.SolanaContact.prototype = {
    get$variabels() {
      return [this.addressObject.address, this.name];
    },
    $isContactCore: 1
  };
  A._SolanaContact_Object_Equatable.prototype = {};
  A.SubstrateContact.prototype = {
    get$variabels() {
      return [this.addressObject.address, this.name];
    },
    $isContactCore: 1
  };
  A._SubstrateContact_Object_Equatable.prototype = {};
  A.TonContact.prototype = {
    get$variabels() {
      return [this.addressObject.toString$0(0), this.name];
    },
    $isContactCore: 1
  };
  A._TonContact_Object_Equatable.prototype = {};
  A.TronContact.prototype = {
    get$variabels() {
      return [this.addressObject.toAddress$0(), this.name];
    },
    $isContactCore: 1
  };
  A._TronContact_Object_Equatable.prototype = {};
  A.RippleContact.prototype = {
    get$variabels() {
      return [this.address, this.name];
    },
    $isContactCore: 1
  };
  A._RippleContact_Object_Equatable.prototype = {};
  A.WalletNetwork.prototype = {
    getProvider$1$1(selectProvider, $T) {
      var t1, supportedProviders;
      A.checkTypeBound($T, type$.APIProvider, "T", "getProvider");
      t1 = $T._eval$1("WhereTypeIterable<0>");
      supportedProviders = new A.WhereIterable(new A.WhereTypeIterable(this.get$coinParam().providers, t1), t1._eval$1("bool(Iterable.E)")._as(new A.WalletNetwork_getProvider_closure($T)), t1._eval$1("WhereIterable<Iterable.E>"));
      if (!supportedProviders.get$iterator(0).moveNext$0())
        return null;
      if (selectProvider == null)
        return supportedProviders.get$first(0);
      return A.MethodUtils_nullOnException(new A.WalletNetwork_getProvider_closure0(this, selectProvider, $T), $T);
    },
    toNetwork$1$0($T) {
      A.checkTypeBound($T, type$.WalletNetwork_NetworkCoinParams_APIProvider, "T", "toNetwork");
      if (!$T._is(this))
        throw A.wrapException($.$get$WalletExceptionConst_incorrectNetwork());
      return $T._as(this);
    }
  };
  A.WalletNetwork_getProvider_closure.prototype = {
    call$1(element) {
      var t1 = this.T._as(element).get$protocol().get$platforms();
      $.$get$PlatformInterface_instance();
      return B.JSArray_methods.contains$1(t1, B.AppPlatform_1);
    },
    $signature() {
      return this.T._eval$1("bool(0)");
    }
  };
  A.WalletNetwork_getProvider_closure0.prototype = {
    call$0() {
      var t1 = this.T;
      return new A.WhereTypeIterable(this.$this.get$coinParam().providers, t1._eval$1("WhereTypeIterable<0>")).firstWhere$1(0, new A.WalletNetwork_getProvider__closure(this.selectProvider, t1));
    },
    $signature() {
      return this.T._eval$1("0()");
    }
  };
  A.WalletNetwork_getProvider__closure.prototype = {
    call$1(element) {
      var t1;
      this.T._as(element);
      t1 = this.selectProvider;
      return element.serviceName === t1.serviceName && element.get$protocol() === t1.get$protocol();
    },
    $signature() {
      return this.T._eval$1("bool(0)");
    }
  };
  A.WalletBitcoinNetwork.prototype = {
    get$type() {
      return B.NetworkType_8eb;
    },
    get$variabels() {
      return [this.value];
    },
    copyWith$2$coinParam$value(coinParam, value) {
      type$.nullable_BitcoinParams._as(coinParam);
      return new A.WalletBitcoinNetwork(value, coinParam);
    },
    get$value() {
      return this.value;
    },
    get$coinParam() {
      return this.coinParam;
    }
  };
  A.WalletBitcoinCashNetwork.prototype = {
    copyWith$2$coinParam$value(coinParam, value) {
      type$.nullable_BitcoinParams._as(coinParam);
      return new A.WalletBitcoinCashNetwork(value, coinParam);
    },
    get$type() {
      return B.NetworkType_8eb0;
    }
  };
  A.WalletXRPNetwork.prototype = {
    get$variabels() {
      return [this.value];
    },
    get$type() {
      return B.NetworkType_Oh2;
    },
    copyWith$2$coinParam$value(coinParam, value) {
      type$.nullable_RippleNetworkParams._as(coinParam);
      return new A.WalletXRPNetwork(value, coinParam);
    },
    get$value() {
      return this.value;
    },
    get$coinParam() {
      return this.coinParam;
    }
  };
  A.WalletEthereumNetwork.prototype = {
    copyWith$2$coinParam$value(coinParam, value) {
      type$.nullable_EthereumNetworkParams._as(coinParam);
      return new A.WalletEthereumNetwork(value, coinParam, this.slip44);
    },
    get$variabels() {
      return [this.value];
    },
    get$type() {
      return B.NetworkType_iDZ;
    },
    get$value() {
      return this.value;
    },
    get$coinParam() {
      return this.coinParam;
    }
  };
  A.WalletTronNetwork.prototype = {
    get$variabels() {
      return [this.value];
    },
    get$type() {
      return B.NetworkType_SkF;
    },
    copyWith$2$coinParam$value(coinParam, value) {
      type$.nullable_TronNetworkParams._as(coinParam);
      return new A.WalletTronNetwork(value, coinParam);
    },
    get$value() {
      return this.value;
    },
    get$coinParam() {
      return this.coinParam;
    }
  };
  A.WalletSolanaNetwork.prototype = {
    copyWith$2$coinParam$value(coinParam, value) {
      type$.nullable_SolanaNetworkParams._as(coinParam);
      return new A.WalletSolanaNetwork(value, coinParam);
    },
    get$variabels() {
      return [this.value];
    },
    get$type() {
      return B.NetworkType_4QF;
    },
    get$value() {
      return this.value;
    },
    get$coinParam() {
      return this.coinParam;
    }
  };
  A.WalletCardanoNetwork.prototype = {
    get$variabels() {
      return [this.value];
    },
    get$type() {
      return B.NetworkType_4ei;
    },
    copyWith$2$coinParam$value(coinParam, value) {
      type$.nullable_CardanoNetworkParams._as(coinParam);
      return new A.WalletCardanoNetwork(value, coinParam);
    },
    get$value() {
      return this.value;
    },
    get$coinParam() {
      return this.coinParam;
    }
  };
  A.WalletCosmosNetwork.prototype = {
    get$variabels() {
      return [this.value];
    },
    get$type() {
      return B.NetworkType_QJm;
    },
    copyWith$2$coinParam$value(coinParam, value) {
      type$.nullable_CosmosNetworkParams._as(coinParam);
      return new A.WalletCosmosNetwork(value, coinParam);
    },
    get$value() {
      return this.value;
    },
    get$coinParam() {
      return this.coinParam;
    }
  };
  A.WalletTonNetwork.prototype = {
    get$variabels() {
      return [this.value];
    },
    get$type() {
      return B.NetworkType_66M;
    },
    copyWith$2$coinParam$value(coinParam, value) {
      type$.nullable_TonNetworkParams._as(coinParam);
      return new A.WalletTonNetwork(value, coinParam);
    },
    get$value() {
      return this.value;
    },
    get$coinParam() {
      return this.coinParam;
    }
  };
  A.WalletPolkadotNetwork.prototype = {
    get$variabels() {
      return [this.value];
    },
    get$type() {
      return B.NetworkType_GRA;
    },
    copyWith$2$coinParam$value(coinParam, value) {
      type$.nullable_SubstrateNetworkParams._as(coinParam);
      return new A.WalletPolkadotNetwork(value, coinParam);
    },
    get$value() {
      return this.value;
    },
    get$coinParam() {
      return this.coinParam;
    }
  };
  A.WalletKusamaNetwork.prototype = {
    get$type() {
      return B.NetworkType_0;
    },
    copyWith$2$coinParam$value(coinParam, value) {
      type$.nullable_SubstrateNetworkParams._as(coinParam);
      return new A.WalletKusamaNetwork(value, coinParam);
    }
  };
  A._WalletNetwork_Object_Equatable.prototype = {};
  A._WalletNetwork_Object_Equatable_CborSerializable.prototype = {};
  A.NetworkCoinParams.prototype = {
    get$mainnet() {
      return this.mainnet;
    }
  };
  A._NetworkCoinParams_Object_CborSerializable.prototype = {};
  A.BitcoinParams.prototype = {
    get$mainnet() {
      return this.transacationNetwork.get$isMainnet();
    },
    updateProviders$1(updateProviders) {
      var _this = this;
      type$.List_APIProvider._as(updateProviders);
      return A.BitcoinParams$(_this.addressExplorer, _this.genesis, new A.CastList(updateProviders, A._arrayInstanceType(updateProviders)._eval$1("CastList<1,BaseBitcoinAPIProvider>")), _this.token, _this.transacationNetwork, _this.transactionExplorer);
    }
  };
  A.BitcoinParams_BitcoinParams$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.BaseBitcoinAPIProvider_BaseBitcoinAPIProvider$fromCborBytesOrObject(null, type$.nullable_CborObject._as(e));
    },
    $signature: 163
  };
  A.CardanoNetworkParams.prototype = {
    updateProviders$1(updateProviders) {
      var _this = this;
      type$.List_APIProvider._as(updateProviders);
      return A.CardanoNetworkParams$(_this.addressExplorer, _this.mainnet, new A.CastList(updateProviders, A._arrayInstanceType(updateProviders)._eval$1("CastList<1,CardanoAPIProvider>")), _this.token, _this.transactionExplorer);
    }
  };
  A.CardanoNetworkParams_CardanoNetworkParams$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject(null, type$.nullable_CborObject._as(e));
    },
    $signature: 164
  };
  A.CosmosNetworkParams.prototype = {
    updateProviders$1(updateProviders) {
      var _this = this;
      type$.List_APIProvider._as(updateProviders);
      return A.CosmosNetworkParams$(_this.addressExplorer, null, _this.nativeCoins, _this.hrp, _this.mainCoin, _this.mainnet, _this.networkType, new A.CastList(updateProviders, A._arrayInstanceType(updateProviders)._eval$1("CastList<1,CosmosAPIProvider>")), _this.token, _this.transactionExplorer);
    }
  };
  A.CosmosNetworkParams_CosmosNetworkParams$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.CosmosAPIProvider_CosmosAPIProvider$fromCborBytesOrObject(null, type$.nullable_CborObject._as(e));
    },
    $signature: 165
  };
  A.CosmosNetworkParams_CosmosNetworkParams$fromCborBytesOrObject_closure0.prototype = {
    call$1(e) {
      return A.CosmosNativeCoin_CosmosNativeCoin$fromCborBytesOrObject(type$.nullable_CborObject._as(e));
    },
    $signature: 166
  };
  A.EthereumNetworkParams.prototype = {
    updateProviders$1(updateProviders) {
      var _this = this;
      type$.List_APIProvider._as(updateProviders);
      return A.EthereumNetworkParams$(_this.addressExplorer, _this.bip32CoinType, _this.chainId, _this.defaultNetwork, _this.mainnet, new A.CastList(updateProviders, A._arrayInstanceType(updateProviders)._eval$1("CastList<1,EthereumAPIProvider>")), _this.supportEIP1559, _this.token, _this.transactionExplorer);
    }
  };
  A.EthereumNetworkParams_EthereumNetworkParams$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.EthereumAPIProvider_EthereumAPIProvider$fromCborBytesOrObject(null, type$.nullable_CborObject._as(e));
    },
    $signature: 51
  };
  A.RippleNetworkParams.prototype = {
    updateProviders$1(updateProviders) {
      var _this = this;
      type$.List_APIProvider._as(updateProviders);
      return A.RippleNetworkParams$(_this.addressExplorer, _this.mainnet, new A.CastList(updateProviders, A._arrayInstanceType(updateProviders)._eval$1("CastList<1,RippleAPIProvider>")), _this.token, _this.transactionExplorer);
    }
  };
  A.RippleNetworkParams_RippleNetworkParams$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.RippleAPIProvider_RippleAPIProvider$fromCborBytesOrObject(null, type$.nullable_CborObject._as(e));
    },
    $signature: 168
  };
  A.SolanaNetworkParams.prototype = {
    updateProviders$1(updateProviders) {
      var _this = this;
      type$.List_APIProvider._as(updateProviders);
      return A.SolanaNetworkParams$(_this.addressExplorer, _this.genesis, _this.mainnet, new A.CastList(updateProviders, A._arrayInstanceType(updateProviders)._eval$1("CastList<1,SolanaAPIProvider>")), _this.token, _this.transactionExplorer);
    }
  };
  A.SolanaNetworkParams_SolanaNetworkParams$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.SolanaAPIProvider_SolanaAPIProvider$fromCborBytesOrObject(null, type$.nullable_CborObject._as(e));
    },
    $signature: 169
  };
  A.SubstrateNetworkParams.prototype = {
    updateProviders$1(updateProviders) {
      var _this = this;
      type$.List_APIProvider._as(updateProviders);
      return A.SubstrateNetworkParams$(_this.addressExplorer, _this.mainnet, new A.CastList(updateProviders, A._arrayInstanceType(updateProviders)._eval$1("CastList<1,SubstrateAPIProvider>")), _this.specVersion, _this.ss58Format, _this.token, _this.transactionExplorer);
    }
  };
  A.SubstrateNetworkParams_SubstrateNetworkParams$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.SubstrateAPIProvider_SubstrateAPIProvider$fromCborBytesOrObject(null, type$.nullable_CborObject._as(e));
    },
    $signature: 170
  };
  A.TonNetworkParams.prototype = {
    updateProviders$1(updateProviders) {
      var t1, _this = this;
      type$.List_APIProvider._as(updateProviders);
      t1 = _this.providers;
      return A.TonNetworkParams$(_this.addressExplorer, _this.mainnet, new A.CastList(t1, A._arrayInstanceType(t1)._eval$1("CastList<1,TonAPIProvider>")), _this.token, _this.transactionExplorer, _this.workchain);
    }
  };
  A.TonNetworkParams_TonNetworkParams$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.TonAPIProvider_TonAPIProvider$fromCborBytesOrObject(null, type$.nullable_CborObject._as(e));
    },
    $signature: 171
  };
  A.TronNetworkParams.prototype = {
    updateProviders$1(updateProviders) {
      var _this = this;
      type$.List_APIProvider._as(updateProviders);
      return A.TronNetworkParams$(_this.addressExplorer, _this.ethereumProviders, _this.genesis, _this.mainnet, new A.CastList(updateProviders, A._arrayInstanceType(updateProviders)._eval$1("CastList<1,TronAPIProvider>")), _this.token, _this.transactionExplorer);
    }
  };
  A.TronNetworkParams_TronNetworkParams$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      return A.TronAPIProvider_TronAPIProvider$fromCborBytesOrObject(null, type$.nullable_CborObject._as(e));
    },
    $signature: 172
  };
  A.TronNetworkParams_TronNetworkParams$fromCborBytesOrObject_closure0.prototype = {
    call$1(e) {
      return A.EthereumAPIProvider_EthereumAPIProvider$fromCborBytesOrObject(null, type$.nullable_CborObject._as(e));
    },
    $signature: 51
  };
  A.CardanoAddrDetails.prototype = {
    toAddress$2(coin, testnet) {
      var adaNetwork, t1, t2, stakeCredential, pubSkey, netTag, _this = this;
      type$.CryptoCoins_CoinConfig._as(coin);
      adaNetwork = testnet ? B.ADANetwork_0_1_testnetPreprod : B.ADANetwork_1_764824073_mainnet;
      switch (_this.addressType) {
        case B.ADAAddressType_0_Base:
          t1 = _this.stakePubkey;
          t1.toString;
          t2 = A.AdaTransactionUtils_validateFixedLengthBytes(A.AdaAddressUtils_publicKeyToHash(_this.publicKey), 28);
          stakeCredential = new A.StakeCredKey(A.AdaTransactionUtils_validateFixedLengthBytes(A.AdaAddressUtils_publicKeyToHash(t1), 28));
          t2 = A.AdaAddressUtils_toAdaStakeCredential(new A.StakeCredKey(t2));
          t1 = type$.Map_String_dynamic._as(A.LinkedHashMap_LinkedHashMap$_literal(["net_tag", adaNetwork, "pub_skey", A.AdaAddressUtils_toAdaStakeCredential(stakeCredential)], type$.String, type$.dynamic));
          pubSkey = A.AddrKeyValidator_validateAddressArgs(t1, "pub_skey", type$.AdaStakeCredential);
          netTag = t1.$index(0, "net_tag");
          if (netTag == null)
            netTag = B.ADANetwork_1_764824073_mainnet;
          if (!(netTag instanceof A.ADANetwork))
            A.throwExpression(B.AddressConverterException_QWm);
          t1 = $.$get$AdaShelleyAddrConst_networkTagToAddrHrp().$index(0, netTag);
          t1.toString;
          return new A.ADABaseAddress(stakeCredential, A.AdaShelleyAddrUtils_encode(t2, t1, netTag, pubSkey, B.ADAAddressType_0_Base), adaNetwork);
        case B.ADAAddressType_6_Enterprise:
          t1 = A.AdaAddressUtils_toAdaStakeCredential(new A.StakeCredKey(A.AdaTransactionUtils_validateFixedLengthBytes(A.AdaAddressUtils_publicKeyToHash(_this.publicKey), 28)));
          netTag = type$.Map_String_dynamic._as(A.LinkedHashMap_LinkedHashMap$_literal(["net_tag", adaNetwork], type$.String, type$.dynamic)).$index(0, "net_tag");
          if (netTag == null)
            netTag = B.ADANetwork_1_764824073_mainnet;
          t2 = $.$get$AdaShelleyAddrConst_networkTagToAddrHrp().$index(0, netTag);
          t2.toString;
          return new A.ADAEnterpriseAddress(A.AdaShelleyAddrUtils_encode(t1, t2, netTag, null, B.ADAAddressType_6_Enterprise), adaNetwork);
        case B.ADAAddressType_14_Reward:
          return new A.ADARewardAddress(new A.AdaShelleyStakingAddrEncoder().encodeCredential$2(A.AdaAddressUtils_toAdaStakeCredential(new A.StakeCredKey(A.AdaTransactionUtils_validateFixedLengthBytes(A.AdaAddressUtils_publicKeyToHash(_this.publicKey), 28))), A.LinkedHashMap_LinkedHashMap$_literal(["net_tag", adaNetwork], type$.String, type$.dynamic)), adaNetwork);
        case B.ADAAddressType_8_Byron:
          t1 = _this.chainCode;
          t1.toString;
          return A.ADAByronAddress_ADAByronAddress$fromPublicKey(t1, _this.hdPath, _this.hdPathKey, adaNetwork, _this.publicKey);
        default:
          throw A.wrapException(A.WalletException$("Invalid address type."));
      }
    },
    get$variabels() {
      var result, _this = this,
        value = _this.__CardanoAddrDetails_hdPathKeyHex_FI;
      if (value === $) {
        result = A.BytesUtils_tryToHexString(_this.hdPathKey);
        _this.__CardanoAddrDetails_hdPathKeyHex_FI !== $ && A.throwLateFieldADI("hdPathKeyHex");
        _this.__CardanoAddrDetails_hdPathKeyHex_FI = result;
        value = result;
      }
      return [_this.publicKey, _this.hdPath, value, _this.chainCode, _this.addressType];
    }
  };
  A._CardanoAddrDetails_Object_Equatable.prototype = {};
  A._CardanoAddrDetails_Object_Equatable_CborSerializable.prototype = {};
  A.CosmosNativeCoin.prototype = {};
  A._CosmosNativeCoin_Object_CborSerializable.prototype = {};
  A.CosmosNetworkTypes.prototype = {
    get$value() {
      return this.value;
    }
  };
  A.CosmosNetworkTypes_CosmosNetworkTypes$fromValue_closure.prototype = {
    call$1(e) {
      return type$.CosmosNetworkTypes._as(e).value === this.value;
    },
    $signature: 173
  };
  A.CosmosNetworkTypes_CosmosNetworkTypes$fromValue_closure0.prototype = {
    call$0() {
      return A.throwExpression(A.WalletException$("No CosmosNetworkTypes element found for the given value."));
    },
    $signature: 2
  };
  A.TronAccountResourceInfo.prototype = {
    toString$0(_) {
      var t8, t9, t10, t11, t12, _this = this,
        t1 = _this.freeNetUsed.toString$0(0),
        t2 = _this.freeNetLimit.toString$0(0),
        t3 = _this.netLimit.toString$0(0),
        t4 = _this.netUsed.toString$0(0),
        t5 = _this.energyLimit.toString$0(0),
        t6 = _this.energyUsed.toString$0(0),
        t7 = _this.__TronAccountResourceInfo_totalBandWith_F;
      t7 === $ && A.throwLateFieldNI("totalBandWith");
      t8 = t7.toString$0(0);
      t9 = _this.__TronAccountResourceInfo_totalBandWithUsed_F;
      t9 === $ && A.throwLateFieldNI("totalBandWithUsed");
      t10 = t9.toString$0(0);
      t11 = _this.tronPowerUsed;
      t12 = _this.tronPowerLimit;
      t9 = t7.$sub(0, t9).toString$0(0);
      t7 = _this.__TronAccountResourceInfo_howManyEnergy_F;
      t7 === $ && A.throwLateFieldNI("howManyEnergy");
      return "      TronAccountResource {\n        freeNetUsed: " + t1 + ",\n        freeNetLimit: " + t2 + ",\n        netLimit: " + t3 + ",\n        netUsed: " + t4 + ",\n        energyLimit: " + t5 + ",\n        energyUsed: " + t6 + ",\n        totalBandWith: " + t8 + ",\n        totalBandWithUsed: " + t10 + ",\n        tronPowerUsed: " + t11 + ",\n        tronPowerLimit: " + t12 + ",\n        howManyVote: " + (t12 - t11) + ",\n        howManyBandwIth: " + t9 + ",\n        howManyEnergy: " + t7.toString$0(0) + ",\n      }\n    ";
    },
    toJson$0() {
      var _this = this;
      return A.LinkedHashMap_LinkedHashMap$_literal(["freeNetLimit", _this.freeNetLimit, "freeNetUsed", _this.freeNetUsed, "NetLimit", _this.netLimit, "NetUsed", _this.netUsed, "EnergyUsed", _this.energyUsed, "EnergyLimit", _this.energyLimit], type$.String, type$.dynamic);
    }
  };
  A._TronAccountResourceInfo_Object_CborSerializable.prototype = {};
  A.TronAccountInfo.prototype = {
    toString$0(_) {
      var _this = this;
      return "      TronAccount {\n        accountName: " + A.S(_this.accountName) + ",\n        address: " + _this.address + ",\n        balance: " + _this.balance.toString$0(0) + ",\n        createTime: " + _this.createTime.toString$0(0) + ",\n        latestOperationTime: " + A.S(_this.latestOperationTime) + ",\n        frozenSupply: " + A.S(_this.frozenSupply) + ",\n        assetIssuedName: " + A.S(_this.assetIssuedName) + ",\n        freeNetUsage: " + A.S(_this.freeNetUsage) + ",\n        latestConsumeFreeTime: " + A.S(_this.latestConsumeFreeTime) + ",\n        netWindowSize: " + _this.netWindowSize + ",\n        netWindowOptimized: " + _this.netWindowOptimized + ",\n        accountResource: " + _this.accountResource.toString$0(0) + ",\n        ownerPermission: " + _this.ownerPermission.toString$0(0) + ",\n        activePermissions: " + A.S(_this.activePermissions) + ",\n        frozenV2: " + A.S(_this.frozenV2) + ",\n        unfrozenV2: " + A.S(_this.unfrozenV2) + ",\n        assetV2: " + A.S(_this.assetV2) + ",\n        assetIssuedID: " + A.S(_this.assetIssuedID) + ",\n        freeAssetNetUsageV2: " + A.S(_this.freeAssetNetUsageV2) + ",\n        assetOptimized: " + _this.assetOptimized + "\n      }\n    ";
    }
  };
  A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      var cbor = A.CborSerializable_decodeCborTags(null, type$.nullable_CborObject._as(e), B.List_200_195_100_6, type$.CborListValue_dynamic),
        t1 = type$.BigInt;
      return new A.FrozenSupply(A.ExtractCborList_elementAt(cbor, 0, t1), A.ExtractCborList_elementAt(cbor, 1, t1));
    },
    $signature: 174
  };
  A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure0.prototype = {
    call$1(e) {
      return A.AccountPermission_AccountPermission$fromCborBytesOrObject(type$.nullable_CborObject._as(e));
    },
    $signature: 175
  };
  A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure1.prototype = {
    call$1(e) {
      var cbor = A.CborSerializable_decodeCborTags(null, type$.nullable_CborObject._as(e), B.List_200_195_100_5, type$.CborListValue_dynamic),
        t1 = A.ResourceCode_fromName(A.ExtractCborList_elementAt(cbor, 1, type$.nullable_String));
      t1.toString;
      return new A.FrozenV2(A.ExtractCborList_elementAt(cbor, 0, type$.BigInt), t1);
    },
    $signature: 176
  };
  A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure2.prototype = {
    call$1(e) {
      var cbor = A.CborSerializable_decodeCborTags(null, type$.nullable_CborObject._as(e), B.List_200_195_100_4, type$.CborListValue_dynamic),
        t1 = type$.BigInt;
      return new A.UnfrozenV2(A.ExtractCborList_elementAt(cbor, 0, type$.nullable_String), A.ExtractCborList_elementAt(cbor, 1, t1), A.ExtractCborList_elementAt(cbor, 2, t1));
    },
    $signature: 177
  };
  A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure3.prototype = {
    call$1(e) {
      var cbor = A.CborSerializable_decodeCborTags(null, type$.nullable_CborObject._as(e), B.List_200_195_100_3, type$.CborListValue_dynamic);
      return new A.AssetV2(A.ExtractCborList_elementAt(cbor, 0, type$.String), A.ExtractCborList_elementAt(cbor, 1, type$.BigInt));
    },
    $signature: 178
  };
  A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure4.prototype = {
    call$1(e) {
      var cbor = A.CborSerializable_decodeCborTags(null, type$.nullable_CborObject._as(e), B.List_200_195_100_2, type$.CborListValue_dynamic);
      return new A.FreeAssetNetUsageV2(A.ExtractCborList_elementAt(cbor, 0, type$.String), A.ExtractCborList_elementAt(cbor, 1, type$.BigInt));
    },
    $signature: 179
  };
  A.AccountPermission.prototype = {
    toString$0(_) {
      var _this = this;
      return "      ActivePermission {\n        type: " + _this.type.toString$0(0) + ",\n        id: " + A.S(_this.id) + ",\n        permissionName: " + A.S(_this.permissionName) + ",\n        threshold: " + _this.threshold.toString$0(0) + ",\n        operations: " + A.S(_this.operations) + ",\n        keys: " + A.S(_this.keys) + "\n      }\n    ";
    }
  };
  A.AccountPermission_AccountPermission$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      var cbor = A.CborSerializable_decodeCborTags(null, type$.nullable_CborObject._as(e), B.List_200_195_100_7, type$.CborListValue_dynamic);
      return new A.PermissionKeys(A.TronAddress_TronAddress(A.ExtractCborList_elementAt(cbor, 0, type$.String)), A.ExtractCborList_elementAt(cbor, 1, type$.BigInt));
    },
    $signature: 180
  };
  A.PermissionKeys.prototype = {
    toString$0(_) {
      return "PermissionKeys(address: " + this.address.toString$0(0) + ", weight: " + this.weight.toString$0(0) + ")";
    },
    get$variabels() {
      return [this.address.toAddress$0(), this.weight];
    }
  };
  A.FrozenSupply.prototype = {
    toString$0(_) {
      return "      FrozenSupply {\n        frozenBalance: " + this.frozenBalance.toString$0(0) + ",\n        expireTime: " + this.expireTime.toString$0(0) + "\n      }\n    ";
    }
  };
  A.FrozenV2.prototype = {
    toString$0(_) {
      return "      FrozenV2 {\n        amount: " + this.amount.toString$0(0) + ",\n        type: " + this.type.toString$0(0) + "\n      }\n    ";
    }
  };
  A.UnfrozenV2.prototype = {
    toString$0(_) {
      return "      UnfrozenV2 {\n        type: " + A.S(this.type) + ",\n        unfreezeAmount: " + this.unfreezeAmount.toString$0(0) + ",\n        unfreezeExpireTime: " + this.unfreezeExpireTime.toString$0(0) + "\n      }\n    ";
    }
  };
  A.AssetV2.prototype = {
    toString$0(_) {
      return "      AssetV2 {\n        key: " + this.key + ",\n        value: " + this.value.toString$0(0) + "\n      }\n    ";
    },
    get$value() {
      return this.value;
    }
  };
  A.FreeAssetNetUsageV2.prototype = {
    toString$0(_) {
      return "      FreeAssetNetUsageV2 {\n        key: " + this.key + ",\n        value: " + this.value.toString$0(0) + "\n      }\n    ";
    },
    get$value() {
      return this.value;
    }
  };
  A.TronAccountResource.prototype = {
    toString$0(_) {
      return "      TronAccountResource {\n        energyWindowSize: " + this.energyWindowSize + ",\n        delegatedFrozenV2BalanceForEnergy: " + A.S(this.delegatedFrozenV2BalanceForEnergy) + ",\n        energyWindowOptimized: " + this.energyWindowOptimized + "\n      }\n    ";
    }
  };
  A._AccountPermission_Object_CborSerializable.prototype = {};
  A._AssetV2_Object_CborSerializable.prototype = {};
  A._FreeAssetNetUsageV2_Object_CborSerializable.prototype = {};
  A._FrozenSupply_Object_CborSerializable.prototype = {};
  A._FrozenV2_Object_CborSerializable.prototype = {};
  A._PermissionKeys_Object_CborSerializable.prototype = {};
  A._PermissionKeys_Object_CborSerializable_Equatable.prototype = {};
  A._TronAccountInfo_Object_CborSerializable.prototype = {};
  A._TronAccountResource_Object_CborSerializable.prototype = {};
  A._UnfrozenV2_Object_CborSerializable.prototype = {};
  A.RippleNFToken.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.uri, _this.nftokenId, _this.flags, _this.issuer, _this.serial, _this.nftokenTaxon];
    },
    $isNFTCore: 1
  };
  A._RippleNFToken_Object_Equatable.prototype = {};
  A.CoingeckoCoin.prototype = {
    toJson$0() {
      return A.LinkedHashMap_LinkedHashMap$_literal(["id", this.apiId, "name", this.coinName, "symbol", this.symbol], type$.String, type$.dynamic);
    }
  };
  A._CoingeckoCoin_Object_CborSerializable.prototype = {};
  A._CoingeckoCoin_Object_CborSerializable_JsonSerialization.prototype = {};
  A.Token.prototype = {
    get$variabels() {
      return [this.name, this.symbol, this.decimal];
    },
    toString$0(_) {
      return "Token: " + this.name;
    }
  };
  A.Token_Token$fromCborBytesOrObject_closure.prototype = {
    call$1(e) {
      var cbor = A.CborSerializable_decodeCborTags(null, type$.CborObject._as(e), B.List_60_12, type$.CborListValue_dynamic),
        t1 = type$.nullable_String;
      return new A.CoingeckoCoin(A.ExtractCborList_elementAt(cbor, 0, type$.String), A.ExtractCborList_elementAt(cbor, 1, t1), A.ExtractCborList_elementAt(cbor, 2, t1));
    },
    $signature: 181
  };
  A._Token_Object_CborSerializable.prototype = {};
  A._Token_Object_CborSerializable_Equatable.prototype = {};
  A.ETHERC20Token.prototype = {
    get$variabels() {
      return [this.contractAddress.address];
    },
    $isTokenCore: 1
  };
  A._ETHERC20Token_Object_Equatable.prototype = {};
  A.RippleIssueToken.prototype = {
    get$variabels() {
      return [this.issuer];
    },
    $isTokenCore: 1
  };
  A._RippleIssueToken_Object_Equatable.prototype = {};
  A.TonJettonToken.prototype = {
    get$variabels() {
      return [this.minterAddress, this.walletAddress];
    },
    $isTokenCore: 1
  };
  A._TonJettonToken_Object_Equatable.prototype = {};
  A.SolanaSPLToken.prototype = {
    get$variabels() {
      return [this.mint.address, this.tokenAccount.address];
    },
    $isTokenCore: 1
  };
  A._SolanaSPLToken_Object_Equatable.prototype = {};
  A.TronTRC10Token.prototype = {
    get$variabels() {
      return [this.tokenID];
    },
    $isTokenCore: 1,
    $isTronToken: 1
  };
  A._TronTRC10Token_Object_Equatable.prototype = {};
  A.TronTRC20Token.prototype = {
    get$variabels() {
      return [this.contractAddress.toAddress$0()];
    },
    $isTokenCore: 1,
    $isTronToken: 1
  };
  A._TronTRC20Token_Object_Equatable.prototype = {};
  A.ChainsHandler.prototype = {
    updateChain$1(chain) {
      type$.nullable_Chain_of_APIProvider_and_NetworkCoinParams_APIProvider_and_dynamic_and_TokenCore_dynamic_and_ChainAccount_of_dynamic_and_TokenCore_dynamic_and_WalletNetwork_NetworkCoinParams_APIProvider_and_NetworkClient_of_ChainAccount_of_dynamic_and_TokenCore_dynamic_and_APIProvider_and_Web3BaseRequestParams_dynamic_dynamic_dynamic._as(chain);
      this._networks.$indexSet(0, chain.network.get$value(), chain);
    }
  };
  A.ChainsHandler_ChainsHandler$deserialize_closure.prototype = {
    call$1(e) {
      return A.Chain_Chain$fromCborBytesOrObject(null, type$.nullable_CborObject._as(e), type$.APIProvider, type$.NetworkCoinParams_APIProvider, type$.dynamic, type$.TokenCore_dynamic, type$.ChainAccount_of_nullable_Object_and_TokenCore_dynamic, type$.WalletNetwork_NetworkCoinParams_APIProvider, type$.NetworkClient_of_ChainAccount_of_nullable_Object_and_TokenCore_dynamic_and_APIProvider, type$.Web3BaseRequestParams_dynamic_dynamic_dynamic);
    },
    $signature: 182
  };
  A._ChainsHandler_Object_CborSerializable.prototype = {};
  A.Web3RequestMethods.prototype = {
    get$tag() {
      var t1 = A.List_List$of(B.List_80_0_3, true, type$.int);
      t1.push(this.id);
      return t1;
    }
  };
  A.Web3RequestParams.prototype = {
    get$type() {
      return B.Web3MessageTypes_359;
    },
    $isWeb3BaseRequestParams: 1
  };
  A._Web3RequestParams_Web3MessageCore_JsonSerialization.prototype = {};
  A.Web3EthereumRequestException.prototype = {
    toMessge$0() {
      return A.Web3ExceptionMessage$(-1, null, "method_not_found", null, null);
    }
  };
  A.Web3EthereumRequestMethods.prototype = {};
  A.Web3EthereumRequestMethods_fromId_closure.prototype = {
    call$1(e) {
      return type$.Web3EthereumRequestMethods._as(e).id === this.id;
    },
    $signature: 50
  };
  A.Web3EthereumRequestMethods_fromId_closure0.prototype = {
    call$0() {
      return A.throwExpression(B.C_Web3EthereumRequestException);
    },
    $signature: 2
  };
  A.Web3EthereumRequestMethods_fromName_closure.prototype = {
    call$1(e) {
      var t1;
      type$.Web3EthereumRequestMethods._as(e);
      t1 = this.name;
      return e.name === t1 || B.JSArray_methods.contains$1(e.methodsName, t1);
    },
    $signature: 50
  };
  A.Web3EthereumRequestMethods_fromName_closure0.prototype = {
    call$0() {
      return A.throwExpression(B.C_Web3EthereumRequestException);
    },
    $signature: 2
  };
  A.Web3EthereumPermissionRequestParam.prototype = {};
  A.Web3EthereumRequestParam.prototype = {};
  A.Web3EthreumAddChain.prototype = {
    toJson$0() {
      var _this = this,
        t1 = _this.decimals,
        t2 = type$.String;
      return A.LinkedHashMap_LinkedHashMap$_literal(["chainId", "0x" + _this.chainId.toRadixString$1(0, 16), "chainName", _this.chainName, "nativeCurrency", A.LinkedHashMap_LinkedHashMap$_literal(["name", _this.name, "symbol", _this.symbol, "decimals", t1], t2, type$.Object), "rpcUrls", _this.rpcUrls, "blockExplorerUrls", _this.blockExplorerUrls, "iconUrls", _this.iconUrls, "decimals", t1], t2, type$.dynamic);
    }
  };
  A.Web3EthreumPersonalSign.prototype = {
    toCbor$0() {
      var t1 = A._setArrayType([B.Web3EthereumRequestMethods_1_personal_sign_List_empty.get$tag(), this.address.address, new A.CborBytesValue(A.BytesUtils_fromHexString(this.challeng))], type$.JSArray_Object);
      return new A.CborTagValue(A.List_List$unmodifiable(B.List_0_10_100_2, type$.int), new A.CborListValue(t1, true, type$.CborListValue_Object), type$.CborTagValue_dynamic);
    },
    toJson$0() {
      return A.LinkedHashMap_LinkedHashMap$_literal(["address", this.address.address, "challeng", this.challeng], type$.String, type$.dynamic);
    }
  };
  A.Web3EthreumPersonalSign_Web3EthreumPersonalSign$fromJson_closure.prototype = {
    call$1(obj) {
      return A.ETHAddress_ETHAddress(obj);
    },
    $signature: 48
  };
  A.Web3EthreumRequestAccounts.prototype = {
    toCbor$0() {
      var t1 = A._setArrayType([B.Web3EthereumRequestMethods_5_eth_requestAccounts_List_empty.get$tag(), this.chainId], type$.JSArray_Object);
      return new A.CborTagValue(A.List_List$unmodifiable(B.List_0_10_100_2, type$.int), new A.CborListValue(t1, true, type$.CborListValue_Object), type$.CborTagValue_dynamic);
    },
    toJson$0() {
      return A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic);
    }
  };
  A.Web3EthreumSendTransaction.prototype = {
    toJson$0() {
      var t2, t3, t4, _this = this, _null = null,
        t1 = _this.gas;
      t1 = t1 == null ? _null : "0x" + B.JSInt_methods.toRadixString$1(t1, 16);
      t2 = _this.gasPrice;
      t2 = t2 == null ? _null : "0x" + t2.toRadixString$1(0, 16);
      t3 = _this.maxFeePerGas;
      t3 = t3 == null ? _null : "0x" + t3.toRadixString$1(0, 16);
      t4 = _this.maxPriorityFeePerGas;
      t4 = t4 == null ? _null : "0x" + t4.toRadixString$1(0, 16);
      return A.LinkedHashMap_LinkedHashMap$_literal(["from", _this.from.address, "to", _this.to.address, "gas", t1, "gasPrice", t2, "maxFeePerGas", t3, "maxPriorityFeePerGas", t4, "value", "0x" + _this.value.toRadixString$1(0, 16), "data", A.BytesUtils_toHexString(_this.data, true, "0x")], type$.String, type$.dynamic);
    },
    get$value() {
      return this.value;
    }
  };
  A.Web3EthreumTypdedData.prototype = {
    toCbor$0() {
      var t1 = A._setArrayType([B.Web3EthereumRequestMethods_MEg.get$tag(), this.address.address, new A.CborStringValue(B.C_JsonCodec.encode$2$toEncodable(this.typedData.toJson$0(), null)), this.chainId], type$.JSArray_Object);
      return new A.CborTagValue(A.List_List$unmodifiable(B.List_0_10_100_2, type$.int), new A.CborListValue(t1, true, type$.CborListValue_Object), type$.CborTagValue_dynamic);
    },
    toJson$0() {
      return A.LinkedHashMap_LinkedHashMap$_literal(["address", this.address.address, "typedData", this.typedData.toJson$0()], type$.String, type$.dynamic);
    }
  };
  A.Web3EthreumTypdedData_Web3EthreumTypdedData$fromJson_closure.prototype = {
    call$1(c) {
      return A.ETHAddress_ETHAddress(c);
    },
    $signature: 48
  };
  A.Web3EthreumSwitchChain.prototype = {
    toJson$0() {
      return A.LinkedHashMap_LinkedHashMap$_literal(["chainId", "0x" + this.chainId.toRadixString$1(0, 16)], type$.String, type$.dynamic);
    }
  };
  A.Web3EthereumValidator_parseTypedData_closure.prototype = {
    call$0() {
      return A.EIP712Base_EIP712Base$fromJson(A.StringUtils_toJson(this.data, type$.Map_String_dynamic));
    },
    $signature: 185
  };
  A.Web3ArgsTypes.prototype = {
    _enumToString$0() {
      return "Web3ArgsTypes." + this._core$_name;
    }
  };
  A.Web3RequestException.prototype = {$isException: 1, $isWeb3Exception: 1};
  A.Web3InternalException.prototype = {
    toMessge$0() {
      var _this = this;
      return A.Web3ExceptionMessage$(_this.code, _this.info, _this.message, _this.request, null);
    },
    $isException: 1,
    $isWeb3Exception: 1
  };
  A.Web3ArgrumentException.prototype = {
    toMessge$0() {
      var t1 = this.message;
      return A.Web3ExceptionMessage$(-20, null, t1 == null ? "" : t1, null, null);
    },
    $isException: 1,
    $isWeb3Exception: 1,
    get$value() {
      return this.value;
    }
  };
  A.Web3ArgsException.prototype = {
    toMessge$0() {
      return A.Web3ExceptionMessage$(-20, null, this.message, null, null);
    },
    $isException: 1,
    $isWeb3Exception: 1
  };
  A.Web3MessageTypes.prototype = {
    _enumToString$0() {
      return "Web3MessageTypes." + this._core$_name;
    }
  };
  A.Web3MessageTypes_fromTag_closure.prototype = {
    call$1(e) {
      return A.BytesUtils_bytesEqual(type$.Web3MessageTypes._as(e).tag, this.tags);
    },
    $signature: 186
  };
  A.Web3MessageTypes_fromTag_closure0.prototype = {
    call$0() {
      return A.throwExpression(A.Web3InternalException_internalError("message_type"));
    },
    $signature: 2
  };
  A.Web3MessageCore.prototype = {
    cast$1$0(_, $T) {
      A.checkTypeBound($T, type$.Web3MessageCore, "T", "cast");
      if (!$T._is(this))
        throw A.wrapException(A.Web3InternalException_internalError("message_casting"));
      return $T._as(this);
    }
  };
  A.Web3ChainMessage.prototype = {
    get$type() {
      return this.type;
    }
  };
  A.Web3EncryptedMessage.prototype = {};
  A.Web3ResponseMessage.prototype = {
    get$type() {
      return B.Web3MessageTypes_fvN;
    },
    get$value() {
      return this.value;
    }
  };
  A.Web3ExceptionMessage.prototype = {
    toJson$0() {
      var _this = this;
      return A.LinkedHashMap_LinkedHashMap$_literal(["message", _this.message, "code", _this.code, "info", _this.info, "request", _this.request, "requestId", _this.requestId], type$.String, type$.dynamic);
    },
    get$type() {
      return B.Web3MessageTypes_L6o;
    }
  };
  A._Web3EncryptedMessage_Object_CborSerializable.prototype = {};
  A._Web3MessageCore_Object_CborSerializable.prototype = {};
  A.Web3ValidatorUtils_parseAddress_closure.prototype = {
    call$0() {
      return this.onParse.call$1(this.value);
    },
    $signature() {
      return this.T._eval$1("0()");
    }
  };
  A.CustomCoins.prototype = {
    get$coinName() {
      return this.name;
    },
    get$proposal() {
      return B.C_CustomProposal;
    },
    get$value() {
      return this;
    },
    get$conf() {
      return this.conf;
    }
  };
  A.CustomCoins_fromName_closure.prototype = {
    call$1(element) {
      return type$.CustomCoins._as(element).name === this.name;
    },
    $signature: 187
  };
  A.CustomProposal.prototype = {
    get$value() {
      return this;
    },
    $isBipProposal: 1,
    get$name() {
      return "CIP-0019";
    }
  };
  A.CustomCurrencyConf_byronLegacy_closure.prototype = {
    call$1(kwargs) {
      return new A.AdaByronLegacyAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 47
  };
  A.CustomCurrencyConf_byronLegacyTestnet_closure.prototype = {
    call$1(kwargs) {
      return new A.AdaByronLegacyAddrEncoder();
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 47
  };
  A.AddressDerivationType.prototype = {
    _enumToString$0() {
      return "AddressDerivationType." + this._core$_name;
    }
  };
  A.AddressDerivationType_fromTag_closure.prototype = {
    call$1(e) {
      return A.BytesUtils_bytesEqual(type$.AddressDerivationType._as(e).tag, this.tag);
    },
    $signature: 189
  };
  A.AddressDerivationType_fromTag_closure0.prototype = {
    call$0() {
      return A.throwExpression($.$get$WalletExceptionConst_invalidAccountDetails());
    },
    $signature: 2
  };
  A.AddressDerivationIndex.prototype = {};
  A._AddressDerivationIndex_Object_CborSerializable.prototype = {};
  A._AddressDerivationIndex_Object_CborSerializable_Equatable.prototype = {};
  A.Bip32AddressIndex.prototype = {
    get$variabels() {
      var _this = this;
      return [_this.purpose, _this.coin, _this.accountLevel, _this.changeLevel, _this.addressIndex, _this.currencyCoin.get$conf().get$type(), _this.seedGeneration.name, _this.importedKeyId];
    },
    toString$0(_) {
      var t1 = this.hdPath;
      return t1 == null ? "non_derivation" : t1;
    }
  };
  A.Bip32AddressIndex__toPath_closure.prototype = {
    call$1(element) {
      return A._asIntQ(element) != null;
    },
    $signature: 190
  };
  A.Bip32AddressIndex__toPath_closure0.prototype = {
    call$1(e) {
      A._asIntQ(e);
      e.toString;
      return A.Bip32KeyIndex_Bip32KeyIndex(e);
    },
    $signature: 191
  };
  A.MultiSigAddressIndex.prototype = {
    get$variabels() {
      return [];
    },
    toString$0(_) {
      return "multi_signature";
    }
  };
  A.SubstrateAddressIndex.prototype = {
    get$variabels() {
      return [$.$get$SubstrateCoins__coinToConf().$index(0, this.currencyCoin).type, this.importedKeyId, this.substratePath];
    },
    toString$0(_) {
      var t1 = this.substratePath;
      return t1 == null ? "non_derivation" : t1;
    }
  };
  A.SeedTypes.prototype = {
    _enumToString$0() {
      return "SeedTypes." + this._core$_name;
    }
  };
  A.SeedTypes_fromName_closure.prototype = {
    call$1(e) {
      return type$.SeedTypes._as(e).name === this.name;
    },
    $signature: 192
  };
  A.SeedTypes_fromName_closure0.prototype = {
    call$0() {
      return A.throwExpression(A.WalletException$("Invalid seed generation type."));
    },
    $signature: 2
  };
  A.NetworkType.prototype = {};
  A.NetworkType_fromTag_closure.prototype = {
    call$1(e) {
      type$.NetworkType._as(e);
      return A.BytesUtils_bytesEqual(this._box_0.tag, e.tag);
    },
    $signature: 193
  };
  A.NetworkType_fromTag_closure0.prototype = {
    call$0() {
      return A.throwExpression($.$get$WalletExceptionConst_incorrectNetwork());
    },
    $signature: 2
  };
  A.ADAByronAddress.prototype = {
    get$addressType() {
      return B.ADAAddressType_8_Byron;
    },
    get$address() {
      return this.address;
    },
    get$network() {
      return this.network;
    }
  };
  A.ADAAddress.prototype = {
    toString$0(_) {
      return this.get$address();
    },
    toJson$0() {
      return this.get$address();
    },
    $eq(_, other) {
      var t1;
      if (other == null)
        return false;
      if (this !== other)
        t1 = other instanceof A.ADAAddress && A.getRuntimeTypeOfDartObject(other) === A.getRuntimeTypeOfDartObject(this) && this.get$address() === other.get$address();
      else
        t1 = true;
      return t1;
    },
    get$hashCode(_) {
      return (B.JSString_methods.get$hashCode(this.get$address()) ^ A.Primitives_objectHashCode(this.get$addressType()) ^ A.Primitives_objectHashCode(this.get$network())) >>> 0;
    }
  };
  A._ADAAddress_Object_ADASerialization.prototype = {};
  A.ADAPointerAddress.prototype = {
    get$addressType() {
      return B.ADAAddressType_4_Pointer;
    },
    get$address() {
      return this.address;
    },
    get$network() {
      return this.network;
    }
  };
  A.ADARewardAddress.prototype = {
    get$addressType() {
      return B.ADAAddressType_14_Reward;
    },
    get$address() {
      return this.address;
    },
    get$network() {
      return this.network;
    }
  };
  A.ADABaseAddress.prototype = {
    get$addressType() {
      return B.ADAAddressType_0_Base;
    },
    get$address() {
      return this.address;
    },
    get$network() {
      return this.network;
    }
  };
  A.ADAShellyAddress.prototype = {};
  A.ADAEnterpriseAddress.prototype = {
    get$addressType() {
      return B.ADAAddressType_6_Enterprise;
    },
    get$address() {
      return this.address;
    },
    get$network() {
      return this.network;
    }
  };
  A.StakeCred.prototype = {};
  A.StakeCredType.prototype = {
    toString$0(_) {
      return "StakeCredType." + this.name;
    },
    toJson$0() {
      return this.name;
    },
    get$value() {
      return this.value;
    }
  };
  A._StakeCredType_Object_ADASerialization.prototype = {};
  A.StakeCredKey.prototype = {
    get$type() {
      return B.StakeCredType_key_0;
    },
    toJson$0() {
      return A.LinkedHashMap_LinkedHashMap$_literal(["key", this.super$FixedBytes$toJson()], type$.String, type$.dynamic);
    }
  };
  A.StakeCredScript.prototype = {
    get$type() {
      return B.StakeCredType_script_1;
    },
    toJson$0() {
      return A.LinkedHashMap_LinkedHashMap$_literal(["script", this.super$FixedBytes$toJson()], type$.String, type$.dynamic);
    }
  };
  A.FixedBytes.prototype = {
    $eq(_, other) {
      var t1;
      if (other == null)
        return false;
      if (this !== other)
        t1 = other instanceof A.StakeCred && A.getRuntimeTypeOfDartObject(other) === A.getRuntimeTypeOfDartObject(this) && A.BytesUtils_bytesEqual(other.data, this.data);
      else
        t1 = true;
      return t1;
    },
    get$hashCode(_) {
      return B.JSArray_methods.fold$1$2(this.data, 4294967295, new A.FixedBytes_hashCode_closure(), type$.int);
    },
    compareTo$1(_, other) {
      var t1 = this.data,
        t2 = type$.FixedBytes._as(other).data,
        lenComparison = B.JSInt_methods.compareTo$1(t1.length, t2.length);
      if (lenComparison === 0)
        return A.BytesUtils_compareBytes(t1, t2);
      return lenComparison;
    },
    toJson$0() {
      return A.BytesUtils_toHexString(this.data, true, null);
    },
    toString$0(_) {
      return A.getRuntimeTypeOfDartObject(this).toString$0(0) + A.S(this.toJson$0()) + "}";
    },
    $isComparable: 1
  };
  A.FixedBytes_hashCode_closure.prototype = {
    call$2(previousValue, element) {
      return (A._asInt(previousValue) ^ B.JSInt_methods.get$hashCode(A._asInt(element))) >>> 0;
    },
    $signature: 19
  };
  A._FixedBytes_Object_ADASerialization.prototype = {};
  A.ADASerialization.prototype = {
    toString$0(_) {
      return J.toString$0$(this.toJson$0());
    }
  };
  A.ETHAddress.prototype = {
    toBytes$0() {
      return A.BytesUtils_fromHexString(this.address);
    },
    toString$0(_) {
      return this.address;
    },
    $isSolidityAddress: 1
  };
  A.EVMRPC.prototype = {};
  A.SolAddress.prototype = {
    $eq(_, other) {
      if (other == null)
        return false;
      return other instanceof A.SolAddress && other.address === this.address;
    },
    get$hashCode(_) {
      return B.JSString_methods.get$hashCode(this.address);
    },
    toString$0(_) {
      return this.address;
    }
  };
  A.AbiParameter.prototype = {
    legacyEip712Encode$2(value, keepSize) {
      return A.ABICoder_ABICoder$fromType(this.type, type$.dynamic).legacyEip712Encode$3(this, value, keepSize);
    },
    abiEncode$1(value) {
      return A.ABICoder_ABICoder$fromType(this.type, type$.dynamic).abiEncode$2(this, value);
    },
    get$isDynamic() {
      var t1 = this.type;
      if (t1 === "string" || t1 === "bytes" || B.JSString_methods.endsWith$1(t1, "[]"))
        return true;
      if (t1 === "tuple")
        return B.JSArray_methods.any$1(this.components, new A.AbiParameter_isDynamic_closure());
      if (B.JSString_methods.endsWith$1(t1, "]"))
        return A._ABIUtils_toArrayType(this).item1.get$isDynamic();
      return false;
    }
  };
  A.AbiParameter_isDynamic_closure.prototype = {
    call$1(component) {
      return type$.AbiParameter._as(component).get$isDynamic();
    },
    $signature: 194
  };
  A.EncoderResult.prototype = {};
  A.EIP712Version.prototype = {};
  A.EIP712Version_fromVersion_closure.prototype = {
    call$1(e) {
      return type$.EIP712Version._as(e).version === this.version;
    },
    $signature: 195
  };
  A.EIP712Version_fromVersion_closure0.prototype = {
    call$0() {
      return A.throwExpression(A.SolidityAbiException$("Invalid EIP712Version version.", A.LinkedHashMap_LinkedHashMap$_literal(["version", this.version, "excepted", B.JSArray_methods.map$1$1(B.List_Gbr, new A.EIP712Version_fromVersion__closure(), type$.int).join$1(0, ", ")], type$.String, type$.dynamic)));
    },
    $signature: 2
  };
  A.EIP712Version_fromVersion__closure.prototype = {
    call$1(e) {
      return type$.EIP712Version._as(e).version;
    },
    $signature: 196
  };
  A.Eip712TypeDetails.prototype = {
    toString$0(_) {
      return "name: " + this.name + "  type: " + this.type;
    },
    toJson$0() {
      return A.LinkedHashMap_LinkedHashMap$_literal(["name", this.name, "type", this.type], type$.String, type$.dynamic);
    }
  };
  A.Eip712TypedData.prototype = {
    encode$0() {
      var t2, _this = this,
        t1 = A.List_List$of(B.List_25_1, true, type$.int);
      B.JSArray_methods.addAll$1(t1, A.Keccack_hash(A._EIP712Utils_encodeStruct(_this, "EIP712Domain", _this.domain), 32));
      B.JSArray_methods.addAll$1(t1, A.Keccack_hash(A._EIP712Utils_encodeStruct(_this, _this.primaryType, _this.message), 32));
      t2 = A.Keccack_hash(t1, 32);
      return t2;
    },
    toJson$0() {
      var _this = this,
        t1 = type$.String;
      return A.LinkedHashMap_LinkedHashMap$_literal(["types", _this.types.map$2$1(0, new A.Eip712TypedData_toJson_closure(), t1, type$.List_Map_String_dynamic), "domain", _this.domain, "message", _this.message, "primaryType", _this.primaryType, "version", _this.version.version], t1, type$.dynamic);
    },
    $isEIP712Base: 1
  };
  A.Eip712TypedData_Eip712TypedData$fromJson_closure.prototype = {
    call$1(e) {
      type$.Map_String_dynamic._as(e);
      return new A.Eip712TypeDetails(A._asString(e.$index(0, "name")), A._asString(e.$index(0, "type")));
    },
    $signature: 197
  };
  A.Eip712TypedData_toJson_closure.prototype = {
    call$2(k, v) {
      var t1;
      A._asString(k);
      t1 = J.map$1$1$ax(type$.List_Eip712TypeDetails._as(v), new A.Eip712TypedData_toJson__closure(), type$.Map_String_dynamic);
      return new A.MapEntry(k, A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E")), type$.MapEntry_of_String_and_List_Map_String_dynamic);
    },
    $signature: 198
  };
  A.Eip712TypedData_toJson__closure.prototype = {
    call$1(e) {
      return type$.Eip712TypeDetails._as(e).toJson$0();
    },
    $signature: 199
  };
  A.Eip712TypedDataV1.prototype = {
    toJson$0() {
      var t1 = this.type;
      return A.LinkedHashMap_LinkedHashMap$_literal(["name", this.name, "type", t1, "value", A._EIP712Utils_eip712TypedDataV1ValueToJson(t1, this.value)], type$.String, type$.dynamic);
    },
    get$value() {
      return this.value;
    }
  };
  A.EIP712Legacy.prototype = {
    encode$0() {
      var t4, types, names, typesHash, _length, _list, index, namesHash,
        t1 = this.typesData,
        t2 = A._arrayInstanceType(t1),
        t3 = t2._eval$1("MappedListIterable<1,@>"),
        values = A.List_List$of(new A.MappedListIterable(t1, t2._eval$1("@(1)")._as(new A.EIP712Legacy_encode_closure()), t3), true, t3._eval$1("ListIterable.E"));
      t3 = t2._eval$1("String(1)");
      t2 = t2._eval$1("MappedListIterable<1,String>");
      t4 = t2._eval$1("ListIterable.E");
      types = A.List_List$of(new A.MappedListIterable(t1, t3._as(new A.EIP712Legacy_encode_closure0()), t2), true, t4);
      names = A.List_List$of(new A.MappedListIterable(t1, t3._as(new A.EIP712Legacy_encode_closure1()), t2), true, t4);
      typesHash = A.Keccack_hash(A._EIP712Utils_legacyV1encode(types, values), 32);
      _length = names.length;
      _list = J.JSArray_JSArray$allocateGrowable(_length, type$.String);
      for (index = 0; index < _length; ++index)
        _list[index] = "string";
      namesHash = A.Keccack_hash(A._EIP712Utils_legacyV1encode(_list, names), 32);
      return A.Keccack_hash(A._EIP712Utils_legacyV1encode(A._setArrayType(["bytes32", "bytes32"], type$.JSArray_String), [namesHash, typesHash]), 32);
    },
    toJson$0() {
      var t1 = this.typesData,
        t2 = A._arrayInstanceType(t1),
        t3 = t2._eval$1("MappedListIterable<1,Map<String,@>>");
      return A.LinkedHashMap_LinkedHashMap$_literal(["types", A.List_List$of(new A.MappedListIterable(t1, t2._eval$1("Map<String,@>(1)")._as(new A.EIP712Legacy_toJson_closure()), t3), true, t3._eval$1("ListIterable.E")), "version", 1], type$.String, type$.dynamic);
    },
    $isEIP712Base: 1
  };
  A.EIP712Legacy_EIP712Legacy$fromJson_closure.prototype = {
    call$1(e) {
      var t1;
      type$.Map_String_dynamic._as(e);
      t1 = A._asString(e.$index(0, "type"));
      return new A.Eip712TypedDataV1(A._asString(e.$index(0, "name")), t1, A._EIP712Utils_ensureCorrectValues(t1, e.$index(0, "value")));
    },
    $signature: 200
  };
  A.EIP712Legacy_encode_closure.prototype = {
    call$1(e) {
      return type$.Eip712TypedDataV1._as(e).value;
    },
    $signature: 201
  };
  A.EIP712Legacy_encode_closure0.prototype = {
    call$1(e) {
      return type$.Eip712TypedDataV1._as(e).type;
    },
    $signature: 46
  };
  A.EIP712Legacy_encode_closure1.prototype = {
    call$1(e) {
      type$.Eip712TypedDataV1._as(e);
      return e.type + " " + e.name;
    },
    $signature: 46
  };
  A.EIP712Legacy_toJson_closure.prototype = {
    call$1(e) {
      return type$.Eip712TypedDataV1._as(e).toJson$0();
    },
    $signature: 203
  };
  A._EIP712Utils_ensureCorrectValues_closure.prototype = {
    call$1(e) {
      var t1 = this.childType;
      t1.toString;
      return A._EIP712Utils_ensureCorrectValues(t1, e);
    },
    $signature: 15
  };
  A._EIP712Utils_eip712TypedDataV1ValueToJson_closure.prototype = {
    call$1(e) {
      var t1 = this.childType;
      t1.toString;
      return A._EIP712Utils_eip712TypedDataV1ValueToJson(t1, e);
    },
    $signature: 15
  };
  A._EIP712Utils_getDependencies_closure.prototype = {
    call$2(previous, t) {
      var t1;
      type$.List_String._as(previous);
      type$.Eip712TypeDetails._as(t);
      t1 = A.List_List$of(previous, true, type$.String);
      B.JSArray_methods.addAll$1(t1, J.where$1$ax(A._EIP712Utils_getDependencies(this.typedData, t.type, previous), new A._EIP712Utils_getDependencies__closure(previous)));
      return t1;
    },
    $signature: 204
  };
  A._EIP712Utils_getDependencies__closure.prototype = {
    call$1(dependency) {
      return !J.contains$1$asx(this.previous, A._asString(dependency));
    },
    $signature: 17
  };
  A._EIP712Utils_encodeValue_closure.prototype = {
    call$1(item) {
      return A._EIP712Utils_encodeValue(this.typedData, this.isArray.item1, item);
    },
    $signature: 205
  };
  A._EIP712Utils_encodeValue_closure0.prototype = {
    call$1(item) {
      return type$.Tuple_String_dynamic._as(item).item1;
    },
    $signature: 206
  };
  A._EIP712Utils_encodeValue_closure1.prototype = {
    call$1(item) {
      return type$.Tuple_String_dynamic._as(item).item2;
    },
    $signature: 207
  };
  A._EIP712Utils_abiEncode_closure.prototype = {
    call$1(e) {
      return A.AbiParameter$(B.List_empty0, "", false, A._asString(e));
    },
    $signature: 72
  };
  A._EIP712Utils_legacyV1encode_closure.prototype = {
    call$1(e) {
      return A.AbiParameter$(B.List_empty0, "", false, A._asString(e));
    },
    $signature: 72
  };
  A._EIP712Utils_getMethodSigature_closure.prototype = {
    call$1(dependency) {
      var t1;
      A._asString(dependency);
      t1 = this.typedData.types.$index(0, dependency);
      t1.toString;
      return dependency + "(" + J.map$1$1$ax(t1, new A._EIP712Utils_getMethodSigature__closure(), type$.String).join$1(0, ",") + ")";
    },
    $signature: 16
  };
  A._EIP712Utils_getMethodSigature__closure.prototype = {
    call$1(t) {
      type$.Eip712TypeDetails._as(t);
      return t.type + " " + t.name;
    },
    $signature: 209
  };
  A.SolidityAbiException.prototype = {
    get$message() {
      return this.message;
    }
  };
  A.AddressCoder.prototype = {
    abiEncode$2(params, input) {
      var bytes, addrBytes;
      type$.SolidityAddress._as(input);
      bytes = A.List_List$filled(32, 0, false, type$.int);
      addrBytes = input.toBytes$0();
      B.JSArray_methods.setAll$2(bytes, 12, addrBytes.length === 21 ? B.JSArray_methods.sublist$1(addrBytes, 1) : addrBytes);
      return new A.EncoderResult(false, bytes);
    },
    legacyEip712Encode$3(params, input, keepSize) {
      var addrBytes;
      type$.SolidityAddress._as(input);
      if (keepSize)
        return this.abiEncode$2(params, input);
      addrBytes = input.toBytes$0();
      B.JSArray_methods.sublist$1(addrBytes, addrBytes.length - 20);
      return new A.EncoderResult(false, input.toBytes$0());
    },
    $isABICoder: 1
  };
  A.ArrayCoder.prototype = {
    abiEncode$2(params, input) {
      var param, t1, t2, encodedParams, dynamicItems, isDynamic, t3, encode, $length, resultBytes, t4;
      type$.List_dynamic._as(input);
      param = A._ABIUtils_toArrayType(params);
      t1 = J.getInterceptor$ax(input);
      t2 = t1.map$1$1(input, new A.ArrayCoder_abiEncode_closure(param), type$.EncoderResult);
      encodedParams = A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E"));
      dynamicItems = encodedParams.length !== 0 && B.JSArray_methods.get$first(encodedParams).isDynamic;
      t2 = param.item2;
      isDynamic = J.$eq$(t2, -1);
      t3 = !isDynamic;
      if (t3 && t1.get$length(input) !== t2)
        throw A.wrapException(B.SolidityAbiException_Auo);
      if (!t3 || dynamicItems) {
        encode = A._ABIUtils_encodeDynamicParams(encodedParams);
        if (isDynamic) {
          $length = B.C_NumbersCoder.abiEncode$2(B.AbiParameter_uint256_false_List_empty, A._BigIntImpl__BigIntImpl$from(encodedParams.length)).encoded;
          if (encodedParams.length === 0)
            t1 = $length;
          else {
            t1 = A.List_List$of($length, true, type$.int);
            B.JSArray_methods.addAll$1(t1, encode);
          }
          return new A.EncoderResult(true, t1);
        }
        return new A.EncoderResult(true, encode);
      }
      t1 = A._arrayInstanceType(encodedParams);
      t2 = t1._eval$1("MappedListIterable<1,List<int>>");
      resultBytes = new A.MappedListIterable(encodedParams, t1._eval$1("List<int>(1)")._as(new A.ArrayCoder_abiEncode_closure0()), t2);
      t1 = A._setArrayType([], type$.JSArray_int);
      for (t3 = new A.ListIterator(resultBytes, resultBytes.get$length(0), t2._eval$1("ListIterator<ListIterable.E>")), t2 = t2._eval$1("ListIterable.E"); t3.moveNext$0();) {
        t4 = t3.__internal$_current;
        B.JSArray_methods.addAll$1(t1, t4 == null ? t2._as(t4) : t4);
      }
      return new A.EncoderResult(false, t1);
    },
    legacyEip712Encode$3(params, input, keepSize) {
      var t2, resultBytes, t3, t4,
        t1 = J.map$1$1$ax(type$.List_dynamic._as(input), new A.ArrayCoder_legacyEip712Encode_closure(A._ABIUtils_toArrayType(params)), type$.EncoderResult),
        encodedParams = A.List_List$of(t1, true, t1.$ti._eval$1("ListIterable.E"));
      t1 = A._arrayInstanceType(encodedParams);
      t2 = t1._eval$1("MappedListIterable<1,List<int>>");
      resultBytes = new A.MappedListIterable(encodedParams, t1._eval$1("List<int>(1)")._as(new A.ArrayCoder_legacyEip712Encode_closure0()), t2);
      t1 = A._setArrayType([], type$.JSArray_int);
      for (t3 = new A.ListIterator(resultBytes, resultBytes.get$length(0), t2._eval$1("ListIterator<ListIterable.E>")), t2 = t2._eval$1("ListIterable.E"); t3.moveNext$0();) {
        t4 = t3.__internal$_current;
        B.JSArray_methods.addAll$1(t1, t4 == null ? t2._as(t4) : t4);
      }
      return new A.EncoderResult(false, t1);
    },
    $isABICoder: 1
  };
  A.ArrayCoder_abiEncode_closure.prototype = {
    call$1(e) {
      return this.param.item1.abiEncode$1(e);
    },
    $signature: 70
  };
  A.ArrayCoder_abiEncode_closure0.prototype = {
    call$1(e) {
      return type$.EncoderResult._as(e).encoded;
    },
    $signature: 14
  };
  A.ArrayCoder_legacyEip712Encode_closure.prototype = {
    call$1(e) {
      return this.param.item1.legacyEip712Encode$2(e, true);
    },
    $signature: 70
  };
  A.ArrayCoder_legacyEip712Encode_closure0.prototype = {
    call$1(e) {
      return type$.EncoderResult._as(e).encoded;
    },
    $signature: 14
  };
  A.BooleanCoder.prototype = {
    abiEncode$2(params, input) {
      var bytes;
      A._asBool(input);
      bytes = A.List_List$filled(32, 0, false, type$.int);
      if (input)
        B.JSArray_methods.$indexSet(bytes, 31, 1);
      return new A.EncoderResult(false, bytes);
    },
    legacyEip712Encode$3(params, input, keepSize) {
      var bytes;
      A._asBool(input);
      if (keepSize)
        return this.abiEncode$2(params, input);
      bytes = A.List_List$filled(1, 0, false, type$.int);
      B.JSArray_methods.$indexSet(bytes, 0, input ? 1 : 0);
      return new A.EncoderResult(false, bytes);
    },
    $isABICoder: 1
  };
  A.BytesCoder.prototype = {
    abiEncode$2(params, input) {
      var t1, encoded, size, bytes;
      type$.List_int._as(input);
      if (params.get$isDynamic()) {
        t1 = J.getInterceptor$asx(input);
        encoded = A.List_List$filled(32 + B.JSNumber_methods.ceil$0(t1.get$length(input) / 32) * 32, 0, false, type$.int);
        B.JSArray_methods.setAll$2(encoded, 0, B.C_NumbersCoder.abiEncode$2(B.AbiParameter_uint32_false_List_empty, A._BigIntImpl__BigIntImpl$from(t1.get$length(input))).encoded);
        B.JSArray_methods.setAll$2(encoded, 32, input);
        return new A.EncoderResult(true, encoded);
      }
      t1 = params.type;
      size = A._ABIUtils_bytesSize(t1);
      size.toString;
      A._ABIValidator_validateBytes(t1, input, size, size);
      bytes = A.List_List$filled(32, 0, false, type$.int);
      B.JSArray_methods.setAll$2(bytes, 0, input);
      return new A.EncoderResult(false, bytes);
    },
    legacyEip712Encode$3(params, input, keepSize) {
      var size;
      type$.List_int._as(input);
      size = A._ABIUtils_bytesSize(params.type);
      if (size != null && J.get$length$asx(input) !== size)
        throw A.wrapException(B.SolidityAbiException_1lF);
      return new A.EncoderResult(false, input);
    },
    $isABICoder: 1
  };
  A.FunctionCoder.prototype = {
    abiEncode$2(params, input) {
      return B.C_BytesCoder.abiEncode$2(B.AbiParameter_bytes24_false_List_empty, type$.List_int._as(input));
    },
    legacyEip712Encode$3(params, input, keepSize) {
      return B.C_BytesCoder.legacyEip712Encode$3(B.AbiParameter_bytes24_false_List_empty, type$.List_int._as(input), keepSize);
    },
    $isABICoder: 1
  };
  A.NumbersCoder.prototype = {
    abiEncode$2(params, input) {
      type$.BigInt._as(input);
      A._ABIValidator_isValidNumber(params.type, input);
      return new A.EncoderResult(false, A.BigintUtils_toBytes(input, 32, B.C_Endian));
    },
    legacyEip712Encode$3(params, input, keepSize) {
      var t1, size;
      type$.BigInt._as(input);
      t1 = params.type;
      A._ABIValidator_isValidNumber(t1, input);
      size = A._ABIUtils_numericSize(t1);
      if (size == null)
        size = 32;
      t1 = $.$get$_BigIntImpl_one();
      t1 = input.$and(0, t1.$shl(0, size * 8).$sub(0, t1));
      return new A.EncoderResult(false, A.BigintUtils_toBytes(t1, keepSize ? 32 : size, B.C_Endian));
    },
    $isABICoder: 1
  };
  A.StringCoder.prototype = {
    abiEncode$2(params, input) {
      return B.C_BytesCoder.abiEncode$2(B.AbiParameter_bytes_false_List_empty, A.StringUtils_encode(A._asString(input), B.StringEncoding_1));
    },
    legacyEip712Encode$3(params, input, keepSize) {
      return B.C_BytesCoder.legacyEip712Encode$3(B.AbiParameter_bytes_false_List_empty, A.StringUtils_encode(A._asString(input), B.StringEncoding_1), keepSize);
    },
    $isABICoder: 1
  };
  A.TupleCoder.prototype = {
    abiEncode$2(params, input) {
      var encoded, t1, t2, t3, isDynamic, i, paramComponent, t4, result, re, _i;
      type$.List_dynamic._as(input);
      encoded = A._setArrayType([], type$.JSArray_EncoderResult);
      t1 = J.getInterceptor$asx(input);
      t2 = params.components;
      if (t1.get$length(input) !== t2.length)
        throw A.wrapException(B.SolidityAbiException_Auo);
      for (t3 = type$.dynamic, isDynamic = false, i = 0; i < t2.length; ++i) {
        paramComponent = t2[i];
        t4 = t1.$index(input, i);
        result = A.ABICoder_ABICoder$fromType(paramComponent.type, t3).abiEncode$2(paramComponent, t4);
        if (result.isDynamic)
          isDynamic = true;
        B.JSArray_methods.add$1(encoded, result);
      }
      if (isDynamic)
        return new A.EncoderResult(true, A._ABIUtils_encodeDynamicParams(encoded));
      t1 = type$.MappedListIterable_of_EncoderResult_and_List_int;
      re = A.List_List$of(new A.MappedListIterable(encoded, type$.List_int_Function_EncoderResult._as(new A.TupleCoder_abiEncode_closure()), t1), true, t1._eval$1("ListIterable.E"));
      t1 = A._setArrayType([], type$.JSArray_int);
      for (t2 = re.length, _i = 0; _i < t2; ++_i)
        B.JSArray_methods.addAll$1(t1, re[_i]);
      return new A.EncoderResult(false, t1);
    },
    legacyEip712Encode$3(params, input, keepSize) {
      var encoded, t1, t2, t3, i, paramComponent, t4, re, _i;
      type$.List_dynamic._as(input);
      encoded = A._setArrayType([], type$.JSArray_EncoderResult);
      t1 = J.getInterceptor$asx(input);
      t2 = params.components;
      if (t1.get$length(input) !== t2.length)
        throw A.wrapException(B.SolidityAbiException_Auo);
      for (t3 = type$.dynamic, i = 0; i < t2.length; ++i) {
        paramComponent = t2[i];
        t4 = t1.$index(input, i);
        B.JSArray_methods.add$1(encoded, A.ABICoder_ABICoder$fromType(paramComponent.type, t3).legacyEip712Encode$3(paramComponent, t4, keepSize));
      }
      t1 = type$.MappedListIterable_of_EncoderResult_and_List_int;
      re = A.List_List$of(new A.MappedListIterable(encoded, type$.List_int_Function_EncoderResult._as(new A.TupleCoder_legacyEip712Encode_closure()), t1), true, t1._eval$1("ListIterable.E"));
      t1 = A._setArrayType([], type$.JSArray_int);
      for (t2 = re.length, _i = 0; _i < t2; ++_i)
        B.JSArray_methods.addAll$1(t1, re[_i]);
      return new A.EncoderResult(false, t1);
    },
    $isABICoder: 1
  };
  A.TupleCoder_abiEncode_closure.prototype = {
    call$1(e) {
      return type$.EncoderResult._as(e).encoded;
    },
    $signature: 14
  };
  A.TupleCoder_legacyEip712Encode_closure.prototype = {
    call$1(e) {
      return type$.EncoderResult._as(e).encoded;
    },
    $signature: 14
  };
  A._ABIUtils_encodeDynamicParams_closure.prototype = {
    call$1(p) {
      return type$.EncoderResult._as(p).encoded;
    },
    $signature: 14
  };
  A._ABIUtils_encodeDynamicParams_closure0.prototype = {
    call$1(element) {
      return type$.List_int._as(element);
    },
    $signature: 67
  };
  A._ABIUtils_encodeDynamicParams_closure1.prototype = {
    call$1(p) {
      return type$.EncoderResult._as(p).encoded;
    },
    $signature: 14
  };
  A._ABIUtils_encodeDynamicParams_closure2.prototype = {
    call$1(element) {
      return type$.List_int._as(element);
    },
    $signature: 67
  };
  A.TronAddress.prototype = {
    toBytes$0() {
      return A.BytesUtils_fromHexString(this._hexAddress);
    },
    toAddress$1(visible) {
      return this._address;
    },
    toAddress$0() {
      return this.toAddress$1(true);
    },
    toString$0(_) {
      return this.toAddress$1(true);
    },
    $isSolidityAddress: 1
  };
  A.PermissionType.prototype = {
    toString$0(_) {
      return this.name;
    },
    get$value() {
      return this.value;
    }
  };
  A.PermissionType_fromName_closure.prototype = {
    call$1(element) {
      return type$.PermissionType._as(element).name === this.name;
    },
    $signature: 213
  };
  A.PermissionType_fromName_closure0.prototype = {
    call$0() {
      return this.defaultPermission;
    },
    $signature: 214
  };
  A.ResourceCode.prototype = {
    toString$0(_) {
      return this.name;
    },
    get$value() {
      return this.value;
    }
  };
  A.ResourceCode_fromName_closure0.prototype = {
    call$1(element) {
      return type$.ResourceCode._as(element).name === this.name;
    },
    $signature: 215
  };
  A.ResourceCode_fromName_closure.prototype = {
    call$0() {
      return this.orElse;
    },
    $signature: 216
  };
  A.Context.prototype = {
    absolute$1(part1) {
      var t2, parts,
        t1 = type$.JSArray_nullable_String;
      A._validateArgList("absolute", A._setArrayType([part1, null, null, null, null, null, null, null, null, null, null, null, null, null, null], t1));
      t2 = this.style;
      t2 = t2.rootLength$1(part1) > 0 && !t2.isRootRelative$1(part1);
      if (t2)
        return part1;
      t2 = A.current();
      parts = A._setArrayType([t2, part1, null, null, null, null, null, null, null, null, null, null, null, null, null, null], t1);
      A._validateArgList("join", parts);
      return this.joinAll$1(new A.WhereTypeIterable(parts, type$.WhereTypeIterable_String));
    },
    joinAll$1(parts) {
      var t1, t2, t3, needsSeparator, isAbsoluteAndNotRootRelative, t4, t5, parsed, path, t6;
      type$.Iterable_String._as(parts);
      for (t1 = parts.$ti, t2 = t1._eval$1("bool(Iterable.E)")._as(new A.Context_joinAll_closure()), t3 = parts.get$iterator(0), t1 = new A.WhereIterator(t3, t2, t1._eval$1("WhereIterator<Iterable.E>")), t2 = this.style, needsSeparator = false, isAbsoluteAndNotRootRelative = false, t4 = ""; t1.moveNext$0();) {
        t5 = t3.get$current();
        if (t2.isRootRelative$1(t5) && isAbsoluteAndNotRootRelative) {
          parsed = A.ParsedPath_ParsedPath$parse(t5, t2);
          path = t4.charCodeAt(0) == 0 ? t4 : t4;
          t4 = B.JSString_methods.substring$2(path, 0, t2.rootLength$2$withDrive(path, true));
          parsed.root = t4;
          if (t2.needsSeparator$1(t4))
            B.JSArray_methods.$indexSet(parsed.separators, 0, t2.get$separator());
          t4 = "" + parsed.toString$0(0);
        } else if (t2.rootLength$1(t5) > 0) {
          isAbsoluteAndNotRootRelative = !t2.isRootRelative$1(t5);
          t4 = "" + t5;
        } else {
          t6 = t5.length;
          if (t6 !== 0) {
            if (0 >= t6)
              return A.ioore(t5, 0);
            t6 = t2.containsSeparator$1(t5[0]);
          } else
            t6 = false;
          if (!t6)
            if (needsSeparator)
              t4 += t2.get$separator();
          t4 += t5;
        }
        needsSeparator = t2.needsSeparator$1(t5);
      }
      return t4.charCodeAt(0) == 0 ? t4 : t4;
    },
    split$1(_, path) {
      var parsed = A.ParsedPath_ParsedPath$parse(path, this.style),
        t1 = parsed.parts,
        t2 = A._arrayInstanceType(t1),
        t3 = t2._eval$1("WhereIterable<1>");
      parsed.set$parts(A.List_List$of(new A.WhereIterable(t1, t2._eval$1("bool(1)")._as(new A.Context_split_closure()), t3), true, t3._eval$1("Iterable.E")));
      t1 = parsed.root;
      if (t1 != null)
        B.JSArray_methods.insert$2(parsed.parts, 0, t1);
      return parsed.parts;
    },
    normalize$1(path) {
      var parsed;
      if (!this._needsNormalization$1(path))
        return path;
      parsed = A.ParsedPath_ParsedPath$parse(path, this.style);
      parsed.normalize$0();
      return parsed.toString$0(0);
    },
    _needsNormalization$1(path) {
      var t2, i, start, previous, t3, previousPrevious, codeUnit, t4,
        t1 = this.style,
        root = t1.rootLength$1(path);
      if (root !== 0) {
        if (t1 === $.$get$Style_windows())
          for (t2 = path.length, i = 0; i < root; ++i) {
            if (!(i < t2))
              return A.ioore(path, i);
            if (path.charCodeAt(i) === 47)
              return true;
          }
        start = root;
        previous = 47;
      } else {
        start = 0;
        previous = null;
      }
      for (t2 = new A.CodeUnits(path).__internal$_string, t3 = t2.length, i = start, previousPrevious = null; i < t3; ++i, previousPrevious = previous, previous = codeUnit) {
        if (!(i >= 0))
          return A.ioore(t2, i);
        codeUnit = t2.charCodeAt(i);
        if (t1.isSeparator$1(codeUnit)) {
          if (t1 === $.$get$Style_windows() && codeUnit === 47)
            return true;
          if (previous != null && t1.isSeparator$1(previous))
            return true;
          if (previous === 46)
            t4 = previousPrevious == null || previousPrevious === 46 || t1.isSeparator$1(previousPrevious);
          else
            t4 = false;
          if (t4)
            return true;
        }
      }
      if (previous == null)
        return true;
      if (t1.isSeparator$1(previous))
        return true;
      if (previous === 46)
        t1 = previousPrevious == null || t1.isSeparator$1(previousPrevious) || previousPrevious === 46;
      else
        t1 = false;
      if (t1)
        return true;
      return false;
    },
    relative$1(path) {
      var from, fromParsed, pathParsed, t3, t4, t5, _this = this,
        _s26_ = 'Unable to find a path to "',
        t1 = _this.style,
        t2 = t1.rootLength$1(path);
      if (t2 <= 0)
        return _this.normalize$1(path);
      from = A.current();
      if (t1.rootLength$1(from) <= 0 && t1.rootLength$1(path) > 0)
        return _this.normalize$1(path);
      if (t1.rootLength$1(path) <= 0 || t1.isRootRelative$1(path))
        path = _this.absolute$1(path);
      if (t1.rootLength$1(path) <= 0 && t1.rootLength$1(from) > 0)
        throw A.wrapException(A.PathException$(_s26_ + path + '" from "' + from + '".'));
      fromParsed = A.ParsedPath_ParsedPath$parse(from, t1);
      fromParsed.normalize$0();
      pathParsed = A.ParsedPath_ParsedPath$parse(path, t1);
      pathParsed.normalize$0();
      t2 = fromParsed.parts;
      t3 = t2.length;
      if (t3 !== 0) {
        if (0 >= t3)
          return A.ioore(t2, 0);
        t2 = J.$eq$(t2[0], ".");
      } else
        t2 = false;
      if (t2)
        return pathParsed.toString$0(0);
      t2 = fromParsed.root;
      t3 = pathParsed.root;
      if (t2 != t3)
        t2 = t2 == null || t3 == null || !t1.pathsEqual$2(t2, t3);
      else
        t2 = false;
      if (t2)
        return pathParsed.toString$0(0);
      while (true) {
        t2 = fromParsed.parts;
        t3 = t2.length;
        if (t3 !== 0) {
          t4 = pathParsed.parts;
          t5 = t4.length;
          if (t5 !== 0) {
            if (0 >= t3)
              return A.ioore(t2, 0);
            t2 = t2[0];
            if (0 >= t5)
              return A.ioore(t4, 0);
            t4 = t1.pathsEqual$2(t2, t4[0]);
            t2 = t4;
          } else
            t2 = false;
        } else
          t2 = false;
        if (!t2)
          break;
        B.JSArray_methods.removeAt$1(fromParsed.parts, 0);
        B.JSArray_methods.removeAt$1(fromParsed.separators, 1);
        B.JSArray_methods.removeAt$1(pathParsed.parts, 0);
        B.JSArray_methods.removeAt$1(pathParsed.separators, 1);
      }
      t2 = fromParsed.parts;
      t3 = t2.length;
      if (t3 !== 0) {
        if (0 >= t3)
          return A.ioore(t2, 0);
        t2 = J.$eq$(t2[0], "..");
      } else
        t2 = false;
      if (t2)
        throw A.wrapException(A.PathException$(_s26_ + path + '" from "' + from + '".'));
      t2 = type$.String;
      B.JSArray_methods.insertAll$2(pathParsed.parts, 0, A.List_List$filled(fromParsed.parts.length, "..", false, t2));
      B.JSArray_methods.$indexSet(pathParsed.separators, 0, "");
      B.JSArray_methods.insertAll$2(pathParsed.separators, 1, A.List_List$filled(fromParsed.parts.length, t1.get$separator(), false, t2));
      t1 = pathParsed.parts;
      t2 = t1.length;
      if (t2 === 0)
        return ".";
      if (t2 > 1 && J.$eq$(B.JSArray_methods.get$last(t1), ".")) {
        B.JSArray_methods.removeLast$0(pathParsed.parts);
        t1 = pathParsed.separators;
        if (0 >= t1.length)
          return A.ioore(t1, -1);
        t1.pop();
        if (0 >= t1.length)
          return A.ioore(t1, -1);
        t1.pop();
        B.JSArray_methods.add$1(t1, "");
      }
      pathParsed.root = "";
      pathParsed.removeTrailingSeparators$0();
      return pathParsed.toString$0(0);
    },
    prettyUri$1(uri) {
      var path, rel, _this = this,
        typedUri = A._parseUri(uri);
      if (typedUri.get$scheme() === "file" && _this.style === $.$get$Style_url())
        return typedUri.toString$0(0);
      else if (typedUri.get$scheme() !== "file" && typedUri.get$scheme() !== "" && _this.style !== $.$get$Style_url())
        return typedUri.toString$0(0);
      path = _this.normalize$1(_this.style.pathFromUri$1(A._parseUri(typedUri)));
      rel = _this.relative$1(path);
      return _this.split$1(0, rel).length > _this.split$1(0, path).length ? path : rel;
    }
  };
  A.Context_joinAll_closure.prototype = {
    call$1(part) {
      return A._asString(part) !== "";
    },
    $signature: 17
  };
  A.Context_split_closure.prototype = {
    call$1(part) {
      return A._asString(part).length !== 0;
    },
    $signature: 17
  };
  A._validateArgList_closure.prototype = {
    call$1(arg) {
      A._asStringQ(arg);
      return arg == null ? "null" : '"' + arg + '"';
    },
    $signature: 217
  };
  A.InternalStyle.prototype = {
    getRoot$1(path) {
      var t1,
        $length = this.rootLength$1(path);
      if ($length > 0)
        return B.JSString_methods.substring$2(path, 0, $length);
      if (this.isRootRelative$1(path)) {
        if (0 >= path.length)
          return A.ioore(path, 0);
        t1 = path[0];
      } else
        t1 = null;
      return t1;
    },
    pathsEqual$2(path1, path2) {
      return path1 === path2;
    }
  };
  A.ParsedPath.prototype = {
    removeTrailingSeparators$0() {
      var t1, t2, _this = this;
      while (true) {
        t1 = _this.parts;
        if (!(t1.length !== 0 && J.$eq$(B.JSArray_methods.get$last(t1), "")))
          break;
        B.JSArray_methods.removeLast$0(_this.parts);
        t1 = _this.separators;
        if (0 >= t1.length)
          return A.ioore(t1, -1);
        t1.pop();
      }
      t1 = _this.separators;
      t2 = t1.length;
      if (t2 !== 0)
        B.JSArray_methods.$indexSet(t1, t2 - 1, "");
    },
    normalize$0() {
      var t1, t2, leadingDoubles, _i, part, t3, _this = this,
        newParts = A._setArrayType([], type$.JSArray_String);
      for (t1 = _this.parts, t2 = t1.length, leadingDoubles = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i) {
        part = t1[_i];
        t3 = J.getInterceptor$(part);
        if (!(t3.$eq(part, ".") || t3.$eq(part, "")))
          if (t3.$eq(part, "..")) {
            t3 = newParts.length;
            if (t3 !== 0) {
              if (0 >= t3)
                return A.ioore(newParts, -1);
              newParts.pop();
            } else
              ++leadingDoubles;
          } else
            B.JSArray_methods.add$1(newParts, part);
      }
      if (_this.root == null)
        B.JSArray_methods.insertAll$2(newParts, 0, A.List_List$filled(leadingDoubles, "..", false, type$.String));
      if (newParts.length === 0 && _this.root == null)
        B.JSArray_methods.add$1(newParts, ".");
      _this.set$parts(newParts);
      t1 = _this.style;
      _this.set$separators(A.List_List$filled(newParts.length + 1, t1.get$separator(), true, type$.String));
      t2 = _this.root;
      if (t2 == null || newParts.length === 0 || !t1.needsSeparator$1(t2))
        B.JSArray_methods.$indexSet(_this.separators, 0, "");
      t2 = _this.root;
      if (t2 != null && t1 === $.$get$Style_windows()) {
        t2.toString;
        _this.root = A.stringReplaceAllUnchecked(t2, "/", "\\");
      }
      _this.removeTrailingSeparators$0();
    },
    toString$0(_) {
      var i, t2, t3, _this = this,
        t1 = _this.root;
      t1 = t1 != null ? "" + t1 : "";
      for (i = 0; i < _this.parts.length; ++i, t1 = t3) {
        t2 = _this.separators;
        if (!(i < t2.length))
          return A.ioore(t2, i);
        t2 = A.S(t2[i]);
        t3 = _this.parts;
        if (!(i < t3.length))
          return A.ioore(t3, i);
        t3 = t1 + t2 + A.S(t3[i]);
      }
      t1 += A.S(B.JSArray_methods.get$last(_this.separators));
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    set$parts(parts) {
      this.parts = type$.List_String._as(parts);
    },
    set$separators(separators) {
      this.separators = type$.List_String._as(separators);
    }
  };
  A.PathException.prototype = {
    toString$0(_) {
      return "PathException: " + this.message;
    },
    $isException: 1
  };
  A.Style.prototype = {
    toString$0(_) {
      return this.get$name();
    }
  };
  A.PosixStyle.prototype = {
    containsSeparator$1(path) {
      return B.JSString_methods.contains$1(path, "/");
    },
    isSeparator$1(codeUnit) {
      return codeUnit === 47;
    },
    needsSeparator$1(path) {
      var t2,
        t1 = path.length;
      if (t1 !== 0) {
        t2 = t1 - 1;
        if (!(t2 >= 0))
          return A.ioore(path, t2);
        t2 = path.charCodeAt(t2) !== 47;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    rootLength$2$withDrive(path, withDrive) {
      var t1 = path.length;
      if (t1 !== 0) {
        if (0 >= t1)
          return A.ioore(path, 0);
        t1 = path.charCodeAt(0) === 47;
      } else
        t1 = false;
      if (t1)
        return 1;
      return 0;
    },
    rootLength$1(path) {
      return this.rootLength$2$withDrive(path, false);
    },
    isRootRelative$1(path) {
      return false;
    },
    pathFromUri$1(uri) {
      var t1;
      if (uri.get$scheme() === "" || uri.get$scheme() === "file") {
        t1 = uri.get$path();
        return A._Uri__uriDecode(t1, 0, t1.length, B.C_Utf8Codec, false);
      }
      throw A.wrapException(A.ArgumentError$("Uri " + uri.toString$0(0) + " must have scheme 'file:'.", null));
    },
    get$name() {
      return "posix";
    },
    get$separator() {
      return "/";
    }
  };
  A.UrlStyle.prototype = {
    containsSeparator$1(path) {
      return B.JSString_methods.contains$1(path, "/");
    },
    isSeparator$1(codeUnit) {
      return codeUnit === 47;
    },
    needsSeparator$1(path) {
      var t2,
        t1 = path.length;
      if (t1 === 0)
        return false;
      t2 = t1 - 1;
      if (!(t2 >= 0))
        return A.ioore(path, t2);
      if (path.charCodeAt(t2) !== 47)
        return true;
      return B.JSString_methods.endsWith$1(path, "://") && this.rootLength$1(path) === t1;
    },
    rootLength$2$withDrive(path, withDrive) {
      var i, codeUnit, index,
        t1 = path.length;
      if (t1 === 0)
        return 0;
      if (0 >= t1)
        return A.ioore(path, 0);
      if (path.charCodeAt(0) === 47)
        return 1;
      for (i = 0; i < t1; ++i) {
        codeUnit = path.charCodeAt(i);
        if (codeUnit === 47)
          return 0;
        if (codeUnit === 58) {
          if (i === 0)
            return 0;
          index = B.JSString_methods.indexOf$2(path, "/", B.JSString_methods.startsWith$2(path, "//", i + 1) ? i + 3 : i);
          if (index <= 0)
            return t1;
          if (!withDrive || t1 < index + 3)
            return index;
          if (!B.JSString_methods.startsWith$1(path, "file://"))
            return index;
          t1 = A.driveLetterEnd(path, index + 1);
          return t1 == null ? index : t1;
        }
      }
      return 0;
    },
    rootLength$1(path) {
      return this.rootLength$2$withDrive(path, false);
    },
    isRootRelative$1(path) {
      var t1 = path.length;
      if (t1 !== 0) {
        if (0 >= t1)
          return A.ioore(path, 0);
        t1 = path.charCodeAt(0) === 47;
      } else
        t1 = false;
      return t1;
    },
    pathFromUri$1(uri) {
      return uri.toString$0(0);
    },
    get$name() {
      return "url";
    },
    get$separator() {
      return "/";
    }
  };
  A.WindowsStyle.prototype = {
    containsSeparator$1(path) {
      return B.JSString_methods.contains$1(path, "/");
    },
    isSeparator$1(codeUnit) {
      return codeUnit === 47 || codeUnit === 92;
    },
    needsSeparator$1(path) {
      var t2,
        t1 = path.length;
      if (t1 === 0)
        return false;
      t2 = t1 - 1;
      if (!(t2 >= 0))
        return A.ioore(path, t2);
      t2 = path.charCodeAt(t2);
      return !(t2 === 47 || t2 === 92);
    },
    rootLength$2$withDrive(path, withDrive) {
      var t2, index,
        t1 = path.length;
      if (t1 === 0)
        return 0;
      if (0 >= t1)
        return A.ioore(path, 0);
      if (path.charCodeAt(0) === 47)
        return 1;
      if (path.charCodeAt(0) === 92) {
        if (t1 >= 2) {
          if (1 >= t1)
            return A.ioore(path, 1);
          t2 = path.charCodeAt(1) !== 92;
        } else
          t2 = true;
        if (t2)
          return 1;
        index = B.JSString_methods.indexOf$2(path, "\\", 2);
        if (index > 0) {
          index = B.JSString_methods.indexOf$2(path, "\\", index + 1);
          if (index > 0)
            return index;
        }
        return t1;
      }
      if (t1 < 3)
        return 0;
      if (!A.isAlphabetic(path.charCodeAt(0)))
        return 0;
      if (path.charCodeAt(1) !== 58)
        return 0;
      t1 = path.charCodeAt(2);
      if (!(t1 === 47 || t1 === 92))
        return 0;
      return 3;
    },
    rootLength$1(path) {
      return this.rootLength$2$withDrive(path, false);
    },
    isRootRelative$1(path) {
      return this.rootLength$1(path) === 1;
    },
    pathFromUri$1(uri) {
      var path, t1;
      if (uri.get$scheme() !== "" && uri.get$scheme() !== "file")
        throw A.wrapException(A.ArgumentError$("Uri " + uri.toString$0(0) + " must have scheme 'file:'.", null));
      path = uri.get$path();
      if (uri.get$host() === "") {
        t1 = path.length;
        if (t1 >= 3 && B.JSString_methods.startsWith$1(path, "/") && A.driveLetterEnd(path, 1) != null) {
          A.RangeError_checkValueInInterval(0, 0, t1, "startIndex");
          path = A.stringReplaceFirstUnchecked(path, "/", "", 0);
        }
      } else
        path = "\\\\" + uri.get$host() + path;
      t1 = A.stringReplaceAllUnchecked(path, "/", "\\");
      return A._Uri__uriDecode(t1, 0, t1.length, B.C_Utf8Codec, false);
    },
    codeUnitsEqual$2(codeUnit1, codeUnit2) {
      var upperCase1;
      if (codeUnit1 === codeUnit2)
        return true;
      if (codeUnit1 === 47)
        return codeUnit2 === 92;
      if (codeUnit1 === 92)
        return codeUnit2 === 47;
      if ((codeUnit1 ^ codeUnit2) !== 32)
        return false;
      upperCase1 = codeUnit1 | 32;
      return upperCase1 >= 97 && upperCase1 <= 122;
    },
    pathsEqual$2(path1, path2) {
      var t1, t2, i;
      if (path1 === path2)
        return true;
      t1 = path1.length;
      t2 = path2.length;
      if (t1 !== t2)
        return false;
      for (i = 0; i < t1; ++i) {
        if (!(i < t2))
          return A.ioore(path2, i);
        if (!this.codeUnitsEqual$2(path1.charCodeAt(i), path2.charCodeAt(i)))
          return false;
      }
      return true;
    },
    get$name() {
      return "windows";
    },
    get$separator() {
      return "\\";
    }
  };
  A.PlatformInterface.prototype = {
    PlatformInterface$1$token(token) {
      var t1 = $.$get$PlatformInterface__instanceTokens();
      t1.$ti._eval$1("1?")._as(token);
      t1._jsWeakMap.set(this, token);
    }
  };
  A.SubstrateAddress.prototype = {
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.SubstrateAddress))
        return false;
      return other.address === this.address && other.ss58Format === this.ss58Format;
    },
    get$hashCode(_) {
      return B.JSString_methods.get$hashCode(this.address) ^ B.JSInt_methods.get$hashCode(this.ss58Format);
    },
    toString$0(_) {
      return this.address;
    }
  };
  A.SourceFile.prototype = {
    get$length(_) {
      return this._decodedChars.length;
    },
    get$lines() {
      return this._lineStarts.length;
    },
    SourceFile$decoded$2$url(decodedChars, url) {
      var t1, t2, t3, i, c, j, t4;
      for (t1 = this._decodedChars, t2 = t1.length, t3 = this._lineStarts, i = 0; i < t2; ++i) {
        c = t1[i];
        if (c === 13) {
          j = i + 1;
          if (j < t2) {
            if (!(j < t2))
              return A.ioore(t1, j);
            t4 = t1[j] !== 10;
          } else
            t4 = true;
          if (t4)
            c = 10;
        }
        if (c === 10)
          B.JSArray_methods.add$1(t3, i + 1);
      }
    },
    getLine$1(offset) {
      var t1, _this = this;
      if (offset < 0)
        throw A.wrapException(A.RangeError$("Offset may not be negative, was " + offset + "."));
      else if (offset > _this._decodedChars.length)
        throw A.wrapException(A.RangeError$("Offset " + offset + string$.x20must_ + _this.get$length(0) + "."));
      t1 = _this._lineStarts;
      if (offset < B.JSArray_methods.get$first(t1))
        return -1;
      if (offset >= B.JSArray_methods.get$last(t1))
        return t1.length - 1;
      if (_this._isNearCachedLine$1(offset)) {
        t1 = _this._cachedLine;
        t1.toString;
        return t1;
      }
      return _this._cachedLine = _this._binarySearch$1(offset) - 1;
    },
    _isNearCachedLine$1(offset) {
      var t2, t3, t4,
        t1 = this._cachedLine;
      if (t1 == null)
        return false;
      t2 = this._lineStarts;
      t3 = t2.length;
      if (t1 >>> 0 !== t1 || t1 >= t3)
        return A.ioore(t2, t1);
      if (offset < t2[t1])
        return false;
      if (!(t1 >= t3 - 1)) {
        t4 = t1 + 1;
        if (!(t4 < t3))
          return A.ioore(t2, t4);
        t4 = offset < t2[t4];
      } else
        t4 = true;
      if (t4)
        return true;
      if (!(t1 >= t3 - 2)) {
        t4 = t1 + 2;
        if (!(t4 < t3))
          return A.ioore(t2, t4);
        t4 = offset < t2[t4];
        t2 = t4;
      } else
        t2 = true;
      if (t2) {
        this._cachedLine = t1 + 1;
        return true;
      }
      return false;
    },
    _binarySearch$1(offset) {
      var min, half,
        t1 = this._lineStarts,
        t2 = t1.length,
        max = t2 - 1;
      for (min = 0; min < max;) {
        half = min + B.JSInt_methods._tdivFast$1(max - min, 2);
        if (!(half >= 0 && half < t2))
          return A.ioore(t1, half);
        if (t1[half] > offset)
          max = half;
        else
          min = half + 1;
      }
      return max;
    },
    getColumn$1(offset) {
      var line, t1, lineStart, _this = this;
      if (offset < 0)
        throw A.wrapException(A.RangeError$("Offset may not be negative, was " + offset + "."));
      else if (offset > _this._decodedChars.length)
        throw A.wrapException(A.RangeError$("Offset " + offset + " must be not be greater than the number of characters in the file, " + _this.get$length(0) + "."));
      line = _this.getLine$1(offset);
      t1 = _this._lineStarts;
      if (!(line >= 0 && line < t1.length))
        return A.ioore(t1, line);
      lineStart = t1[line];
      if (lineStart > offset)
        throw A.wrapException(A.RangeError$("Line " + line + " comes after offset " + offset + "."));
      return offset - lineStart;
    },
    getOffset$1(line) {
      var t1, t2, result, t3;
      if (line < 0)
        throw A.wrapException(A.RangeError$("Line may not be negative, was " + line + "."));
      else {
        t1 = this._lineStarts;
        t2 = t1.length;
        if (line >= t2)
          throw A.wrapException(A.RangeError$("Line " + line + " must be less than the number of lines in the file, " + this.get$lines() + "."));
      }
      result = t1[line];
      if (result <= this._decodedChars.length) {
        t3 = line + 1;
        t1 = t3 < t2 && result >= t1[t3];
      } else
        t1 = true;
      if (t1)
        throw A.wrapException(A.RangeError$("Line " + line + " doesn't have 0 columns."));
      return result;
    }
  };
  A.FileLocation.prototype = {
    get$sourceUrl() {
      return this.file.url;
    },
    get$line() {
      return this.file.getLine$1(this.offset);
    },
    get$column() {
      return this.file.getColumn$1(this.offset);
    },
    get$offset() {
      return this.offset;
    }
  };
  A._FileSpan.prototype = {
    get$sourceUrl() {
      return this.file.url;
    },
    get$length(_) {
      return this._end - this._file$_start;
    },
    get$start() {
      return A.FileLocation$_(this.file, this._file$_start);
    },
    get$end() {
      return A.FileLocation$_(this.file, this._end);
    },
    get$text() {
      return A.String_String$fromCharCodes(B.NativeUint32List_methods.sublist$2(this.file._decodedChars, this._file$_start, this._end), 0, null);
    },
    get$context() {
      var _this = this,
        t1 = _this.file,
        endOffset = _this._end,
        endLine = t1.getLine$1(endOffset);
      if (t1.getColumn$1(endOffset) === 0 && endLine !== 0) {
        if (endOffset - _this._file$_start === 0)
          return endLine === t1._lineStarts.length - 1 ? "" : A.String_String$fromCharCodes(B.NativeUint32List_methods.sublist$2(t1._decodedChars, t1.getOffset$1(endLine), t1.getOffset$1(endLine + 1)), 0, null);
      } else
        endOffset = endLine === t1._lineStarts.length - 1 ? t1._decodedChars.length : t1.getOffset$1(endLine + 1);
      return A.String_String$fromCharCodes(B.NativeUint32List_methods.sublist$2(t1._decodedChars, t1.getOffset$1(t1.getLine$1(_this._file$_start)), endOffset), 0, null);
    },
    compareTo$1(_, other) {
      var result;
      type$.SourceSpan._as(other);
      if (!(other instanceof A._FileSpan))
        return this.super$SourceSpanMixin$compareTo(0, other);
      result = B.JSInt_methods.compareTo$1(this._file$_start, other._file$_start);
      return result === 0 ? B.JSInt_methods.compareTo$1(this._end, other._end) : result;
    },
    $eq(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (!(other instanceof A._FileSpan))
        return _this.super$SourceSpanMixin$$eq(0, other);
      return _this._file$_start === other._file$_start && _this._end === other._end && J.$eq$(_this.file.url, other.file.url);
    },
    get$hashCode(_) {
      return A.Object_hash(this._file$_start, this._end, this.file.url);
    },
    $isSourceSpanWithContext: 1
  };
  A.Highlighter.prototype = {
    highlight$0() {
      var t2, highlightsByColumn, t3, t4, i, line, lastLine, t5, t6, t7, t8, t9, t10, t11, index, primaryIdx, primary, _i, _this = this, _null = null,
        t1 = _this._lines;
      _this._writeFileStart$1(B.JSArray_methods.get$first(t1).url);
      t2 = _this._maxMultilineSpans;
      highlightsByColumn = A.List_List$filled(t2, _null, false, type$.nullable__Highlight);
      for (t3 = _this._highlighter$_buffer, t2 = t2 !== 0, t4 = _this._primaryColor, i = 0; i < t1.length; ++i) {
        line = t1[i];
        if (i > 0) {
          lastLine = t1[i - 1];
          t5 = lastLine.url;
          t6 = line.url;
          if (!J.$eq$(t5, t6)) {
            _this._writeSidebar$1$end("\u2575");
            t3._contents += "\n";
            _this._writeFileStart$1(t6);
          } else if (lastLine.number + 1 !== line.number) {
            _this._writeSidebar$1$text("...");
            t3._contents += "\n";
          }
        }
        for (t5 = line.highlights, t6 = A._arrayInstanceType(t5)._eval$1("ReversedListIterable<1>"), t7 = new A.ReversedListIterable(t5, t6), t7 = new A.ListIterator(t7, t7.get$length(0), t6._eval$1("ListIterator<ListIterable.E>")), t6 = t6._eval$1("ListIterable.E"), t8 = line.number, t9 = line.text; t7.moveNext$0();) {
          t10 = t7.__internal$_current;
          if (t10 == null)
            t10 = t6._as(t10);
          t11 = t10.span;
          if (t11.get$start().get$line() !== t11.get$end().get$line() && t11.get$start().get$line() === t8 && _this._isOnlyWhitespace$1(B.JSString_methods.substring$2(t9, 0, t11.get$start().get$column()))) {
            index = B.JSArray_methods.indexOf$1(highlightsByColumn, _null);
            if (index < 0)
              A.throwExpression(A.ArgumentError$(A.S(highlightsByColumn) + " contains no null elements.", _null));
            B.JSArray_methods.$indexSet(highlightsByColumn, index, t10);
          }
        }
        _this._writeSidebar$1$line(t8);
        t3._contents += " ";
        _this._writeMultilineHighlights$2(line, highlightsByColumn);
        if (t2)
          t3._contents += " ";
        primaryIdx = B.JSArray_methods.indexWhere$1(t5, new A.Highlighter_highlight_closure());
        if (primaryIdx === -1)
          primary = _null;
        else {
          if (!(primaryIdx >= 0 && primaryIdx < t5.length))
            return A.ioore(t5, primaryIdx);
          primary = t5[primaryIdx];
        }
        t6 = primary != null;
        if (t6) {
          t7 = primary.span;
          t10 = t7.get$start().get$line() === t8 ? t7.get$start().get$column() : 0;
          _this._writeHighlightedText$4$color(t9, t10, t7.get$end().get$line() === t8 ? t7.get$end().get$column() : t9.length, t4);
        } else
          _this._writeText$1(t9);
        t3._contents += "\n";
        if (t6)
          _this._writeIndicator$3(line, primary, highlightsByColumn);
        for (t6 = t5.length, _i = 0; _i < t6; ++_i) {
          t5[_i].toString;
          continue;
        }
      }
      _this._writeSidebar$1$end("\u2575");
      t1 = t3._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _writeFileStart$1(url) {
      var t1, t2, _this = this;
      if (!_this._multipleFiles || !type$.Uri._is(url))
        _this._writeSidebar$1$end("\u2577");
      else {
        _this._writeSidebar$1$end("\u250c");
        _this._colorize$1$2$color(new A.Highlighter__writeFileStart_closure(_this), "\x1b[34m", type$.void);
        t1 = _this._highlighter$_buffer;
        t2 = " " + $.$get$context().prettyUri$1(url);
        t1._contents += t2;
      }
      _this._highlighter$_buffer._contents += "\n";
    },
    _writeMultilineHighlights$3$current(line, highlightsByColumn, current) {
      var t1, currentColor, t2, t3, t4, t5, t6, foundCurrent, _i, highlight, t7, startLine, endLine, _this = this, _box_0 = {};
      type$.List_nullable__Highlight._as(highlightsByColumn);
      _box_0.openedOnThisLine = false;
      _box_0.openedOnThisLineColor = null;
      t1 = current == null;
      if (t1)
        currentColor = null;
      else
        currentColor = _this._primaryColor;
      for (t2 = highlightsByColumn.length, t3 = type$.Null, t4 = _this._primaryColor, t1 = !t1, t5 = _this._highlighter$_buffer, t6 = type$.void, foundCurrent = false, _i = 0; _i < t2; ++_i) {
        highlight = highlightsByColumn[_i];
        t7 = highlight == null;
        startLine = t7 ? null : highlight.span.get$start().get$line();
        endLine = t7 ? null : highlight.span.get$end().get$line();
        if (t1 && highlight === current) {
          _this._colorize$1$2$color(new A.Highlighter__writeMultilineHighlights_closure(_this, startLine, line), currentColor, t3);
          foundCurrent = true;
        } else if (foundCurrent)
          _this._colorize$1$2$color(new A.Highlighter__writeMultilineHighlights_closure0(_this, highlight), currentColor, t3);
        else if (t7)
          if (_box_0.openedOnThisLine)
            _this._colorize$1$2$color(new A.Highlighter__writeMultilineHighlights_closure1(_this), _box_0.openedOnThisLineColor, t6);
          else
            t5._contents += " ";
        else
          _this._colorize$1$2$color(new A.Highlighter__writeMultilineHighlights_closure2(_box_0, _this, current, startLine, line, highlight, endLine), t4, t3);
      }
    },
    _writeMultilineHighlights$2(line, highlightsByColumn) {
      return this._writeMultilineHighlights$3$current(line, highlightsByColumn, null);
    },
    _writeHighlightedText$4$color(text, startColumn, endColumn, color) {
      var _this = this;
      _this._writeText$1(B.JSString_methods.substring$2(text, 0, startColumn));
      _this._colorize$1$2$color(new A.Highlighter__writeHighlightedText_closure(_this, text, startColumn, endColumn), color, type$.void);
      _this._writeText$1(B.JSString_methods.substring$2(text, endColumn, text.length));
    },
    _writeIndicator$3(line, highlight, highlightsByColumn) {
      var color, t1, t2, _this = this;
      type$.List_nullable__Highlight._as(highlightsByColumn);
      color = _this._primaryColor;
      t1 = highlight.span;
      if (t1.get$start().get$line() === t1.get$end().get$line()) {
        _this._writeSidebar$0();
        t1 = _this._highlighter$_buffer;
        t1._contents += " ";
        _this._writeMultilineHighlights$3$current(line, highlightsByColumn, highlight);
        if (highlightsByColumn.length !== 0)
          t1._contents += " ";
        _this._writeLabel$3(highlight, highlightsByColumn, _this._colorize$1$2$color(new A.Highlighter__writeIndicator_closure(_this, line, highlight), color, type$.int));
      } else {
        t2 = line.number;
        if (t1.get$start().get$line() === t2) {
          if (B.JSArray_methods.contains$1(highlightsByColumn, highlight))
            return;
          A.replaceFirstNull(highlightsByColumn, highlight, type$._Highlight);
          _this._writeSidebar$0();
          t1 = _this._highlighter$_buffer;
          t1._contents += " ";
          _this._writeMultilineHighlights$3$current(line, highlightsByColumn, highlight);
          _this._colorize$1$2$color(new A.Highlighter__writeIndicator_closure0(_this, line, highlight), color, type$.void);
          t1._contents += "\n";
        } else if (t1.get$end().get$line() === t2) {
          t1 = t1.get$end().get$column();
          if (t1 === line.text.length) {
            A.replaceWithNull(highlightsByColumn, highlight, type$._Highlight);
            return;
          }
          _this._writeSidebar$0();
          _this._highlighter$_buffer._contents += " ";
          _this._writeMultilineHighlights$3$current(line, highlightsByColumn, highlight);
          _this._writeLabel$3(highlight, highlightsByColumn, _this._colorize$1$2$color(new A.Highlighter__writeIndicator_closure1(_this, false, line, highlight), color, type$.int));
          A.replaceWithNull(highlightsByColumn, highlight, type$._Highlight);
        }
      }
    },
    _writeArrow$3$beginning(line, column, beginning) {
      var t1 = beginning ? 0 : 1,
        t2 = this._highlighter$_buffer;
      t1 = B.JSString_methods.$mul("\u2500", 1 + column + this._countTabs$1(B.JSString_methods.substring$2(line.text, 0, column + t1)) * 3);
      t1 = t2._contents += t1;
      t2._contents = t1 + "^";
    },
    _writeArrow$2(line, column) {
      return this._writeArrow$3$beginning(line, column, true);
    },
    _writeLabel$3(highlight, highlightsByColumn, underlineLength) {
      type$.List_nullable__Highlight._as(highlightsByColumn);
      this._highlighter$_buffer._contents += "\n";
      return;
    },
    _writeText$1(text) {
      var t1, t2, t3, t4;
      for (t1 = new A.CodeUnits(text), t2 = type$.CodeUnits, t1 = new A.ListIterator(t1, t1.get$length(0), t2._eval$1("ListIterator<ListBase.E>")), t3 = this._highlighter$_buffer, t2 = t2._eval$1("ListBase.E"); t1.moveNext$0();) {
        t4 = t1.__internal$_current;
        if (t4 == null)
          t4 = t2._as(t4);
        if (t4 === 9) {
          t4 = B.JSString_methods.$mul(" ", 4);
          t3._contents += t4;
        } else {
          t4 = A.Primitives_stringFromCharCode(t4);
          t3._contents += t4;
        }
      }
    },
    _writeSidebar$3$end$line$text(end, line, text) {
      var t1 = {};
      t1.text = text;
      if (line != null)
        t1.text = B.JSInt_methods.toString$0(line + 1);
      this._colorize$1$2$color(new A.Highlighter__writeSidebar_closure(t1, this, end), "\x1b[34m", type$.Null);
    },
    _writeSidebar$1$end(end) {
      return this._writeSidebar$3$end$line$text(end, null, null);
    },
    _writeSidebar$1$text(text) {
      return this._writeSidebar$3$end$line$text(null, null, text);
    },
    _writeSidebar$1$line(line) {
      return this._writeSidebar$3$end$line$text(null, line, null);
    },
    _writeSidebar$0() {
      return this._writeSidebar$3$end$line$text(null, null, null);
    },
    _countTabs$1(text) {
      var t1, t2, count, t3;
      for (t1 = new A.CodeUnits(text), t2 = type$.CodeUnits, t1 = new A.ListIterator(t1, t1.get$length(0), t2._eval$1("ListIterator<ListBase.E>")), t2 = t2._eval$1("ListBase.E"), count = 0; t1.moveNext$0();) {
        t3 = t1.__internal$_current;
        if ((t3 == null ? t2._as(t3) : t3) === 9)
          ++count;
      }
      return count;
    },
    _isOnlyWhitespace$1(text) {
      var t1, t2, t3;
      for (t1 = new A.CodeUnits(text), t2 = type$.CodeUnits, t1 = new A.ListIterator(t1, t1.get$length(0), t2._eval$1("ListIterator<ListBase.E>")), t2 = t2._eval$1("ListBase.E"); t1.moveNext$0();) {
        t3 = t1.__internal$_current;
        if (t3 == null)
          t3 = t2._as(t3);
        if (t3 !== 32 && t3 !== 9)
          return false;
      }
      return true;
    },
    _colorize$1$2$color(callback, color, $T) {
      var t1, result;
      $T._eval$1("0()")._as(callback);
      t1 = this._primaryColor != null;
      if (t1 && color != null)
        this._highlighter$_buffer._contents += color;
      result = callback.call$0();
      if (t1 && color != null)
        this._highlighter$_buffer._contents += "\x1b[0m";
      return result;
    }
  };
  A.Highlighter_closure.prototype = {
    call$0() {
      return this.color;
    },
    $signature: 218
  };
  A.Highlighter$__closure.prototype = {
    call$1(line) {
      var t1 = type$._Line._as(line).highlights,
        t2 = A._arrayInstanceType(t1);
      return new A.WhereIterable(t1, t2._eval$1("bool(1)")._as(new A.Highlighter$___closure()), t2._eval$1("WhereIterable<1>")).get$length(0);
    },
    $signature: 219
  };
  A.Highlighter$___closure.prototype = {
    call$1(highlight) {
      var t1 = type$._Highlight._as(highlight).span;
      return t1.get$start().get$line() !== t1.get$end().get$line();
    },
    $signature: 32
  };
  A.Highlighter$__closure0.prototype = {
    call$1(line) {
      return type$._Line._as(line).url;
    },
    $signature: 221
  };
  A.Highlighter__collateLines_closure.prototype = {
    call$1(highlight) {
      var t1 = type$._Highlight._as(highlight).span.get$sourceUrl();
      return t1 == null ? new A.Object() : t1;
    },
    $signature: 222
  };
  A.Highlighter__collateLines_closure0.prototype = {
    call$2(highlight1, highlight2) {
      var t1 = type$._Highlight;
      return t1._as(highlight1).span.compareTo$1(0, t1._as(highlight2).span);
    },
    $signature: 223
  };
  A.Highlighter__collateLines_closure1.prototype = {
    call$1(entry) {
      var url, highlightsForFile, lines, t1, t2, t3, t4, context, t5, linesBeforeSpan, lineNumber, _i, line, activeHighlights, highlightIndex, oldHighlightLength, t6;
      type$.MapEntry_of_Object_and_List__Highlight._as(entry);
      url = entry.key;
      highlightsForFile = entry.value;
      lines = A._setArrayType([], type$.JSArray__Line);
      for (t1 = J.getInterceptor$ax(highlightsForFile), t2 = t1.get$iterator(highlightsForFile), t3 = type$.JSArray__Highlight; t2.moveNext$0();) {
        t4 = t2.get$current().span;
        context = t4.get$context();
        t5 = A.findLineStart(context, t4.get$text(), t4.get$start().get$column());
        t5.toString;
        linesBeforeSpan = B.JSString_methods.allMatches$1("\n", B.JSString_methods.substring$2(context, 0, t5)).get$length(0);
        lineNumber = t4.get$start().get$line() - linesBeforeSpan;
        for (t4 = context.split("\n"), t5 = t4.length, _i = 0; _i < t5; ++_i) {
          line = t4[_i];
          if (lines.length === 0 || lineNumber > B.JSArray_methods.get$last(lines).number)
            B.JSArray_methods.add$1(lines, new A._Line(line, lineNumber, url, A._setArrayType([], t3)));
          ++lineNumber;
        }
      }
      activeHighlights = A._setArrayType([], t3);
      for (t2 = lines.length, t3 = type$.bool_Function__Highlight, highlightIndex = 0, _i = 0; _i < lines.length; lines.length === t2 || (0, A.throwConcurrentModificationError)(lines), ++_i) {
        line = lines[_i];
        t4 = t3._as(new A.Highlighter__collateLines__closure(line));
        if (!!activeHighlights.fixed$length)
          A.throwExpression(A.UnsupportedError$("removeWhere"));
        B.JSArray_methods._removeWhere$2(activeHighlights, t4, true);
        oldHighlightLength = activeHighlights.length;
        for (t4 = t1.skip$1(highlightsForFile, highlightIndex), t5 = t4.$ti, t4 = new A.ListIterator(t4, t4.get$length(0), t5._eval$1("ListIterator<ListIterable.E>")), t5 = t5._eval$1("ListIterable.E"); t4.moveNext$0();) {
          t6 = t4.__internal$_current;
          if (t6 == null)
            t6 = t5._as(t6);
          if (t6.span.get$start().get$line() > line.number)
            break;
          B.JSArray_methods.add$1(activeHighlights, t6);
        }
        highlightIndex += activeHighlights.length - oldHighlightLength;
        B.JSArray_methods.addAll$1(line.highlights, activeHighlights);
      }
      return lines;
    },
    $signature: 224
  };
  A.Highlighter__collateLines__closure.prototype = {
    call$1(highlight) {
      return type$._Highlight._as(highlight).span.get$end().get$line() < this.line.number;
    },
    $signature: 32
  };
  A.Highlighter_highlight_closure.prototype = {
    call$1(highlight) {
      type$._Highlight._as(highlight);
      return true;
    },
    $signature: 32
  };
  A.Highlighter__writeFileStart_closure.prototype = {
    call$0() {
      var t1 = this.$this._highlighter$_buffer,
        t2 = B.JSString_methods.$mul("\u2500", 2) + ">";
      t1._contents += t2;
      return null;
    },
    $signature: 0
  };
  A.Highlighter__writeMultilineHighlights_closure.prototype = {
    call$0() {
      var t1 = this.$this._highlighter$_buffer,
        t2 = this.startLine === this.line.number ? "\u250c" : "\u2514";
      t1._contents += t2;
    },
    $signature: 11
  };
  A.Highlighter__writeMultilineHighlights_closure0.prototype = {
    call$0() {
      var t1 = this.$this._highlighter$_buffer,
        t2 = this.highlight == null ? "\u2500" : "\u253c";
      t1._contents += t2;
    },
    $signature: 11
  };
  A.Highlighter__writeMultilineHighlights_closure1.prototype = {
    call$0() {
      this.$this._highlighter$_buffer._contents += "\u2500";
      return null;
    },
    $signature: 0
  };
  A.Highlighter__writeMultilineHighlights_closure2.prototype = {
    call$0() {
      var t2, t3, _this = this,
        t1 = _this._box_0,
        vertical = t1.openedOnThisLine ? "\u253c" : "\u2502";
      if (_this.current != null)
        _this.$this._highlighter$_buffer._contents += vertical;
      else {
        t2 = _this.line;
        t3 = t2.number;
        if (_this.startLine === t3) {
          t2 = _this.$this;
          t2._colorize$1$2$color(new A.Highlighter__writeMultilineHighlights__closure(t1, t2), t1.openedOnThisLineColor, type$.Null);
          t1.openedOnThisLine = true;
          if (t1.openedOnThisLineColor == null)
            t1.openedOnThisLineColor = t2._primaryColor;
        } else {
          t2 = _this.endLine === t3 && _this.highlight.span.get$end().get$column() === t2.text.length;
          t3 = _this.$this;
          if (t2)
            t3._highlighter$_buffer._contents += "\u2514";
          else
            t3._colorize$1$2$color(new A.Highlighter__writeMultilineHighlights__closure0(t3, vertical), t1.openedOnThisLineColor, type$.Null);
        }
      }
    },
    $signature: 11
  };
  A.Highlighter__writeMultilineHighlights__closure.prototype = {
    call$0() {
      var t1 = this.$this._highlighter$_buffer,
        t2 = this._box_0.openedOnThisLine ? "\u252c" : "\u250c";
      t1._contents += t2;
    },
    $signature: 11
  };
  A.Highlighter__writeMultilineHighlights__closure0.prototype = {
    call$0() {
      this.$this._highlighter$_buffer._contents += this.vertical;
    },
    $signature: 11
  };
  A.Highlighter__writeHighlightedText_closure.prototype = {
    call$0() {
      var _this = this;
      return _this.$this._writeText$1(B.JSString_methods.substring$2(_this.text, _this.startColumn, _this.endColumn));
    },
    $signature: 0
  };
  A.Highlighter__writeIndicator_closure.prototype = {
    call$0() {
      var tabsBefore, tabsInside,
        t1 = this.$this,
        t2 = t1._highlighter$_buffer,
        t3 = t2._contents,
        t4 = this.highlight.span,
        startColumn = t4.get$start().get$column(),
        endColumn = t4.get$end().get$column();
      t4 = this.line.text;
      tabsBefore = t1._countTabs$1(B.JSString_methods.substring$2(t4, 0, startColumn));
      tabsInside = t1._countTabs$1(B.JSString_methods.substring$2(t4, startColumn, endColumn));
      startColumn += tabsBefore * 3;
      t4 = B.JSString_methods.$mul(" ", startColumn);
      t2._contents += t4;
      t4 = B.JSString_methods.$mul("^", Math.max(endColumn + (tabsBefore + tabsInside) * 3 - startColumn, 1));
      t4 = t2._contents += t4;
      return t4.length - t3.length;
    },
    $signature: 26
  };
  A.Highlighter__writeIndicator_closure0.prototype = {
    call$0() {
      return this.$this._writeArrow$2(this.line, this.highlight.span.get$start().get$column());
    },
    $signature: 0
  };
  A.Highlighter__writeIndicator_closure1.prototype = {
    call$0() {
      var _this = this,
        t1 = _this.$this,
        t2 = t1._highlighter$_buffer,
        t3 = t2._contents;
      if (_this.coversWholeLine) {
        t1 = B.JSString_methods.$mul("\u2500", 3);
        t2._contents += t1;
      } else
        t1._writeArrow$3$beginning(_this.line, Math.max(_this.highlight.span.get$end().get$column() - 1, 0), false);
      return t2._contents.length - t3.length;
    },
    $signature: 26
  };
  A.Highlighter__writeSidebar_closure.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = t1._highlighter$_buffer,
        t3 = this._box_0.text;
      if (t3 == null)
        t3 = "";
      t1 = B.JSString_methods.padRight$1(t3, t1._paddingBeforeSidebar);
      t1 = t2._contents += t1;
      t3 = this.end;
      t2._contents = t1 + (t3 == null ? "\u2502" : t3);
    },
    $signature: 11
  };
  A._Highlight.prototype = {
    toString$0(_) {
      var t1 = this.span;
      t1 = "" + "primary " + ("" + t1.get$start().get$line() + ":" + t1.get$start().get$column() + "-" + t1.get$end().get$line() + ":" + t1.get$end().get$column());
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  A._Highlight_closure.prototype = {
    call$0() {
      var t2, t3, t4, t5,
        t1 = this.span;
      if (!(type$.SourceSpanWithContext._is(t1) && A.findLineStart(t1.get$context(), t1.get$text(), t1.get$start().get$column()) != null)) {
        t2 = A.SourceLocation$(t1.get$start().get$offset(), 0, 0, t1.get$sourceUrl());
        t3 = t1.get$end().get$offset();
        t4 = t1.get$sourceUrl();
        t5 = A.countCodeUnits(t1.get$text(), 10);
        t1 = A.SourceSpanWithContext$(t2, A.SourceLocation$(t3, A._Highlight__lastLineLength(t1.get$text()), t5, t4), t1.get$text(), t1.get$text());
      }
      return A._Highlight__normalizeEndOfLine(A._Highlight__normalizeTrailingNewline(A._Highlight__normalizeNewlines(t1)));
    },
    $signature: 225
  };
  A._Line.prototype = {
    toString$0(_) {
      return "" + this.number + ': "' + this.text + '" (' + B.JSArray_methods.join$1(this.highlights, ", ") + ")";
    }
  };
  A.SourceLocation.prototype = {
    distance$1(other) {
      var t1 = this.sourceUrl;
      if (!J.$eq$(t1, other.get$sourceUrl()))
        throw A.wrapException(A.ArgumentError$('Source URLs "' + A.S(t1) + '" and "' + A.S(other.get$sourceUrl()) + "\" don't match.", null));
      return Math.abs(this.offset - other.get$offset());
    },
    compareTo$1(_, other) {
      var t1;
      type$.SourceLocation._as(other);
      t1 = this.sourceUrl;
      if (!J.$eq$(t1, other.get$sourceUrl()))
        throw A.wrapException(A.ArgumentError$('Source URLs "' + A.S(t1) + '" and "' + A.S(other.get$sourceUrl()) + "\" don't match.", null));
      return this.offset - other.get$offset();
    },
    $eq(_, other) {
      if (other == null)
        return false;
      return type$.SourceLocation._is(other) && J.$eq$(this.sourceUrl, other.get$sourceUrl()) && this.offset === other.get$offset();
    },
    get$hashCode(_) {
      var t1 = this.sourceUrl;
      t1 = t1 == null ? null : t1.get$hashCode(t1);
      if (t1 == null)
        t1 = 0;
      return t1 + this.offset;
    },
    toString$0(_) {
      var _this = this,
        t1 = A.getRuntimeTypeOfDartObject(_this).toString$0(0),
        source = _this.sourceUrl;
      return "<" + t1 + ": " + _this.offset + " " + (A.S(source == null ? "unknown source" : source) + ":" + (_this.line + 1) + ":" + (_this.column + 1)) + ">";
    },
    $isComparable: 1,
    get$sourceUrl() {
      return this.sourceUrl;
    },
    get$offset() {
      return this.offset;
    },
    get$line() {
      return this.line;
    },
    get$column() {
      return this.column;
    }
  };
  A.SourceLocationMixin.prototype = {
    distance$1(other) {
      if (!J.$eq$(this.file.url, other.get$sourceUrl()))
        throw A.wrapException(A.ArgumentError$('Source URLs "' + A.S(this.get$sourceUrl()) + '" and "' + A.S(other.get$sourceUrl()) + "\" don't match.", null));
      return Math.abs(this.offset - other.get$offset());
    },
    compareTo$1(_, other) {
      type$.SourceLocation._as(other);
      if (!J.$eq$(this.file.url, other.get$sourceUrl()))
        throw A.wrapException(A.ArgumentError$('Source URLs "' + A.S(this.get$sourceUrl()) + '" and "' + A.S(other.get$sourceUrl()) + "\" don't match.", null));
      return this.offset - other.get$offset();
    },
    $eq(_, other) {
      if (other == null)
        return false;
      return type$.SourceLocation._is(other) && J.$eq$(this.file.url, other.get$sourceUrl()) && this.offset === other.get$offset();
    },
    get$hashCode(_) {
      var t1 = this.file.url;
      t1 = t1 == null ? null : t1.get$hashCode(t1);
      if (t1 == null)
        t1 = 0;
      return t1 + this.offset;
    },
    toString$0(_) {
      var t1 = A.getRuntimeTypeOfDartObject(this).toString$0(0),
        t2 = this.offset,
        t3 = this.file,
        source = t3.url;
      return "<" + t1 + ": " + t2 + " " + (A.S(source == null ? "unknown source" : source) + ":" + (t3.getLine$1(t2) + 1) + ":" + (t3.getColumn$1(t2) + 1)) + ">";
    },
    $isComparable: 1,
    $isSourceLocation: 1
  };
  A.SourceSpanBase.prototype = {
    SourceSpanBase$3(start, end, text) {
      var t3,
        t1 = this.end,
        t2 = this.start;
      if (!J.$eq$(t1.get$sourceUrl(), t2.get$sourceUrl()))
        throw A.wrapException(A.ArgumentError$('Source URLs "' + A.S(t2.get$sourceUrl()) + '" and  "' + A.S(t1.get$sourceUrl()) + "\" don't match.", null));
      else if (t1.get$offset() < t2.get$offset())
        throw A.wrapException(A.ArgumentError$("End " + t1.toString$0(0) + " must come after start " + t2.toString$0(0) + ".", null));
      else {
        t3 = this.text;
        if (t3.length !== t2.distance$1(t1))
          throw A.wrapException(A.ArgumentError$('Text "' + t3 + '" must be ' + t2.distance$1(t1) + " characters long.", null));
      }
    },
    get$start() {
      return this.start;
    },
    get$end() {
      return this.end;
    },
    get$text() {
      return this.text;
    }
  };
  A.SourceSpanException.prototype = {
    get$message() {
      return this._span_exception$_message;
    },
    toString$0(_) {
      var t3, t4, highlight,
        t1 = this._span,
        t2 = "" + ("line " + (t1.get$start().get$line() + 1) + ", column " + (t1.get$start().get$column() + 1));
      if (t1.get$sourceUrl() != null) {
        t3 = t1.get$sourceUrl();
        t4 = $.$get$context();
        t3.toString;
        t3 = t2 + (" of " + t4.prettyUri$1(t3));
        t2 = t3;
      }
      t2 += ": " + this._span_exception$_message;
      highlight = t1.highlight$1$color(null);
      t1 = highlight.length !== 0 ? t2 + "\n" + highlight : t2;
      return "Error on " + (t1.charCodeAt(0) == 0 ? t1 : t1);
    },
    $isException: 1
  };
  A.SourceSpanFormatException.prototype = {
    get$offset() {
      var t1 = this._span;
      t1 = A.FileLocation$_(t1.file, t1._file$_start);
      return t1.offset;
    },
    $isFormatException: 1,
    get$source() {
      return this.source;
    }
  };
  A.SourceSpanMixin.prototype = {
    get$sourceUrl() {
      return this.get$start().get$sourceUrl();
    },
    get$length(_) {
      return this.get$end().get$offset() - this.get$start().get$offset();
    },
    compareTo$1(_, other) {
      var result;
      type$.SourceSpan._as(other);
      result = this.get$start().compareTo$1(0, other.get$start());
      return result === 0 ? this.get$end().compareTo$1(0, other.get$end()) : result;
    },
    highlight$1$color(color) {
      var _this = this;
      if (!type$.SourceSpanWithContext._is(_this) && _this.get$length(_this) === 0)
        return "";
      return A.Highlighter$(_this, color).highlight$0();
    },
    $eq(_, other) {
      if (other == null)
        return false;
      return other instanceof A.SourceSpanMixin && this.get$start().$eq(0, other.get$start()) && this.get$end().$eq(0, other.get$end());
    },
    get$hashCode(_) {
      return A.Object_hash(this.get$start(), this.get$end(), B.C_SentinelValue);
    },
    toString$0(_) {
      var _this = this;
      return "<" + A.getRuntimeTypeOfDartObject(_this).toString$0(0) + ": from " + _this.get$start().toString$0(0) + " to " + _this.get$end().toString$0(0) + ' "' + _this.get$text() + '">';
    },
    $isComparable: 1,
    $isSourceSpan: 1
  };
  A.SourceSpanWithContext.prototype = {
    get$context() {
      return this._context;
    }
  };
  A.StringScannerException.prototype = {
    get$source() {
      return A._asString(this.source);
    }
  };
  A.StringScanner.prototype = {
    get$lastMatch() {
      var _this = this;
      if (_this._string_scanner$_position !== _this._lastMatchPosition)
        _this._lastMatch = null;
      return _this._lastMatch;
    },
    scan$1(pattern) {
      var success, _this = this,
        t1 = _this._lastMatch = J.matchAsPrefix$2$s(pattern, _this.string, _this._string_scanner$_position);
      _this._lastMatchPosition = _this._string_scanner$_position;
      success = t1 != null;
      if (success)
        _this._lastMatchPosition = _this._string_scanner$_position = t1.get$end();
      return success;
    },
    expect$2$name(pattern, $name) {
      var t1;
      if (this.scan$1(pattern))
        return;
      if ($name == null)
        if (pattern instanceof A.JSSyntaxRegExp)
          $name = "/" + pattern.pattern + "/";
        else {
          t1 = J.toString$0$(pattern);
          t1 = A.stringReplaceAllUnchecked(t1, "\\", "\\\\");
          $name = '"' + A.stringReplaceAllUnchecked(t1, '"', '\\"') + '"';
        }
      this._fail$1($name);
    },
    expect$1(pattern) {
      return this.expect$2$name(pattern, null);
    },
    expectDone$0() {
      if (this._string_scanner$_position === this.string.length)
        return;
      this._fail$1("no more input");
    },
    error$3$length$position(message, $length, position) {
      var t2, t3, t4, t5, sourceFile, end,
        t1 = this.string;
      if (position < 0)
        A.throwExpression(A.RangeError$("position must be greater than or equal to 0."));
      else if (position > t1.length)
        A.throwExpression(A.RangeError$("position must be less than or equal to the string length."));
      t2 = position + $length > t1.length;
      if (t2)
        A.throwExpression(A.RangeError$("position plus length must not go beyond the end of the string."));
      t2 = this.sourceUrl;
      t3 = new A.CodeUnits(t1);
      t4 = A._setArrayType([0], type$.JSArray_int);
      t5 = new Uint32Array(A._ensureNativeList(t3.toList$0(t3)));
      sourceFile = new A.SourceFile(t2, t4, t5);
      sourceFile.SourceFile$decoded$2$url(t3, t2);
      end = position + $length;
      if (end > t5.length)
        A.throwExpression(A.RangeError$("End " + end + string$.x20must_ + sourceFile.get$length(0) + "."));
      else if (position < 0)
        A.throwExpression(A.RangeError$("Start may not be negative, was " + position + "."));
      throw A.wrapException(new A.StringScannerException(t1, message, new A._FileSpan(sourceFile, position, end)));
    },
    _fail$1($name) {
      this.error$3$length$position("expected " + $name + ".", 0, this._string_scanner$_position);
    }
  };
  A.TonAddress.prototype = {
    toString$0(_) {
      var t2, _this = this,
        t1 = _this.defaultFlags;
      if (t1.length === 0)
        return A.BytesUtils_toHexString(_this.hash, true, "" + _this.workChain + ":");
      t2 = B.JSArray_methods.contains$1(t1, B.FriendlyAddressFlags_17);
      t2 = t2;
      t1 = B.JSArray_methods.contains$1(t1, B.FriendlyAddressFlags_128);
      return A.TonAddressUtils_encodeAddress(t2, _this.hash, t1, true, _this.workChain);
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof A.TonAddress))
        return false;
      return A.BytesUtils_bytesEqual(other.hash, this.hash) && other.workChain === this.workChain;
    },
    get$hashCode(_) {
      return A.Object_hash(this.hash, this.workChain, B.C_SentinelValue);
    }
  };
  A.TonContractException.prototype = {};
  A.WalletVersion.prototype = {
    toString$0(_) {
      return "WalletVersion." + this.name;
    }
  };
  A.WalletVersion_WalletVersion$fromValue_closure.prototype = {
    call$1(element) {
      return type$.WalletVersion._as(element).name === this.name;
    },
    $signature: 226
  };
  A.WalletVersion_WalletVersion$fromValue_closure0.prototype = {
    call$0() {
      return A.throwExpression(new A.TonContractException("Cannot find WalletVersion from provided status", A.LinkedHashMap_LinkedHashMap$_literal(["name", this.name], type$.String, type$.dynamic)));
    },
    $signature: 2
  };
  A.TonDartPluginException.prototype = {
    toString$0(_) {
      var _this = this,
        t1 = _this.details.get$entries().where$1(0, new A.TonDartPluginException_toString_closure()),
        t2 = type$.String,
        infos = A.Map_Map$fromEntries(t1, t2, type$.dynamic);
      if (infos.__js_helper$_length === 0)
        return A.getRuntimeTypeOfDartObject(_this).toString$0(0) + "(" + _this.message + ")";
      t1 = infos.get$entries().map$1$1(0, new A.TonDartPluginException_toString_closure0(), t2).join$1(0, ", ");
      return A.getRuntimeTypeOfDartObject(_this).toString$0(0) + "(" + (_this.message + " " + t1) + ")";
    },
    get$message() {
      return this.message;
    }
  };
  A.TonDartPluginException_toString_closure.prototype = {
    call$1(element) {
      return type$.MapEntry_String_dynamic._as(element).value != null;
    },
    $signature: 227
  };
  A.TonDartPluginException_toString_closure0.prototype = {
    call$1(e) {
      type$.MapEntry_String_dynamic._as(e);
      return A.S(e.key) + ": " + A.S(e.value);
    },
    $signature: 228
  };
  A.TonApiType.prototype = {};
  A.TonApiType_TonApiType$fromValue_closure.prototype = {
    call$1(element) {
      return type$.TonApiType._as(element).name === this.name;
    },
    $signature: 229
  };
  A.TonApiType_TonApiType$fromValue_closure0.prototype = {
    call$0() {
      return A.throwExpression(A.TonDartPluginException$("Cannot find TonApiType from provided name", A.LinkedHashMap_LinkedHashMap$_literal(["name", this.name], type$.String, type$.dynamic)));
    },
    $signature: 2
  };
  A.EventStreamProvider.prototype = {};
  A._EventStream.prototype = {
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      var t1 = this.$ti;
      t1._eval$1("~(1)?")._as(onData);
      type$.nullable_void_Function._as(onDone);
      return A._EventStreamSubscription$(this._target, this._eventType, onData, false, t1._precomputed1);
    },
    listen$3$cancelOnError$onDone(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    }
  };
  A._EventStreamSubscription.prototype = {
    cancel$0() {
      var _this = this,
        emptyFuture = A.Future_Future$value(null, type$.void);
      if (_this._target == null)
        return emptyFuture;
      _this._unlisten$0();
      _this._onData = _this._target = null;
      return emptyFuture;
    },
    onData$1(handleData) {
      var t1, _this = this;
      _this.$ti._eval$1("~(1)?")._as(handleData);
      if (_this._target == null)
        throw A.wrapException(A.StateError$("Subscription has been canceled."));
      _this._unlisten$0();
      t1 = A._wrapZone(new A._EventStreamSubscription_onData_closure(handleData), type$.JSObject);
      t1 = t1 == null ? null : type$.JavaScriptFunction._as(A.allowInterop(t1, type$.Function));
      _this._onData = t1;
      _this._tryResume$0();
    },
    onError$1(handleError) {
    },
    _tryResume$0() {
      var _this = this,
        t1 = _this._onData;
      if (t1 != null && _this._pauseCount <= 0)
        _this._target.addEventListener(_this._eventType, t1, false);
    },
    _unlisten$0() {
      var t1 = this._onData;
      if (t1 != null)
        this._target.removeEventListener(this._eventType, t1, false);
    },
    $isStreamSubscription: 1
  };
  A._EventStreamSubscription_closure.prototype = {
    call$1(e) {
      return this.onData.call$1(type$.JSObject._as(e));
    },
    $signature: 33
  };
  A._EventStreamSubscription_onData_closure.prototype = {
    call$1(e) {
      return this.handleData.call$1(type$.JSObject._as(e));
    },
    $signature: 33
  };
  A.XRPAddress.prototype = {
    toString$0(_) {
      return this.address;
    }
  };
  A.XRPLAddressCodecException.prototype = {
    toString$0(_) {
      return "Invalid ripple address";
    },
    $isException: 1,
    $isBlockchainUtilsException: 1
  };
  A.MessageCompleterHandler.prototype = {};
  A.MessageCompleter.prototype = {};
  A.JsEthereumHandler.prototype = {
    buildMessage$1(params) {
      var method, e, message, e0, message0, t1, toList, t2, t3, version, typedData, data, exception, _null = null;
      try {
        method = A.Web3EthereumRequestMethods_fromName(A._asStringQ(params.method));
        switch (method) {
          case B.Web3EthereumRequestMethods_5_eth_requestAccounts_List_empty:
            t1 = $.Zone__current;
            return new A.Web3EthreumRequestAccounts(this._currentChain, new A._AsyncCompleter(new A._Future(t1, type$._Future_List_Web3AccountPermission_ETHAddress), type$._AsyncCompleter_List_Web3AccountPermission_ETHAddress));
          case B.Web3EthereumRequestMethods_1_personal_sign_List_empty:
            toList = A.EthereumRequestParams_toStringListParam(params, 2);
            t1 = J.getInterceptor$asx(toList);
            t1 = A.Web3EthreumPersonalSign_Web3EthreumPersonalSign$fromJson(A.LinkedHashMap_LinkedHashMap$_literal(["address", t1.$index(toList, 0), "challeng", t1.$index(toList, 1)], type$.String, type$.dynamic));
            return t1;
          case B.Web3EthereumRequestMethods_MEg:
            toList = A.EthereumRequestParams_tryParamsToList(params, 2);
            if (toList == null)
              A.throwExpression(B.Web3ArgsException_izi);
            t1 = A._asStringQ(params.method);
            t2 = t1.length;
            t3 = t2 - 1;
            if (!(t3 >= 0))
              return A.ioore(t1, t3);
            version = A.Primitives_parseInt(t1[t3], _null);
            if (A.EIP712Version_fromVersion(version == null ? 1 : version) === B.EIP712Version_1) {
              t1 = J.getInterceptor$asx(toList);
              typedData = A.EthereumJsParamsValidator__typdedDataToJson(t1.$index(toList, 0));
              typedData.$indexSet(0, "version", 1);
              data = A.LinkedHashMap_LinkedHashMap$_literal(["address", t1.$index(toList, 1), "typedData", B.C_JsonCodec.encode$2$toEncodable(typedData, _null)], type$.String, type$.dynamic);
            } else
              data = _null;
            if (data == null) {
              t1 = J.getInterceptor$asx(toList);
              typedData = A.EthereumJsParamsValidator__typdedDataToJson(t1.$index(toList, 1));
              typedData.$indexSet(0, "version", toList);
              data = A.LinkedHashMap_LinkedHashMap$_literal(["address", t1.$index(toList, 0), "typedData", B.C_JsonCodec.encode$2$toEncodable(typedData, _null)], type$.String, type$.dynamic);
            }
            if (data.$index(0, "chainId") == null)
              data.$indexSet(0, "chainId", this._currentChain);
            t1 = A.Web3EthreumTypdedData_Web3EthreumTypdedData$fromJson(data);
            return t1;
          default:
            t1 = A.UnimplementedError$(_null);
            throw A.wrapException(t1);
        }
      } catch (exception) {
        t1 = A.unwrapException(exception);
        if (type$.Web3Exception._is(t1)) {
          e = t1;
          message = e.toMessge$0();
          throw A.wrapException(A.ToWalletError_toWalletError(message, A.EthereumRequestParams_toJson(params)));
        } else {
          e0 = t1;
          message0 = A.Web3InternalException_internalError(J.toString$0$(e0)).toMessge$0();
          t1 = A.ToWalletError_toWalletError(message0, A.EthereumRequestParams_toJson(params));
          throw A.wrapException(t1);
        }
      }
    }
  };
  A.EthereumRequestParams_toStringListParam_closure.prototype = {
    call$0() {
      return A.List_List$from(this.toDart, true, type$.String);
    },
    $signature: 231
  };
  A.JSWalletHandler.prototype = {
    _onResponse$2$requestId(message, requestId) {
      var t1, completer, result, t2, t3, t4, t5, t6, updatedChain, _this = this,
        _s20_ = "request to compelte ",
        _null = null;
      switch (message.get$type()) {
        case B.Web3MessageTypes_fvN:
          A.print("\x1b[33m" + (_s20_ + A.S(requestId)) + "\x1b[0m");
          t1 = type$.Web3ResponseMessage;
          t1 = t1._as(message.cast$1$0(0, t1));
          completer = _this.completer._awaitingMessages.remove$1(0, requestId);
          if (completer != null) {
            t1 = t1.value;
            result = t1 == null ? _null : type$.JSObject._as(self.JSON).parse(t1);
            completer.completer.complete$1(result);
          }
          break;
        case B.Web3MessageTypes_L6o:
          A.print("\x1b[33m" + (_s20_ + A.S(requestId)) + "\x1b[0m");
          t1 = type$.Web3ExceptionMessage;
          t1 = t1._as(message.cast$1$0(0, t1));
          completer = _this.completer._awaitingMessages.remove$1(0, requestId);
          if (completer != null) {
            A.print("message json " + t1.toJson$0().toString$0(0));
            t2 = completer.id;
            t3 = t1.code;
            if (t3 == null)
              t3 = _null;
            t4 = t1.info;
            t4 = t4 == null ? _null : A.jsify(t4);
            t5 = t1.request;
            t5 = t5 == null ? _null : B.C_JsonCodec.encode$2$toEncodable(t5, _null);
            t6 = t1.requestId;
            if (t6 == null)
              t6 = _null;
            if (!(t6 == null))
              t2 = t6;
            t2 = A.jsify(A.LinkedHashMap_LinkedHashMap$_literal(["message", t1.message, "code", t3, "info", t4, "request", t5, "requestId", t2], type$.String, type$.nullable_Object));
            t1 = t2 == null ? {} : t2;
            completer.completer.completeError$1(t1);
          }
          break;
        case B.Web3MessageTypes_n9E:
          _this.chain = A.ChainsHandler_ChainsHandler$deserialize(message.cast$1$0(0, type$.Web3ChainMessage).message);
          break;
        case B.Web3MessageTypes_eYh:
          updatedChain = A.Chain_Chain$fromCborBytesOrObject(message.cast$1$0(0, type$.Web3ChainMessage).message, _null, type$.APIProvider, type$.NetworkCoinParams_APIProvider, type$.dynamic, type$.TokenCore_dynamic, type$.ChainAccount_of_nullable_Object_and_TokenCore_dynamic, type$.WalletNetwork_NetworkCoinParams_APIProvider, type$.NetworkClient_of_ChainAccount_of_nullable_Object_and_TokenCore_dynamic_and_APIProvider, type$.Web3BaseRequestParams_dynamic_dynamic_dynamic);
          _this.chain.updateChain$1(updatedChain);
          break;
      }
      A.print("\x1b[33m" + ("Updated " + message.get$type()._core$_name) + "\x1b[0m");
    },
    onResponse$1(request) {
      var data, debugHash, encryptedMessage, decode, message, e, s, t1, t2, t3, t4, exception;
      type$.JSObject._as(request);
      try {
        t1 = A._asStringQ(request.id);
        if (t1 == null)
          t1 = null;
        if (t1 !== this.scriptId) {
          t1 = A.Exception_Exception("invalid id: ");
          throw A.wrapException(t1);
        }
        t1 = type$.nullable_JSArray_nullable_Object;
        t2 = t1._as(request.data);
        t2.toString;
        t3 = type$.List_double;
        if (!t3._is(t2))
          t2 = new A.CastList(t2, A._arrayInstanceType(t2)._eval$1("CastList<1,double>"));
        t4 = type$.int;
        data = A.List_List$from(t2, true, t4);
        t1 = t1._as(request.data);
        t1.toString;
        if (!t3._is(t1))
          t1 = new A.CastList(t1, A._arrayInstanceType(t1)._eval$1("CastList<1,double>"));
        debugHash = A.BytesUtils_tryToHexString(A.SHA256_hash(A.List_List$from(t1, true, t4)));
        A.print("\x1b[33m" + ("debugHash " + A.S(debugHash)) + "\x1b[0m");
        encryptedMessage = A.Web3EncryptedMessage_Web3EncryptedMessage$deserialize(data);
        decode = this._crypto.decrypt$2(encryptedMessage.nonce, encryptedMessage.message);
        message = A.Web3MessageCore_Web3MessageCore$deserialize(decode);
        t4 = A._asStringQ(request.requestId);
        t1 = t4 == null ? null : t4;
        this._onResponse$2$requestId(message, t1);
      } catch (exception) {
        e = A.unwrapException(exception);
        s = A.getTraceFromException(exception);
        A.print("\x1b[33m" + ("error " + A.S(e) + " " + A.S(s)) + "\x1b[0m");
      }
    },
    _completeMessage$1(params) {
      return this._completeMessage$body$JSWalletHandler(params);
    },
    _completeMessage$body$JSWalletHandler(params) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.nullable_Object),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$self = this, message, request, result, e, message0, r, requestId, completer, t1, t2, exception, $async$exception;
      var $async$_completeMessage$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              message0 = $async$self.ethereum.buildMessage$1(params);
              r = $.$get$QuickCrypto__generateRandom().call$1(12);
              message = new A.Web3EncryptedMessage($async$self._crypto.encrypt$2(r, message0.toCbor$0().encode$0()), A.BytesUtils_toBytes(r, true));
              type$.Web3EncryptedMessage._as(message);
              requestId = A.UUID_generateUUIDv4();
              completer = new A.MessageCompleter(requestId, new A._AsyncCompleter(new A._Future($.Zone__current, type$._Future_nullable_Object), type$._AsyncCompleter_nullable_Object));
              $async$self.completer._awaitingMessages.$indexSet(0, requestId, completer);
              request = completer;
              t1 = type$.JSObject._as(self.MRT);
              t2 = message;
              t2 = A._setArrayType([new A.CborBytesValue(t2.message), new A.CborBytesValue(t2.nonce)], type$.JSArray_CborBytesValue);
              t1.onMrtJsRequest($async$self.scriptId, A.BytesUtils_toHexString(new A.CborTagValue(A.List_List$unmodifiable(B.List_0_10_200_0, type$.int), new A.CborListValue(t2, true, type$.CborListValue_CborBytesValue), type$.CborTagValue_dynamic).encode$0(), true, null), request.id, $async$self.clientId);
              A.print("\x1b[33m" + ("message was send! " + request.id) + "\x1b[0m");
              $async$goto = 7;
              return A._asyncAwait(request.completer.future, $async$_completeMessage$1);
            case 7:
              // returning from await.
              result = $async$result;
              A.print("\x1b[33m" + ("I got result " + A.S(A.dartify(result))) + "\x1b[0m");
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              e = A.unwrapException($async$exception);
              A.print("\x1b[33m" + ("error " + A.S(A.dartify(e)) + " ") + "\x1b[0m");
              throw $async$exception;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return A._asyncStartSync($async$_completeMessage$1, $async$completer);
    },
    onEthereumRequest$1(params) {
      type$.JSObject._as(params);
      A.print("params " + A.S(params.params) + " " + A.S(A._asStringQ(params.method)));
      return A.FutureTest_get_toPromise(this._completeMessage$1(params), type$.nullable_Object);
    }
  };
  A.FutureTest_get_toPromise_closure.prototype = {
    call$2(resolve, reject) {
      var t1 = type$.JavaScriptFunction;
      t1._as(resolve);
      t1._as(reject);
      this._this.then$1$2$onError(new A.FutureTest_get_toPromise__closure(resolve), new A.FutureTest_get_toPromise__closure0(reject), type$.nullable_Object).catchError$1(new A.FutureTest_get_toPromise__closure1(reject, resolve));
    },
    $signature: 233
  };
  A.FutureTest_get_toPromise__closure.prototype = {
    call$1(value) {
      var t1 = this.resolve;
      A.callMethod(t1, "call", [t1, value], type$.nullable_Object);
      return value;
    },
    $signature: 31
  };
  A.FutureTest_get_toPromise__closure0.prototype = {
    call$2(error, stackTrace) {
      var t1;
      type$.Object._as(error);
      error.stack = type$.StackTrace._as(stackTrace).toString$0(0);
      t1 = this.reject;
      A.callMethod(t1, "call", [t1, error], type$.nullable_Object);
      return error;
    },
    $signature: 234
  };
  A.FutureTest_get_toPromise__closure1.prototype = {
    call$1(e) {
      A.callMethod(this.reject, "call", [this.resolve, e], type$.nullable_Object);
      return e;
    },
    $signature: 15
  };
  A.main_onActivation.prototype = {
    call$1(data) {
      var wallet, t1, clientId;
      A._asString(data);
      A.print("\x1b[33m" + ("onActivation " + data) + "\x1b[0m");
      t1 = A._asString(type$.JSObject._as(self.MRT).scriptId());
      clientId = A.UUID_generateUUIDv4();
      wallet = new A.JSWalletHandler(A.ChaCha20Poly1305$(A.BytesUtils_fromHexString(data)), t1, clientId, new A.JsEthereumHandler($.$get$_BigIntImpl_one()), new A.MessageCompleterHandler(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.MessageCompleter)), new A.ChainsHandler(A.LinkedHashMap_LinkedHashMap$_empty(type$.int, type$.Chain_of_APIProvider_and_NetworkCoinParams_APIProvider_and_dynamic_and_TokenCore_dynamic_and_ChainAccount_of_dynamic_and_TokenCore_dynamic_and_WalletNetwork_NetworkCoinParams_APIProvider_and_NetworkClient_of_ChainAccount_of_dynamic_and_TokenCore_dynamic_and_APIProvider_and_Web3BaseRequestParams_dynamic_dynamic_dynamic)));
      this.completer.complete$1(wallet);
      return wallet.clientId;
    },
    $signature: 16
  };
  (function aliases() {
    var _ = J.LegacyJavaScriptObject.prototype;
    _.super$LegacyJavaScriptObject$toString = _.toString$0;
    _ = A.JsLinkedHashMap.prototype;
    _.super$JsLinkedHashMap$internalContainsKey = _.internalContainsKey$1;
    _.super$JsLinkedHashMap$internalGet = _.internalGet$1;
    _.super$JsLinkedHashMap$internalSet = _.internalSet$2;
    _.super$JsLinkedHashMap$internalRemove = _.internalRemove$1;
    _ = A.ListBase.prototype;
    _.super$ListBase$setRange = _.setRange$4;
    _ = A.Iterable.prototype;
    _.super$Iterable$where = _.where$1;
    _ = A.LegacyAddress.prototype;
    _.super$LegacyAddress$toAddress = _.toAddress$1;
    _ = A._Keccack.prototype;
    _.super$_Keccack$reset = _.reset$0;
    _.super$_Keccack$update = _.update$1;
    _ = A.BaseRequest.prototype;
    _.super$BaseRequest$finalize = _.finalize$0;
    _ = A.LiveListenable.prototype;
    _.super$LiveListenable$value = _.set$value;
    _ = A.FixedBytes.prototype;
    _.super$FixedBytes$toJson = _.toJson$0;
    _ = A.SourceSpanMixin.prototype;
    _.super$SourceSpanMixin$compareTo = _.compareTo$1;
    _.super$SourceSpanMixin$$eq = _.$eq;
  })();
  (function installTearOffs() {
    var _static_2 = hunkHelpers._static_2,
      _instance_1_u = hunkHelpers._instance_1u,
      _static_1 = hunkHelpers._static_1,
      _static_0 = hunkHelpers._static_0,
      _instance = hunkHelpers.installInstanceTearOff,
      _instance_2_u = hunkHelpers._instance_2u,
      _instance_0_u = hunkHelpers._instance_0u,
      _instance_1_i = hunkHelpers._instance_1i,
      _static = hunkHelpers.installStaticTearOff,
      _instance_0_i = hunkHelpers._instance_0i;
    _static_2(J, "_interceptors_JSArray__compareAny$closure", "JSArray__compareAny", 58);
    _instance_1_u(A.CastStreamSubscription.prototype, "get$__internal$_onData", "__internal$_onData$1", 63);
    _static_1(A, "async__AsyncRun__scheduleImmediateJsOverride$closure", "_AsyncRun__scheduleImmediateJsOverride", 29);
    _static_1(A, "async__AsyncRun__scheduleImmediateWithSetImmediate$closure", "_AsyncRun__scheduleImmediateWithSetImmediate", 29);
    _static_1(A, "async__AsyncRun__scheduleImmediateWithTimer$closure", "_AsyncRun__scheduleImmediateWithTimer", 29);
    _static_0(A, "async___startMicrotaskLoop$closure", "_startMicrotaskLoop", 0);
    _static_1(A, "async___nullDataHandler$closure", "_nullDataHandler", 12);
    _static_2(A, "async___nullErrorHandler$closure", "_nullErrorHandler", 37);
    _static_0(A, "async___nullDoneHandler$closure", "_nullDoneHandler", 0);
    _instance(A._Completer.prototype, "get$completeError", 0, 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["completeError$2", "completeError$1"], 188, 0, 0);
    _instance_2_u(A._Future.prototype, "get$_completeError", "_completeError$2", 37);
    _instance_0_u(A._DoneStreamSubscription.prototype, "get$_onMicrotask", "_onMicrotask$0", 0);
    _static_2(A, "collection___defaultEquals$closure", "_defaultEquals", 52);
    _static_1(A, "collection___defaultHashCode$closure", "_defaultHashCode", 49);
    _static_2(A, "collection_ListBase__compareAny$closure", "ListBase__compareAny", 58);
    _static_1(A, "convert___defaultToEncodable$closure", "_defaultToEncodable", 15);
    var _;
    _instance_1_i(_ = A._ByteCallbackSink.prototype, "get$add", "add$1", 63);
    _instance_0_u(_, "get$close", "close$0", 0);
    _static_1(A, "core__identityHashCode$closure", "identityHashCode", 49);
    _static_2(A, "core__identical$closure", "identical", 52);
    _static_1(A, "core_Uri_decodeComponent$closure", "Uri_decodeComponent", 16);
    _instance(_ = A._RawSecureSocket.prototype, "get$_completeCloseCompleter", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["_completeCloseCompleter$1", "_completeCloseCompleter$0"], 211, 0, 0);
    _instance_1_u(_, "get$_onBadCertificateWrapper", "_onBadCertificateWrapper$1", 61);
    _instance_1_u(_, "get$_eventDispatcher", "_eventDispatcher$1", 230);
    _instance_0_u(_, "get$_doneHandler", "_doneHandler$0", 0);
    _instance(_, "get$_reportError", 0, 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["_reportError$2", "_reportError$1"], 236, 0, 0);
    _instance_0_u(_, "get$_secureHandshakeCompleteHandler", "_secureHandshakeCompleteHandler$0", 0);
    _instance_0_u(_, "get$_onPauseStateChange", "_onPauseStateChange$0", 0);
    _instance_0_u(_, "get$_onSubscriptionStateChange", "_onSubscriptionStateChange$0", 0);
    _instance_1_u(_, "get$_readSocketOrBufferedData", "_readSocketOrBufferedData$1", 241);
    _static(A, "math__max$closure", 2, null, ["call$1$2", "call$2"], ["max", function(a, b) {
      return A.max(a, b, type$.num);
    }], 239, 1);
    _static_2(A, "bch_bech32__BchBech32Utils_computeChecksum$closure", "_BchBech32Utils_computeChecksum", 71);
    _static_2(A, "bch_bech32__BchBech32Utils_verifyChecksum$closure", "_BchBech32Utils_verifyChecksum", 66);
    _static(A, "bech32_base_Bech32Utils_computeChecksum$closure", 2, function() {
      return [B.Bech32Encodings_0];
    }, ["call$3", "call$2"], ["Bech32Utils_computeChecksum", function(hrp, data) {
      return A.Bech32Utils_computeChecksum(hrp, data, B.Bech32Encodings_0);
    }], 242, 0);
    _static(A, "bech32_base_Bech32Utils_verifyChecksum$closure", 2, function() {
      return [B.Bech32Encodings_0];
    }, ["call$3", "call$2"], ["Bech32Utils_verifyChecksum", function(hrp, data) {
      return A.Bech32Utils_verifyChecksum(hrp, data, B.Bech32Encodings_0);
    }], 243, 0);
    _static_1(A, "bip32_path_Bip32PathParser__parseElem$closure", "Bip32PathParser__parseElem", 162);
    _instance_0_i(A.Bip32Path.prototype, "get$length", "length$0", 26);
    _instance_0_u(_ = A.WebSocketService.prototype, "get$_onClose", "_onClose$0", 0);
    _instance_1_u(_, "get$_onMessge", "_onMessge$1", 119);
    _instance_1_u(_ = A.JSWalletHandler.prototype, "get$onResponse", "onResponse$1", 33);
    _instance_1_u(_, "get$onEthereumRequest", "onEthereumRequest$1", 232);
    _static_2(A, "segwit_bech32_SegwitBech32Encoder__computeChecksum$closure", "SegwitBech32Encoder__computeChecksum", 71);
    _static_2(A, "segwit_bech32_SegwitBech32Decoder__verifyChecksum$closure", "SegwitBech32Decoder__verifyChecksum", 66);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _inherit = hunkHelpers.inherit,
      _inheritMany = hunkHelpers.inheritMany;
    _inherit(A.Object, null);
    _inheritMany(A.Object, [A.JS_CONST, J.Interceptor, J.ArrayIterator, A.Stream, A.CastStreamSubscription, A.Iterable, A.CastIterator, A.Closure, A.MapBase, A.Error, A.ListBase, A.SentinelValue, A.ListIterator, A.MappedIterator, A.WhereIterator, A.ExpandIterator, A.TakeIterator, A.SkipIterator, A.EmptyIterator, A.WhereTypeIterator, A.FixedLengthListMixin, A.UnmodifiableListMixin, A.Symbol, A.MapView, A.ConstantMap, A._KeysOrValuesOrElementsIterator, A.JSInvocationMirror, A.TypeErrorDecoder, A.NullThrownFromJavaScriptException, A.ExceptionAndStackTrace, A._StackTrace, A._Required, A.LinkedHashMapCell, A.LinkedHashMapKeyIterator, A.JSSyntaxRegExp, A._MatchImplementation, A._AllMatchesIterator, A.StringMatch, A._StringAllMatchesIterator, A._Cell, A.Rti, A._FunctionParameters, A._Type, A._TimerImpl, A._AsyncAwaitCompleter, A._SyncStarIterator, A.AsyncError, A.TimeoutException, A._Completer, A._FutureListener, A._Future, A._AsyncCallbackEntry, A._StreamController, A._SyncStreamControllerDispatch, A._AsyncStreamControllerDispatch, A._BufferingStreamSubscription, A._DelayedEvent, A._DelayedDone, A._PendingEvents, A._DoneStreamSubscription, A._StreamIterator, A._Zone, A._HashMapKeyIterator, A.SetBase, A._LinkedHashSetCell, A._LinkedHashSetIterator, A._UnmodifiableMapMixin, A.Codec, A.Converter, A._Base64Encoder, A._Base64Decoder, A.ByteConversionSink, A._JsonStringifier, A._Utf8Encoder, A._Utf8Decoder, A._BigIntImpl, A._BigIntClassic, A.DateTime, A.Duration, A._Enum, A.OutOfMemoryError, A.StackOverflowError, A._Exception, A.FormatException, A.IntegerDivisionByZeroException, A.MapEntry, A.Null, A._StringStackTrace, A.RuneIterator, A.StringBuffer, A._Uri, A.UriData, A._SimpleUri, A.Expando, A._FilterStatus, A.TlsException, A.SocketDirection, A.RawSocketEvent, A.NullRejectionException, A._JSSecureRandom, A.Endian, A.PubKeyAddressType, A.P2pkhAddressType, A.P2shAddressType, A.SegwitAddresType, A.LegacyAddress, A.BitcoinNetworkAddress, A.SegwitAddress, A.Script, A.ECPublic, A.BlockchainUtilsException, A.BitcoinSVNetwork, A.BitcoinNetwork, A.LitecoinNetwork, A.DashNetwork, A.DogecoinNetwork, A.BitcoinCashNetwork, A.PepeNetwork, A.ApiProvider, A.APIConfig, A.Base58ChecksumError, A.Bech32ChecksumError, A.ADAAddressType, A.ADAByronAddrTypes, A.ADAByronAddrAttrs, A.ADAByronAddrPayload, A.ADAByronAddr, A.AdaByronIcarusAddrEncoder, A.AdaByronLegacyAddrEncoder, A.Pointer, A.AdaStakeCredType, A.AdaStakeCredential, A.AdaShelleyAddrEncoder, A.AdaShelleyStakingAddrEncoder, A.AdaGenericAddrDecoderResult, A.AdaGenericAddrDecoder, A.ADANetwork, A.AlgoAddrEncoder, A.AptosAddrEncoder, A.AtomAddrEncoder, A.AtomNist256P1AddrEncoder, A.AvaxPChainAddrEncoder, A.AvaxXChainAddrEncoder, A.EgldAddrEncoder, A.BlockchainAddressEncoder, A.EosAddrEncoder, A.ErgoNetworkTypes, A.ErgoP2PKHAddrEncoder, A.EthAddrDecoder, A.EthAddrEncoder, A.AddressConverterException, A.FilSecp256k1AddrEncoder, A.IcxAddrEncoder, A.InjAddrEncoder, A.NanoAddrEncoder, A.NearAddrEncoder, A.NeoAddrEncoder, A.OkexAddrEncoder, A.OneAddrEncoder, A.P2PKHAddrEncoder, A.BchP2PKHAddrEncoder, A.P2SHAddrEncoder, A.BchP2SHAddrEncoder, A.P2TRAddrEncoder, A.P2WPKHAddrEncoder, A.SolAddrDecoder, A.SolAddrEncoder, A.SubstrateEd25519AddrEncoder, A.SubstrateSr25519AddrEncoder, A.SubstrateSecp256k1AddrEncoder, A.DecodeAddressResult, A.FriendlyAddressFlags, A.TonAddrDecoder, A.TonAddrEncoder, A.TrxAddrDecoder, A.TrxAddrEncoder, A.XlmAddrTypes, A.XlmAddrEncoder, A.XRPXAddressDecodeResult, A.XrpAddrEncoder, A.XtzAddrPrefixes, A.XtzAddrEncoder, A.ZilAddrEncoder, A.Bip32PathError, A.Bip32ChainCode, A.Bip32FingerPrint, A.Bip32KeyIndex, A.Bip32KeyData, A.Bip32KeyNetVersions, A.Bip32KeyBase, A.Bip32Path, A.BipCoins, A.BipProposal, A.BipCoinConfig, A.CipProposal, A.CoinConf, A.CoinParams, A.CoinNames, A.EllipticCurveTypes, A.Ed25519Blake2bPublicKey, A.Ed25519PublicKey, A.Ed25519KholawPublicKey, A.Ed25519MoneroPublicKey, A.Nist256p1PublicKey, A.Secp256k1PublicKeyEcdsa, A.Sr25519PublicKey, A.MoneroCoinConf, A.MoneroCoins, A.MoneroProposal, A.MoneroKeyError, A.MoneroPublicKey, A.SubstrateCoinConf, A.SubstrateCoins, A.SubstratePropoosal, A.CborBase64Types, A.CborBaseUrlValue, A.CborBigFloatValue, A.CborBigIntValue, A.CborBoleanValue, A.CborBytesValue, A.CborDynamicBytesValue, A.CborTagValue, A._CborDate, A.CborDecimalFracValue, A.CborFloatValue, A.CborIntValue, A.CborSafeIntValue, A.CborListValue, A.CborMapValue, A.CborMimeValue, A.CborNullValue, A.CborUndefinedValue, A.CborRegxpValue, A.CborSetValue, A.CborString, A.CborUriValue, A.CborBytesTracker, A.FloatLength, A.FloatUtils, A.AES, A.AESLib, A.Curve, A.ECDSAPublicKey, A.EDDSAPublicKey, A.AbstractPoint, A.SquareRootError, A.JacobiError, A.ChaCha20Poly1305, A.CTR, A.BLAKE2b, A._Keccack, A._RIPEMD, A.SHA256, A.Poly1305, A.FortunaPRNG, A.SchnorrkelPublicKey, A.ArgumentException, A.MessageException, A._Hex, A.SS58ChecksumError, A.DynamicByteTracker, A.BigRational, A.Tuple, A.CanonicalizedMap, A.CosmosBaseAddress, A.BaseClient, A.BaseRequest, A.BaseResponse, A.ClientException, A.MediaType, A.PlatformInterface, A.ApiProviderException, A.WalletException, A.Equatable, A._LiveListenable_Object__LiveListenable, A._LiveListenable, A._APPImage_Object_CborSerializable, A.CborSerializable, A.JsonSerialization, A.SynchronizedLock, A.MethodResult, A.WebsocketWeb, A.BaseRepository, A._NetworkClient_Object_BaseRepository, A.SubstrateRepository, A._APIProvider_Object_Equatable, A.APIServiceTracker, A.HTTPService, A.BaseSocketService, A._ProviderAuth_Object_CborSerializable, A.ApiRequest, A.SocketRequestCompeleter, A._Chain_Object_CborSerializable, A.AccountBalance, A._CryptoAddress_Object_CborSerializable, A.BitcoinMultiSigBase, A._BitcoinMultiSigSignerDetais_Object_Equatable, A._BitcoinMultiSignatureAddress_Object_CborSerializable, A._TronMultiSigSignerDetais_Object_Equatable, A._TronMultiSignatureAddress_Object_Equatable, A._RippleMultiSigSignerDetais_Object_Equatable, A._RippleMultiSignatureAddress_Object_Equatable, A._Web3PermissionActivities_Object_CborSerializable, A._Web3AccountPermission_Object_CborSerializable, A._Web3Permission_Object_CborSerializable, A.DecimalBalance, A.IntegerBalance, A._BitcoinContact_Object_Equatable, A._CardanoContact_Object_Equatable, A._CosmosContact_Object_Equatable, A._EthereumContract_Object_Equatable, A._SolanaContact_Object_Equatable, A._SubstrateContact_Object_Equatable, A._TonContact_Object_Equatable, A._TronContact_Object_Equatable, A._RippleContact_Object_Equatable, A._WalletNetwork_Object_Equatable, A._NetworkCoinParams_Object_CborSerializable, A._CardanoAddrDetails_Object_Equatable, A._CosmosNativeCoin_Object_CborSerializable, A.CosmosNetworkTypes, A._TronAccountResourceInfo_Object_CborSerializable, A._TronAccountInfo_Object_CborSerializable, A._AccountPermission_Object_CborSerializable, A._PermissionKeys_Object_CborSerializable, A._FrozenSupply_Object_CborSerializable, A._FrozenV2_Object_CborSerializable, A._UnfrozenV2_Object_CborSerializable, A._AssetV2_Object_CborSerializable, A._FreeAssetNetUsageV2_Object_CborSerializable, A._TronAccountResource_Object_CborSerializable, A._RippleNFToken_Object_Equatable, A._CoingeckoCoin_Object_CborSerializable, A._Token_Object_CborSerializable, A._ETHERC20Token_Object_Equatable, A._RippleIssueToken_Object_Equatable, A._TonJettonToken_Object_Equatable, A._SolanaSPLToken_Object_Equatable, A._TronTRC10Token_Object_Equatable, A._TronTRC20Token_Object_Equatable, A._ChainsHandler_Object_CborSerializable, A.Web3RequestMethods, A._Web3MessageCore_Object_CborSerializable, A.Web3RequestException, A.Web3InternalException, A.Web3ArgrumentException, A.Web3ArgsException, A._Web3EncryptedMessage_Object_CborSerializable, A.CustomProposal, A._AddressDerivationIndex_Object_CborSerializable, A.NetworkType, A._ADAAddress_Object_ADASerialization, A._FixedBytes_Object_ADASerialization, A._StakeCredType_Object_ADASerialization, A.ADASerialization, A.ETHAddress, A.EVMRPC, A.SolAddress, A.AbiParameter, A.EncoderResult, A.EIP712Version, A.Eip712TypeDetails, A.Eip712TypedData, A.Eip712TypedDataV1, A.EIP712Legacy, A.AddressCoder, A.ArrayCoder, A.BooleanCoder, A.BytesCoder, A.FunctionCoder, A.NumbersCoder, A.StringCoder, A.TupleCoder, A.TronAddress, A.PermissionType, A.ResourceCode, A.Context, A.Style, A.ParsedPath, A.PathException, A.SubstrateAddress, A.SourceFile, A.SourceLocationMixin, A.SourceSpanMixin, A.Highlighter, A._Highlight, A._Line, A.SourceLocation, A.SourceSpanException, A.StringScanner, A.TonAddress, A.WalletVersion, A.TonApiType, A.EventStreamProvider, A._EventStreamSubscription, A.XRPAddress, A.XRPLAddressCodecException, A.MessageCompleterHandler, A.MessageCompleter, A.JsEthereumHandler, A.JSWalletHandler]);
    _inheritMany(J.Interceptor, [J.JSBool, J.JSNull, J.JavaScriptObject, J.JavaScriptBigInt, J.JavaScriptSymbol, J.JSNumber, J.JSString]);
    _inheritMany(J.JavaScriptObject, [J.LegacyJavaScriptObject, J.JSArray, A.NativeByteBuffer, A.NativeTypedData]);
    _inheritMany(J.LegacyJavaScriptObject, [J.PlainJavaScriptObject, J.UnknownJavaScriptObject, J.JavaScriptFunction]);
    _inherit(J.JSUnmodifiableArray, J.JSArray);
    _inheritMany(J.JSNumber, [J.JSInt, J.JSNumNotInt]);
    _inheritMany(A.Stream, [A.CastStream, A.StreamView, A._StreamImpl, A._EmptyStream, A._RawSecureSocket, A._EventStream]);
    _inheritMany(A.Iterable, [A._CastIterableBase, A.EfficientLengthIterable, A.MappedIterable, A.WhereIterable, A.ExpandIterable, A.TakeIterable, A.SkipIterable, A.WhereTypeIterable, A._KeysOrValues, A._AllMatchesIterable, A._StringAllMatchesIterable, A._SyncStarIterable, A.Runes]);
    _inheritMany(A._CastIterableBase, [A.CastIterable, A.__CastListBase__CastIterableBase_ListMixin]);
    _inherit(A._EfficientLengthCastIterable, A.CastIterable);
    _inherit(A._CastListBase, A.__CastListBase__CastIterableBase_ListMixin);
    _inheritMany(A.Closure, [A.Closure2Args, A.CastMap_entries_closure, A.Closure0Args, A.Instantiation, A.TearOffClosure, A.JsLinkedHashMap_values_closure, A.initHooks_closure, A.initHooks_closure1, A._AsyncRun__initializeScheduleImmediate_internalCallback, A._AsyncRun__initializeScheduleImmediate_closure, A._awaitOnObject_closure, A._Future__chainForeignFuture_closure, A._Future__propagateToListeners_handleWhenCompleteCallback_closure, A._Future_timeout_closure0, A.Stream_length_closure, A.Stream_first_closure0, A._RootZone_bindUnaryCallbackGuarded_closure, A._LinkedCustomHashMap_closure, A.MapBase_entries_closure, A._BigIntImpl_hashCode_finish, A.DateTime_parse_parseIntOrZero, A.DateTime_parse_parseMilliAndMicroseconds, A._createTables_setChars, A._createTables_setRange, A.SecureSocket_connect_closure, A.RawSecureSocket_connect_closure, A.jsify__convert, A.promiseToFuture_closure, A.promiseToFuture_closure0, A.dartify_convert, A.BitcoinAddressType_fromValue_closure, A.BasedUtxoNetwork_fromName_closure, A._BchBech32Utils_hrpExpand_closure, A.Bech32EncoderBase_encodeBech32_closure, A.Bech32DecoderBase_decodeBech32_closure, A.Bech32DecoderBase_decodeBech32_closure0, A.Bech32DecoderBase_decodeBech32_closure1, A.ADAAddressType_fromHeader_closure, A.ADAByronAddrTypes_ADAByronAddrTypes$fromCbor_closure, A.ADANetwork_fromTag_closure, A.ADANetwork_fromProtocolMagic_closure, A.EthAddrUtils__checksumEncode_closure, A.Bip32PathParser_parse_closure, A.Bip32PathParser__parseElem_closure, A.Bip44Coins_fromName_closure, A.Bip44Conf_akashNetwork_closure, A.Bip44Conf_algorand_closure, A.Bip44Conf_aptos_closure, A.Bip44Conf_avaxCChain_closure, A.Bip44Conf_avaxPChain_closure, A.Bip44Conf_avaxXChain_closure, A.Bip44Conf_axelar_closure, A.Bip44Conf_bandProtocol_closure, A.Bip44Conf_binanceChain_closure, A.Bip44Conf_binanceSmartChain_closure, A.Bip44Conf_bitcoinMainNet_closure, A.Bip44Conf_bitcoinTestNet_closure, A.Bip44Conf_bitcoinCashMainNet_closure, A.Bip44Conf_bitcoinCashTestNet_closure, A.Bip44Conf_bitcoinCashSlpMainNet_closure, A.Bip44Conf_bitcoinCashSlpTestNet_closure, A.Bip44Conf_bitcoinSvMainNet_closure, A.Bip44Conf_bitcoinSvTestNet_closure, A.Bip44Conf_cardanoByronIcarus_closure, A.Bip44Conf_cardanoByronLedger_closure, A.Bip44Conf_cardanoByronIcarusTestnet_closure, A.Bip44Conf_cardanoByronLedgerTestnet_closure, A.Bip44Conf_celo_closure, A.Bip44Conf_certik_closure, A.Bip44Conf_chihuahua_closure, A.Bip44Conf_cosmos_closure, A.Bip44Conf_cosmosTestnet_closure, A.Bip44Conf_cosmosNist256p1_closure, A.Bip44Conf_cosmosTestnetNist256p1_closure, A.Bip44Conf_dashMainNet_closure, A.Bip44Conf_dashTestNet_closure, A.Bip44Conf_dogecoinMainNet_closure, A.Bip44Conf_dogecoinTestNet_closure, A.Bip44Conf_pepeMainnet_closure, A.Bip44Conf_pepeTestnet_closure, A.Bip44Conf_ecashMainNet_closure, A.Bip44Conf_ecashTestNet_closure, A.Bip44Conf_elrond_closure, A.Bip44Conf_eos_closure, A.Bip44Conf_ergoMainNet_closure, A.Bip44Conf_ergoTestNet_closure, A.Bip44Conf_ethereum_closure, A.Bip44Conf_ethereumTestnet_closure, A.Bip44Conf_ethereumClassic_closure, A.Bip44Conf_fantomOpera_closure, A.Bip44Conf_filecoin_closure, A.Bip44Conf_harmonyOneMetamask_closure, A.Bip44Conf_harmonyOneEth_closure, A.Bip44Conf_harmonyOneAtom_closure, A.Bip44Conf_huobiChain_closure, A.Bip44Conf_icon_closure, A.Bip44Conf_injective_closure, A.Bip44Conf_irisNet_closure, A.Bip44Conf_kava_closure, A.Bip44Conf_kusamaEd25519Slip_closure, A.Bip44Conf_kusamaTestnetEd25519Slip_closure, A.Bip44Conf_litecoinMainNet_closure, A.Bip44Conf_litecoinTestNet_closure, A.Bip44Conf_moneroEd25519Slip_closure, A.Bip44Conf_moneroSecp256k1_closure, A.Bip44Conf_nano_closure, A.Bip44Conf_nearProtocol_closure, A.Bip44Conf_neo_closure, A.Bip44Conf_nineChroniclesGold_closure, A.Bip44Conf_okexChainEth_closure, A.Bip44Conf_okexChainAtom_closure, A.Bip44Conf_okexChainAtomOld_closure, A.Bip44Conf_ontology_closure, A.Bip44Conf_osmosis_closure, A.Bip44Conf_piNetwork_closure, A.Bip44Conf_polkadotEd25519Slip_closure, A.Bip44Conf_polkadotTestnetEd25519Slip_closure, A.Bip44Conf_polygon_closure, A.Bip44Conf_ripple_closure, A.Bip44Conf_rippleTestnet_closure, A.Bip44Conf_rippleEd25519_closure, A.Bip44Conf_rippleTestnetEd25519_closure, A.Bip44Conf_secretNetworkOld_closure, A.Bip44Conf_secretNetworkNew_closure, A.Bip44Conf_solana_closure, A.Bip44Conf_solanaTestnet_closure, A.Bip44Conf_stellar_closure, A.Bip44Conf_terra_closure, A.Bip44Conf_tezos_closure, A.Bip44Conf_theta_closure, A.Bip44Conf_tron_closure, A.Bip44Conf_tronTestnet_closure, A.Bip44Conf_vechain_closure, A.Bip44Conf_verge_closure, A.Bip44Conf_zcashMainNet_closure, A.Bip44Conf_zcashTestNet_closure, A.Bip44Conf_zilliqa_closure, A.Bip44Conf_tonMainnet_closure, A.Bip44Conf_tonTestnet_closure, A.Bip49Coins_fromName_closure, A.Bip49Conf_dashMainNet_closure, A.Bip49Conf_dashTestNet_closure, A.Bip49Conf_dogecoinMainNet_closure, A.Bip49Conf_dogecoinTestNet_closure, A.Bip49Conf_litecoinMainNet_closure, A.Bip49Conf_litecoinTestNet_closure, A.Bip49Conf_zcashMainNet_closure, A.Bip49Conf_zcashTestNet_closure, A.Bip49Conf_bitcoinMainNet_closure, A.Bip49Conf_bitcoinTestNet_closure, A.Bip49Conf_bitcoinSvMainNet_closure, A.Bip49Conf_bitcoinSvTestNet_closure, A.Bip49Conf_bitcoinCashMainNet_closure, A.Bip49Conf_bitcoinCashTestNet_closure, A.Bip49Conf_bitcoinCashSlpMainNet_closure, A.Bip49Conf_bitcoinCashSlpTestNet_closure, A.Bip49Conf_ecashMainNet_closure, A.Bip49Conf_ecashTestNet_closure, A.Bip49Conf_pepeMainnet_closure, A.Bip49Conf_pepeTestnet_closure, A.Bip84Coins_fromName_closure, A.Bip84Conf_bitcoinMainNet_closure, A.Bip84Conf_bitcoinTestNet_closure, A.Bip84Conf_litecoinMainNet_closure, A.Bip84Conf_litecoinTestNet_closure, A.Bip86Coins_fromName_closure, A.Bip86Conf_bitcoinMainNet_closure, A.Bip86Conf_bitcoinTestNet_closure, A.CoinProposal_fromName_closure, A.Cip1852Coins_fromName_closure, A.Cip1852Conf_cardanoIcarusMainNet_closure, A.Cip1852Conf_cardanoIcarusTestNet_closure, A.Cip1852Conf_cardanoLedgerMainNet_closure, A.Cip1852Conf_cardanoLedgerTestNet_closure, A.EllipticCurveTypes_fromName_closure, A.MoneroCoins_fromName_closure, A.SubstrateCoins_fromName_closure, A.SubstrateConf_acalaEd25519_closure, A.SubstrateConf_acalaSecp256k1_closure, A.SubstrateConf_acalaSr25519_closure, A.SubstrateConf_bifrostEd25519_closure, A.SubstrateConf_bifrostSecp256k1_closure, A.SubstrateConf_bifrostSr25519_closure, A.SubstrateConf_chainXEd25519_closure, A.SubstrateConf_chainXSecp256k1_closure, A.SubstrateConf_chainXSr25519_closure, A.SubstrateConf_edgewareEd25519_closure, A.SubstrateConf_edgewareSecp256k1_closure, A.SubstrateConf_edgewareSr25519_closure, A.SubstrateConf_genericEd25519_closure, A.SubstrateConf_genericSecp256k1_closure, A.SubstrateConf_genericSr25519_closure, A.SubstrateConf_karuraEd25519_closure, A.SubstrateConf_karuraSecp256k1_closure, A.SubstrateConf_karuraSr25519_closure, A.SubstrateConf_kusamaEd25519_closure, A.SubstrateConf_kusamaSecp256k1_closure, A.SubstrateConf_kusamaSr25519_closure, A.SubstrateConf_moonbeamEd25519_closure, A.SubstrateConf_moonbeamSecp256k1_closure, A.SubstrateConf_moonbeamSr25519_closure, A.SubstrateConf_moonriverEd25519_closure, A.SubstrateConf_moonriverSecp256k1_closure, A.SubstrateConf_moonriverSr25519_closure, A.SubstrateConf_phalaEd25519_closure, A.SubstrateConf_phalaSecp256k1_closure, A.SubstrateConf_phalaSr25519_closure, A.SubstrateConf_plasmEd25519_closure, A.SubstrateConf_plasmSecp256k1_closure, A.SubstrateConf_plasmSr25519_closure, A.SubstrateConf_polkadotEd25519_closure, A.SubstrateConf_polkadotSecp256k1_closure, A.SubstrateConf_polkadotSr25519_closure, A.SubstrateConf_soraEd25519_closure, A.SubstrateConf_soraSecp256k1_closure, A.SubstrateConf_soraSr25519_closure, A.SubstrateConf_stafiEd25519_closure, A.SubstrateConf_stafiSecp256k1_closure, A.SubstrateConf_stafiSr25519_closure, A.CborObject_CborObject$fromDynamic_closure, A.CborUtils__decodeUtf8String_closure, A.CborUtils__toStringObject_closure, A.CborUtils__toStringObject_closure0, A.CborUtils__decodeBytesString_closure, A.AESLib_initialize__rot24, A.QuickCrypto__generateRandom_closure, A.BytesUtils_toBytes_closure, A.UUID_generateUUIDv4_closure, A.UUID_generateUUIDv4_closure0, A.CanonicalizedMap_entries_closure, A.CanonicalizedMap_keys_closure, A.BaseRequest_closure0, A.BrowserClient_send_closure, A.BrowserClient_send_closure0, A.ByteStream_toBytes_closure, A.CaseInsensitiveMap$from_closure, A.MediaType_toString__closure, A.expectQuotedString_closure, A.JSWebSocket_constructor_create_closure, A.WebEventStream_stream_closure, A.ContentType_fromValue_closure, A.ExtractCborMap_toMap_closure, A.SynchronizedLock_synchronized_closure, A.MethodUtils_call_closure, A.StrUtils_toSnakeCase_closure, A.WebsocketWeb$__closure, A.WebsocketWeb$__closure0, A.WebsocketWeb$__closure1, A.WebsocketWeb_connect_closure, A.ProvidersConst_getDefaultService_closure, A.ProvidersConst_getDefaultService_closure0, A.BitcoinExplorerProviderType_fromName_closure, A.BitcoinExplorerAPIProvider_BitcoinExplorerAPIProvider$fromCborBytesOrObject_closure, A.ElectrumAPIProvider_ElectrumAPIProvider$fromCborBytesOrObject_closure, A.CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject_closure, A.CardanoAPIProvider_CardanoAPIProvider$fromCborBytesOrObject_closure0, A.CosmosAPIProvider_CosmosAPIProvider$fromCborBytesOrObject_closure, A.EthereumAPIProvider_EthereumAPIProvider$fromCborBytesOrObject_closure, A.RippleAPIProvider_RippleAPIProvider$fromCborBytesOrObject_closure, A.SolanaAPIProvider_SolanaAPIProvider$fromCborBytesOrObject_closure, A.SubstrateAPIProvider_SubstrateAPIProvider$fromCborBytesOrObject_closure, A.TonAPIProvider_TonAPIProvider$fromCborBytesOrObject_closure, A.TronAPIProvider_TronAPIProvider$fromCborBytesOrObject_closure, A.APIServiceTracker__checkStatus_closure, A.SSLService_connect___closure, A.WebSocketService__onClose_closure, A.ProviderAuthType_fromName_closure, A.ServiceProtocol_fromID_closure, A.ADAChain_ADAChain$deserialize_closure0, A.ADAChain_ADAChain$deserialize_closure1, A.BitcoinChain_BitcoinChain$deserialize_closure0, A.BitcoinChain_BitcoinChain$deserialize_closure1, A.CosmosChain_CosmosChain$deserialize_closure0, A.CosmosChain_CosmosChain$deserialize_closure1, A.EthereumChain_EthereumChain$deserialize_closure0, A.EthereumChain_EthereumChain$deserialize_closure1, A.SolanaChain_SolanaChain$deserialize_closure0, A.SolanaChain_SolanaChain$deserialize_closure1, A.SubstrateChain_SubstrateChain$deserialize_closure0, A.SubstrateChain_SubstrateChain$deserialize_closure1, A.TonChain_TonChain$deserialize_closure0, A.TonChain_TonChain$deserialize_closure1, A.TronChain_TronChain$deserialize_closure0, A.TronChain_TronChain$deserialize_closure1, A.RippleChain_RippleChain$deserialize_closure0, A.RippleChain_RippleChain$deserialize_closure1, A.BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject_closure, A.BitcoinMultiSignatureAddress_BitcoinMultiSignatureAddress$fromCborBytesOrObject_closure0, A.BitcoinMultiSignatureAddress_toP2shAddress_closure, A.ITonAddress_ITonAddress$fromCborBytesOrObject_closure, A.TronMultiSignatureAddress_TronMultiSignatureAddress$fromCborBytesOrObject_closure, A.ITronAddress_ITronAddress$fromCborBytesOrObject_closure, A.ITronAddress_ITronAddress$fromCborBytesOrObject_closure0, A.ITronMultisigAddress_ITronMultisigAddress$fromCborBytesOrObject_closure, A.ITronMultisigAddress_ITronMultisigAddress$fromCborBytesOrObject_closure0, A.RippleMultiSignatureAddress_RippleMultiSignatureAddress$fromCborBytesOrObject_closure, A.IXRPAddress_IXRPAddress$fromCborBytesOrObject_closure, A.IXRPAddress_IXRPAddress$fromCborBytesOrObject_closure0, A.Web3Permission_Web3Permission$deserialize_closure, A.Web3Permission_Web3Permission$deserialize_closure0, A.Web3Permission_Web3Permission$deserialize_closure1, A.WalletNetwork_getProvider_closure, A.WalletNetwork_getProvider__closure, A.BitcoinParams_BitcoinParams$fromCborBytesOrObject_closure, A.CardanoNetworkParams_CardanoNetworkParams$fromCborBytesOrObject_closure, A.CosmosNetworkParams_CosmosNetworkParams$fromCborBytesOrObject_closure, A.CosmosNetworkParams_CosmosNetworkParams$fromCborBytesOrObject_closure0, A.EthereumNetworkParams_EthereumNetworkParams$fromCborBytesOrObject_closure, A.RippleNetworkParams_RippleNetworkParams$fromCborBytesOrObject_closure, A.SolanaNetworkParams_SolanaNetworkParams$fromCborBytesOrObject_closure, A.SubstrateNetworkParams_SubstrateNetworkParams$fromCborBytesOrObject_closure, A.TonNetworkParams_TonNetworkParams$fromCborBytesOrObject_closure, A.TronNetworkParams_TronNetworkParams$fromCborBytesOrObject_closure, A.TronNetworkParams_TronNetworkParams$fromCborBytesOrObject_closure0, A.CosmosNetworkTypes_CosmosNetworkTypes$fromValue_closure, A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure, A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure0, A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure1, A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure2, A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure3, A.TronAccountInfo_TronAccountInfo$fromCborBytesOrObject_closure4, A.AccountPermission_AccountPermission$fromCborBytesOrObject_closure, A.Token_Token$fromCborBytesOrObject_closure, A.ChainsHandler_ChainsHandler$deserialize_closure, A.Web3EthereumRequestMethods_fromId_closure, A.Web3EthereumRequestMethods_fromName_closure, A.Web3EthreumPersonalSign_Web3EthreumPersonalSign$fromJson_closure, A.Web3EthreumTypdedData_Web3EthreumTypdedData$fromJson_closure, A.Web3MessageTypes_fromTag_closure, A.CustomCoins_fromName_closure, A.CustomCurrencyConf_byronLegacy_closure, A.CustomCurrencyConf_byronLegacyTestnet_closure, A.AddressDerivationType_fromTag_closure, A.Bip32AddressIndex__toPath_closure, A.Bip32AddressIndex__toPath_closure0, A.SeedTypes_fromName_closure, A.NetworkType_fromTag_closure, A.AbiParameter_isDynamic_closure, A.EIP712Version_fromVersion_closure, A.EIP712Version_fromVersion__closure, A.Eip712TypedData_Eip712TypedData$fromJson_closure, A.Eip712TypedData_toJson__closure, A.EIP712Legacy_EIP712Legacy$fromJson_closure, A.EIP712Legacy_encode_closure, A.EIP712Legacy_encode_closure0, A.EIP712Legacy_encode_closure1, A.EIP712Legacy_toJson_closure, A._EIP712Utils_ensureCorrectValues_closure, A._EIP712Utils_eip712TypedDataV1ValueToJson_closure, A._EIP712Utils_getDependencies__closure, A._EIP712Utils_encodeValue_closure, A._EIP712Utils_encodeValue_closure0, A._EIP712Utils_encodeValue_closure1, A._EIP712Utils_abiEncode_closure, A._EIP712Utils_legacyV1encode_closure, A._EIP712Utils_getMethodSigature_closure, A._EIP712Utils_getMethodSigature__closure, A.ArrayCoder_abiEncode_closure, A.ArrayCoder_abiEncode_closure0, A.ArrayCoder_legacyEip712Encode_closure, A.ArrayCoder_legacyEip712Encode_closure0, A.TupleCoder_abiEncode_closure, A.TupleCoder_legacyEip712Encode_closure, A._ABIUtils_encodeDynamicParams_closure, A._ABIUtils_encodeDynamicParams_closure0, A._ABIUtils_encodeDynamicParams_closure1, A._ABIUtils_encodeDynamicParams_closure2, A.PermissionType_fromName_closure, A.ResourceCode_fromName_closure0, A.Context_joinAll_closure, A.Context_split_closure, A._validateArgList_closure, A.Highlighter$__closure, A.Highlighter$___closure, A.Highlighter$__closure0, A.Highlighter__collateLines_closure, A.Highlighter__collateLines_closure1, A.Highlighter__collateLines__closure, A.Highlighter_highlight_closure, A.WalletVersion_WalletVersion$fromValue_closure, A.TonDartPluginException_toString_closure, A.TonDartPluginException_toString_closure0, A.TonApiType_TonApiType$fromValue_closure, A._EventStreamSubscription_closure, A._EventStreamSubscription_onData_closure, A.FutureTest_get_toPromise__closure, A.FutureTest_get_toPromise__closure1, A.main_onActivation]);
    _inheritMany(A.Closure2Args, [A._CastListBase_sort_closure, A.CastMap_forEach_closure, A.Primitives_functionNoSuchMethod_closure, A.JsLinkedHashMap_addAll_closure, A.initHooks_closure0, A._awaitOnObject_closure0, A._wrapJsFunctionForAsync_closure, A._Future__chainForeignFuture_closure0, A._Future_timeout_closure1, A.LinkedHashMap_LinkedHashMap$from_closure, A.MapBase_mapToString_closure, A._JsonStringifier_writeMap_closure, A._BigIntImpl_hashCode_combine, A.NoSuchMethodError_toString_closure, A.Uri__parseIPv4Address_error, A.Uri_parseIPv6Address_error, A.Uri_parseIPv6Address_parseHex, A._createTables_build, A.AESLib_initialize_mul, A.CanonicalizedMap_addAll_closure, A.CanonicalizedMap_forEach_closure, A.BaseRequest_closure, A.MediaType_toString_closure, A.FixedBytes_hashCode_closure, A.Eip712TypedData_toJson_closure, A._EIP712Utils_getDependencies_closure, A.Highlighter__collateLines_closure0, A.FutureTest_get_toPromise_closure, A.FutureTest_get_toPromise__closure0]);
    _inherit(A.CastList, A._CastListBase);
    _inheritMany(A.MapBase, [A.CastMap, A.UnmodifiableMapBase, A.JsLinkedHashMap, A._HashMap, A._JsonMap]);
    _inheritMany(A.Error, [A.LateError, A.TypeError, A.JsNoSuchMethodError, A.UnknownJsTypeError, A._CyclicInitializationError, A.RuntimeError, A.AssertionError, A._Error, A.JsonUnsupportedObjectError, A.ArgumentError, A.NoSuchMethodError, A.UnsupportedError, A.UnimplementedError, A.StateError, A.ConcurrentModificationError]);
    _inherit(A.UnmodifiableListBase, A.ListBase);
    _inherit(A.CodeUnits, A.UnmodifiableListBase);
    _inheritMany(A.Closure0Args, [A.nullFuture_closure, A._AsyncRun__scheduleImmediateJsOverride_internalCallback, A._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback, A._TimerImpl_internalCallback, A.Future_Future$delayed_closure, A._Future__addListener_closure, A._Future__prependListeners_closure, A._Future__chainForeignFuture_closure1, A._Future__chainCoreFutureAsync_closure, A._Future__asyncCompleteWithValue_closure, A._Future__asyncCompleteError_closure, A._Future__propagateToListeners_handleWhenCompleteCallback, A._Future__propagateToListeners_handleValueCallback, A._Future__propagateToListeners_handleError, A._Future_timeout_closure, A.Stream_length_closure0, A.Stream_first_closure, A._StreamController__subscribe_closure, A._StreamController__recordCancel_complete, A._BufferingStreamSubscription__sendError_sendError, A._BufferingStreamSubscription__sendDone_sendDone, A._PendingEvents_schedule_closure, A._cancelAndValue_closure, A._rootHandleError_closure, A._RootZone_bindCallbackGuarded_closure, A._Utf8Decoder__decoder_closure, A._Utf8Decoder__decoderNonfatal_closure, A._RawSecureSocket__secureHandshakeCompleteHandler_closure, A.BitcoinAddressType_fromValue_closure0, A.ADAAddressType_fromHeader_closure0, A.ADANetwork_fromTag_closure0, A.ADANetwork_fromProtocolMagic_closure0, A.CoinProposal_fromName_closure0, A.MediaType_MediaType$parse_closure, A.WebEventStream_stream_closure0, A.ContentType_fromValue_closure0, A.SynchronizedLock_synchronized_complete, A.ProvidersConst_getDefaultService_closure1, A.BitcoinExplorerProviderType_fromName_closure0, A.HTTPService_providerPOST_closure, A.SSLService_connect_closure, A.SSLService_connect__closure, A.SSLService_post_closure, A.TCPService_connect_closure, A.TCPService_connect__closure, A.TCPService_post_closure, A.WebSocketService_connect_closure, A.WebSocketService_connect__closure, A.WebSocketService_addMessage_closure, A.ProviderAuthType_fromName_closure0, A.Chain_Chain$fromCborBytesOrObject_closure, A.Chain_Chain$fromCborBytesOrObject_closure0, A.Chain_Chain$fromCborBytesOrObject_closure1, A.Chain_Chain$fromCborBytesOrObject_closure2, A.ADAChain_ADAChain$deserialize_closure, A.BitcoinChain_BitcoinChain$deserialize_closure, A.CosmosChain_CosmosChain$deserialize_closure, A.EthereumChain_EthereumChain$deserialize_closure, A.SolanaChain_SolanaChain$deserialize_closure, A.SubstrateChain_SubstrateChain$deserialize_closure, A.TonChain_TonChain$deserialize_closure, A.TronChain_TronChain$deserialize_closure, A.RippleChain_RippleChain$deserialize_closure, A.WalletNetwork_getProvider_closure0, A.CosmosNetworkTypes_CosmosNetworkTypes$fromValue_closure0, A.Web3EthereumRequestMethods_fromId_closure0, A.Web3EthereumRequestMethods_fromName_closure0, A.Web3EthereumValidator_parseTypedData_closure, A.Web3MessageTypes_fromTag_closure0, A.Web3ValidatorUtils_parseAddress_closure, A.AddressDerivationType_fromTag_closure0, A.SeedTypes_fromName_closure0, A.NetworkType_fromTag_closure0, A.EIP712Version_fromVersion_closure0, A.PermissionType_fromName_closure0, A.ResourceCode_fromName_closure, A.Highlighter_closure, A.Highlighter__writeFileStart_closure, A.Highlighter__writeMultilineHighlights_closure, A.Highlighter__writeMultilineHighlights_closure0, A.Highlighter__writeMultilineHighlights_closure1, A.Highlighter__writeMultilineHighlights_closure2, A.Highlighter__writeMultilineHighlights__closure, A.Highlighter__writeMultilineHighlights__closure0, A.Highlighter__writeHighlightedText_closure, A.Highlighter__writeIndicator_closure, A.Highlighter__writeIndicator_closure0, A.Highlighter__writeIndicator_closure1, A.Highlighter__writeSidebar_closure, A._Highlight_closure, A.WalletVersion_WalletVersion$fromValue_closure0, A.TonApiType_TonApiType$fromValue_closure0, A.EthereumRequestParams_toStringListParam_closure]);
    _inheritMany(A.EfficientLengthIterable, [A.ListIterable, A.EmptyIterable, A.LinkedHashMapKeyIterable, A._HashMapKeyIterable]);
    _inheritMany(A.ListIterable, [A.SubListIterable, A.MappedListIterable, A._ListIndicesIterable, A.ReversedListIterable, A._JsonMapKeyIterable]);
    _inherit(A.EfficientLengthMappedIterable, A.MappedIterable);
    _inherit(A.EfficientLengthTakeIterable, A.TakeIterable);
    _inherit(A.EfficientLengthSkipIterable, A.SkipIterable);
    _inherit(A.ListMapView, A.UnmodifiableMapBase);
    _inherit(A._UnmodifiableMapView_MapView__UnmodifiableMapMixin, A.MapView);
    _inherit(A.UnmodifiableMapView, A._UnmodifiableMapView_MapView__UnmodifiableMapMixin);
    _inherit(A.ConstantMapView, A.UnmodifiableMapView);
    _inheritMany(A.ConstantMap, [A.ConstantStringMap, A.GeneralConstantMap]);
    _inherit(A.Instantiation1, A.Instantiation);
    _inherit(A.NullError, A.TypeError);
    _inheritMany(A.TearOffClosure, [A.StaticClosure, A.BoundClosure]);
    _inherit(A._AssertionError, A.AssertionError);
    _inheritMany(A.JsLinkedHashMap, [A.JsIdentityLinkedHashMap, A.JsConstantLinkedHashMap, A._LinkedCustomHashMap]);
    _inheritMany(A.NativeTypedData, [A.NativeByteData, A.NativeTypedArray]);
    _inheritMany(A.NativeTypedArray, [A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin]);
    _inherit(A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin);
    _inherit(A.NativeTypedArrayOfDouble, A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inherit(A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin);
    _inherit(A.NativeTypedArrayOfInt, A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inheritMany(A.NativeTypedArrayOfDouble, [A.NativeFloat32List, A.NativeFloat64List]);
    _inheritMany(A.NativeTypedArrayOfInt, [A.NativeInt16List, A.NativeInt32List, A.NativeInt8List, A.NativeUint16List, A.NativeUint32List, A.NativeUint8ClampedList, A.NativeUint8List]);
    _inherit(A._TypeError, A._Error);
    _inheritMany(A._Completer, [A._AsyncCompleter, A._SyncCompleter]);
    _inheritMany(A._StreamController, [A._AsyncStreamController, A._SyncStreamController]);
    _inherit(A._ControllerStream, A._StreamImpl);
    _inherit(A._ControllerSubscription, A._BufferingStreamSubscription);
    _inheritMany(A._DelayedEvent, [A._DelayedData, A._DelayedError]);
    _inherit(A._RootZone, A._Zone);
    _inherit(A._IdentityHashMap, A._HashMap);
    _inherit(A._SetBase, A.SetBase);
    _inherit(A._LinkedHashSet, A._SetBase);
    _inheritMany(A.Codec, [A.Encoding, A.Base64Codec, A.JsonCodec]);
    _inheritMany(A.Encoding, [A.AsciiCodec, A.Latin1Codec, A.Utf8Codec]);
    _inheritMany(A.Converter, [A._UnicodeSubsetEncoder, A._UnicodeSubsetDecoder, A.Base64Encoder, A.Base64Decoder, A.JsonEncoder, A.JsonDecoder, A.Utf8Encoder, A.Utf8Decoder]);
    _inheritMany(A._UnicodeSubsetEncoder, [A.AsciiEncoder, A.Latin1Encoder]);
    _inheritMany(A._UnicodeSubsetDecoder, [A.AsciiDecoder, A.Latin1Decoder]);
    _inherit(A._ByteCallbackSink, A.ByteConversionSink);
    _inherit(A.JsonCyclicError, A.JsonUnsupportedObjectError);
    _inherit(A._JsonStringStringifier, A._JsonStringifier);
    _inheritMany(A.ArgumentError, [A.RangeError, A.IndexError]);
    _inherit(A._DataUri, A._Uri);
    _inherit(A.HandshakeException, A.TlsException);
    _inheritMany(A.LegacyAddress, [A.P2shAddress, A.P2pkhAddress, A.P2pkAddress]);
    _inheritMany(A.BitcoinNetworkAddress, [A.BitcoinAddress, A.DogeAddress, A.PepeAddress, A.LitecoinAddress, A.BitcoinCashAddress, A.DashAddress]);
    _inheritMany(A.SegwitAddress, [A.P2wpkhAddress, A.P2trAddress, A.P2wshAddress]);
    _inheritMany(A.BlockchainUtilsException, [A.BitcoinBasePluginException, A.SolidityAbiException, A.TonDartPluginException]);
    _inheritMany(A._Enum, [A.APIType, A.Base58Alphabets, A.Bech32Encodings, A.EncodeType, A.StringEncoding, A.AppPlatform, A.ContentType, A.NodeClientStatus, A.BitcoinExplorerProviderType, A.ProviderAuthType, A.ServiceProtocol, A.SocketStatus, A.APIServiceStatus, A.Web3ArgsTypes, A.Web3MessageTypes, A.AddressDerivationType, A.SeedTypes]);
    _inherit(A.XmrAddrEncoder, A.BlockchainAddressEncoder);
    _inherit(A.Bip32PublicKey, A.Bip32KeyBase);
    _inheritMany(A.BipCoins, [A.Bip44Coins, A.Bip49Coins, A.Bip84Coins, A.Bip86Coins, A.Cip1852Coins, A.CustomCoins]);
    _inheritMany(A.BipCoinConfig, [A.BipBitcoinCashConf, A.BipLitecoinConf]);
    _inheritMany(A._CborDate, [A.CborStringDateValue, A.CborEpochFloatValue, A.CborEpochIntValue]);
    _inheritMany(A.CborString, [A.CborStringValue, A.CborIndefiniteStringValue]);
    _inheritMany(A.Curve, [A.CurveFp, A.CurveED]);
    _inheritMany(A.AbstractPoint, [A.ProjectiveECCPoint, A.EDPoint]);
    _inherit(A.RistrettoPoint, A.EDPoint);
    _inheritMany(A._Keccack, [A.Keccack, A.SHA3, A.SHAKE]);
    _inherit(A.SHA3256, A.SHA3);
    _inherit(A.SHAKE256, A.SHAKE);
    _inherit(A.RIPEMD160, A._RIPEMD);
    _inherit(A.BrowserClient, A.BaseClient);
    _inherit(A.ByteStream, A.StreamView);
    _inherit(A.Request, A.BaseRequest);
    _inheritMany(A.BaseResponse, [A.Response, A.StreamedResponse]);
    _inherit(A.StreamedResponseV2, A.StreamedResponse);
    _inherit(A.CaseInsensitiveMap, A.CanonicalizedMap);
    _inherit(A.MrtPlatformInterface, A.PlatformInterface);
    _inherit(A.MrtNativeWeb, A.MrtPlatformInterface);
    _inherit(A.LiveListenable, A._LiveListenable_Object__LiveListenable);
    _inherit(A._Live, A.LiveListenable);
    _inherit(A.Live, A._Live);
    _inherit(A.APPImage, A._APPImage_Object_CborSerializable);
    _inherit(A.NetworkClient, A._NetworkClient_Object_BaseRepository);
    _inheritMany(A.NetworkClient, [A.BitcoinClient, A.CardanoClient, A.CosmosClient, A.EthereumClient, A.RippleClient, A.SolanaClient, A._SubstrateClient_NetworkClient_SubstrateRepository, A.TonClient, A.TronClient]);
    _inheritMany(A.BitcoinClient, [A.BitcoinElectrumClient, A.BitcoinExplorerApiProvider]);
    _inherit(A.SubstrateClient, A._SubstrateClient_NetworkClient_SubstrateRepository);
    _inherit(A._APIProvider_Object_Equatable_CborSerializable, A._APIProvider_Object_Equatable);
    _inherit(A.APIProvider, A._APIProvider_Object_Equatable_CborSerializable);
    _inheritMany(A.APIProvider, [A.BaseBitcoinAPIProvider, A.CardanoAPIProvider, A.CosmosAPIProvider, A.EthereumAPIProvider, A.RippleAPIProvider, A.SolanaAPIProvider, A.SubstrateAPIProvider, A.TonAPIProvider, A.TronAPIProvider]);
    _inheritMany(A.BaseBitcoinAPIProvider, [A.BitcoinExplorerAPIProvider, A.ElectrumAPIProvider]);
    _inheritMany(A.BaseSocketService, [A.SSLService, A.TCPService, A.WebSocketService]);
    _inherit(A.ProviderAuth, A._ProviderAuth_Object_CborSerializable);
    _inherit(A.ElectrumSSLSocketService, A.SSLService);
    _inherit(A.ElectrumSocketService, A.TCPService);
    _inheritMany(A.WebSocketService, [A.ElectrumWebsocketService, A.RippleWebsocketService]);
    _inherit(A.RippleHTTPService, A.HTTPService);
    _inherit(A.Chain, A._Chain_Object_CborSerializable);
    _inheritMany(A.Chain, [A.ADAChain, A.BitcoinChain, A.CosmosChain, A.EthereumChain, A.SolanaChain, A.SubstrateChain, A.TonChain, A.TronChain, A.RippleChain]);
    _inherit(A.CryptoAddress, A._CryptoAddress_Object_CborSerializable);
    _inherit(A.ChainAccount, A.CryptoAddress);
    _inheritMany(A.ChainAccount, [A._IBitcoinAddress_ChainAccount_Equatable, A._ICardanoAddress_ChainAccount_Equatable, A._ICosmosAddress_ChainAccount_Equatable, A._IEthAddress_ChainAccount_Equatable, A._ISolanaAddress_ChainAccount_Equatable, A._ISubstrateAddress_ChainAccount_Equatable, A._ITonAddress_ChainAccount_Equatable, A._ITronAddress_ChainAccount_Equatable, A._IXRPAddress_ChainAccount_Equatable]);
    _inherit(A.IBitcoinAddress, A._IBitcoinAddress_ChainAccount_Equatable);
    _inheritMany(A.IBitcoinAddress, [A.IBitcoinCashAddress, A._IBitcoinMultiSigAddress_IBitcoinAddress_BitcoinMultiSigBase]);
    _inherit(A._IBitcoinCashMultiSigAddress_IBitcoinCashAddress_BitcoinMultiSigBase, A.IBitcoinCashAddress);
    _inherit(A.IBitcoinCashMultiSigAddress, A._IBitcoinCashMultiSigAddress_IBitcoinCashAddress_BitcoinMultiSigBase);
    _inherit(A.IBitcoinMultiSigAddress, A._IBitcoinMultiSigAddress_IBitcoinAddress_BitcoinMultiSigBase);
    _inherit(A._BitcoinMultiSigSignerDetais_Object_Equatable_CborSerializable, A._BitcoinMultiSigSignerDetais_Object_Equatable);
    _inherit(A.BitcoinMultiSigSignerDetais, A._BitcoinMultiSigSignerDetais_Object_Equatable_CborSerializable);
    _inherit(A.BitcoinMultiSignatureAddress, A._BitcoinMultiSignatureAddress_Object_CborSerializable);
    _inherit(A.ICardanoAddress, A._ICardanoAddress_ChainAccount_Equatable);
    _inherit(A.ICosmosAddress, A._ICosmosAddress_ChainAccount_Equatable);
    _inherit(A.IEthAddress, A._IEthAddress_ChainAccount_Equatable);
    _inherit(A.ISolanaAddress, A._ISolanaAddress_ChainAccount_Equatable);
    _inherit(A.ISubstrateAddress, A._ISubstrateAddress_ChainAccount_Equatable);
    _inherit(A.ITonAddress, A._ITonAddress_ChainAccount_Equatable);
    _inherit(A._TronMultiSigSignerDetais_Object_Equatable_CborSerializable, A._TronMultiSigSignerDetais_Object_Equatable);
    _inherit(A.TronMultiSigSignerDetais, A._TronMultiSigSignerDetais_Object_Equatable_CborSerializable);
    _inherit(A._TronMultiSignatureAddress_Object_Equatable_CborSerializable, A._TronMultiSignatureAddress_Object_Equatable);
    _inherit(A.TronMultiSignatureAddress, A._TronMultiSignatureAddress_Object_Equatable_CborSerializable);
    _inherit(A.ITronAddress, A._ITronAddress_ChainAccount_Equatable);
    _inherit(A.ITronMultisigAddress, A.ITronAddress);
    _inherit(A._RippleMultiSigSignerDetais_Object_Equatable_CborSerializable, A._RippleMultiSigSignerDetais_Object_Equatable);
    _inherit(A.RippleMultiSigSignerDetais, A._RippleMultiSigSignerDetais_Object_Equatable_CborSerializable);
    _inherit(A._RippleMultiSignatureAddress_Object_Equatable_CborSerializable, A._RippleMultiSignatureAddress_Object_Equatable);
    _inherit(A.RippleMultiSignatureAddress, A._RippleMultiSignatureAddress_Object_Equatable_CborSerializable);
    _inherit(A.IXRPAddress, A._IXRPAddress_ChainAccount_Equatable);
    _inherit(A.IXRPMultisigAddress, A.IXRPAddress);
    _inherit(A.Web3PermissionActivities, A._Web3PermissionActivities_Object_CborSerializable);
    _inherit(A._Web3AccountPermission_Object_CborSerializable_Equatable, A._Web3AccountPermission_Object_CborSerializable);
    _inherit(A.Web3AccountPermission, A._Web3AccountPermission_Object_CborSerializable_Equatable);
    _inherit(A.Web3Permission, A._Web3Permission_Object_CborSerializable);
    _inherit(A.Web3EthereumPermission, A.Web3AccountPermission);
    _inherit(A.BitcoinContact, A._BitcoinContact_Object_Equatable);
    _inherit(A.CardanoContact, A._CardanoContact_Object_Equatable);
    _inherit(A.CosmosContact, A._CosmosContact_Object_Equatable);
    _inherit(A.EthereumContract, A._EthereumContract_Object_Equatable);
    _inherit(A.SolanaContact, A._SolanaContact_Object_Equatable);
    _inherit(A.SubstrateContact, A._SubstrateContact_Object_Equatable);
    _inherit(A.TonContact, A._TonContact_Object_Equatable);
    _inherit(A.TronContact, A._TronContact_Object_Equatable);
    _inherit(A.RippleContact, A._RippleContact_Object_Equatable);
    _inherit(A._WalletNetwork_Object_Equatable_CborSerializable, A._WalletNetwork_Object_Equatable);
    _inherit(A.WalletNetwork, A._WalletNetwork_Object_Equatable_CborSerializable);
    _inheritMany(A.WalletNetwork, [A.WalletBitcoinNetwork, A.WalletXRPNetwork, A.WalletEthereumNetwork, A.WalletTronNetwork, A.WalletSolanaNetwork, A.WalletCardanoNetwork, A.WalletCosmosNetwork, A.WalletTonNetwork, A.WalletPolkadotNetwork]);
    _inherit(A.WalletBitcoinCashNetwork, A.WalletBitcoinNetwork);
    _inherit(A.WalletKusamaNetwork, A.WalletPolkadotNetwork);
    _inherit(A.NetworkCoinParams, A._NetworkCoinParams_Object_CborSerializable);
    _inheritMany(A.NetworkCoinParams, [A.BitcoinParams, A.CardanoNetworkParams, A.CosmosNetworkParams, A.EthereumNetworkParams, A.RippleNetworkParams, A.SolanaNetworkParams, A.SubstrateNetworkParams, A.TonNetworkParams, A.TronNetworkParams]);
    _inherit(A._CardanoAddrDetails_Object_Equatable_CborSerializable, A._CardanoAddrDetails_Object_Equatable);
    _inherit(A.CardanoAddrDetails, A._CardanoAddrDetails_Object_Equatable_CborSerializable);
    _inherit(A.CosmosNativeCoin, A._CosmosNativeCoin_Object_CborSerializable);
    _inherit(A.TronAccountResourceInfo, A._TronAccountResourceInfo_Object_CborSerializable);
    _inherit(A.TronAccountInfo, A._TronAccountInfo_Object_CborSerializable);
    _inherit(A.AccountPermission, A._AccountPermission_Object_CborSerializable);
    _inherit(A._PermissionKeys_Object_CborSerializable_Equatable, A._PermissionKeys_Object_CborSerializable);
    _inherit(A.PermissionKeys, A._PermissionKeys_Object_CborSerializable_Equatable);
    _inherit(A.FrozenSupply, A._FrozenSupply_Object_CborSerializable);
    _inherit(A.FrozenV2, A._FrozenV2_Object_CborSerializable);
    _inherit(A.UnfrozenV2, A._UnfrozenV2_Object_CborSerializable);
    _inherit(A.AssetV2, A._AssetV2_Object_CborSerializable);
    _inherit(A.FreeAssetNetUsageV2, A._FreeAssetNetUsageV2_Object_CborSerializable);
    _inherit(A.TronAccountResource, A._TronAccountResource_Object_CborSerializable);
    _inherit(A.RippleNFToken, A._RippleNFToken_Object_Equatable);
    _inherit(A._CoingeckoCoin_Object_CborSerializable_JsonSerialization, A._CoingeckoCoin_Object_CborSerializable);
    _inherit(A.CoingeckoCoin, A._CoingeckoCoin_Object_CborSerializable_JsonSerialization);
    _inherit(A._Token_Object_CborSerializable_Equatable, A._Token_Object_CborSerializable);
    _inherit(A.Token, A._Token_Object_CborSerializable_Equatable);
    _inherit(A.ETHERC20Token, A._ETHERC20Token_Object_Equatable);
    _inherit(A.RippleIssueToken, A._RippleIssueToken_Object_Equatable);
    _inherit(A.TonJettonToken, A._TonJettonToken_Object_Equatable);
    _inherit(A.SolanaSPLToken, A._SolanaSPLToken_Object_Equatable);
    _inherit(A.TronTRC10Token, A._TronTRC10Token_Object_Equatable);
    _inherit(A.TronTRC20Token, A._TronTRC20Token_Object_Equatable);
    _inherit(A.ChainsHandler, A._ChainsHandler_Object_CborSerializable);
    _inherit(A.Web3MessageCore, A._Web3MessageCore_Object_CborSerializable);
    _inheritMany(A.Web3MessageCore, [A._Web3RequestParams_Web3MessageCore_JsonSerialization, A.Web3ChainMessage, A.Web3ResponseMessage, A.Web3ExceptionMessage]);
    _inherit(A.Web3RequestParams, A._Web3RequestParams_Web3MessageCore_JsonSerialization);
    _inherit(A.Web3EthereumRequestException, A.Web3RequestException);
    _inherit(A.Web3EthereumRequestMethods, A.Web3RequestMethods);
    _inherit(A.Web3EthereumRequestParam, A.Web3RequestParams);
    _inheritMany(A.Web3EthereumRequestParam, [A.Web3EthereumPermissionRequestParam, A.Web3EthreumAddChain, A.Web3EthreumPersonalSign, A.Web3EthreumSendTransaction, A.Web3EthreumTypdedData, A.Web3EthreumSwitchChain]);
    _inherit(A.Web3EthreumRequestAccounts, A.Web3EthereumPermissionRequestParam);
    _inherit(A.Web3EncryptedMessage, A._Web3EncryptedMessage_Object_CborSerializable);
    _inherit(A._AddressDerivationIndex_Object_CborSerializable_Equatable, A._AddressDerivationIndex_Object_CborSerializable);
    _inherit(A.AddressDerivationIndex, A._AddressDerivationIndex_Object_CborSerializable_Equatable);
    _inheritMany(A.AddressDerivationIndex, [A.Bip32AddressIndex, A.MultiSigAddressIndex, A.SubstrateAddressIndex]);
    _inherit(A.ADAAddress, A._ADAAddress_Object_ADASerialization);
    _inheritMany(A.ADAAddress, [A.ADAByronAddress, A.ADAShellyAddress]);
    _inheritMany(A.ADAShellyAddress, [A.ADAPointerAddress, A.ADARewardAddress, A.ADABaseAddress, A.ADAEnterpriseAddress]);
    _inherit(A.FixedBytes, A._FixedBytes_Object_ADASerialization);
    _inherit(A.StakeCred, A.FixedBytes);
    _inherit(A.StakeCredType, A._StakeCredType_Object_ADASerialization);
    _inheritMany(A.StakeCred, [A.StakeCredKey, A.StakeCredScript]);
    _inherit(A.InternalStyle, A.Style);
    _inheritMany(A.InternalStyle, [A.PosixStyle, A.UrlStyle, A.WindowsStyle]);
    _inherit(A.FileLocation, A.SourceLocationMixin);
    _inheritMany(A.SourceSpanMixin, [A._FileSpan, A.SourceSpanBase]);
    _inherit(A.SourceSpanFormatException, A.SourceSpanException);
    _inherit(A.SourceSpanWithContext, A.SourceSpanBase);
    _inherit(A.StringScannerException, A.SourceSpanFormatException);
    _inherit(A.TonContractException, A.TonDartPluginException);
    _mixin(A.UnmodifiableListBase, A.UnmodifiableListMixin);
    _mixin(A.__CastListBase__CastIterableBase_ListMixin, A.ListBase);
    _mixin(A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, A.ListBase);
    _mixin(A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, A.FixedLengthListMixin);
    _mixin(A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin, A.ListBase);
    _mixin(A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, A.FixedLengthListMixin);
    _mixin(A._AsyncStreamController, A._AsyncStreamControllerDispatch);
    _mixin(A._SyncStreamController, A._SyncStreamControllerDispatch);
    _mixin(A.UnmodifiableMapBase, A._UnmodifiableMapMixin);
    _mixin(A._UnmodifiableMapView_MapView__UnmodifiableMapMixin, A._UnmodifiableMapMixin);
    _mixin(A._LiveListenable_Object__LiveListenable, A._LiveListenable);
    _mixin(A._APPImage_Object_CborSerializable, A.CborSerializable);
    _mixin(A._NetworkClient_Object_BaseRepository, A.BaseRepository);
    _mixin(A._SubstrateClient_NetworkClient_SubstrateRepository, A.SubstrateRepository);
    _mixin(A._APIProvider_Object_Equatable, A.Equatable);
    _mixin(A._APIProvider_Object_Equatable_CborSerializable, A.CborSerializable);
    _mixin(A._ProviderAuth_Object_CborSerializable, A.CborSerializable);
    _mixin(A._Chain_Object_CborSerializable, A.CborSerializable);
    _mixin(A._CryptoAddress_Object_CborSerializable, A.CborSerializable);
    _mixin(A._IBitcoinCashMultiSigAddress_IBitcoinCashAddress_BitcoinMultiSigBase, A.BitcoinMultiSigBase);
    _mixin(A._IBitcoinAddress_ChainAccount_Equatable, A.Equatable);
    _mixin(A._IBitcoinMultiSigAddress_IBitcoinAddress_BitcoinMultiSigBase, A.BitcoinMultiSigBase);
    _mixin(A._BitcoinMultiSigSignerDetais_Object_Equatable, A.Equatable);
    _mixin(A._BitcoinMultiSigSignerDetais_Object_Equatable_CborSerializable, A.CborSerializable);
    _mixin(A._BitcoinMultiSignatureAddress_Object_CborSerializable, A.CborSerializable);
    _mixin(A._ICardanoAddress_ChainAccount_Equatable, A.Equatable);
    _mixin(A._ICosmosAddress_ChainAccount_Equatable, A.Equatable);
    _mixin(A._IEthAddress_ChainAccount_Equatable, A.Equatable);
    _mixin(A._ISolanaAddress_ChainAccount_Equatable, A.Equatable);
    _mixin(A._ISubstrateAddress_ChainAccount_Equatable, A.Equatable);
    _mixin(A._ITonAddress_ChainAccount_Equatable, A.Equatable);
    _mixin(A._TronMultiSigSignerDetais_Object_Equatable, A.Equatable);
    _mixin(A._TronMultiSigSignerDetais_Object_Equatable_CborSerializable, A.CborSerializable);
    _mixin(A._TronMultiSignatureAddress_Object_Equatable, A.Equatable);
    _mixin(A._TronMultiSignatureAddress_Object_Equatable_CborSerializable, A.CborSerializable);
    _mixin(A._ITronAddress_ChainAccount_Equatable, A.Equatable);
    _mixin(A._RippleMultiSigSignerDetais_Object_Equatable, A.Equatable);
    _mixin(A._RippleMultiSigSignerDetais_Object_Equatable_CborSerializable, A.CborSerializable);
    _mixin(A._RippleMultiSignatureAddress_Object_Equatable, A.Equatable);
    _mixin(A._RippleMultiSignatureAddress_Object_Equatable_CborSerializable, A.CborSerializable);
    _mixin(A._IXRPAddress_ChainAccount_Equatable, A.Equatable);
    _mixin(A._Web3AccountPermission_Object_CborSerializable, A.CborSerializable);
    _mixin(A._Web3AccountPermission_Object_CborSerializable_Equatable, A.Equatable);
    _mixin(A._Web3Permission_Object_CborSerializable, A.CborSerializable);
    _mixin(A._Web3PermissionActivities_Object_CborSerializable, A.CborSerializable);
    _mixin(A._BitcoinContact_Object_Equatable, A.Equatable);
    _mixin(A._CardanoContact_Object_Equatable, A.Equatable);
    _mixin(A._CosmosContact_Object_Equatable, A.Equatable);
    _mixin(A._EthereumContract_Object_Equatable, A.Equatable);
    _mixin(A._SolanaContact_Object_Equatable, A.Equatable);
    _mixin(A._SubstrateContact_Object_Equatable, A.Equatable);
    _mixin(A._TonContact_Object_Equatable, A.Equatable);
    _mixin(A._TronContact_Object_Equatable, A.Equatable);
    _mixin(A._RippleContact_Object_Equatable, A.Equatable);
    _mixin(A._WalletNetwork_Object_Equatable, A.Equatable);
    _mixin(A._WalletNetwork_Object_Equatable_CborSerializable, A.CborSerializable);
    _mixin(A._NetworkCoinParams_Object_CborSerializable, A.CborSerializable);
    _mixin(A._CardanoAddrDetails_Object_Equatable, A.Equatable);
    _mixin(A._CardanoAddrDetails_Object_Equatable_CborSerializable, A.CborSerializable);
    _mixin(A._CosmosNativeCoin_Object_CborSerializable, A.CborSerializable);
    _mixin(A._TronAccountResourceInfo_Object_CborSerializable, A.CborSerializable);
    _mixin(A._AccountPermission_Object_CborSerializable, A.CborSerializable);
    _mixin(A._AssetV2_Object_CborSerializable, A.CborSerializable);
    _mixin(A._FreeAssetNetUsageV2_Object_CborSerializable, A.CborSerializable);
    _mixin(A._FrozenSupply_Object_CborSerializable, A.CborSerializable);
    _mixin(A._FrozenV2_Object_CborSerializable, A.CborSerializable);
    _mixin(A._PermissionKeys_Object_CborSerializable, A.CborSerializable);
    _mixin(A._PermissionKeys_Object_CborSerializable_Equatable, A.Equatable);
    _mixin(A._TronAccountInfo_Object_CborSerializable, A.CborSerializable);
    _mixin(A._TronAccountResource_Object_CborSerializable, A.CborSerializable);
    _mixin(A._UnfrozenV2_Object_CborSerializable, A.CborSerializable);
    _mixin(A._RippleNFToken_Object_Equatable, A.Equatable);
    _mixin(A._CoingeckoCoin_Object_CborSerializable, A.CborSerializable);
    _mixin(A._CoingeckoCoin_Object_CborSerializable_JsonSerialization, A.JsonSerialization);
    _mixin(A._Token_Object_CborSerializable, A.CborSerializable);
    _mixin(A._Token_Object_CborSerializable_Equatable, A.Equatable);
    _mixin(A._ETHERC20Token_Object_Equatable, A.Equatable);
    _mixin(A._RippleIssueToken_Object_Equatable, A.Equatable);
    _mixin(A._TonJettonToken_Object_Equatable, A.Equatable);
    _mixin(A._SolanaSPLToken_Object_Equatable, A.Equatable);
    _mixin(A._TronTRC10Token_Object_Equatable, A.Equatable);
    _mixin(A._TronTRC20Token_Object_Equatable, A.Equatable);
    _mixin(A._ChainsHandler_Object_CborSerializable, A.CborSerializable);
    _mixin(A._Web3RequestParams_Web3MessageCore_JsonSerialization, A.JsonSerialization);
    _mixin(A._Web3EncryptedMessage_Object_CborSerializable, A.CborSerializable);
    _mixin(A._Web3MessageCore_Object_CborSerializable, A.CborSerializable);
    _mixin(A._AddressDerivationIndex_Object_CborSerializable, A.CborSerializable);
    _mixin(A._AddressDerivationIndex_Object_CborSerializable_Equatable, A.Equatable);
    _mixin(A._ADAAddress_Object_ADASerialization, A.ADASerialization);
    _mixin(A._StakeCredType_Object_ADASerialization, A.ADASerialization);
    _mixin(A._FixedBytes_Object_ADASerialization, A.ADASerialization);
  })();
  var init = {
    typeUniverse: {eC: new Map(), tR: {}, eT: {}, tPV: {}, sEA: []},
    mangledGlobalNames: {int: "int", double: "double", num: "num", String: "String", bool: "bool", Null: "Null", List: "List", Object: "Object", Map: "Map"},
    mangledNames: {},
    types: ["~()", "SubstrateEd25519AddrEncoder([@])", "0&()", "P2PKHAddrEncoder([@])", "EthAddrEncoder([@])", "AtomAddrEncoder([@])", "P2SHAddrEncoder([@])", "SubstrateSr25519AddrEncoder([@])", "SubstrateSecp256k1AddrEncoder([@])", "BlockchainAddressEncoder([@])", "ProviderAuth(CborTagValue<@>)", "Null()", "~(@)", "int(int)", "List<int>(EncoderResult)", "@(@)", "String(String)", "bool(String)", "Future<Null>()", "int(int,int)", "AdaByronIcarusAddrEncoder([@])", "Null(@)", "XrpAddrEncoder([@])", "AdaShelleyAddrEncoder([@])", "P2WPKHAddrEncoder([@])", "Null(JSObject)", "int()", "String(Match)", "APIProvider()", "~(~())", "Future<Map<String,@>>()", "Object?(Object?)", "bool(_Highlight)", "~(JSObject)", "String(int)", "bool(int)", "bool(ADANetwork)", "~(Object,StackTrace)", "Null(Object,StackTrace)", "AtomNist256P1AddrEncoder([@])", "ErgoP2PKHAddrEncoder([@])", "~(Object?,Object?)", "XmrAddrEncoder([@])", "NeoAddrEncoder([@])", "OkexAddrEncoder([@])", "XlmAddrEncoder([@])", "String(Eip712TypedDataV1)", "AdaByronLegacyAddrEncoder([@])", "ETHAddress(String)", "int(Object?)", "bool(Web3EthereumRequestMethods)", "EthereumAPIProvider(@)", "bool(Object?,Object?)", "TronTRC10Token(@)", "TronTRC20Token(@)", "WalletNetwork<NetworkCoinParams<APIProvider>>()", "~(Uint8List,String,int)", "bool(APIProvider)", "int(@,@)", "bool(CborBase64Types)", "int(String?)", "bool(X509Certificate)", "P2TRAddrEncoder([@])", "~(Object?)", "TonAddrEncoder([@])", "TrxAddrEncoder([@])", "bool(String,List<int>)", "List<int>(List<int>)", "SolAddrEncoder([@])", "@()", "EncoderResult(@)", "List<int>(String,List<int>)", "AbiParameter(String)", "NearAddrEncoder([@])", "NanoAddrEncoder([@])", "XtzAddrEncoder([@])", "InjAddrEncoder([@])", "ZilAddrEncoder([@])", "IcxAddrEncoder([@])", "bool(Bip49Coins)", "Null(~())", "bool(Bip84Coins)", "OneAddrEncoder([@])", "bool(Bip86Coins)", "FilSecp256k1AddrEncoder([@])", "bool(BipProposal)", "bool(Cip1852Coins)", "@(@,String)", "bool(EllipticCurveTypes)", "bool(MoneroCoins)", "bool(SubstrateCoins)", "~(Symbol0,@)", "EosAddrEncoder([@])", "CborObject(@)", "String(CborStringValue)", "EgldAddrEncoder([@])", "List<int>(CborBytesValue)", "List<int>(int)", "bool(String,String)", "int(String)", "~(String,int)", "~(List<int>)", "~(String,int?)", "MediaType()", "~(String,String)", "Uint8List(@,@)", "bool(ContentType)", "ContentType()", "Null(~)", "~(@,@)", "bool(@)", "bool(BitcoinExplorerProviderType)", "SecureSocket(RawSecureSocket)", "ProviderAuth(String)", "bool(ApiRequest)", "Future<Response>()", "Future<SecureSocket>()", "Future<RawSecureSocket>(RawSocket)", "Future<Socket>()", "~(String)", "Future<PlatformWebScoket>()", "bool(ProviderAuthType)", "bool(ServiceProtocol)", "_Future<@>(@)", "ICardanoAddress()", "ContactCore<ADAAddress>(@)", "Web3Permission<ADAAddress>(@)", "IBitcoinAddress()", "ContactCore<BitcoinBaseAddress>(@)", "Web3Permission<BitcoinBaseAddress>(@)", "ICosmosAddress()", "ContactCore<CosmosBaseAddress>(@)", "Web3Permission<CosmosBaseAddress>(@)", "IEthAddress()", "ContactCore<ETHAddress>(@)", "Web3Permission<ETHAddress>(@)", "ISolanaAddress()", "ContactCore<SolAddress>(@)", "Web3Permission<SolAddress>(@)", "ISubstrateAddress()", "ContactCore<SubstrateAddress>(@)", "Web3Permission<SubstrateAddress>(@)", "ITonAddress()", "ContactCore<TonAddress>(@)", "Web3Permission<TonAddress>(@)", "ITronAddress()", "ContactCore<TronAddress>(@)", "Web3Permission<TronAddress>(@)", "IXRPAddress()", "ContactCore<XRPAddress>(@)", "Web3Permission<XRPAddress>(@)", "BitcoinMultiSigSignerDetais(@)", "String(@)", "String(P2shAddressType)", "TonJettonToken(@)", "TronMultiSigSignerDetais(@)", "AvaxXChainAddrEncoder([@])", "AvaxPChainAddrEncoder([@])", "RippleMultiSigSignerDetais(@)", "RippleIssueToken(@)", "RippleNFToken(@)", "APPImage(CborTagValue<@>)", "Bip32KeyIndex(String)", "BaseBitcoinAPIProvider(@)", "CardanoAPIProvider(@)", "CosmosAPIProvider(@)", "CosmosNativeCoin(@)", "AptosAddrEncoder([@])", "RippleAPIProvider(@)", "SolanaAPIProvider(@)", "SubstrateAPIProvider(@)", "TonAPIProvider(@)", "TronAPIProvider(@)", "bool(CosmosNetworkTypes)", "FrozenSupply(@)", "AccountPermission(@)", "FrozenV2(@)", "UnfrozenV2(@)", "AssetV2(@)", "FreeAssetNetUsageV2(@)", "PermissionKeys(@)", "CoingeckoCoin(CborObject)", "Chain<APIProvider,NetworkCoinParams<APIProvider>,@,TokenCore<@>,ChainAccount<Object?,TokenCore<@>>,WalletNetwork<NetworkCoinParams<APIProvider>>,NetworkClient<ChainAccount<Object?,TokenCore<@>>,APIProvider>,Web3BaseRequestParams<@,@,@>>(@)", "AlgoAddrEncoder([@])", "bool(Bip44Coins)", "EIP712Base()", "bool(Web3MessageTypes)", "bool(CustomCoins)", "~(Object[StackTrace?])", "bool(AddressDerivationType)", "bool(int?)", "Bip32KeyIndex(int?)", "bool(SeedTypes)", "bool(NetworkType)", "bool(AbiParameter)", "bool(EIP712Version)", "int(EIP712Version)", "Eip712TypeDetails(@)", "MapEntry<String,List<Map<String,@>>>(String,List<Eip712TypeDetails>)", "Map<String,@>(Eip712TypeDetails)", "Eip712TypedDataV1(Map<String,@>)", "@(Eip712TypedDataV1)", "~(int,@)", "Map<String,@>(Eip712TypedDataV1)", "List<String>(List<String>,Eip712TypeDetails)", "Tuple<String,@>(@)", "String(Tuple<String,@>)", "@(Tuple<String,@>)", "String(MapEntry<int,String>)", "String(Eip712TypeDetails)", "bool(ADAByronAddrTypes)", "~([RawSocket?])", "bool(ADAAddressType)", "bool(PermissionType)", "PermissionType()", "bool(ResourceCode)", "ResourceCode()", "String(String?)", "String?()", "int(_Line)", "Null(@,StackTrace)", "Object(_Line)", "Object(_Highlight)", "int(_Highlight,_Highlight)", "List<_Line>(MapEntry<Object,List<_Highlight>>)", "SourceSpanWithContext()", "bool(WalletVersion)", "bool(MapEntry<String,@>)", "String(MapEntry<String,@>)", "bool(TonApiType)", "~(RawSocketEvent)", "List<String>()", "JSObject(JSObject)", "Null(JavaScriptFunction,JavaScriptFunction)", "Object(Object,StackTrace)", "bool(BasedUtxoNetwork)", "~(@[StackTrace?])", "~(String,@)", "bool(BitcoinAddressType)", "0^(0^,0^)<num>", "@(String)", "List<int>?(int)", "List<int>(String,List<int>[Bech32Encodings])", "bool(String,List<int>[Bech32Encodings])", "Web3PermissionActivities(@)"],
    interceptorsByTag: null,
    leafTags: null,
    arrayRti: Symbol("$ti")
  };
  A._Universe_addRules(init.typeUniverse, JSON.parse('{"JavaScriptFunction":"LegacyJavaScriptObject","PlainJavaScriptObject":"LegacyJavaScriptObject","UnknownJavaScriptObject":"LegacyJavaScriptObject","JSArray":{"List":["1"],"EfficientLengthIterable":["1"],"JSObject":[],"Iterable":["1"]},"JSBool":{"bool":[],"TrustedGetRuntimeType":[]},"JSNull":{"Null":[],"TrustedGetRuntimeType":[]},"JavaScriptObject":{"JSObject":[]},"LegacyJavaScriptObject":{"JSObject":[]},"JSUnmodifiableArray":{"JSArray":["1"],"List":["1"],"EfficientLengthIterable":["1"],"JSObject":[],"Iterable":["1"]},"ArrayIterator":{"Iterator":["1"]},"JSNumber":{"double":[],"num":[],"Comparable":["num"]},"JSInt":{"double":[],"int":[],"num":[],"Comparable":["num"],"TrustedGetRuntimeType":[]},"JSNumNotInt":{"double":[],"num":[],"Comparable":["num"],"TrustedGetRuntimeType":[]},"JSString":{"String":[],"Comparable":["String"],"Pattern":[],"TrustedGetRuntimeType":[]},"CastStream":{"Stream":["2"],"Stream.T":"2"},"CastStreamSubscription":{"StreamSubscription":["2"]},"_CastIterableBase":{"Iterable":["2"]},"CastIterator":{"Iterator":["2"]},"CastIterable":{"_CastIterableBase":["1","2"],"Iterable":["2"],"Iterable.E":"2"},"_EfficientLengthCastIterable":{"CastIterable":["1","2"],"_CastIterableBase":["1","2"],"EfficientLengthIterable":["2"],"Iterable":["2"],"Iterable.E":"2"},"_CastListBase":{"ListBase":["2"],"List":["2"],"_CastIterableBase":["1","2"],"EfficientLengthIterable":["2"],"Iterable":["2"]},"CastList":{"_CastListBase":["1","2"],"ListBase":["2"],"List":["2"],"_CastIterableBase":["1","2"],"EfficientLengthIterable":["2"],"Iterable":["2"],"ListBase.E":"2","Iterable.E":"2"},"CastMap":{"MapBase":["3","4"],"Map":["3","4"],"MapBase.K":"3","MapBase.V":"4"},"LateError":{"Error":[]},"CodeUnits":{"ListBase":["int"],"UnmodifiableListMixin":["int"],"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"],"ListBase.E":"int","UnmodifiableListMixin.E":"int"},"EfficientLengthIterable":{"Iterable":["1"]},"ListIterable":{"EfficientLengthIterable":["1"],"Iterable":["1"]},"SubListIterable":{"ListIterable":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1","ListIterable.E":"1"},"ListIterator":{"Iterator":["1"]},"MappedIterable":{"Iterable":["2"],"Iterable.E":"2"},"EfficientLengthMappedIterable":{"MappedIterable":["1","2"],"EfficientLengthIterable":["2"],"Iterable":["2"],"Iterable.E":"2"},"MappedIterator":{"Iterator":["2"]},"MappedListIterable":{"ListIterable":["2"],"EfficientLengthIterable":["2"],"Iterable":["2"],"Iterable.E":"2","ListIterable.E":"2"},"WhereIterable":{"Iterable":["1"],"Iterable.E":"1"},"WhereIterator":{"Iterator":["1"]},"ExpandIterable":{"Iterable":["2"],"Iterable.E":"2"},"ExpandIterator":{"Iterator":["2"]},"TakeIterable":{"Iterable":["1"],"Iterable.E":"1"},"EfficientLengthTakeIterable":{"TakeIterable":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"TakeIterator":{"Iterator":["1"]},"SkipIterable":{"Iterable":["1"],"Iterable.E":"1"},"EfficientLengthSkipIterable":{"SkipIterable":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"SkipIterator":{"Iterator":["1"]},"EmptyIterable":{"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"EmptyIterator":{"Iterator":["1"]},"WhereTypeIterable":{"Iterable":["1"],"Iterable.E":"1"},"WhereTypeIterator":{"Iterator":["1"]},"UnmodifiableListBase":{"ListBase":["1"],"UnmodifiableListMixin":["1"],"List":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"]},"_ListIndicesIterable":{"ListIterable":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"],"Iterable.E":"int","ListIterable.E":"int"},"ListMapView":{"MapBase":["int","1"],"_UnmodifiableMapMixin":["int","1"],"Map":["int","1"],"MapBase.K":"int","MapBase.V":"1","_UnmodifiableMapMixin.K":"int","_UnmodifiableMapMixin.V":"1"},"ReversedListIterable":{"ListIterable":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1","ListIterable.E":"1"},"Symbol":{"Symbol0":[]},"ConstantMapView":{"UnmodifiableMapView":["1","2"],"_UnmodifiableMapView_MapView__UnmodifiableMapMixin":["1","2"],"MapView":["1","2"],"_UnmodifiableMapMixin":["1","2"],"Map":["1","2"],"_UnmodifiableMapMixin.K":"1","_UnmodifiableMapMixin.V":"2"},"ConstantMap":{"Map":["1","2"]},"ConstantStringMap":{"ConstantMap":["1","2"],"Map":["1","2"]},"_KeysOrValues":{"Iterable":["1"],"Iterable.E":"1"},"_KeysOrValuesOrElementsIterator":{"Iterator":["1"]},"GeneralConstantMap":{"ConstantMap":["1","2"],"Map":["1","2"]},"Instantiation":{"Closure":[],"Function":[]},"Instantiation1":{"Closure":[],"Function":[]},"JSInvocationMirror":{"Invocation":[]},"NullError":{"TypeError":[],"Error":[]},"JsNoSuchMethodError":{"Error":[]},"UnknownJsTypeError":{"Error":[]},"NullThrownFromJavaScriptException":{"Exception":[]},"_StackTrace":{"StackTrace":[]},"Closure":{"Function":[]},"Closure0Args":{"Closure":[],"Function":[]},"Closure2Args":{"Closure":[],"Function":[]},"TearOffClosure":{"Closure":[],"Function":[]},"StaticClosure":{"Closure":[],"Function":[]},"BoundClosure":{"Closure":[],"Function":[]},"_CyclicInitializationError":{"Error":[]},"RuntimeError":{"Error":[]},"_AssertionError":{"Error":[]},"JsLinkedHashMap":{"MapBase":["1","2"],"LinkedHashMap":["1","2"],"Map":["1","2"],"MapBase.K":"1","MapBase.V":"2"},"LinkedHashMapKeyIterable":{"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"LinkedHashMapKeyIterator":{"Iterator":["1"]},"JsIdentityLinkedHashMap":{"JsLinkedHashMap":["1","2"],"MapBase":["1","2"],"LinkedHashMap":["1","2"],"Map":["1","2"],"MapBase.K":"1","MapBase.V":"2"},"JsConstantLinkedHashMap":{"JsLinkedHashMap":["1","2"],"MapBase":["1","2"],"LinkedHashMap":["1","2"],"Map":["1","2"],"MapBase.K":"1","MapBase.V":"2"},"JSSyntaxRegExp":{"RegExp":[],"Pattern":[]},"_MatchImplementation":{"RegExpMatch":[],"Match":[]},"_AllMatchesIterable":{"Iterable":["RegExpMatch"],"Iterable.E":"RegExpMatch"},"_AllMatchesIterator":{"Iterator":["RegExpMatch"]},"StringMatch":{"Match":[]},"_StringAllMatchesIterable":{"Iterable":["Match"],"Iterable.E":"Match"},"_StringAllMatchesIterator":{"Iterator":["Match"]},"NativeByteBuffer":{"JSObject":[],"ByteBuffer":[],"TrustedGetRuntimeType":[]},"NativeTypedData":{"JSObject":[]},"NativeByteData":{"ByteData":[],"JSObject":[],"TrustedGetRuntimeType":[]},"NativeTypedArray":{"JavaScriptIndexingBehavior":["1"],"JSObject":[]},"NativeTypedArrayOfDouble":{"ListBase":["double"],"NativeTypedArray":["double"],"List":["double"],"JavaScriptIndexingBehavior":["double"],"EfficientLengthIterable":["double"],"JSObject":[],"Iterable":["double"],"FixedLengthListMixin":["double"]},"NativeTypedArrayOfInt":{"ListBase":["int"],"NativeTypedArray":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"]},"NativeFloat32List":{"ListBase":["double"],"Float32List":[],"NativeTypedArray":["double"],"List":["double"],"JavaScriptIndexingBehavior":["double"],"EfficientLengthIterable":["double"],"JSObject":[],"Iterable":["double"],"FixedLengthListMixin":["double"],"TrustedGetRuntimeType":[],"ListBase.E":"double","FixedLengthListMixin.E":"double"},"NativeFloat64List":{"ListBase":["double"],"Float64List":[],"NativeTypedArray":["double"],"List":["double"],"JavaScriptIndexingBehavior":["double"],"EfficientLengthIterable":["double"],"JSObject":[],"Iterable":["double"],"FixedLengthListMixin":["double"],"TrustedGetRuntimeType":[],"ListBase.E":"double","FixedLengthListMixin.E":"double"},"NativeInt16List":{"NativeTypedArrayOfInt":[],"ListBase":["int"],"Int16List":[],"NativeTypedArray":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int","FixedLengthListMixin.E":"int"},"NativeInt32List":{"NativeTypedArrayOfInt":[],"ListBase":["int"],"Int32List":[],"NativeTypedArray":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int","FixedLengthListMixin.E":"int"},"NativeInt8List":{"NativeTypedArrayOfInt":[],"ListBase":["int"],"Int8List":[],"NativeTypedArray":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int","FixedLengthListMixin.E":"int"},"NativeUint16List":{"NativeTypedArrayOfInt":[],"ListBase":["int"],"Uint16List":[],"NativeTypedArray":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int","FixedLengthListMixin.E":"int"},"NativeUint32List":{"NativeTypedArrayOfInt":[],"ListBase":["int"],"Uint32List":[],"NativeTypedArray":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int","FixedLengthListMixin.E":"int"},"NativeUint8ClampedList":{"NativeTypedArrayOfInt":[],"ListBase":["int"],"Uint8ClampedList":[],"NativeTypedArray":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int","FixedLengthListMixin.E":"int"},"NativeUint8List":{"NativeTypedArrayOfInt":[],"ListBase":["int"],"Uint8List":[],"NativeTypedArray":["int"],"List":["int"],"JavaScriptIndexingBehavior":["int"],"EfficientLengthIterable":["int"],"JSObject":[],"Iterable":["int"],"FixedLengthListMixin":["int"],"TrustedGetRuntimeType":[],"ListBase.E":"int","FixedLengthListMixin.E":"int"},"_Error":{"Error":[]},"_TypeError":{"TypeError":[],"Error":[]},"_Future":{"Future":["1"]},"_AsyncAwaitCompleter":{"Completer":["1"]},"_SyncStarIterator":{"Iterator":["1"]},"_SyncStarIterable":{"Iterable":["1"],"Iterable.E":"1"},"AsyncError":{"Error":[]},"TimeoutException":{"Exception":[]},"_Completer":{"Completer":["1"]},"_AsyncCompleter":{"_Completer":["1"],"Completer":["1"]},"_SyncCompleter":{"_Completer":["1"],"Completer":["1"]},"StreamView":{"Stream":["1"]},"_StreamController":{"StreamController":["1"],"_StreamControllerLifecycle":["1"],"_EventDispatch":["1"]},"_AsyncStreamController":{"_AsyncStreamControllerDispatch":["1"],"_StreamController":["1"],"StreamController":["1"],"_StreamControllerLifecycle":["1"],"_EventDispatch":["1"]},"_SyncStreamController":{"_SyncStreamControllerDispatch":["1"],"_StreamController":["1"],"StreamController":["1"],"_StreamControllerLifecycle":["1"],"_EventDispatch":["1"]},"_ControllerStream":{"_StreamImpl":["1"],"Stream":["1"],"Stream.T":"1"},"_ControllerSubscription":{"_BufferingStreamSubscription":["1"],"StreamSubscription":["1"],"_EventDispatch":["1"]},"_BufferingStreamSubscription":{"StreamSubscription":["1"],"_EventDispatch":["1"]},"_StreamImpl":{"Stream":["1"]},"_DelayedData":{"_DelayedEvent":["1"]},"_DelayedError":{"_DelayedEvent":["@"]},"_DelayedDone":{"_DelayedEvent":["@"]},"_DoneStreamSubscription":{"StreamSubscription":["1"]},"_EmptyStream":{"Stream":["1"],"Stream.T":"1"},"_Zone":{"Zone":[]},"_RootZone":{"_Zone":[],"Zone":[]},"_HashMap":{"MapBase":["1","2"],"Map":["1","2"]},"_IdentityHashMap":{"_HashMap":["1","2"],"MapBase":["1","2"],"Map":["1","2"],"MapBase.K":"1","MapBase.V":"2"},"_HashMapKeyIterable":{"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"_HashMapKeyIterator":{"Iterator":["1"]},"_LinkedCustomHashMap":{"JsLinkedHashMap":["1","2"],"MapBase":["1","2"],"LinkedHashMap":["1","2"],"Map":["1","2"],"MapBase.K":"1","MapBase.V":"2"},"_LinkedHashSet":{"SetBase":["1"],"Set":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"]},"_LinkedHashSetIterator":{"Iterator":["1"]},"ListBase":{"List":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"]},"MapBase":{"Map":["1","2"]},"UnmodifiableMapBase":{"MapBase":["1","2"],"_UnmodifiableMapMixin":["1","2"],"Map":["1","2"]},"MapView":{"Map":["1","2"]},"UnmodifiableMapView":{"_UnmodifiableMapView_MapView__UnmodifiableMapMixin":["1","2"],"MapView":["1","2"],"_UnmodifiableMapMixin":["1","2"],"Map":["1","2"],"_UnmodifiableMapMixin.K":"1","_UnmodifiableMapMixin.V":"2"},"SetBase":{"Set":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"]},"_SetBase":{"SetBase":["1"],"Set":["1"],"EfficientLengthIterable":["1"],"Iterable":["1"]},"Encoding":{"Codec":["String","List<int>"]},"_JsonMap":{"MapBase":["String","@"],"Map":["String","@"],"MapBase.K":"String","MapBase.V":"@"},"_JsonMapKeyIterable":{"ListIterable":["String"],"EfficientLengthIterable":["String"],"Iterable":["String"],"Iterable.E":"String","ListIterable.E":"String"},"AsciiCodec":{"Encoding":[],"Codec":["String","List<int>"],"Codec.S":"String"},"Base64Codec":{"Codec":["List<int>","String"],"Codec.S":"List<int>"},"JsonUnsupportedObjectError":{"Error":[]},"JsonCyclicError":{"Error":[]},"JsonCodec":{"Codec":["Object?","String"],"Codec.S":"Object?"},"Latin1Codec":{"Encoding":[],"Codec":["String","List<int>"],"Codec.S":"String"},"Utf8Codec":{"Encoding":[],"Codec":["String","List<int>"],"Codec.S":"String"},"BigInt":{"Comparable":["BigInt"]},"DateTime":{"Comparable":["DateTime"]},"double":{"num":[],"Comparable":["num"]},"Duration":{"Comparable":["Duration"]},"int":{"num":[],"Comparable":["num"]},"List":{"EfficientLengthIterable":["1"],"Iterable":["1"]},"num":{"Comparable":["num"]},"RegExpMatch":{"Match":[]},"String":{"Comparable":["String"],"Pattern":[]},"_BigIntImpl":{"BigInt":[],"Comparable":["BigInt"]},"AssertionError":{"Error":[]},"TypeError":{"Error":[]},"ArgumentError":{"Error":[]},"RangeError":{"Error":[]},"IndexError":{"Error":[]},"NoSuchMethodError":{"Error":[]},"UnsupportedError":{"Error":[]},"UnimplementedError":{"Error":[]},"StateError":{"Error":[]},"ConcurrentModificationError":{"Error":[]},"OutOfMemoryError":{"Error":[]},"StackOverflowError":{"Error":[]},"_Exception":{"Exception":[]},"FormatException":{"Exception":[]},"IntegerDivisionByZeroException":{"Exception":[],"Error":[]},"_StringStackTrace":{"StackTrace":[]},"Runes":{"Iterable":["int"],"Iterable.E":"int"},"RuneIterator":{"Iterator":["int"]},"StringBuffer":{"StringSink":[]},"_Uri":{"Uri":[]},"_SimpleUri":{"Uri":[]},"_DataUri":{"Uri":[]},"SecureSocket":{"Socket":[],"Stream":["Uint8List"],"StringSink":[]},"RawSecureSocket":{"RawSocket":[],"Stream":["RawSocketEvent"]},"_RawSecureSocket":{"RawSecureSocket":[],"RawSocket":[],"Stream":["RawSocketEvent"],"Stream.T":"RawSocketEvent"},"RawSocket":{"Stream":["RawSocketEvent"]},"Socket":{"Stream":["Uint8List"],"StringSink":[]},"TlsException":{"Exception":[]},"HandshakeException":{"Exception":[]},"NullRejectionException":{"Exception":[]},"Int8List":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Uint8List":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Uint8ClampedList":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Int16List":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Uint16List":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Int32List":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Uint32List":{"List":["int"],"EfficientLengthIterable":["int"],"Iterable":["int"]},"Float32List":{"List":["double"],"EfficientLengthIterable":["double"],"Iterable":["double"]},"Float64List":{"List":["double"],"EfficientLengthIterable":["double"],"Iterable":["double"]},"P2shAddressType":{"BitcoinAddressType":[]},"PubKeyAddressType":{"BitcoinAddressType":[]},"P2pkhAddressType":{"BitcoinAddressType":[]},"SegwitAddresType":{"BitcoinAddressType":[]},"LegacyAddress":{"BitcoinBaseAddress":[]},"P2shAddress":{"BitcoinBaseAddress":[]},"P2pkhAddress":{"BitcoinBaseAddress":[]},"P2pkAddress":{"BitcoinBaseAddress":[]},"SegwitAddress":{"BitcoinBaseAddress":[]},"P2wpkhAddress":{"BitcoinBaseAddress":[]},"P2trAddress":{"BitcoinBaseAddress":[]},"P2wshAddress":{"BitcoinBaseAddress":[]},"BitcoinBasePluginException":{"BlockchainUtilsException":[],"Exception":[]},"BitcoinNetwork":{"BasedUtxoNetwork":[]},"LitecoinNetwork":{"BasedUtxoNetwork":[]},"DashNetwork":{"BasedUtxoNetwork":[]},"DogecoinNetwork":{"BasedUtxoNetwork":[]},"BitcoinCashNetwork":{"BasedUtxoNetwork":[]},"PepeNetwork":{"BasedUtxoNetwork":[]},"BitcoinSVNetwork":{"BasedUtxoNetwork":[]},"Base58ChecksumError":{"BlockchainUtilsException":[],"Exception":[]},"Bech32ChecksumError":{"BlockchainUtilsException":[],"Exception":[]},"AdaByronIcarusAddrEncoder":{"BlockchainAddressEncoder":[]},"AdaByronLegacyAddrEncoder":{"BlockchainAddressEncoder":[]},"AdaShelleyAddrEncoder":{"BlockchainAddressEncoder":[]},"AdaShelleyStakingAddrEncoder":{"BlockchainAddressEncoder":[]},"AlgoAddrEncoder":{"BlockchainAddressEncoder":[]},"AptosAddrEncoder":{"BlockchainAddressEncoder":[]},"AtomAddrEncoder":{"BlockchainAddressEncoder":[]},"AtomNist256P1AddrEncoder":{"BlockchainAddressEncoder":[]},"AvaxPChainAddrEncoder":{"BlockchainAddressEncoder":[]},"AvaxXChainAddrEncoder":{"BlockchainAddressEncoder":[]},"EgldAddrEncoder":{"BlockchainAddressEncoder":[]},"EosAddrEncoder":{"BlockchainAddressEncoder":[]},"ErgoP2PKHAddrEncoder":{"BlockchainAddressEncoder":[]},"EthAddrEncoder":{"BlockchainAddressEncoder":[]},"AddressConverterException":{"BlockchainUtilsException":[],"Exception":[]},"FilSecp256k1AddrEncoder":{"BlockchainAddressEncoder":[]},"IcxAddrEncoder":{"BlockchainAddressEncoder":[]},"InjAddrEncoder":{"BlockchainAddressEncoder":[]},"NanoAddrEncoder":{"BlockchainAddressEncoder":[]},"NearAddrEncoder":{"BlockchainAddressEncoder":[]},"NeoAddrEncoder":{"BlockchainAddressEncoder":[]},"OkexAddrEncoder":{"BlockchainAddressEncoder":[]},"OneAddrEncoder":{"BlockchainAddressEncoder":[]},"P2PKHAddrEncoder":{"BlockchainAddressEncoder":[]},"BchP2PKHAddrEncoder":{"BlockchainAddressEncoder":[]},"P2SHAddrEncoder":{"BlockchainAddressEncoder":[]},"BchP2SHAddrEncoder":{"BlockchainAddressEncoder":[]},"P2TRAddrEncoder":{"BlockchainAddressEncoder":[]},"P2WPKHAddrEncoder":{"BlockchainAddressEncoder":[]},"SolAddrEncoder":{"BlockchainAddressEncoder":[]},"SubstrateEd25519AddrEncoder":{"BlockchainAddressEncoder":[]},"SubstrateSr25519AddrEncoder":{"BlockchainAddressEncoder":[]},"SubstrateSecp256k1AddrEncoder":{"BlockchainAddressEncoder":[]},"TonAddrEncoder":{"BlockchainAddressEncoder":[]},"TrxAddrEncoder":{"BlockchainAddressEncoder":[]},"XlmAddrEncoder":{"BlockchainAddressEncoder":[]},"XmrAddrEncoder":{"BlockchainAddressEncoder":[]},"XrpAddrEncoder":{"BlockchainAddressEncoder":[]},"XtzAddrEncoder":{"BlockchainAddressEncoder":[]},"ZilAddrEncoder":{"BlockchainAddressEncoder":[]},"Bip32PathError":{"BlockchainUtilsException":[],"Exception":[]},"BipCoins":{"CryptoCoins":["BipCoinConfig"]},"Bip44Coins":{"CryptoCoins":["BipCoinConfig"]},"Bip49Coins":{"CryptoCoins":["BipCoinConfig"]},"Bip84Coins":{"CryptoCoins":["BipCoinConfig"]},"Bip86Coins":{"CryptoCoins":["BipCoinConfig"]},"BipBitcoinCashConf":{"BipCoinConfig":[],"CoinConfig":[]},"BipCoinConfig":{"CoinConfig":[]},"BipLitecoinConf":{"BipCoinConfig":[],"CoinConfig":[]},"Cip1852Coins":{"CryptoCoins":["BipCoinConfig"]},"CipProposal":{"BipProposal":[]},"Ed25519Blake2bPublicKey":{"IPublicKey":[]},"Ed25519PublicKey":{"IPublicKey":[]},"Ed25519KholawPublicKey":{"IPublicKey":[]},"Ed25519MoneroPublicKey":{"IPublicKey":[]},"Nist256p1PublicKey":{"IPublicKey":[]},"Secp256k1PublicKeyEcdsa":{"IPublicKey":[]},"Sr25519PublicKey":{"IPublicKey":[]},"MoneroCoinConf":{"CoinConfig":[]},"MoneroCoins":{"CryptoCoins":["MoneroCoinConf"]},"MoneroKeyError":{"BlockchainUtilsException":[],"Exception":[]},"MoneroPublicKey":{"IPublicKey":[]},"SubstrateCoinConf":{"CoinConfig":[]},"SubstrateCoins":{"CryptoCoins":["SubstrateCoinConf"]},"CborNumeric":{"CborObject":[]},"CborBaseUrlValue":{"CborObject":[]},"CborBigFloatValue":{"CborObject":[]},"CborBigIntValue":{"CborNumeric":[],"CborObject":[]},"CborBoleanValue":{"CborObject":[]},"CborBytesValue":{"CborObject":[]},"CborDynamicBytesValue":{"CborObject":[]},"CborTagValue":{"CborObject":[]},"CborEpochIntValue":{"CborObject":[]},"_CborDate":{"CborObject":[]},"CborStringDateValue":{"CborObject":[]},"CborEpochFloatValue":{"CborObject":[]},"CborDecimalFracValue":{"CborObject":[]},"CborFloatValue":{"CborObject":[]},"CborIntValue":{"CborNumeric":[],"CborObject":[]},"CborSafeIntValue":{"CborNumeric":[],"CborObject":[]},"CborListValue":{"CborObject":[]},"CborMapValue":{"CborObject":[]},"CborMimeValue":{"CborObject":[]},"CborNullValue":{"CborObject":[]},"CborUndefinedValue":{"CborObject":[]},"CborRegxpValue":{"CborObject":[]},"CborSetValue":{"CborObject":[]},"CborStringValue":{"CborObject":[]},"CborIndefiniteStringValue":{"CborObject":[]},"CborString":{"CborObject":[]},"CborUriValue":{"CborObject":[]},"AES":{"BlockCipher":[]},"ProjectiveECCPoint":{"AbstractPoint":[]},"EDPoint":{"AbstractPoint":[]},"RistrettoPoint":{"EDPoint":[],"AbstractPoint":[]},"SquareRootError":{"BlockchainUtilsException":[],"Exception":[]},"JacobiError":{"BlockchainUtilsException":[],"Exception":[]},"BlockchainUtilsException":{"Exception":[]},"ArgumentException":{"BlockchainUtilsException":[],"Exception":[]},"MessageException":{"BlockchainUtilsException":[],"Exception":[]},"SS58ChecksumError":{"BlockchainUtilsException":[],"Exception":[]},"CanonicalizedMap":{"Map":["2","3"]},"ByteStream":{"StreamView":["List<int>"],"Stream":["List<int>"],"StreamView.T":"List<int>","Stream.T":"List<int>"},"ClientException":{"Exception":[]},"Request":{"BaseRequest":[]},"StreamedResponseV2":{"StreamedResponse":[]},"CaseInsensitiveMap":{"CanonicalizedMap":["String","String","1"],"Map":["String","1"],"CanonicalizedMap.K":"String","CanonicalizedMap.V":"1","CanonicalizedMap.C":"String"},"ApiProviderException":{"Exception":[]},"WalletException":{"Exception":[]},"_Live":{"LiveListenable":["1"]},"Live":{"_Live":["1"],"LiveListenable":["1"]},"WebsocketWeb":{"PlatformWebScoket":[]},"BitcoinElectrumClient":{"BitcoinClient":["IBitcoinAddress"],"NetworkClient":["IBitcoinAddress","BaseBitcoinAPIProvider"]},"BitcoinExplorerApiProvider":{"BitcoinClient":["IBitcoinAddress"],"NetworkClient":["IBitcoinAddress","BaseBitcoinAPIProvider"]},"BitcoinClient":{"NetworkClient":["1","BaseBitcoinAPIProvider"]},"CardanoClient":{"NetworkClient":["ICardanoAddress","CardanoAPIProvider"]},"CosmosClient":{"NetworkClient":["ICosmosAddress","CosmosAPIProvider"]},"EthereumClient":{"NetworkClient":["IEthAddress","EthereumAPIProvider"]},"RippleClient":{"NetworkClient":["IXRPAddress","RippleAPIProvider"]},"SolanaClient":{"NetworkClient":["ISolanaAddress","SolanaAPIProvider"]},"SubstrateClient":{"NetworkClient":["ISubstrateAddress","SubstrateAPIProvider"]},"TonClient":{"NetworkClient":["ITonAddress","TonAPIProvider"]},"TronClient":{"NetworkClient":["ITronAddress","TronAPIProvider"]},"APIProvider":{"Equatable":[]},"BitcoinExplorerAPIProvider":{"BaseBitcoinAPIProvider":[],"APIProvider":[],"Equatable":[]},"ElectrumAPIProvider":{"BaseBitcoinAPIProvider":[],"APIProvider":[],"Equatable":[]},"BaseBitcoinAPIProvider":{"APIProvider":[],"Equatable":[]},"CardanoAPIProvider":{"APIProvider":[],"Equatable":[]},"CosmosAPIProvider":{"APIProvider":[],"Equatable":[]},"EthereumAPIProvider":{"APIProvider":[],"Equatable":[]},"RippleAPIProvider":{"APIProvider":[],"Equatable":[]},"SolanaAPIProvider":{"APIProvider":[],"Equatable":[]},"SubstrateAPIProvider":{"APIProvider":[],"Equatable":[]},"TonAPIProvider":{"APIProvider":[],"Equatable":[]},"TronAPIProvider":{"APIProvider":[],"Equatable":[]},"ElectrumSSLSocketService":{"SSLService":["ElectrumAPIProvider"],"SSLService.T":"ElectrumAPIProvider"},"ElectrumSocketService":{"TCPService":["ElectrumAPIProvider"],"TCPService.T":"ElectrumAPIProvider"},"ElectrumWebsocketService":{"WebSocketService":["ElectrumAPIProvider"],"WebSocketService.T":"ElectrumAPIProvider"},"RippleWebsocketService":{"WebSocketService":["RippleAPIProvider"],"WebSocketService.T":"RippleAPIProvider"},"Chain":{"BaseChain":["@","ChainAccount<@,TokenCore<@>>","@","@","@"]},"ADAChain":{"Chain":["CardanoAPIProvider","CardanoNetworkParams","ADAAddress","TokenCore<@>","ICardanoAddress","WalletCardanoNetwork","CardanoClient","Web3RequestParams<@,@,@>"],"BaseChain":["@","ChainAccount<@,TokenCore<@>>","@","@","@"],"Chain.5":"WalletCardanoNetwork","Chain.2":"ADAAddress","Chain.4":"ICardanoAddress","Chain.6":"CardanoClient"},"BitcoinChain":{"Chain":["BaseBitcoinAPIProvider","BitcoinParams","BitcoinBaseAddress","TokenCore<@>","IBitcoinAddress","WalletBitcoinNetwork","BitcoinClient<IBitcoinAddress>","Web3RequestParams<@,@,@>"],"BaseChain":["@","ChainAccount<@,TokenCore<@>>","@","@","@"],"Chain.5":"WalletBitcoinNetwork","Chain.2":"BitcoinBaseAddress","Chain.4":"IBitcoinAddress","Chain.6":"BitcoinClient<IBitcoinAddress>"},"CosmosChain":{"Chain":["CosmosAPIProvider","CosmosNetworkParams","CosmosBaseAddress","TokenCore<@>","ICosmosAddress","WalletCosmosNetwork","CosmosClient","Web3RequestParams<@,@,@>"],"BaseChain":["@","ChainAccount<@,TokenCore<@>>","@","@","@"],"Chain.5":"WalletCosmosNetwork","Chain.2":"CosmosBaseAddress","Chain.4":"ICosmosAddress","Chain.6":"CosmosClient"},"EthereumChain":{"Chain":["EthereumAPIProvider","EthereumNetworkParams","ETHAddress","ETHERC20Token","IEthAddress","WalletEthereumNetwork","EthereumClient","Web3EthereumRequestParam<@,@>"],"BaseChain":["@","ChainAccount<@,TokenCore<@>>","@","@","@"],"Chain.5":"WalletEthereumNetwork","Chain.2":"ETHAddress","Chain.4":"IEthAddress","Chain.6":"EthereumClient"},"SolanaChain":{"Chain":["SolanaAPIProvider","SolanaNetworkParams","SolAddress","SolanaSPLToken","ISolanaAddress","WalletSolanaNetwork","SolanaClient","Web3RequestParams<@,@,@>"],"BaseChain":["@","ChainAccount<@,TokenCore<@>>","@","@","@"],"Chain.5":"WalletSolanaNetwork","Chain.2":"SolAddress","Chain.4":"ISolanaAddress","Chain.6":"SolanaClient"},"SubstrateChain":{"Chain":["SubstrateAPIProvider","SubstrateNetworkParams","SubstrateAddress","TokenCore<@>","ISubstrateAddress","WalletPolkadotNetwork","SubstrateClient","Web3RequestParams<@,@,@>"],"BaseChain":["@","ChainAccount<@,TokenCore<@>>","@","@","@"],"Chain.5":"WalletPolkadotNetwork","Chain.2":"SubstrateAddress","Chain.4":"ISubstrateAddress","Chain.6":"SubstrateClient"},"TonChain":{"Chain":["TonAPIProvider","TonNetworkParams","TonAddress","TonJettonToken","ITonAddress","WalletTonNetwork","TonClient","Web3RequestParams<@,@,@>"],"BaseChain":["@","ChainAccount<@,TokenCore<@>>","@","@","@"],"Chain.5":"WalletTonNetwork","Chain.2":"TonAddress","Chain.4":"ITonAddress","Chain.6":"TonClient"},"TronChain":{"Chain":["TronAPIProvider","TronNetworkParams","TronAddress","TronToken","ITronAddress","WalletTronNetwork","TronClient","Web3RequestParams<@,@,@>"],"BaseChain":["@","ChainAccount<@,TokenCore<@>>","@","@","@"],"Chain.5":"WalletTronNetwork","Chain.2":"TronAddress","Chain.4":"ITronAddress","Chain.6":"TronClient"},"RippleChain":{"Chain":["RippleAPIProvider","RippleNetworkParams","XRPAddress","RippleIssueToken","IXRPAddress","WalletXRPNetwork","RippleClient","Web3RequestParams<@,@,@>"],"BaseChain":["@","ChainAccount<@,TokenCore<@>>","@","@","@"],"Chain.5":"WalletXRPNetwork","Chain.2":"XRPAddress","Chain.4":"IXRPAddress","Chain.6":"RippleClient"},"AccountBalance":{"AddressBalanceCore":["BigInt"]},"IBitcoinCashAddress":{"IBitcoinAddress":[],"ChainAccount":["BitcoinBaseAddress","TokenCore<@>"],"Equatable":[]},"IBitcoinCashMultiSigAddress":{"IBitcoinAddress":[],"ChainAccount":["BitcoinBaseAddress","TokenCore<@>"],"Equatable":[]},"IBitcoinAddress":{"ChainAccount":["BitcoinBaseAddress","TokenCore<@>"],"Equatable":[]},"IBitcoinMultiSigAddress":{"IBitcoinAddress":[],"ChainAccount":["BitcoinBaseAddress","TokenCore<@>"],"Equatable":[]},"BitcoinMultiSigSignerDetais":{"Equatable":[]},"ICardanoAddress":{"ChainAccount":["ADAAddress","TokenCore<@>"],"Equatable":[]},"ICosmosAddress":{"ChainAccount":["CosmosBaseAddress","TokenCore<@>"],"Equatable":[]},"IEthAddress":{"ChainAccount":["ETHAddress","ETHERC20Token"],"Equatable":[]},"ISolanaAddress":{"ChainAccount":["SolAddress","SolanaSPLToken"],"Equatable":[]},"ISubstrateAddress":{"ChainAccount":["SubstrateAddress","TokenCore<@>"],"Equatable":[]},"ITonAddress":{"ChainAccount":["TonAddress","TonJettonToken"],"Equatable":[]},"TronMultiSigSignerDetais":{"Equatable":[]},"TronMultiSignatureAddress":{"Equatable":[]},"ITronAddress":{"ChainAccount":["TronAddress","TronToken"],"Equatable":[]},"ITronMultisigAddress":{"ITronAddress":[],"ChainAccount":["TronAddress","TronToken"],"Equatable":[]},"RippleMultiSigSignerDetais":{"Equatable":[]},"RippleMultiSignatureAddress":{"Equatable":[]},"IXRPAddress":{"ChainAccount":["XRPAddress","RippleIssueToken"],"Equatable":[]},"IXRPMultisigAddress":{"IXRPAddress":[],"ChainAccount":["XRPAddress","RippleIssueToken"],"Equatable":[]},"Web3AccountPermission":{"Equatable":[]},"Web3EthereumPermission":{"Web3AccountPermission":["ETHAddress"],"Equatable":[],"Web3AccountPermission.0":"ETHAddress"},"BitcoinContact":{"ContactCore":["BitcoinBaseAddress"],"Equatable":[]},"CardanoContact":{"ContactCore":["ADAAddress"],"Equatable":[]},"CosmosContact":{"ContactCore":["CosmosBaseAddress"],"Equatable":[]},"EthereumContract":{"ContactCore":["ETHAddress"],"Equatable":[]},"SolanaContact":{"ContactCore":["SolAddress"],"Equatable":[]},"SubstrateContact":{"ContactCore":["SubstrateAddress"],"Equatable":[]},"TonContact":{"ContactCore":["TonAddress"],"Equatable":[]},"TronContact":{"ContactCore":["TronAddress"],"Equatable":[]},"RippleContact":{"ContactCore":["XRPAddress"],"Equatable":[]},"WalletNetwork":{"Equatable":[]},"WalletBitcoinNetwork":{"WalletNetwork":["BitcoinParams"],"Equatable":[]},"WalletXRPNetwork":{"WalletNetwork":["RippleNetworkParams"],"Equatable":[]},"WalletEthereumNetwork":{"WalletNetwork":["EthereumNetworkParams"],"Equatable":[]},"WalletTronNetwork":{"WalletNetwork":["TronNetworkParams"],"Equatable":[]},"WalletSolanaNetwork":{"WalletNetwork":["SolanaNetworkParams"],"Equatable":[]},"WalletCardanoNetwork":{"WalletNetwork":["CardanoNetworkParams"],"Equatable":[]},"WalletCosmosNetwork":{"WalletNetwork":["CosmosNetworkParams"],"Equatable":[]},"WalletTonNetwork":{"WalletNetwork":["TonNetworkParams"],"Equatable":[]},"WalletPolkadotNetwork":{"WalletNetwork":["SubstrateNetworkParams"],"Equatable":[]},"WalletBitcoinCashNetwork":{"WalletBitcoinNetwork":[],"WalletNetwork":["BitcoinParams"],"Equatable":[]},"WalletKusamaNetwork":{"WalletPolkadotNetwork":[],"WalletNetwork":["SubstrateNetworkParams"],"Equatable":[]},"BitcoinParams":{"NetworkCoinParams":["BaseBitcoinAPIProvider"],"NetworkCoinParams.0":"BaseBitcoinAPIProvider"},"CardanoNetworkParams":{"NetworkCoinParams":["CardanoAPIProvider"],"NetworkCoinParams.0":"CardanoAPIProvider"},"CosmosNetworkParams":{"NetworkCoinParams":["CosmosAPIProvider"],"NetworkCoinParams.0":"CosmosAPIProvider"},"EthereumNetworkParams":{"NetworkCoinParams":["EthereumAPIProvider"],"NetworkCoinParams.0":"EthereumAPIProvider"},"RippleNetworkParams":{"NetworkCoinParams":["RippleAPIProvider"],"NetworkCoinParams.0":"RippleAPIProvider"},"SolanaNetworkParams":{"NetworkCoinParams":["SolanaAPIProvider"],"NetworkCoinParams.0":"SolanaAPIProvider"},"SubstrateNetworkParams":{"NetworkCoinParams":["SubstrateAPIProvider"],"NetworkCoinParams.0":"SubstrateAPIProvider"},"TonNetworkParams":{"NetworkCoinParams":["TonAPIProvider"],"NetworkCoinParams.0":"TonAPIProvider"},"TronNetworkParams":{"NetworkCoinParams":["TronAPIProvider"],"NetworkCoinParams.0":"TronAPIProvider"},"CardanoAddrDetails":{"Equatable":[]},"PermissionKeys":{"Equatable":[]},"RippleNFToken":{"NFTCore":[],"Equatable":[]},"Token":{"Equatable":[]},"ETHERC20Token":{"TokenCore":["BigInt"],"Equatable":[]},"RippleIssueToken":{"TokenCore":["BigRational"],"Equatable":[]},"TonJettonToken":{"TokenCore":["BigInt"],"Equatable":[]},"SolanaSPLToken":{"TokenCore":["BigInt"],"Equatable":[]},"TronTRC10Token":{"TronToken":[],"TokenCore":["BigInt"],"Equatable":[]},"TronToken":{"TokenCore":["BigInt"]},"TronTRC20Token":{"TronToken":[],"TokenCore":["BigInt"],"Equatable":[]},"Web3RequestParams":{"Web3MessageCore":[],"Web3BaseRequestParams":["1","2","3"]},"Web3EthereumRequestException":{"Web3Exception":[],"Exception":[]},"Web3EthereumRequestMethods":{"Web3RequestMethods":[]},"Web3EthereumRequestParam":{"Web3RequestParams":["1","2","ETHAddress"],"Web3MessageCore":[],"Web3BaseRequestParams":["1","2","ETHAddress"]},"Web3EthereumPermissionRequestParam":{"Web3EthereumRequestParam":["1","List<Web3AccountPermission<ETHAddress>>"],"Web3RequestParams":["1","List<Web3AccountPermission<ETHAddress>>","ETHAddress"],"Web3MessageCore":[],"Web3BaseRequestParams":["1","List<Web3AccountPermission<ETHAddress>>","ETHAddress"]},"Web3EthreumAddChain":{"Web3EthereumRequestParam":["@","@"],"Web3RequestParams":["@","@","ETHAddress"],"Web3MessageCore":[],"Web3BaseRequestParams":["@","@","ETHAddress"],"Web3RequestParams.1":"@"},"Web3EthreumPersonalSign":{"Web3EthereumRequestParam":["@","@"],"Web3RequestParams":["@","@","ETHAddress"],"Web3MessageCore":[],"Web3BaseRequestParams":["@","@","ETHAddress"],"Web3RequestParams.1":"@"},"Web3EthreumRequestAccounts":{"Web3EthereumRequestParam":["List<String>","List<Web3AccountPermission<ETHAddress>>"],"Web3RequestParams":["List<String>","List<Web3AccountPermission<ETHAddress>>","ETHAddress"],"Web3MessageCore":[],"Web3BaseRequestParams":["List<String>","List<Web3AccountPermission<ETHAddress>>","ETHAddress"],"Web3RequestParams.1":"List<Web3AccountPermission<ETHAddress>>"},"Web3EthreumSendTransaction":{"Web3EthereumRequestParam":["@","@"],"Web3RequestParams":["@","@","ETHAddress"],"Web3MessageCore":[],"Web3BaseRequestParams":["@","@","ETHAddress"],"Web3RequestParams.1":"@"},"Web3EthreumTypdedData":{"Web3EthereumRequestParam":["@","@"],"Web3RequestParams":["@","@","ETHAddress"],"Web3MessageCore":[],"Web3BaseRequestParams":["@","@","ETHAddress"],"Web3RequestParams.1":"@"},"Web3EthreumSwitchChain":{"Web3EthereumRequestParam":["@","@"],"Web3RequestParams":["@","@","ETHAddress"],"Web3MessageCore":[],"Web3BaseRequestParams":["@","@","ETHAddress"],"Web3RequestParams.1":"@"},"Web3RequestException":{"Web3Exception":[],"Exception":[]},"Web3InternalException":{"Web3Exception":[],"Exception":[]},"Web3ArgrumentException":{"Web3Exception":[],"Exception":[]},"Web3ArgsException":{"Web3Exception":[],"Exception":[]},"Web3ChainMessage":{"Web3MessageCore":[]},"Web3ResponseMessage":{"Web3MessageCore":[]},"Web3ExceptionMessage":{"Web3MessageCore":[]},"CustomCoins":{"CryptoCoins":["BipCoinConfig"]},"CustomProposal":{"BipProposal":[]},"AddressDerivationIndex":{"Equatable":[]},"Bip32AddressIndex":{"AddressDerivationIndex":[],"Equatable":[]},"MultiSigAddressIndex":{"AddressDerivationIndex":[],"Equatable":[]},"SubstrateAddressIndex":{"AddressDerivationIndex":[],"Equatable":[]},"ADAByronAddress":{"ADAAddress":[]},"ADAPointerAddress":{"ADAAddress":[]},"ADARewardAddress":{"ADAAddress":[]},"ADABaseAddress":{"ADAAddress":[]},"ADAShellyAddress":{"ADAAddress":[]},"ADAEnterpriseAddress":{"ADAAddress":[]},"StakeCred":{"FixedBytes":[],"Comparable":["FixedBytes"]},"StakeCredKey":{"StakeCred":[],"FixedBytes":[],"Comparable":["FixedBytes"]},"StakeCredScript":{"StakeCred":[],"FixedBytes":[],"Comparable":["FixedBytes"]},"FixedBytes":{"Comparable":["FixedBytes"]},"ETHAddress":{"SolidityAddress":[]},"Eip712TypedData":{"EIP712Base":[]},"EIP712Legacy":{"EIP712Base":[]},"SolidityAbiException":{"BlockchainUtilsException":[],"Exception":[]},"AddressCoder":{"ABICoder":["SolidityAddress"]},"ArrayCoder":{"ABICoder":["List<@>"]},"BooleanCoder":{"ABICoder":["bool"]},"BytesCoder":{"ABICoder":["List<int>"]},"FunctionCoder":{"ABICoder":["List<int>"]},"NumbersCoder":{"ABICoder":["BigInt"]},"StringCoder":{"ABICoder":["String"]},"TupleCoder":{"ABICoder":["List<@>"]},"TronAddress":{"SolidityAddress":[]},"PathException":{"Exception":[]},"PosixStyle":{"InternalStyle":[]},"UrlStyle":{"InternalStyle":[]},"WindowsStyle":{"InternalStyle":[]},"FileLocation":{"SourceLocation":[],"Comparable":["SourceLocation"]},"_FileSpan":{"SourceSpanWithContext":[],"SourceSpan":[],"Comparable":["SourceSpan"]},"SourceLocation":{"Comparable":["SourceLocation"]},"SourceLocationMixin":{"SourceLocation":[],"Comparable":["SourceLocation"]},"SourceSpan":{"Comparable":["SourceSpan"]},"SourceSpanBase":{"SourceSpan":[],"Comparable":["SourceSpan"]},"SourceSpanException":{"Exception":[]},"SourceSpanFormatException":{"FormatException":[],"Exception":[]},"SourceSpanMixin":{"SourceSpan":[],"Comparable":["SourceSpan"]},"SourceSpanWithContext":{"SourceSpan":[],"Comparable":["SourceSpan"]},"StringScannerException":{"FormatException":[],"Exception":[]},"TonContractException":{"BlockchainUtilsException":[],"Exception":[]},"TonDartPluginException":{"BlockchainUtilsException":[],"Exception":[]},"_EventStream":{"Stream":["1"],"Stream.T":"1"},"_EventStreamSubscription":{"StreamSubscription":["1"]},"XRPLAddressCodecException":{"BlockchainUtilsException":[],"Exception":[]}}'));
  A._Universe_addErasedTypes(init.typeUniverse, JSON.parse('{"UnmodifiableListBase":1,"__CastListBase__CastIterableBase_ListMixin":2,"NativeTypedArray":1,"_DelayedEvent":1,"UnmodifiableMapBase":2,"_SetBase":1,"Converter":2,"BitcoinNetworkAddress":1,"HTTPService":1,"BaseSocketService":1,"CryptoAddress":1,"Web3BaseRequestParams":3,"Web3EthereumPermissionRequestParam":1}'));
  var string$ = {
    x20must_: " must not be greater than the number of characters in the file, ",
    x3000000: "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
    x3723700: "7237005577332262213973186563042994240857116359379907606001950938285454250989",
    ABCDEF: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    Cannotff: "Cannot extract a file path from a URI with a fragment component",
    Cannotfq: "Cannot extract a file path from a URI with a query component",
    Cannotn: "Cannot extract a non-Windows file path from a file URI with an authority",
    Error_: "Error handler must accept one Object or one Object and a StackTrace as arguments, and return a value of the returned future's type",
    decodi: "decoding cbor required object, bytes or hex. no value provided for decoding.",
    handle: "handleError callback must take either an Object (the error), or both an Object (the error) and a StackTrace.",
    https_lda: "https://live.blockcypher.com/doge/address/#address/",
    https_ldt: "https://live.blockcypher.com/doge/tx/#txid/",
    https_lla: "https://live.blockcypher.com/ltc/address/#address/",
    https_llt: "https://live.blockcypher.com/ltc/tx/#txid/",
    https_pa: "https://polkadot.subscan.io/account/#address",
    https_pe: "https://polkadot.subscan.io/extrinsic/#txid"
  };
  var type$ = (function rtii() {
    var findType = A.findType;
    return {
      $env_1_1_dynamic: findType("@<@>"),
      $env_1_1_void: findType("@<~>"),
      ADAAddress: findType("ADAAddress"),
      ADAAddressType: findType("ADAAddressType"),
      ADABaseAddress: findType("ADABaseAddress"),
      ADAByronAddrTypes: findType("ADAByronAddrTypes"),
      ADANetwork: findType("ADANetwork"),
      ADARewardAddress: findType("ADARewardAddress"),
      APIProvider: findType("APIProvider"),
      APPImage: findType("APPImage"),
      AbiParameter: findType("AbiParameter"),
      AccountPermission: findType("AccountPermission"),
      AdaStakeCredential: findType("AdaStakeCredential"),
      AddressDerivationType: findType("AddressDerivationType"),
      ApiRequest: findType("ApiRequest"),
      AssetV2: findType("AssetV2"),
      AsyncError: findType("AsyncError"),
      Base58Alphabets: findType("Base58Alphabets"),
      Base64Codec: findType("Base64Codec"),
      BaseBitcoinAPIProvider: findType("BaseBitcoinAPIProvider"),
      BaseChain_of_dynamic_and_ChainAccount_of_dynamic_and_TokenCore_dynamic_and_dynamic_and_dynamic_and_dynamic: findType("BaseChain<@,ChainAccount<@,TokenCore<@>>,@,@,@>"),
      BasedUtxoNetwork: findType("BasedUtxoNetwork"),
      Bech32Encodings: findType("Bech32Encodings"),
      BigInt: findType("BigInt"),
      Bip32ChainCode: findType("Bip32ChainCode"),
      Bip32Path: findType("Bip32Path"),
      Bip44Coins: findType("Bip44Coins"),
      Bip49Coins: findType("Bip49Coins"),
      Bip84Coins: findType("Bip84Coins"),
      Bip86Coins: findType("Bip86Coins"),
      BipCoinConfig: findType("BipCoinConfig"),
      BipProposal: findType("BipProposal"),
      BitcoinAddressType: findType("BitcoinAddressType"),
      BitcoinBaseAddress: findType("BitcoinBaseAddress"),
      BitcoinClient_IBitcoinAddress: findType("BitcoinClient<IBitcoinAddress>"),
      BitcoinExplorerAPIProvider: findType("BitcoinExplorerAPIProvider"),
      BitcoinExplorerProviderType: findType("BitcoinExplorerProviderType"),
      BitcoinMultiSigSignerDetais: findType("BitcoinMultiSigSignerDetais"),
      BlockchainUtilsException: findType("BlockchainUtilsException"),
      ByteBuffer: findType("ByteBuffer"),
      ByteData: findType("ByteData"),
      CardanoAPIProvider: findType("CardanoAPIProvider"),
      CardanoClient: findType("CardanoClient"),
      CborBase64Types: findType("CborBase64Types"),
      CborBytesValue: findType("CborBytesValue"),
      CborIntValue: findType("CborIntValue"),
      CborListValue_CborBytesValue: findType("CborListValue<CborBytesValue>"),
      CborListValue_CborObject: findType("CborListValue<CborObject>"),
      CborListValue_Object: findType("CborListValue<Object>"),
      CborListValue_dynamic: findType("CborListValue<@>"),
      CborListValue_int: findType("CborListValue<int>"),
      CborMapValue_CborObject_CborObject: findType("CborMapValue<CborObject,CborObject>"),
      CborMapValue_dynamic_dynamic: findType("CborMapValue<@,@>"),
      CborNumeric: findType("CborNumeric"),
      CborObject: findType("CborObject"),
      CborSetValue_CborObject: findType("CborSetValue<CborObject>"),
      CborStringValue: findType("CborStringValue"),
      CborTagValue_CborBigFloatValue: findType("CborTagValue<CborBigFloatValue>"),
      CborTagValue_CborDecimalFracValue: findType("CborTagValue<CborDecimalFracValue>"),
      CborTagValue_CborDynamicBytesValue: findType("CborTagValue<CborDynamicBytesValue>"),
      CborTagValue_CborEpochIntValue: findType("CborTagValue<CborEpochIntValue>"),
      CborTagValue_CborIndefiniteStringValue: findType("CborTagValue<CborIndefiniteStringValue>"),
      CborTagValue_CborListValue_CborObject: findType("CborTagValue<CborListValue<CborObject>>"),
      CborTagValue_CborMapValue_CborObject_CborObject: findType("CborTagValue<CborMapValue<CborObject,CborObject>>"),
      CborTagValue_CborNumeric: findType("CborTagValue<CborNumeric>"),
      CborTagValue_CborObject: findType("CborTagValue<CborObject>"),
      CborTagValue_CborSetValue_CborObject: findType("CborTagValue<CborSetValue<CborObject>>"),
      CborTagValue_List_int: findType("CborTagValue<List<int>>"),
      CborTagValue_dynamic: findType("CborTagValue<@>"),
      ChainAccount_of_dynamic_and_TokenCore_dynamic: findType("ChainAccount<@,TokenCore<@>>"),
      ChainAccount_of_nullable_Object_and_TokenCore_dynamic: findType("ChainAccount<Object?,TokenCore<@>>"),
      Chain_of_APIProvider_and_NetworkCoinParams_APIProvider_and_dynamic_and_TokenCore_dynamic_and_ChainAccount_of_dynamic_and_TokenCore_dynamic_and_WalletNetwork_NetworkCoinParams_APIProvider_and_NetworkClient_of_ChainAccount_of_dynamic_and_TokenCore_dynamic_and_APIProvider_and_Web3BaseRequestParams_dynamic_dynamic_dynamic: findType("Chain<APIProvider,NetworkCoinParams<APIProvider>,@,TokenCore<@>,ChainAccount<@,TokenCore<@>>,WalletNetwork<NetworkCoinParams<APIProvider>>,NetworkClient<ChainAccount<@,TokenCore<@>>,APIProvider>,Web3BaseRequestParams<@,@,@>>"),
      Chain_of_APIProvider_and_NetworkCoinParams_APIProvider_and_dynamic_and_TokenCore_dynamic_and_ChainAccount_of_nullable_Object_and_TokenCore_dynamic_and_WalletNetwork_NetworkCoinParams_APIProvider_and_NetworkClient_of_ChainAccount_of_nullable_Object_and_TokenCore_dynamic_and_APIProvider_and_Web3BaseRequestParams_dynamic_dynamic_dynamic: findType("Chain<APIProvider,NetworkCoinParams<APIProvider>,@,TokenCore<@>,ChainAccount<Object?,TokenCore<@>>,WalletNetwork<NetworkCoinParams<APIProvider>>,NetworkClient<ChainAccount<Object?,TokenCore<@>>,APIProvider>,Web3BaseRequestParams<@,@,@>>"),
      Cip1852Coins: findType("Cip1852Coins"),
      CodeUnits: findType("CodeUnits"),
      CoingeckoCoin: findType("CoingeckoCoin"),
      Comparable_dynamic: findType("Comparable<@>"),
      ConstantMapView_Symbol_dynamic: findType("ConstantMapView<Symbol0,@>"),
      ContactCore_ADAAddress: findType("ContactCore<ADAAddress>"),
      ContactCore_BitcoinBaseAddress: findType("ContactCore<BitcoinBaseAddress>"),
      ContactCore_CosmosBaseAddress: findType("ContactCore<CosmosBaseAddress>"),
      ContactCore_ETHAddress: findType("ContactCore<ETHAddress>"),
      ContactCore_SolAddress: findType("ContactCore<SolAddress>"),
      ContactCore_SubstrateAddress: findType("ContactCore<SubstrateAddress>"),
      ContactCore_TonAddress: findType("ContactCore<TonAddress>"),
      ContactCore_TronAddress: findType("ContactCore<TronAddress>"),
      ContactCore_XRPAddress: findType("ContactCore<XRPAddress>"),
      ContentType: findType("ContentType"),
      CosmosAPIProvider: findType("CosmosAPIProvider"),
      CosmosBaseAddress: findType("CosmosBaseAddress"),
      CosmosClient: findType("CosmosClient"),
      CosmosNativeCoin: findType("CosmosNativeCoin"),
      CosmosNetworkTypes: findType("CosmosNetworkTypes"),
      CryptoCoins_CoinConfig: findType("CryptoCoins<CoinConfig>"),
      CurveFp: findType("CurveFp"),
      CustomCoins: findType("CustomCoins"),
      DateTime: findType("DateTime"),
      Duration: findType("Duration"),
      EIP712Base: findType("EIP712Base"),
      EIP712Version: findType("EIP712Version"),
      ETHAddress: findType("ETHAddress"),
      ETHERC20Token: findType("ETHERC20Token"),
      EfficientLengthIterable_dynamic: findType("EfficientLengthIterable<@>"),
      Eip712TypeDetails: findType("Eip712TypeDetails"),
      Eip712TypedDataV1: findType("Eip712TypedDataV1"),
      ElectrumRequestDetails: findType("ElectrumRequestDetails"),
      EllipticCurveTypes: findType("EllipticCurveTypes"),
      EncoderResult: findType("EncoderResult"),
      Equatable: findType("Equatable"),
      Error: findType("Error"),
      EthereumAPIProvider: findType("EthereumAPIProvider"),
      EthereumClient: findType("EthereumClient"),
      Exception: findType("Exception"),
      FixedBytes: findType("FixedBytes"),
      Float32List: findType("Float32List"),
      Float64List: findType("Float64List"),
      FormatException: findType("FormatException"),
      FreeAssetNetUsageV2: findType("FreeAssetNetUsageV2"),
      FriendlyAddressFlags: findType("FriendlyAddressFlags"),
      FrozenSupply: findType("FrozenSupply"),
      FrozenV2: findType("FrozenV2"),
      Function: findType("Function"),
      FutureOr_Map_String_dynamic: findType("Map<String,@>/"),
      Future_Map_String_dynamic_Function: findType("Future<Map<String,@>>()"),
      Future_Response_Function: findType("Future<Response>()"),
      Future_dynamic: findType("Future<@>"),
      IBitcoinAddress: findType("IBitcoinAddress"),
      ICardanoAddress: findType("ICardanoAddress"),
      ICosmosAddress: findType("ICosmosAddress"),
      IEthAddress: findType("IEthAddress"),
      ISolanaAddress: findType("ISolanaAddress"),
      ISubstrateAddress: findType("ISubstrateAddress"),
      ITonAddress: findType("ITonAddress"),
      ITronAddress: findType("ITronAddress"),
      IXRPAddress: findType("IXRPAddress"),
      Int16List: findType("Int16List"),
      Int32List: findType("Int32List"),
      Int8List: findType("Int8List"),
      Invocation: findType("Invocation"),
      Iterable_String: findType("Iterable<String>"),
      Iterable_dynamic: findType("Iterable<@>"),
      Iterable_int: findType("Iterable<int>"),
      Iterable_nullable_Object: findType("Iterable<Object?>"),
      JSArray_APIProvider: findType("JSArray<APIProvider>"),
      JSArray_ApiRequest: findType("JSArray<ApiRequest>"),
      JSArray_AppPlatform: findType("JSArray<AppPlatform>"),
      JSArray_BaseBitcoinAPIProvider: findType("JSArray<BaseBitcoinAPIProvider>"),
      JSArray_BigInt: findType("JSArray<BigInt>"),
      JSArray_BitcoinAddressType: findType("JSArray<BitcoinAddressType>"),
      JSArray_CborBytesValue: findType("JSArray<CborBytesValue>"),
      JSArray_CborObject: findType("JSArray<CborObject>"),
      JSArray_ContactCore_ADAAddress: findType("JSArray<ContactCore<ADAAddress>>"),
      JSArray_ContactCore_BitcoinBaseAddress: findType("JSArray<ContactCore<BitcoinBaseAddress>>"),
      JSArray_ContactCore_CosmosBaseAddress: findType("JSArray<ContactCore<CosmosBaseAddress>>"),
      JSArray_ContactCore_ETHAddress: findType("JSArray<ContactCore<ETHAddress>>"),
      JSArray_ContactCore_SolAddress: findType("JSArray<ContactCore<SolAddress>>"),
      JSArray_ContactCore_SubstrateAddress: findType("JSArray<ContactCore<SubstrateAddress>>"),
      JSArray_ContactCore_TonAddress: findType("JSArray<ContactCore<TonAddress>>"),
      JSArray_ContactCore_TronAddress: findType("JSArray<ContactCore<TronAddress>>"),
      JSArray_ContactCore_XRPAddress: findType("JSArray<ContactCore<XRPAddress>>"),
      JSArray_CosmosAPIProvider: findType("JSArray<CosmosAPIProvider>"),
      JSArray_CosmosNativeCoin: findType("JSArray<CosmosNativeCoin>"),
      JSArray_ETHERC20Token: findType("JSArray<ETHERC20Token>"),
      JSArray_EncoderResult: findType("JSArray<EncoderResult>"),
      JSArray_EthereumAPIProvider: findType("JSArray<EthereumAPIProvider>"),
      JSArray_FriendlyAddressFlags: findType("JSArray<FriendlyAddressFlags>"),
      JSArray_IBitcoinAddress: findType("JSArray<IBitcoinAddress>"),
      JSArray_ICardanoAddress: findType("JSArray<ICardanoAddress>"),
      JSArray_ICosmosAddress: findType("JSArray<ICosmosAddress>"),
      JSArray_IEthAddress: findType("JSArray<IEthAddress>"),
      JSArray_ISolanaAddress: findType("JSArray<ISolanaAddress>"),
      JSArray_ISubstrateAddress: findType("JSArray<ISubstrateAddress>"),
      JSArray_ITonAddress: findType("JSArray<ITonAddress>"),
      JSArray_ITronAddress: findType("JSArray<ITronAddress>"),
      JSArray_IXRPAddress: findType("JSArray<IXRPAddress>"),
      JSArray_List_BigInt: findType("JSArray<List<BigInt>>"),
      JSArray_NFTCore: findType("JSArray<NFTCore>"),
      JSArray_Object: findType("JSArray<Object>"),
      JSArray_RippleIssueToken: findType("JSArray<RippleIssueToken>"),
      JSArray_RippleNFToken: findType("JSArray<RippleNFToken>"),
      JSArray_SolanaSPLToken: findType("JSArray<SolanaSPLToken>"),
      JSArray_String: findType("JSArray<String>"),
      JSArray_TokenCore_BigInt: findType("JSArray<TokenCore<BigInt>>"),
      JSArray_TokenCore_dynamic: findType("JSArray<TokenCore<@>>"),
      JSArray_TronTRC10Token: findType("JSArray<TronTRC10Token>"),
      JSArray_TronTRC20Token: findType("JSArray<TronTRC20Token>"),
      JSArray__Highlight: findType("JSArray<_Highlight>"),
      JSArray__Line: findType("JSArray<_Line>"),
      JSArray_double: findType("JSArray<double>"),
      JSArray_dynamic: findType("JSArray<@>"),
      JSArray_int: findType("JSArray<int>"),
      JSArray_nullable_String: findType("JSArray<String?>"),
      JSArray_nullable_int: findType("JSArray<int?>"),
      JSNull: findType("JSNull"),
      JSObject: findType("JSObject"),
      JavaScriptFunction: findType("JavaScriptFunction"),
      JavaScriptIndexingBehavior_dynamic: findType("JavaScriptIndexingBehavior<@>"),
      JsLinkedHashMap_Symbol_dynamic: findType("JsLinkedHashMap<Symbol0,@>"),
      ListMapView_String: findType("ListMapView<String>"),
      List_APIProvider: findType("List<APIProvider>"),
      List_BigInt: findType("List<BigInt>"),
      List_Eip712TypeDetails: findType("List<Eip712TypeDetails>"),
      List_List_BigInt: findType("List<List<BigInt>>"),
      List_List_int: findType("List<List<int>>"),
      List_Map_String_dynamic: findType("List<Map<String,@>>"),
      List_String: findType("List<String>"),
      List_double: findType("List<double>"),
      List_dynamic: findType("List<@>"),
      List_int: findType("List<int>"),
      List_int_Function_EncoderResult: findType("List<int>(EncoderResult)"),
      List_nullable_Object: findType("List<Object?>"),
      List_nullable__Highlight: findType("List<_Highlight?>"),
      Live_APIServiceStatus: findType("Live<APIServiceStatus>"),
      Live_DecimalBalance: findType("Live<DecimalBalance>"),
      Live_IntegerBalance: findType("Live<IntegerBalance>"),
      Live_NodeClientStatus: findType("Live<NodeClientStatus>"),
      MapEntry_CborObject_CborObject: findType("MapEntry<CborObject,CborObject>"),
      MapEntry_String_dynamic: findType("MapEntry<String,@>"),
      MapEntry_int_String: findType("MapEntry<int,String>"),
      MapEntry_of_Object_and_List__Highlight: findType("MapEntry<Object,List<_Highlight>>"),
      MapEntry_of_String_and_List_Map_String_dynamic: findType("MapEntry<String,List<Map<String,@>>>"),
      Map_String_dynamic: findType("Map<String,@>"),
      Map_dynamic_dynamic: findType("Map<@,@>"),
      Map_of_nullable_Object_and_nullable_Object: findType("Map<Object?,Object?>"),
      MappedListIterable_String_dynamic: findType("MappedListIterable<String,@>"),
      MappedListIterable_of_EncoderResult_and_List_int: findType("MappedListIterable<EncoderResult,List<int>>"),
      MediaType: findType("MediaType"),
      MessageCompleter: findType("MessageCompleter"),
      MoneroCoins: findType("MoneroCoins"),
      NFTCore: findType("NFTCore"),
      NativeByteBuffer: findType("NativeByteBuffer"),
      NativeTypedArrayOfInt: findType("NativeTypedArrayOfInt"),
      NativeUint8List: findType("NativeUint8List"),
      NetworkClient_of_ChainAccount_of_nullable_Object_and_TokenCore_dynamic_and_APIProvider: findType("NetworkClient<ChainAccount<Object?,TokenCore<@>>,APIProvider>"),
      NetworkCoinParams_APIProvider: findType("NetworkCoinParams<APIProvider>"),
      NetworkType: findType("NetworkType"),
      Null: findType("Null"),
      Object: findType("Object"),
      P2shAddressType: findType("P2shAddressType"),
      PermissionKeys: findType("PermissionKeys"),
      PermissionType: findType("PermissionType"),
      PlatformWebScoket: findType("PlatformWebScoket"),
      ProjectiveECCPoint: findType("ProjectiveECCPoint"),
      ProviderAuth: findType("ProviderAuth"),
      ProviderAuthType: findType("ProviderAuthType"),
      RPCRequestDetails: findType("RPCRequestDetails"),
      RawSecureSocket: findType("RawSecureSocket"),
      RawSocketEvent: findType("RawSocketEvent"),
      Record: findType("Record"),
      RegExpMatch: findType("RegExpMatch"),
      ResourceCode: findType("ResourceCode"),
      Response: findType("Response"),
      ReversedListIterable_String: findType("ReversedListIterable<String>"),
      ReversedListIterable_int: findType("ReversedListIterable<int>"),
      RippleAPIProvider: findType("RippleAPIProvider"),
      RippleClient: findType("RippleClient"),
      RippleIssueToken: findType("RippleIssueToken"),
      RippleMultiSigSignerDetais: findType("RippleMultiSigSignerDetais"),
      RippleNFToken: findType("RippleNFToken"),
      Runes: findType("Runes"),
      SecureSocket: findType("SecureSocket"),
      SeedTypes: findType("SeedTypes"),
      ServiceProtocol: findType("ServiceProtocol"),
      Socket: findType("Socket"),
      SocketRequestCompeleter: findType("SocketRequestCompeleter"),
      SolAddress: findType("SolAddress"),
      SolanaAPIProvider: findType("SolanaAPIProvider"),
      SolanaClient: findType("SolanaClient"),
      SolanaSPLToken: findType("SolanaSPLToken"),
      SolidityAddress: findType("SolidityAddress"),
      SourceLocation: findType("SourceLocation"),
      SourceSpan: findType("SourceSpan"),
      SourceSpanWithContext: findType("SourceSpanWithContext"),
      StackTrace: findType("StackTrace"),
      StreamSubscription_RawSocketEvent: findType("StreamSubscription<RawSocketEvent>"),
      StreamedResponse: findType("StreamedResponse"),
      String: findType("String"),
      String_Function_Match: findType("String(Match)"),
      SubstrateAPIProvider: findType("SubstrateAPIProvider"),
      SubstrateAddress: findType("SubstrateAddress"),
      SubstrateClient: findType("SubstrateClient"),
      SubstrateCoins: findType("SubstrateCoins"),
      Symbol: findType("Symbol0"),
      TokenCore_BigInt: findType("TokenCore<BigInt>"),
      TokenCore_dynamic: findType("TokenCore<@>"),
      TonAPIProvider: findType("TonAPIProvider"),
      TonAddress: findType("TonAddress"),
      TonApiType: findType("TonApiType"),
      TonClient: findType("TonClient"),
      TonJettonToken: findType("TonJettonToken"),
      TronAPIProvider: findType("TronAPIProvider"),
      TronAddress: findType("TronAddress"),
      TronClient: findType("TronClient"),
      TronMultiSigSignerDetais: findType("TronMultiSigSignerDetais"),
      TronTRC10Token: findType("TronTRC10Token"),
      TronTRC20Token: findType("TronTRC20Token"),
      TrustedGetRuntimeType: findType("TrustedGetRuntimeType"),
      Tuple_AbiParameter_int: findType("Tuple<AbiParameter,int>"),
      Tuple_BigInt_BigInt: findType("Tuple<BigInt,BigInt>"),
      Tuple_BigInt_int: findType("Tuple<BigInt,int>"),
      Tuple_CborObject_int: findType("Tuple<CborObject,int>"),
      Tuple_String_dynamic: findType("Tuple<String,@>"),
      Tuple_String_int: findType("Tuple<String,int>"),
      Tuple_bool_BigInt: findType("Tuple<bool,BigInt>"),
      Tuple_bool_bool: findType("Tuple<bool,bool>"),
      Tuple_dynamic_int: findType("Tuple<@,int>"),
      Tuple_int_int: findType("Tuple<int,int>"),
      Tuple_of_List_int_and_FloatLength: findType("Tuple<List<int>,FloatLength>"),
      Tuple_of_List_int_and_List_int: findType("Tuple<List<int>,List<int>>"),
      Tuple_of_List_int_and_int: findType("Tuple<List<int>,int>"),
      Tuple_of_String_and_List_int: findType("Tuple<String,List<int>>"),
      Tuple_of_int_and_List_int: findType("Tuple<int,List<int>>"),
      TypeError: findType("TypeError"),
      Uint16List: findType("Uint16List"),
      Uint32List: findType("Uint32List"),
      Uint8ClampedList: findType("Uint8ClampedList"),
      Uint8List: findType("Uint8List"),
      UnfrozenV2: findType("UnfrozenV2"),
      UnknownJavaScriptObject: findType("UnknownJavaScriptObject"),
      UnmodifiableMapView_String_String: findType("UnmodifiableMapView<String,String>"),
      Uri: findType("Uri"),
      WalletBitcoinCashNetwork: findType("WalletBitcoinCashNetwork"),
      WalletBitcoinNetwork: findType("WalletBitcoinNetwork"),
      WalletCardanoNetwork: findType("WalletCardanoNetwork"),
      WalletCosmosNetwork: findType("WalletCosmosNetwork"),
      WalletEthereumNetwork: findType("WalletEthereumNetwork"),
      WalletNetwork_NetworkCoinParams_APIProvider: findType("WalletNetwork<NetworkCoinParams<APIProvider>>"),
      WalletPolkadotNetwork: findType("WalletPolkadotNetwork"),
      WalletSolanaNetwork: findType("WalletSolanaNetwork"),
      WalletTonNetwork: findType("WalletTonNetwork"),
      WalletTronNetwork: findType("WalletTronNetwork"),
      WalletVersion: findType("WalletVersion"),
      WalletXRPNetwork: findType("WalletXRPNetwork"),
      Web3BaseRequestParams_dynamic_dynamic_dynamic: findType("Web3BaseRequestParams<@,@,@>"),
      Web3ChainMessage: findType("Web3ChainMessage"),
      Web3EncryptedMessage: findType("Web3EncryptedMessage"),
      Web3EthereumRequestMethods: findType("Web3EthereumRequestMethods"),
      Web3Exception: findType("Web3Exception"),
      Web3ExceptionMessage: findType("Web3ExceptionMessage"),
      Web3MessageCore: findType("Web3MessageCore"),
      Web3MessageTypes: findType("Web3MessageTypes"),
      Web3PermissionActivities: findType("Web3PermissionActivities"),
      Web3Permission_ADAAddress: findType("Web3Permission<ADAAddress>"),
      Web3Permission_BitcoinBaseAddress: findType("Web3Permission<BitcoinBaseAddress>"),
      Web3Permission_CosmosBaseAddress: findType("Web3Permission<CosmosBaseAddress>"),
      Web3Permission_ETHAddress: findType("Web3Permission<ETHAddress>"),
      Web3Permission_SolAddress: findType("Web3Permission<SolAddress>"),
      Web3Permission_SubstrateAddress: findType("Web3Permission<SubstrateAddress>"),
      Web3Permission_TonAddress: findType("Web3Permission<TonAddress>"),
      Web3Permission_TronAddress: findType("Web3Permission<TronAddress>"),
      Web3Permission_XRPAddress: findType("Web3Permission<XRPAddress>"),
      Web3ResponseMessage: findType("Web3ResponseMessage"),
      WebsocketWeb: findType("WebsocketWeb"),
      WhereIterable_String: findType("WhereIterable<String>"),
      WhereTypeIterable_CborBytesValue: findType("WhereTypeIterable<CborBytesValue>"),
      WhereTypeIterable_CborNumeric: findType("WhereTypeIterable<CborNumeric>"),
      WhereTypeIterable_CborStringValue: findType("WhereTypeIterable<CborStringValue>"),
      WhereTypeIterable_String: findType("WhereTypeIterable<String>"),
      XRPAddress: findType("XRPAddress"),
      _AsyncCompleter_JSWalletHandler: findType("_AsyncCompleter<JSWalletHandler>"),
      _AsyncCompleter_List_Web3AccountPermission_ETHAddress: findType("_AsyncCompleter<List<Web3AccountPermission<ETHAddress>>>"),
      _AsyncCompleter_RawSecureSocket: findType("_AsyncCompleter<RawSecureSocket>"),
      _AsyncCompleter_StreamedResponse: findType("_AsyncCompleter<StreamedResponse>"),
      _AsyncCompleter_Uint8List: findType("_AsyncCompleter<Uint8List>"),
      _AsyncCompleter_WebsocketWeb: findType("_AsyncCompleter<WebsocketWeb>"),
      _AsyncCompleter__RawSecureSocket: findType("_AsyncCompleter<_RawSecureSocket>"),
      _AsyncCompleter_dynamic: findType("_AsyncCompleter<@>"),
      _AsyncCompleter_nullable_Object: findType("_AsyncCompleter<Object?>"),
      _AsyncCompleter_void: findType("_AsyncCompleter<~>"),
      _BigIntImpl: findType("_BigIntImpl"),
      _EventStream_JSObject: findType("_EventStream<JSObject>"),
      _FilterStatus: findType("_FilterStatus"),
      _Future_JSWalletHandler: findType("_Future<JSWalletHandler>"),
      _Future_List_Web3AccountPermission_ETHAddress: findType("_Future<List<Web3AccountPermission<ETHAddress>>>"),
      _Future_RawSecureSocket: findType("_Future<RawSecureSocket>"),
      _Future_StreamedResponse: findType("_Future<StreamedResponse>"),
      _Future_Uint8List: findType("_Future<Uint8List>"),
      _Future_WebsocketWeb: findType("_Future<WebsocketWeb>"),
      _Future__RawSecureSocket: findType("_Future<_RawSecureSocket>"),
      _Future_dynamic: findType("_Future<@>"),
      _Future_int: findType("_Future<int>"),
      _Future_nullable_Object: findType("_Future<Object?>"),
      _Future_void: findType("_Future<~>"),
      _Highlight: findType("_Highlight"),
      _IdentityHashMap_of_nullable_Object_and_nullable_Object: findType("_IdentityHashMap<Object?,Object?>"),
      _Line: findType("_Line"),
      _StreamControllerAddStreamState_nullable_Object: findType("_StreamControllerAddStreamState<Object?>"),
      _SyncCompleter_void: findType("_SyncCompleter<~>"),
      bool: findType("bool"),
      bool_Function_Object: findType("bool(Object)"),
      bool_Function_String: findType("bool(String)"),
      bool_Function__Highlight: findType("bool(_Highlight)"),
      double: findType("double"),
      dynamic: findType("@"),
      dynamic_Function: findType("@()"),
      dynamic_Function_Object: findType("@(Object)"),
      dynamic_Function_Object_StackTrace: findType("@(Object,StackTrace)"),
      dynamic_Function_String: findType("@(String)"),
      int: findType("int"),
      legacy_Never: findType("0&*"),
      legacy_Object: findType("Object*"),
      nullable_BigInt: findType("BigInt?"),
      nullable_BitcoinParams: findType("BitcoinParams?"),
      nullable_CardanoNetworkParams: findType("CardanoNetworkParams?"),
      nullable_CborListValue_dynamic: findType("CborListValue<@>?"),
      nullable_CborObject: findType("CborObject?"),
      nullable_CborTagValue_dynamic: findType("CborTagValue<@>?"),
      nullable_Chain_of_APIProvider_and_NetworkCoinParams_APIProvider_and_dynamic_and_TokenCore_dynamic_and_ChainAccount_of_dynamic_and_TokenCore_dynamic_and_WalletNetwork_NetworkCoinParams_APIProvider_and_NetworkClient_of_ChainAccount_of_dynamic_and_TokenCore_dynamic_and_APIProvider_and_Web3BaseRequestParams_dynamic_dynamic_dynamic: findType("Chain<APIProvider,NetworkCoinParams<APIProvider>,@,TokenCore<@>,ChainAccount<@,TokenCore<@>>,WalletNetwork<NetworkCoinParams<APIProvider>>,NetworkClient<ChainAccount<@,TokenCore<@>>,APIProvider>,Web3BaseRequestParams<@,@,@>>?"),
      nullable_CosmosNetworkParams: findType("CosmosNetworkParams?"),
      nullable_DateTime: findType("DateTime?"),
      nullable_Duration: findType("Duration?"),
      nullable_EthereumNetworkParams: findType("EthereumNetworkParams?"),
      nullable_Future_Null: findType("Future<Null>?"),
      nullable_JSArray_nullable_Object: findType("JSArray<Object?>?"),
      nullable_List_CborObject: findType("List<CborObject>?"),
      nullable_List_dynamic: findType("List<@>?"),
      nullable_List_int: findType("List<int>?"),
      nullable_Map_String_String: findType("Map<String,String>?"),
      nullable_Map_String_dynamic: findType("Map<String,@>?"),
      nullable_Object: findType("Object?"),
      nullable_PlatformWebScoket: findType("PlatformWebScoket?"),
      nullable_RawSocket: findType("RawSocket?"),
      nullable_RippleNetworkParams: findType("RippleNetworkParams?"),
      nullable_SecureSocket: findType("SecureSocket?"),
      nullable_Socket: findType("Socket?"),
      nullable_SolanaNetworkParams: findType("SolanaNetworkParams?"),
      nullable_StackTrace: findType("StackTrace?"),
      nullable_StreamSubscription_List_int: findType("StreamSubscription<List<int>>?"),
      nullable_StreamSubscription_String: findType("StreamSubscription<String>?"),
      nullable_String: findType("String?"),
      nullable_String_Function_Match: findType("String(Match)?"),
      nullable_SubstrateNetworkParams: findType("SubstrateNetworkParams?"),
      nullable_TonNetworkParams: findType("TonNetworkParams?"),
      nullable_TronNetworkParams: findType("TronNetworkParams?"),
      nullable__DelayedEvent_dynamic: findType("_DelayedEvent<@>?"),
      nullable__FutureListener_dynamic_dynamic: findType("_FutureListener<@,@>?"),
      nullable__Highlight: findType("_Highlight?"),
      nullable__LinkedHashSetCell: findType("_LinkedHashSetCell?"),
      nullable_bool: findType("bool?"),
      nullable_int: findType("int?"),
      nullable_void_Function: findType("~()?"),
      nullable_void_Function_RawSocketEvent: findType("~(RawSocketEvent)?"),
      num: findType("num"),
      void: findType("~"),
      void_Function: findType("~()"),
      void_Function_List_int: findType("~(List<int>)"),
      void_Function_Object: findType("~(Object)"),
      void_Function_Object_StackTrace: findType("~(Object,StackTrace)"),
      void_Function_String_dynamic: findType("~(String,@)")
    };
  })();
  (function constants() {
    var makeConstList = hunkHelpers.makeConstList;
    B.Interceptor_methods = J.Interceptor.prototype;
    B.JSArray_methods = J.JSArray.prototype;
    B.JSBool_methods = J.JSBool.prototype;
    B.JSInt_methods = J.JSInt.prototype;
    B.JSNumber_methods = J.JSNumber.prototype;
    B.JSString_methods = J.JSString.prototype;
    B.JavaScriptFunction_methods = J.JavaScriptFunction.prototype;
    B.JavaScriptObject_methods = J.JavaScriptObject.prototype;
    B.NativeByteData_methods = A.NativeByteData.prototype;
    B.NativeUint32List_methods = A.NativeUint32List.prototype;
    B.NativeUint8List_methods = A.NativeUint8List.prototype;
    B.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
    B.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
    B.ADAAddressType_0_Base = new A.ADAAddressType(0, "Base");
    B.ADAAddressType_14_Reward = new A.ADAAddressType(14, "Reward");
    B.ADAAddressType_4_Pointer = new A.ADAAddressType(4, "Pointer");
    B.ADAAddressType_6_Enterprise = new A.ADAAddressType(6, "Enterprise");
    B.ADAAddressType_8_Byron = new A.ADAAddressType(8, "Byron");
    B.ADAByronAddrTypes_0_publicKey = new A.ADAByronAddrTypes(0, "publicKey");
    B.ADANetwork_0_1097911063_testnet = new A.ADANetwork(0, 1097911063, "testnet");
    B.ADANetwork_0_1_testnetPreprod = new A.ADANetwork(0, 1, "testnetPreprod");
    B.ADANetwork_0_2_testnetPreview = new A.ADANetwork(0, 2, "testnetPreview");
    B.ADANetwork_1_764824073_mainnet = new A.ADANetwork(1, 764824073, "mainnet");
    B.APIServiceStatus_0 = new A.APIServiceStatus("active");
    B.APIServiceStatus_1 = new A.APIServiceStatus("warning");
    B.APIServiceStatus_2 = new A.APIServiceStatus("error");
    B.APIType_0 = new A.APIType("mempool");
    B.APIType_1 = new A.APIType("blockCypher");
    B.List_empty0 = A._setArrayType(makeConstList([]), A.findType("JSArray<AbiParameter>"));
    B.AbiParameter_bytes24_false_List_empty = new A.AbiParameter("bytes24", false, B.List_empty0);
    B.AbiParameter_bytes_false_List_empty = new A.AbiParameter("bytes", false, B.List_empty0);
    B.AbiParameter_uint256_false_List_empty = new A.AbiParameter("uint256", false, B.List_empty0);
    B.AbiParameter_uint32_false_List_empty = new A.AbiParameter("uint32", false, B.List_empty0);
    B.AdaStakeCredType_Key_0 = new A.AdaStakeCredType("Key", 0);
    B.AdaStakeCredType_Script_1 = new A.AdaStakeCredType("Script", 1);
    B.AddressConverterException_4Df = new A.AddressConverterException("Invalid address payload");
    B.AddressConverterException_6hT = new A.AddressConverterException("Invalid prefix for mainnet or testnet ripple address");
    B.AddressConverterException_6uL = new A.AddressConverterException("Invalid address encoding");
    B.AddressConverterException_8aB = new A.AddressConverterException("tag bytes must be zero for flag 0");
    B.AddressConverterException_AZs = new A.AddressConverterException("hd path must be string or Bip32Path");
    B.AddressConverterException_Cpp = new A.AddressConverterException("invalid chaincode ");
    B.AddressConverterException_GJk = new A.AddressConverterException("Unable to compute LiftX point");
    B.AddressConverterException_GrX = new A.AddressConverterException("Invalid address length.");
    B.AddressConverterException_MPa = new A.AddressConverterException("hd path key must be bytes");
    B.AddressConverterException_MQy = new A.AddressConverterException("HD path key shall be 32-byte long");
    B.AddressConverterException_QWm = new A.AddressConverterException("Address type is not an enumerative of ADANetwork");
    B.AddressConverterException_X5e = new A.AddressConverterException("Invalid protocol magic or network does not supported.");
    B.AddressConverterException_fw6 = new A.AddressConverterException("Invalid CBOR tag");
    B.AddressConverterException_kZb = new A.AddressConverterException("chain code must be bytes or Bip32ChainCode");
    B.AddressConverterException_lvx = new A.AddressConverterException("Invalid header value encountered.");
    B.AddressConverterException_uiu = new A.AddressConverterException("Invalid checksum encoding");
    B.AddressConverterException_yZp = new A.AddressConverterException("Invalid address attributes");
    B.List_200_81 = A._setArrayType(makeConstList([200, 81]), type$.JSArray_int);
    B.AddressDerivationType_List_200_81_bip32 = new A.AddressDerivationType(B.List_200_81, "bip32");
    B.List_200_83 = A._setArrayType(makeConstList([200, 83]), type$.JSArray_int);
    B.AddressDerivationType_List_200_83_multisig = new A.AddressDerivationType(B.List_200_83, "multisig");
    B.List_200_84 = A._setArrayType(makeConstList([200, 84]), type$.JSArray_int);
    B.AddressDerivationType_List_200_84_substrate = new A.AddressDerivationType(B.List_200_84, "substrate");
    B.ApiProviderException_api_http_client_error_null_null = new A.ApiProviderException("api_http_client_error", null, null);
    B.ApiProviderException_api_http_timeout_error_null_null = new A.ApiProviderException("api_http_timeout_error", null, null);
    B.ApiProviderException_api_unknown_error_null_null = new A.ApiProviderException("api_unknown_error", null, null);
    B.ApiProviderException_invalid_json_response_null_null = new A.ApiProviderException("invalid_json_response", null, null);
    B.ApiProviderException_invalid_request_type_null_null = new A.ApiProviderException("invalid_request_type", null, null);
    B.ApiProviderException_node_connection_error_null_null = new A.ApiProviderException("node_connection_error", null, null);
    B.AppPlatform_0 = new A.AppPlatform("windows");
    B.AppPlatform_1 = new A.AppPlatform("web");
    B.AppPlatform_2 = new A.AppPlatform("android");
    B.AppPlatform_3 = new A.AppPlatform("ios");
    B.AppPlatform_4 = new A.AppPlatform("macos");
    B.ArgumentException_1Sg = new A.ArgumentException("ChaCha20Poly1305: incorrect nonce length");
    B.ArgumentException_23B = new A.ArgumentException("Hex input string must be divisible by two");
    B.ArgumentException_92p = new A.ArgumentException("Invalid bech32 format (no separator found)");
    B.ArgumentException_ALf = new A.ArgumentException("ChaCha nonce must be 8 or 12 bytes");
    B.ArgumentException_APm = new A.ArgumentException("ChaCha: destination is shorter than source");
    B.ArgumentException_GEX = new A.ArgumentException("Inconsistent hybrid point encoding");
    B.ArgumentException_GlQ = new A.ArgumentException("Generator point must have order.");
    B.ArgumentException_IJC = new A.ArgumentException("Invalid RistrettoPoint");
    B.ArgumentException_IVQ = new A.ArgumentException("ChaCha20Poly1305 needs a 32-byte key");
    B.ArgumentException_JNA = new A.ArgumentException("Invalid key net version length");
    B.ArgumentException_Jwp = new A.ArgumentException("AES: invalid destination block size");
    B.ArgumentException_MYu = new A.ArgumentException("The other point is on a different curve");
    B.ArgumentException_PzB = new A.ArgumentException("invalid input for parse bigint");
    B.ArgumentException_Qs0 = new A.ArgumentException("invalid hex bytes");
    B.ArgumentException_RsV = new A.ArgumentException("AES: initialized with different key size");
    B.ArgumentException_TTS = new A.ArgumentException("Invalid bech32 format (data part not valid)");
    B.ArgumentException_UNa = new A.ArgumentException("invalid or unsuported cbor tag");
    B.ArgumentException_VXU = new A.ArgumentException("Denominator cannot be 0.");
    B.ArgumentException_a51 = new A.ArgumentException("Invalid data, cannot perform conversion from base32");
    B.ArgumentException_aep = new A.ArgumentException("invalid key length");
    B.ArgumentException_bJa = new A.ArgumentException("AffinePointt does not lay on the curve");
    B.ArgumentException_cKo = new A.ArgumentException("blake2b: wrong digest length");
    B.ArgumentException_deg = new A.ArgumentException("blake2b: can't update because hash was finished.");
    B.ArgumentException_e2q0 = new A.ArgumentException("Invalid input: too many '.' tokens");
    B.ArgumentException_e2q = new A.ArgumentException("Invalid input: too many 'e' tokens");
    B.ArgumentException_e4a = new A.ArgumentException("invalid cbornumeric");
    B.ArgumentException_ezC = new A.ArgumentException("Invalid fingerprint length");
    B.ArgumentException_hWj = new A.ArgumentException("Input byte array must be exactly 2 bytes long for Float16");
    B.ArgumentException_ifn = new A.ArgumentException("Generator point order is bad.");
    B.ArgumentException_mxs = new A.ArgumentException("Invalid data, cannot perform conversion to base32");
    B.ArgumentException_o91 = new A.ArgumentException("AES: invalid source block size");
    B.ArgumentException_oWp = new A.ArgumentException("CTR: iv length must be equal to cipher block size");
    B.ArgumentException_oyU = new A.ArgumentException("The public point has x or y out of range.");
    B.ArgumentException_qBh = new A.ArgumentException("ChaCha: key size must be 32 bytes");
    B.ArgumentException_qkE = new A.ArgumentException("AffinePointt length doesn't match the curve.");
    B.ArgumentException_qpm = new A.ArgumentException("Incorrect characters for hex decoding");
    B.ArgumentException_sDr = new A.ArgumentException("Invalid bech32 format (string is mixed case)");
    B.ArgumentException_sav = new A.ArgumentException("SHA3: incorrect capacity");
    B.ArgumentException_yDH = new A.ArgumentException("CTR: counter overflow");
    B.ArgumentException_yPV = new A.ArgumentException("Malformed compressed point encoding");
    B.AsciiDecoder_false_127 = new A.AsciiDecoder(false, 127);
    B.AsciiDecoder_true_127 = new A.AsciiDecoder(true, 127);
    B.AsciiEncoder_127 = new A.AsciiEncoder(127);
    B.Base58Alphabets_0 = new A.Base58Alphabets("bitcoin");
    B.Base58Alphabets_1 = new A.Base58Alphabets("ripple");
    B.Base64Encoder_false = new A.Base64Encoder(false);
    B.Base64Codec_Base64Encoder_false = new A.Base64Codec(B.Base64Encoder_false);
    B.Base64Encoder_true = new A.Base64Encoder(true);
    B.Base64Codec_Base64Encoder_true = new A.Base64Codec(B.Base64Encoder_true);
    B.Bech32Encodings_0 = new A.Bech32Encodings("bech32");
    B.Bech32Encodings_1 = new A.Bech32Encodings("bech32m");
    B.Bip44Coins_akashNetwork = new A.Bip44Coins("akashNetwork");
    B.Bip44Coins_algorand = new A.Bip44Coins("algorand");
    B.Bip44Coins_aptos = new A.Bip44Coins("aptos");
    B.Bip44Coins_avaxCChain = new A.Bip44Coins("avaxCChain");
    B.Bip44Coins_avaxPChain = new A.Bip44Coins("avaxPChain");
    B.Bip44Coins_avaxXChain = new A.Bip44Coins("avaxXChain");
    B.Bip44Coins_axelar = new A.Bip44Coins("axelar");
    B.Bip44Coins_bandProtocol = new A.Bip44Coins("bandProtocol");
    B.Bip44Coins_binanceChain = new A.Bip44Coins("binanceChain");
    B.Bip44Coins_binanceSmartChain = new A.Bip44Coins("binanceSmartChain");
    B.Bip44Coins_bitcoin = new A.Bip44Coins("bitcoin");
    B.Bip44Coins_bitcoinCash = new A.Bip44Coins("bitcoinCash");
    B.Bip44Coins_bitcoinCashSlp = new A.Bip44Coins("bitcoinCashSlp");
    B.Bip44Coins_bitcoinCashSlpTestnet = new A.Bip44Coins("bitcoinCashSlpTestnet");
    B.Bip44Coins_bitcoinCashTestnet = new A.Bip44Coins("bitcoinCashTestnet");
    B.Bip44Coins_bitcoinSv = new A.Bip44Coins("bitcoinSv");
    B.Bip44Coins_bitcoinSvTestnet = new A.Bip44Coins("bitcoinSvTestnet");
    B.Bip44Coins_bitcoinTestnet = new A.Bip44Coins("bitcoinTestnet");
    B.Bip44Coins_cardanoByronIcarus = new A.Bip44Coins("cardanoByronIcarus");
    B.Bip44Coins_cardanoByronIcarusTestnet = new A.Bip44Coins("cardanoByronIcarusTestnet");
    B.Bip44Coins_cardanoByronLedger = new A.Bip44Coins("cardanoByronLedger");
    B.Bip44Coins_cardanoByronLedgerTestnet = new A.Bip44Coins("cardanoByronLedgerTestnet");
    B.Bip44Coins_celo = new A.Bip44Coins("celo");
    B.Bip44Coins_certik = new A.Bip44Coins("certik");
    B.Bip44Coins_chihuahua = new A.Bip44Coins("chihuahua");
    B.Bip44Coins_cosmos = new A.Bip44Coins("cosmos");
    B.Bip44Coins_cosmosNist256p1 = new A.Bip44Coins("cosmosNist256p1");
    B.Bip44Coins_cosmosTestnet = new A.Bip44Coins("cosmosTestnet");
    B.Bip44Coins_cosmosTestnetNist256p1 = new A.Bip44Coins("cosmosTestnetNist256p1");
    B.Bip44Coins_dash = new A.Bip44Coins("dash");
    B.Bip44Coins_dashTestnet = new A.Bip44Coins("dashTestnet");
    B.Bip44Coins_dogecoin = new A.Bip44Coins("dogecoin");
    B.Bip44Coins_dogecoinTestnet = new A.Bip44Coins("dogecoinTestnet");
    B.Bip44Coins_ecash = new A.Bip44Coins("ecash");
    B.Bip44Coins_ecashTestnet = new A.Bip44Coins("ecashTestnet");
    B.Bip44Coins_elrond = new A.Bip44Coins("elrond");
    B.Bip44Coins_eos = new A.Bip44Coins("eos");
    B.Bip44Coins_ergo = new A.Bip44Coins("ergo");
    B.Bip44Coins_ergoTestnet = new A.Bip44Coins("ergoTestnet");
    B.Bip44Coins_ethereum = new A.Bip44Coins("ethereum");
    B.Bip44Coins_ethereumClassic = new A.Bip44Coins("ethereumClassic");
    B.Bip44Coins_ethereumTestnet = new A.Bip44Coins("ethereumTestnet");
    B.Bip44Coins_fantomOpera = new A.Bip44Coins("fantomOpera");
    B.Bip44Coins_filecoin = new A.Bip44Coins("filecoin");
    B.Bip44Coins_harmonyOneAtom = new A.Bip44Coins("harmonyOneAtom");
    B.Bip44Coins_harmonyOneEth = new A.Bip44Coins("harmonyOneEth");
    B.Bip44Coins_harmonyOneMetamask = new A.Bip44Coins("harmonyOneMetamask");
    B.Bip44Coins_huobiChain = new A.Bip44Coins("huobiChain");
    B.Bip44Coins_icon = new A.Bip44Coins("icon");
    B.Bip44Coins_injective = new A.Bip44Coins("injective");
    B.Bip44Coins_irisNet = new A.Bip44Coins("irisNet");
    B.Bip44Coins_kava = new A.Bip44Coins("kava");
    B.Bip44Coins_kusamaEd25519Slip = new A.Bip44Coins("kusamaEd25519Slip");
    B.Bip44Coins_kusamaTestnetEd25519Slip = new A.Bip44Coins("kusamaTestnetEd25519Slip");
    B.Bip44Coins_litecoin = new A.Bip44Coins("litecoin");
    B.Bip44Coins_litecoinTestnet = new A.Bip44Coins("litecoinTestnet");
    B.Bip44Coins_moneroEd25519Slip = new A.Bip44Coins("moneroEd25519Slip");
    B.Bip44Coins_moneroSecp256k1 = new A.Bip44Coins("moneroSecp256k1");
    B.Bip44Coins_nano = new A.Bip44Coins("nano");
    B.Bip44Coins_nearProtocol = new A.Bip44Coins("nearProtocol");
    B.Bip44Coins_neo = new A.Bip44Coins("neo");
    B.Bip44Coins_nineChroniclesGold = new A.Bip44Coins("nineChroniclesGold");
    B.Bip44Coins_okexChainAtom = new A.Bip44Coins("okexChainAtom");
    B.Bip44Coins_okexChainAtomOld = new A.Bip44Coins("okexChainAtomOld");
    B.Bip44Coins_okexChainEth = new A.Bip44Coins("okexChainEth");
    B.Bip44Coins_ontology = new A.Bip44Coins("ontology");
    B.Bip44Coins_osmosis = new A.Bip44Coins("osmosis");
    B.Bip44Coins_pepecoin = new A.Bip44Coins("pepecoin");
    B.Bip44Coins_pepecoinTestnet = new A.Bip44Coins("pepecoinTestnet");
    B.Bip44Coins_piNetwork = new A.Bip44Coins("piNetwork");
    B.Bip44Coins_polkadotEd25519Slip = new A.Bip44Coins("polkadotEd25519Slip");
    B.Bip44Coins_polkadotTestnetEd25519Slip = new A.Bip44Coins("polkadotTestnetEd25519Slip");
    B.Bip44Coins_polygon = new A.Bip44Coins("polygon");
    B.Bip44Coins_ripple = new A.Bip44Coins("ripple");
    B.Bip44Coins_rippleED25519 = new A.Bip44Coins("rippleED25519");
    B.Bip44Coins_rippleTestnet = new A.Bip44Coins("rippleTestnet");
    B.Bip44Coins_rippleTestnetED25519 = new A.Bip44Coins("rippleTestnetED25519");
    B.Bip44Coins_secretNetworkNew = new A.Bip44Coins("secretNetworkNew");
    B.Bip44Coins_secretNetworkOld = new A.Bip44Coins("secretNetworkOld");
    B.Bip44Coins_solana = new A.Bip44Coins("solana");
    B.Bip44Coins_solanaTestnet = new A.Bip44Coins("solanaTestnet");
    B.Bip44Coins_stellar = new A.Bip44Coins("stellar");
    B.Bip44Coins_terra = new A.Bip44Coins("terra");
    B.Bip44Coins_tezos = new A.Bip44Coins("tezos");
    B.Bip44Coins_theta = new A.Bip44Coins("theta");
    B.Bip44Coins_tonMainnet = new A.Bip44Coins("tonMainnet");
    B.Bip44Coins_tonTestnet = new A.Bip44Coins("tonTestnet");
    B.Bip44Coins_tron = new A.Bip44Coins("tron");
    B.Bip44Coins_tronTestnet = new A.Bip44Coins("tronTestnet");
    B.Bip44Coins_vechain = new A.Bip44Coins("vechain");
    B.Bip44Coins_verge = new A.Bip44Coins("verge");
    B.Bip44Coins_zcash = new A.Bip44Coins("zcash");
    B.Bip44Coins_zcashTestnet = new A.Bip44Coins("zcashTestnet");
    B.Bip44Coins_zilliqa = new A.Bip44Coins("zilliqa");
    B.Bip49Coins_bitcoin = new A.Bip49Coins("bitcoin");
    B.Bip49Coins_bitcoinCash = new A.Bip49Coins("bitcoinCash");
    B.Bip49Coins_bitcoinCashSlp = new A.Bip49Coins("bitcoinCashSlp");
    B.Bip49Coins_bitcoinCashSlpTestnet = new A.Bip49Coins("bitcoinCashSlpTestnet");
    B.Bip49Coins_bitcoinCashTestnet = new A.Bip49Coins("bitcoinCashTestnet");
    B.Bip49Coins_bitcoinSv = new A.Bip49Coins("bitcoinSv");
    B.Bip49Coins_bitcoinSvTestnet = new A.Bip49Coins("bitcoinSvTestnet");
    B.Bip49Coins_bitcoinTestnet = new A.Bip49Coins("bitcoinTestnet");
    B.Bip49Coins_dash = new A.Bip49Coins("dash");
    B.Bip49Coins_dashTestnet = new A.Bip49Coins("dashTestnet");
    B.Bip49Coins_dogecoin = new A.Bip49Coins("dogecoin");
    B.Bip49Coins_dogecoinTestnet = new A.Bip49Coins("dogecoinTestnet");
    B.Bip49Coins_ecash = new A.Bip49Coins("ecash");
    B.Bip49Coins_ecashTestnet = new A.Bip49Coins("ecashTestnet");
    B.Bip49Coins_litecoin = new A.Bip49Coins("litecoin");
    B.Bip49Coins_litecoinTestnet = new A.Bip49Coins("litecoinTestnet");
    B.Bip49Coins_pepecoin = new A.Bip49Coins("pepecoin");
    B.Bip49Coins_pepecoinTestnet = new A.Bip49Coins("pepecoinTestnet");
    B.Bip49Coins_zcash = new A.Bip49Coins("zcash");
    B.Bip49Coins_zcashTestnet = new A.Bip49Coins("zcashTestnet");
    B.Bip84Coins_bitcoin = new A.Bip84Coins("bitcoin");
    B.Bip84Coins_bitcoinTestnet = new A.Bip84Coins("bitcoinTestnet");
    B.Bip84Coins_litecoin = new A.Bip84Coins("litecoin");
    B.Bip84Coins_litecoinTestnet = new A.Bip84Coins("litecoinTestnet");
    B.Bip86Coins_bitcoin = new A.Bip86Coins("bitcoin");
    B.Bip86Coins_bitcoinTestnet = new A.Bip86Coins("bitcoinTestnet");
    B.BipProposal_bip44 = new A.BipProposal("bip44");
    B.BipProposal_bip49 = new A.BipProposal("bip49");
    B.BipProposal_bip84 = new A.BipProposal("bip84");
    B.BipProposal_bip86 = new A.BipProposal("bip86");
    B.BitcoinBasePluginException_8Gl = new A.BitcoinBasePluginException("Invalid secp256k1 public key");
    B.BitcoinBasePluginException_8Gl0 = new A.BitcoinBasePluginException("network does not support p2wpkh HRP");
    B.BitcoinBasePluginException_b1g = new A.BitcoinBasePluginException("Invalid Bitcoin address");
    B.BitcoinBasePluginException_ijF = new A.BitcoinBasePluginException("DogecoinNetwork network does not support P2WPKH/P2WSH");
    B.BitcoinBasePluginException_ld1 = new A.BitcoinBasePluginException("DashNetwork network does not support P2WPKH/P2WSH");
    B.BitcoinBasePluginException_uH4 = new A.BitcoinBasePluginException("Invalid Bitcoin address program length (program length should be 32 or 20 bytes)");
    B.BitcoinBasePluginException_uhV = new A.BitcoinBasePluginException("Data too large. Cannot push into script");
    B.BitcoinBasePluginException_xLE = new A.BitcoinBasePluginException("Integer is currently required to be positive.");
    B.BitcoinBasePluginException_yXb = new A.BitcoinBasePluginException("Invalid segwit version");
    B.CoinNames_Iot = new A.CoinNames("Bitcoin Cash TestNet");
    B.List_239 = A._setArrayType(makeConstList([239]), type$.JSArray_int);
    B.List_00 = A._setArrayType(makeConstList([0]), type$.JSArray_int);
    B.List_111 = A._setArrayType(makeConstList([111]), type$.JSArray_int);
    B.List_8 = A._setArrayType(makeConstList([8]), type$.JSArray_int);
    B.List_196 = A._setArrayType(makeConstList([196]), type$.JSArray_int);
    B.CoinParams_Axp = new A.CoinParams(null, null, null, null, B.List_239, null, null, null, "bchtest", B.List_00, B.List_111, "bchtest", B.List_8, B.List_196, null, null, null, null, null, null, null, null);
    B.CoinConf_O3a = new A.CoinConf(B.CoinNames_Iot, B.CoinParams_Axp);
    B.List_16 = A._setArrayType(makeConstList([16]), type$.JSArray_int);
    B.List_11 = A._setArrayType(makeConstList([11]), type$.JSArray_int);
    B.List_24 = A._setArrayType(makeConstList([24]), type$.JSArray_int);
    B.List_27 = A._setArrayType(makeConstList([27]), type$.JSArray_int);
    B.C_PubKeyAddressType = new A.PubKeyAddressType();
    B.P2pkhAddressType_P2PKH = new A.P2pkhAddressType("P2PKH");
    B.P2pkhAddressType_P2PKHWT = new A.P2pkhAddressType("P2PKHWT");
    B.P2shAddressType_sc9 = new A.P2shAddressType(20, "P2SH/P2PKH");
    B.P2shAddressType_g2q = new A.P2shAddressType(20, "P2SH/P2PK");
    B.P2shAddressType_hK7 = new A.P2shAddressType(32, "P2SH32/P2PKH");
    B.P2shAddressType_Q9u = new A.P2shAddressType(32, "P2SH32/P2PK");
    B.P2shAddressType_0 = new A.P2shAddressType(32, "P2SH32WT/P2PKH");
    B.P2shAddressType_TLC = new A.P2shAddressType(32, "P2SH32WT/P2PK");
    B.P2shAddressType_lhG = new A.P2shAddressType(20, "P2SHWT/P2PKH");
    B.P2shAddressType_CXi = new A.P2shAddressType(20, "P2SHWT/P2PK");
    B.List_ab8 = A._setArrayType(makeConstList([B.C_PubKeyAddressType, B.P2pkhAddressType_P2PKH, B.P2pkhAddressType_P2PKHWT, B.P2shAddressType_sc9, B.P2shAddressType_g2q, B.P2shAddressType_hK7, B.P2shAddressType_Q9u, B.P2shAddressType_0, B.P2shAddressType_TLC, B.P2shAddressType_lhG, B.P2shAddressType_CXi]), type$.JSArray_BitcoinAddressType);
    B.BitcoinCashNetwork_69P = new A.BitcoinCashNetwork(B.CoinConf_O3a, "bitcoinCashTestnet");
    B.CoinNames_CDm = new A.CoinNames("Bitcoin Cash");
    B.List_128 = A._setArrayType(makeConstList([128]), type$.JSArray_int);
    B.List_5 = A._setArrayType(makeConstList([5]), type$.JSArray_int);
    B.CoinParams_vhP = new A.CoinParams(null, null, null, null, B.List_128, null, null, null, "bitcoincash", B.List_00, B.List_00, "bitcoincash", B.List_8, B.List_5, null, null, null, null, null, null, null, null);
    B.CoinConf_o8I = new A.CoinConf(B.CoinNames_CDm, B.CoinParams_vhP);
    B.BitcoinCashNetwork_q9y = new A.BitcoinCashNetwork(B.CoinConf_o8I, "bitcoinCashMainnet");
    B.BitcoinExplorerProviderType_1 = new A.BitcoinExplorerProviderType("mempool");
    B.ServiceProtocol_HTTP_0_http = new A.ServiceProtocol("HTTP", 0, "http");
    B.BitcoinExplorerAPIProvider_SNI = new A.BitcoinExplorerAPIProvider(null, B.BitcoinExplorerProviderType_1, B.ServiceProtocol_HTTP_0_http, "Mempool", "https://mempool.space/");
    B.BitcoinExplorerProviderType_0 = new A.BitcoinExplorerProviderType("blockcypher");
    B.BitcoinExplorerAPIProvider_iLh = new A.BitcoinExplorerAPIProvider(null, B.BitcoinExplorerProviderType_0, B.ServiceProtocol_HTTP_0_http, "BlockCypher", "https://www.blockcypher.com/");
    B.CoinNames_tuc = new A.CoinNames("Bitcoin TestNet");
    B.CoinParams_npp = new A.CoinParams(B.List_111, B.List_196, "tb", "tb", B.List_239, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_uoT = new A.CoinConf(B.CoinNames_tuc, B.CoinParams_npp);
    B.BitcoinNetwork_DSc = new A.BitcoinNetwork(B.CoinConf_uoT, "bitcoinTestnet");
    B.CoinNames_Bitcoin = new A.CoinNames("Bitcoin");
    B.CoinParams_ITb = new A.CoinParams(B.List_00, B.List_5, "bc", "bc", B.List_128, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_k2a = new A.CoinConf(B.CoinNames_Bitcoin, B.CoinParams_ITb);
    B.BitcoinNetwork_qBr = new A.BitcoinNetwork(B.CoinConf_k2a, "bitcoinMainnet");
    B.CoinNames_BitcoinSV = new A.CoinNames("BitcoinSV");
    B.CoinParams_B8J = new A.CoinParams(B.List_00, B.List_5, null, null, B.List_128, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_u7u = new A.CoinConf(B.CoinNames_BitcoinSV, B.CoinParams_B8J);
    B.BitcoinSVNetwork_GZw = new A.BitcoinSVNetwork(B.CoinConf_u7u, "BitcoinSVMainnet");
    B.C__EmptyStream = new A._EmptyStream(A.findType("_EmptyStream<List<int>>"));
    B.ByteStream__EmptyStream = new A.ByteStream(B.C__EmptyStream);
    B.CONSTANT = new A.Instantiation1(A.math__max$closure(), A.findType("Instantiation1<int>"));
    B.ContentType_0_local = new A.ContentType(0, "local");
    B.C_APPImage11 = new A.APPImage();
    B.C_APPImage7 = new A.APPImage();
    B.C_APPImage15 = new A.APPImage();
    B.C_APPImage8 = new A.APPImage();
    B.C_APPImage17 = new A.APPImage();
    B.C_APPImage20 = new A.APPImage();
    B.C_APPImage6 = new A.APPImage();
    B.C_APPImage16 = new A.APPImage();
    B.C_APPImage18 = new A.APPImage();
    B.C_APPImage10 = new A.APPImage();
    B.C_APPImage0 = new A.APPImage();
    B.C_APPImage4 = new A.APPImage();
    B.C_APPImage19 = new A.APPImage();
    B.C_APPImage9 = new A.APPImage();
    B.C_APPImage3 = new A.APPImage();
    B.C_APPImage14 = new A.APPImage();
    B.C_APPImage1 = new A.APPImage();
    B.C_APPImage12 = new A.APPImage();
    B.C_APPImage5 = new A.APPImage();
    B.C_APPImage2 = new A.APPImage();
    B.C_APPImage = new A.APPImage();
    B.C_APPImage13 = new A.APPImage();
    B.C_AsciiCodec = new A.AsciiCodec();
    B.C_Base64Decoder = new A.Base64Decoder();
    B.C_Bech32ChecksumError = new A.Bech32ChecksumError();
    B.C_BytesCoder = new A.BytesCoder();
    B.C_CborNullValue = new A.CborNullValue();
    B.C_CborUndefinedValue = new A.CborUndefinedValue();
    B.C_CipProposal = new A.CipProposal();
    B.C_CosmosNativeCoin3 = new A.CosmosNativeCoin();
    B.C_CosmosNativeCoin0 = new A.CosmosNativeCoin();
    B.C_CosmosNativeCoin = new A.CosmosNativeCoin();
    B.C_CosmosNativeCoin1 = new A.CosmosNativeCoin();
    B.C_CosmosNativeCoin2 = new A.CosmosNativeCoin();
    B.C_CustomProposal = new A.CustomProposal();
    B.C_EmptyIterator = new A.EmptyIterator(A.findType("EmptyIterator<0&>"));
    B.C_Endian = new A.Endian();
    B.C_Endian0 = new A.Endian();
    B.C_IntegerDivisionByZeroException = new A.IntegerDivisionByZeroException();
    B.C_JS_CONST = function getTagFallback(o) {
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
    B.C_JS_CONST0 = function() {
  var toStringFunction = Object.prototype.toString;
  function getTag(o) {
    var s = toStringFunction.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = toStringFunction.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof HTMLElement == "function";
  return {
    getTag: getTag,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
    B.C_JS_CONST6 = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var userAgent = navigator.userAgent;
    if (typeof userAgent != "string") return hooks;
    if (userAgent.indexOf("DumpRenderTree") >= 0) return hooks;
    if (userAgent.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
    B.C_JS_CONST1 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
    B.C_JS_CONST5 = function(hooks) {
  if (typeof navigator != "object") return hooks;
  var userAgent = navigator.userAgent;
  if (typeof userAgent != "string") return hooks;
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
    B.C_JS_CONST4 = function(hooks) {
  if (typeof navigator != "object") return hooks;
  var userAgent = navigator.userAgent;
  if (typeof userAgent != "string") return hooks;
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
    B.C_JS_CONST2 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
    B.C_JS_CONST3 = function(hooks) { return hooks; }
;
    B.C_JsonCodec = new A.JsonCodec();
    B.C_Latin1Codec = new A.Latin1Codec();
    B.C_MoneroKeyError = new A.MoneroKeyError();
    B.C_MoneroProposal = new A.MoneroProposal();
    B.C_MultiSigAddressIndex = new A.MultiSigAddressIndex();
    B.C_NumbersCoder = new A.NumbersCoder();
    B.C_OutOfMemoryError = new A.OutOfMemoryError();
    B.CoinNames_Pepecoin = new A.CoinNames("Pepecoin");
    B.List_56 = A._setArrayType(makeConstList([56]), type$.JSArray_int);
    B.List_22 = A._setArrayType(makeConstList([22]), type$.JSArray_int);
    B.List_158 = A._setArrayType(makeConstList([158]), type$.JSArray_int);
    B.CoinParams_B8J0 = new A.CoinParams(B.List_56, B.List_22, null, null, B.List_158, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_6ti = new A.CoinConf(B.CoinNames_Pepecoin, B.CoinParams_B8J0);
    B.List_WRr = A._setArrayType(makeConstList([B.C_PubKeyAddressType, B.P2pkhAddressType_P2PKH, B.P2shAddressType_sc9, B.P2shAddressType_g2q]), type$.JSArray_BitcoinAddressType);
    B.C_PepeNetwork = new A.PepeNetwork();
    B.C_SentinelValue = new A.SentinelValue();
    B.C_SocketDirection1 = new A.SocketDirection();
    B.C_SocketDirection = new A.SocketDirection();
    B.C_SocketDirection0 = new A.SocketDirection();
    B.C_SubstratePropoosal = new A.SubstratePropoosal();
    B.C_Utf8Codec = new A.Utf8Codec();
    B.C_Utf8Encoder = new A.Utf8Encoder();
    B.C_Web3EthereumRequestException = new A.Web3EthereumRequestException();
    B.C_XRPLAddressCodecException = new A.XRPLAddressCodecException();
    B.C_XlmAddrTypes = new A.XlmAddrTypes();
    B.List_6_161_159 = A._setArrayType(makeConstList([6, 161, 159]), type$.JSArray_int);
    B.C_XtzAddrPrefixes = new A.XtzAddrPrefixes();
    B.C__DelayedDone = new A._DelayedDone();
    B.C__Hex = new A._Hex();
    B.C__Required = new A._Required();
    B.C__RootZone = new A._RootZone();
    B.C__StringStackTrace = new A._StringStackTrace();
    B.CborBoleanValue_false = new A.CborBoleanValue(false);
    B.CborBoleanValue_true = new A.CborBoleanValue(true);
    B.CborIntValue_1 = new A.CborIntValue(1);
    B.CborIntValue_2 = new A.CborIntValue(2);
    B.Cip1852Coins_cardanoIcarus = new A.Cip1852Coins("cardanoIcarus");
    B.Cip1852Coins_cardanoIcarusTestnet = new A.Cip1852Coins("cardanoIcarusTestnet");
    B.Cip1852Coins_cardanoLedger = new A.Cip1852Coins("cardanoLedger");
    B.Cip1852Coins_cardanoLedgerTestnet = new A.Cip1852Coins("cardanoLedgerTestnet");
    B.CoinNames_Stafi = new A.CoinNames("Stafi");
    B.CoinParams_GVt = new A.CoinParams(null, null, null, null, null, 20, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_9R3 = new A.CoinConf(B.CoinNames_Stafi, B.CoinParams_GVt);
    B.CoinNames_MMm = new A.CoinNames("Generic Substrate");
    B.CoinParams_GVt0 = new A.CoinParams(null, null, null, null, null, 42, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_A0t = new A.CoinConf(B.CoinNames_MMm, B.CoinParams_GVt0);
    B.CoinNames_Edgeware = new A.CoinNames("Edgeware");
    B.CoinParams_GVt1 = new A.CoinParams(null, null, null, null, null, 7, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_CtR = new A.CoinConf(B.CoinNames_Edgeware, B.CoinParams_GVt1);
    B.CoinNames_Monero = new A.CoinNames("Monero");
    B.List_18 = A._setArrayType(makeConstList([18]), type$.JSArray_int);
    B.List_19 = A._setArrayType(makeConstList([19]), type$.JSArray_int);
    B.List_42 = A._setArrayType(makeConstList([42]), type$.JSArray_int);
    B.CoinParams_0 = new A.CoinParams(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, B.List_18, B.List_19, B.List_42, null, null);
    B.CoinConf_Ktx = new A.CoinConf(B.CoinNames_Monero, B.CoinParams_0);
    B.CoinNames_ChainX = new A.CoinNames("ChainX");
    B.CoinParams_GVt2 = new A.CoinParams(null, null, null, null, null, 44, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_UEA = new A.CoinConf(B.CoinNames_ChainX, B.CoinParams_GVt2);
    B.CoinNames_Polkadot = new A.CoinNames("Polkadot");
    B.CoinParams_GVt3 = new A.CoinParams(null, null, null, null, null, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_UW6 = new A.CoinConf(B.CoinNames_Polkadot, B.CoinParams_GVt3);
    B.CoinNames_Sora = new A.CoinNames("Sora");
    B.CoinParams_GVt4 = new A.CoinParams(null, null, null, null, null, 69, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_VjA = new A.CoinConf(B.CoinNames_Sora, B.CoinParams_GVt4);
    B.CoinNames_Karura = new A.CoinNames("Karura");
    B.CoinParams_GVt5 = new A.CoinParams(null, null, null, null, null, 8, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_Xmb = new A.CoinConf(B.CoinNames_Karura, B.CoinParams_GVt5);
    B.CoinNames_Moonriver = new A.CoinNames("Moonriver");
    B.CoinParams_gT2 = new A.CoinParams(null, null, null, null, null, 1285, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_Z8h = new A.CoinConf(B.CoinNames_Moonriver, B.CoinParams_gT2);
    B.CoinNames_Kusama = new A.CoinNames("Kusama");
    B.CoinParams_GVt6 = new A.CoinParams(null, null, null, null, null, 2, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_aWd = new A.CoinConf(B.CoinNames_Kusama, B.CoinParams_GVt6);
    B.CoinNames_Bifrost = new A.CoinNames("Bifrost");
    B.CoinParams_GVt7 = new A.CoinParams(null, null, null, null, null, 6, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_cOY = new A.CoinConf(B.CoinNames_Bifrost, B.CoinParams_GVt7);
    B.CoinNames_LYK = new A.CoinNames("Plasm Network");
    B.CoinParams_GVt8 = new A.CoinParams(null, null, null, null, null, 5, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_gT2 = new A.CoinConf(B.CoinNames_LYK, B.CoinParams_GVt8);
    B.CoinNames_bpI = new A.CoinNames("Monero StageNet");
    B.List_25 = A._setArrayType(makeConstList([25]), type$.JSArray_int);
    B.List_36 = A._setArrayType(makeConstList([36]), type$.JSArray_int);
    B.CoinParams_00 = new A.CoinParams(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, B.List_24, B.List_25, B.List_36, null, null);
    B.CoinConf_gWX = new A.CoinConf(B.CoinNames_bpI, B.CoinParams_00);
    B.CoinNames_Acala = new A.CoinNames("Acala");
    B.CoinParams_GVt9 = new A.CoinParams(null, null, null, null, null, 10, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_oMr = new A.CoinConf(B.CoinNames_Acala, B.CoinParams_GVt9);
    B.CoinNames_izR = new A.CoinNames("Monero TestNet");
    B.List_53 = A._setArrayType(makeConstList([53]), type$.JSArray_int);
    B.List_54 = A._setArrayType(makeConstList([54]), type$.JSArray_int);
    B.List_63 = A._setArrayType(makeConstList([63]), type$.JSArray_int);
    B.CoinParams_01 = new A.CoinParams(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, B.List_53, B.List_54, B.List_63, null, null);
    B.CoinConf_uUv = new A.CoinConf(B.CoinNames_izR, B.CoinParams_01);
    B.CoinNames_bHn = new A.CoinNames("Phala Network");
    B.CoinParams_GVt10 = new A.CoinParams(null, null, null, null, null, 30, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_wcW = new A.CoinConf(B.CoinNames_bHn, B.CoinParams_GVt10);
    B.CoinNames_Moonbeam = new A.CoinNames("Moonbeam");
    B.CoinParams_YWc = new A.CoinParams(null, null, null, null, null, 1284, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_yvr = new A.CoinConf(B.CoinNames_Moonbeam, B.CoinParams_YWc);
    B.CoinNames_4N8 = new A.CoinNames("Ergo TestNet");
    B.CoinNames_AdS1 = new A.CoinNames("Avax C-Chain");
    B.CoinNames_AdS0 = new A.CoinNames("Avax P-Chain");
    B.CoinNames_AdS = new A.CoinNames("Avax X-Chain");
    B.CoinNames_Algorand = new A.CoinNames("Algorand");
    B.CoinNames_Aptos = new A.CoinNames("Aptos");
    B.CoinNames_Axelar = new A.CoinNames("Axelar");
    B.CoinNames_B2l = new A.CoinNames("BitcoinSV TestNet");
    B.CoinNames_Cardano = new A.CoinNames("Cardano");
    B.CoinNames_Celo = new A.CoinNames("Celo");
    B.CoinNames_Certik = new A.CoinNames("Certik");
    B.CoinNames_Chihuahua = new A.CoinNames("Chihuahua");
    B.CoinNames_Cosmos = new A.CoinNames("Cosmos");
    B.CoinNames_D4j = new A.CoinNames("Binance Chain");
    B.CoinNames_Dash = new A.CoinNames("Dash");
    B.CoinNames_Dogecoin = new A.CoinNames("Dogecoin");
    B.CoinNames_Due = new A.CoinNames("Binance Smart Chain");
    B.CoinNames_EOS = new A.CoinNames("EOS");
    B.CoinNames_Ergo = new A.CoinNames("Ergo");
    B.CoinNames_Ethereum = new A.CoinNames("Ethereum");
    B.CoinNames_FCG0 = new A.CoinNames("Band Protocol");
    B.CoinNames_FCG = new A.CoinNames("Bitcoin Cash SLP TestNet");
    B.CoinNames_Filecoin = new A.CoinNames("Filecoin");
    B.CoinNames_HZw = new A.CoinNames("eCash TestNet");
    B.CoinNames_IIS = new A.CoinNames("Litecoin TestNet");
    B.CoinNames_Icon = new A.CoinNames("Icon");
    B.CoinNames_Injective = new A.CoinNames("Injective");
    B.CoinNames_JiH = new A.CoinNames("Fantom Opera");
    B.CoinNames_Kava = new A.CoinNames("Kava");
    B.CoinNames_Litecoin = new A.CoinNames("Litecoin");
    B.CoinNames_MUB = new A.CoinNames("Dash TestNet");
    B.CoinNames_MYA = new A.CoinNames("Huobi Token");
    B.CoinNames_NEO = new A.CoinNames("NEO");
    B.CoinNames_Nano = new A.CoinNames("Nano");
    B.CoinNames_NineChroniclesGold = new A.CoinNames("NineChroniclesGold");
    B.CoinNames_O1S = new A.CoinNames("Zcash TestNet");
    B.CoinNames_OKExChain = new A.CoinNames("OKExChain");
    B.CoinNames_OPN = new A.CoinNames("Dogecoin TestNet");
    B.CoinNames_OWX = new A.CoinNames("Near Protocol");
    B.CoinNames_Ontology = new A.CoinNames("Ontology");
    B.CoinNames_Osmosis = new A.CoinNames("Osmosis");
    B.CoinNames_PVK = new A.CoinNames("Byron legacy testnet");
    B.CoinNames_Polygon = new A.CoinNames("Polygon");
    B.CoinNames_QyU = new A.CoinNames("Pepecoin TestNet");
    B.CoinNames_Ripple = new A.CoinNames("Ripple");
    B.CoinNames_Solana = new A.CoinNames("Solana");
    B.CoinNames_Stellar = new A.CoinNames("Stellar");
    B.CoinNames_Terra = new A.CoinNames("Terra");
    B.CoinNames_Tezos = new A.CoinNames("Tezos");
    B.CoinNames_Tron = new A.CoinNames("Tron");
    B.CoinNames_UiL = new A.CoinNames("Cardano TestNet");
    B.CoinNames_VeChain = new A.CoinNames("VeChain");
    B.CoinNames_Verge = new A.CoinNames("Verge");
    B.CoinNames_Zcash = new A.CoinNames("Zcash");
    B.CoinNames_Zilliqa = new A.CoinNames("Zilliqa");
    B.CoinNames_aBy = new A.CoinNames("The Open Network");
    B.CoinNames_aBy0 = new A.CoinNames("The Open Network");
    B.CoinNames_adc = new A.CoinNames("Pi Network");
    B.CoinNames_e9z = new A.CoinNames("IRIS Network");
    B.CoinNames_eCash = new A.CoinNames("eCash");
    B.CoinNames_eHw = new A.CoinNames("Harmony One");
    B.CoinNames_ki8 = new A.CoinNames("Secret Network");
    B.CoinNames_mqm = new A.CoinNames("Ethereum Classic");
    B.CoinNames_qd4 = new A.CoinNames("Theta Network");
    B.CoinNames_qxe = new A.CoinNames("Elrond eGold");
    B.CoinNames_rCZ = new A.CoinNames("Bitcoin Cash SLP");
    B.CoinNames_xw8 = new A.CoinNames("Byron legacy");
    B.CoinNames_z8q = new A.CoinNames("Akash Network");
    B.CoingeckoCoin_5QF = new A.CoingeckoCoin("cosmos", "cosmos-hub", null);
    B.CoingeckoCoin_EW9 = new A.CoingeckoCoin("cacao", "maya-protocol", null);
    B.CoingeckoCoin_N1Q = new A.CoingeckoCoin("matic-network", "polygon", null);
    B.CoingeckoCoin_QuN = new A.CoingeckoCoin("bitcoin-cash-sv", "bitcoin-sv", null);
    B.CoingeckoCoin_b1V = new A.CoingeckoCoin("pepecoin-network", "pepecoin-network", null);
    B.CoingeckoCoin_binancecoin_bnb_null = new A.CoingeckoCoin("binancecoin", "bnb", null);
    B.CoingeckoCoin_bitcoin_bitcoin_null = new A.CoingeckoCoin("bitcoin", "bitcoin", null);
    B.CoingeckoCoin_cardano_cardano_null = new A.CoingeckoCoin("cardano", "cardano", null);
    B.CoingeckoCoin_dash_dash_null = new A.CoingeckoCoin("dash", "dash", null);
    B.CoingeckoCoin_dogecoin_dogecoin_null = new A.CoingeckoCoin("dogecoin", "dogecoin", null);
    B.CoingeckoCoin_ethereum_ethereum_null = new A.CoingeckoCoin("ethereum", "ethereum", null);
    B.CoingeckoCoin_kujira_kujira_null = new A.CoingeckoCoin("kujira", "kujira", null);
    B.CoingeckoCoin_kusama_kusama_KSM = new A.CoingeckoCoin("kusama", "kusama", "KSM");
    B.CoingeckoCoin_litecoin_litecoin_null = new A.CoingeckoCoin("litecoin", "litecoin", null);
    B.CoingeckoCoin_osmosis_osmosis_null = new A.CoingeckoCoin("osmosis", "osmosis", null);
    B.CoingeckoCoin_polkadot_polkadot_DOT = new A.CoingeckoCoin("polkadot", "polkadot", "DOT");
    B.CoingeckoCoin_ripple_xrp_null = new A.CoingeckoCoin("ripple", "xrp", null);
    B.CoingeckoCoin_solana_solana_null = new A.CoingeckoCoin("solana", "solana", null);
    B.CoingeckoCoin_thorchain_thorchain_null = new A.CoingeckoCoin("thorchain", "thorchain", null);
    B.CoingeckoCoin_tron_tron_null = new A.CoingeckoCoin("tron", "tron", null);
    B.CoingeckoCoin_wzg = new A.CoingeckoCoin("bitcoin-cash", "bitcoin-cash", null);
    B.CoingeckoCoin_yLX = new A.CoingeckoCoin("the-open-network", "toncoin", null);
    B.CosmosNetworkTypes_0 = new A.CosmosNetworkTypes(0);
    B.CosmosNetworkTypes_1 = new A.CosmosNetworkTypes(1);
    B.CosmosNetworkTypes_2 = new A.CosmosNetworkTypes(2);
    B.List_76 = A._setArrayType(makeConstList([76]), type$.JSArray_int);
    B.List_204 = A._setArrayType(makeConstList([204]), type$.JSArray_int);
    B.CoinParams_B8J1 = new A.CoinParams(B.List_76, B.List_16, null, null, B.List_204, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_adS = new A.CoinConf(B.CoinNames_Dash, B.CoinParams_B8J1);
    B.DashNetwork_XbV = new A.DashNetwork(B.CoinConf_adS, "dashMainnet");
    B.List_30 = A._setArrayType(makeConstList([30]), type$.JSArray_int);
    B.CoinParams_B8J2 = new A.CoinParams(B.List_30, B.List_22, null, null, B.List_158, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_Wqx = new A.CoinConf(B.CoinNames_Dogecoin, B.CoinParams_B8J2);
    B.DogecoinNetwork_6L0 = new A.DogecoinNetwork(B.CoinConf_Wqx, "dogeMainnet");
    B.List_113 = A._setArrayType(makeConstList([113]), type$.JSArray_int);
    B.List_241 = A._setArrayType(makeConstList([241]), type$.JSArray_int);
    B.CoinParams_H7P = new A.CoinParams(B.List_113, B.List_196, null, null, B.List_241, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_33Y = new A.CoinConf(B.CoinNames_OPN, B.CoinParams_H7P);
    B.DogecoinNetwork_n3E = new A.DogecoinNetwork(B.CoinConf_33Y, "dogeTestnet");
    B.Duration_0 = new A.Duration(0);
    B.Duration_30000000 = new A.Duration(30000000);
    B.EIP712Version_1 = new A.EIP712Version(1);
    B.EIP712Version_3 = new A.EIP712Version(3);
    B.EIP712Version_4 = new A.EIP712Version(4);
    B.EllipticCurveTypes_ed25519 = new A.EllipticCurveTypes("ed25519");
    B.EllipticCurveTypes_ed25519Blake2b = new A.EllipticCurveTypes("ed25519Blake2b");
    B.EllipticCurveTypes_ed25519Kholaw = new A.EllipticCurveTypes("ed25519Kholaw");
    B.EllipticCurveTypes_ed25519Monero = new A.EllipticCurveTypes("ed25519Monero");
    B.EllipticCurveTypes_nist256p1 = new A.EllipticCurveTypes("nist256p1");
    B.EllipticCurveTypes_secp256k1 = new A.EllipticCurveTypes("secp256k1");
    B.EllipticCurveTypes_sr25519 = new A.EllipticCurveTypes("sr25519");
    B.EncodeType_0 = new A.EncodeType("comprossed");
    B.EncodeType_1 = new A.EncodeType("hybrid");
    B.EncodeType_2 = new A.EncodeType("raw");
    B.EncodeType_3 = new A.EncodeType("uncompressed");
    B.ErgoNetworkTypes_0 = new A.ErgoNetworkTypes(0);
    B.ErgoNetworkTypes_16 = new A.ErgoNetworkTypes(16);
    B.FloatLength_11_52 = new A.FloatLength(11, 52);
    B.FloatLength_5_10 = new A.FloatLength(5, 10);
    B.FloatLength_8_23 = new A.FloatLength(8, 23);
    B.FriendlyAddressFlags_128 = new A.FriendlyAddressFlags(128);
    B.FriendlyAddressFlags_17 = new A.FriendlyAddressFlags(17);
    B.FriendlyAddressFlags_81 = new A.FriendlyAddressFlags(81);
    B.JacobiError_QXN = new A.JacobiError("n must be larger than 2");
    B.JacobiError_afZ = new A.JacobiError("n must be odd");
    B.JsonDecoder_null = new A.JsonDecoder(null);
    B.JsonEncoder_null = new A.JsonEncoder(null);
    B.Latin1Decoder_false_255 = new A.Latin1Decoder(false, 255);
    B.Latin1Encoder_255 = new A.Latin1Encoder(255);
    B.List_176 = A._setArrayType(makeConstList([176]), type$.JSArray_int);
    B.List_48 = A._setArrayType(makeConstList([48]), type$.JSArray_int);
    B.List_50 = A._setArrayType(makeConstList([50]), type$.JSArray_int);
    B.CoinParams_2jN = new A.CoinParams(null, null, "ltc", null, B.List_176, null, null, null, null, B.List_48, null, null, B.List_50, null, null, B.List_00, B.List_5, null, null, null, null, null);
    B.CoinConf_odZ = new A.CoinConf(B.CoinNames_Litecoin, B.CoinParams_2jN);
    B.SegwitAddresType_P2WPKH = new A.SegwitAddresType("P2WPKH");
    B.SegwitAddresType_P2WSH = new A.SegwitAddresType("P2WSH");
    B.P2shAddressType_qI5 = new A.P2shAddressType(20, "P2SH/P2WSH");
    B.P2shAddressType_SfU = new A.P2shAddressType(20, "P2SH/P2WPKH");
    B.List_j4A = A._setArrayType(makeConstList([B.P2pkhAddressType_P2PKH, B.SegwitAddresType_P2WPKH, B.C_PubKeyAddressType, B.SegwitAddresType_P2WSH, B.P2shAddressType_qI5, B.P2shAddressType_SfU, B.P2shAddressType_sc9, B.P2shAddressType_g2q]), type$.JSArray_BitcoinAddressType);
    B.LitecoinNetwork_OXY = new A.LitecoinNetwork(B.CoinConf_odZ, "litecoinMainnet");
    B.List_58 = A._setArrayType(makeConstList([58]), type$.JSArray_int);
    B.CoinParams_xw8 = new A.CoinParams(null, null, "tltc", null, B.List_239, null, null, null, null, B.List_111, null, null, B.List_58, null, null, B.List_111, B.List_196, null, null, null, null, null);
    B.CoinConf_QCv = new A.CoinConf(B.CoinNames_IIS, B.CoinParams_xw8);
    B.LitecoinNetwork_CiQ = new A.LitecoinNetwork(B.CoinConf_QCv, "litecoinTestnet");
    B.List_140 = A._setArrayType(makeConstList([140]), type$.JSArray_int);
    B.CoinParams_H7P0 = new A.CoinParams(B.List_140, B.List_19, null, null, B.List_239, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_kEL = new A.CoinConf(B.CoinNames_MUB, B.CoinParams_H7P0);
    B.DashNetwork_QOU = new A.DashNetwork(B.CoinConf_kEL, "dashTestnet");
    B.CoinParams_H7P1 = new A.CoinParams(B.List_111, B.List_196, null, null, B.List_239, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    B.CoinConf_eMT = new A.CoinConf(B.CoinNames_B2l, B.CoinParams_H7P1);
    B.BitcoinSVNetwork_UZe = new A.BitcoinSVNetwork(B.CoinConf_eMT, "BitcoinSVTestnet");
    B.List_01 = A._setArrayType(makeConstList([B.BitcoinNetwork_qBr, B.BitcoinNetwork_DSc, B.LitecoinNetwork_OXY, B.LitecoinNetwork_CiQ, B.DashNetwork_XbV, B.DashNetwork_QOU, B.DogecoinNetwork_6L0, B.DogecoinNetwork_n3E, B.BitcoinCashNetwork_q9y, B.BitcoinCashNetwork_69P, B.BitcoinSVNetwork_GZw, B.BitcoinSVNetwork_UZe, B.C_PepeNetwork]), A.findType("JSArray<BasedUtxoNetwork>"));
    B.List_0 = A._setArrayType(makeConstList([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), type$.JSArray_dynamic);
    B.List_0_0_0_0 = A._setArrayType(makeConstList([0, 0, 0, 0]), type$.JSArray_int);
    B.List_0_0_0_1 = A._setArrayType(makeConstList([0, 0, 0, 1]), type$.JSArray_int);
    B.List_0_0_2_1 = A._setArrayType(makeConstList([0, 0, 2, 1]), type$.JSArray_int);
    B.List_0_10_100_2 = A._setArrayType(makeConstList([0, 10, 100, 2]), type$.JSArray_int);
    B.List_0_10_100_3 = A._setArrayType(makeConstList([0, 10, 100, 3]), type$.JSArray_int);
    B.List_0_10_100_4 = A._setArrayType(makeConstList([0, 10, 100, 4]), type$.JSArray_int);
    B.List_0_10_200_0 = A._setArrayType(makeConstList([0, 10, 200, 0]), type$.JSArray_int);
    B.List_0uY = A._setArrayType(makeConstList(["'", "h", "p"]), type$.JSArray_String);
    B.List_1 = A._setArrayType(makeConstList([1]), type$.JSArray_int);
    B.List_100_0 = A._setArrayType(makeConstList([100, 0]), type$.JSArray_int);
    B.List_100_1 = A._setArrayType(makeConstList([100, 1]), type$.JSArray_int);
    B.List_100_2 = A._setArrayType(makeConstList([100, 2]), type$.JSArray_int);
    B.List_100_3 = A._setArrayType(makeConstList([100, 3]), type$.JSArray_int);
    B.List_100_4 = A._setArrayType(makeConstList([100, 4]), type$.JSArray_int);
    B.List_100_5 = A._setArrayType(makeConstList([100, 5]), type$.JSArray_int);
    B.List_100_6 = A._setArrayType(makeConstList([100, 6]), type$.JSArray_int);
    B.List_100_7 = A._setArrayType(makeConstList([100, 7]), type$.JSArray_int);
    B.List_100_8 = A._setArrayType(makeConstList([100, 8]), type$.JSArray_int);
    B.List_110 = A._setArrayType(makeConstList([110]), type$.JSArray_int);
    B.List_110_1 = A._setArrayType(makeConstList([110, 1]), type$.JSArray_int);
    B.List_110_10 = A._setArrayType(makeConstList([110, 10]), type$.JSArray_int);
    B.List_110_20 = A._setArrayType(makeConstList([110, 20]), type$.JSArray_int);
    B.List_110_30 = A._setArrayType(makeConstList([110, 30]), type$.JSArray_int);
    B.List_110_31 = A._setArrayType(makeConstList([110, 31]), type$.JSArray_int);
    B.List_110_32 = A._setArrayType(makeConstList([110, 32]), type$.JSArray_int);
    B.List_110_33 = A._setArrayType(makeConstList([110, 33]), type$.JSArray_int);
    B.List_120_10 = A._setArrayType(makeConstList([120, 10]), type$.JSArray_int);
    B.List_2 = A._setArrayType(makeConstList([2]), type$.JSArray_int);
    B.List_200 = A._setArrayType(makeConstList([200]), type$.JSArray_int);
    B.List_200_191 = A._setArrayType(makeConstList([200, 191]), type$.JSArray_int);
    B.List_200_191_1 = A._setArrayType(makeConstList([200, 191, 1]), type$.JSArray_int);
    B.List_200_192 = A._setArrayType(makeConstList([200, 192]), type$.JSArray_int);
    B.List_200_192_1 = A._setArrayType(makeConstList([200, 192, 1]), type$.JSArray_int);
    B.List_200_192_1_0 = A._setArrayType(makeConstList([200, 192, 1, 0]), type$.JSArray_int);
    B.List_200_193 = A._setArrayType(makeConstList([200, 193]), type$.JSArray_int);
    B.List_200_193_1 = A._setArrayType(makeConstList([200, 193, 1]), type$.JSArray_int);
    B.List_200_193_1_0 = A._setArrayType(makeConstList([200, 193, 1, 0]), type$.JSArray_int);
    B.List_200_194 = A._setArrayType(makeConstList([200, 194]), type$.JSArray_int);
    B.List_200_195 = A._setArrayType(makeConstList([200, 195]), type$.JSArray_int);
    B.List_200_195_1 = A._setArrayType(makeConstList([200, 195, 1]), type$.JSArray_int);
    B.List_200_195_100 = A._setArrayType(makeConstList([200, 195, 100]), type$.JSArray_int);
    B.List_200_195_100_1 = A._setArrayType(makeConstList([200, 195, 100, 1]), type$.JSArray_int);
    B.List_200_195_100_2 = A._setArrayType(makeConstList([200, 195, 100, 2]), type$.JSArray_int);
    B.List_200_195_100_3 = A._setArrayType(makeConstList([200, 195, 100, 3]), type$.JSArray_int);
    B.List_200_195_100_4 = A._setArrayType(makeConstList([200, 195, 100, 4]), type$.JSArray_int);
    B.List_200_195_100_5 = A._setArrayType(makeConstList([200, 195, 100, 5]), type$.JSArray_int);
    B.List_200_195_100_6 = A._setArrayType(makeConstList([200, 195, 100, 6]), type$.JSArray_int);
    B.List_200_195_100_7 = A._setArrayType(makeConstList([200, 195, 100, 7]), type$.JSArray_int);
    B.List_200_195_100_8 = A._setArrayType(makeConstList([200, 195, 100, 8]), type$.JSArray_int);
    B.List_200_195_101 = A._setArrayType(makeConstList([200, 195, 101]), type$.JSArray_int);
    B.List_200_195_1_0 = A._setArrayType(makeConstList([200, 195, 1, 0]), type$.JSArray_int);
    B.List_200_196 = A._setArrayType(makeConstList([200, 196]), type$.JSArray_int);
    B.List_200_197 = A._setArrayType(makeConstList([200, 197]), type$.JSArray_int);
    B.List_200_197_100 = A._setArrayType(makeConstList([200, 197, 100]), type$.JSArray_int);
    B.List_200_198 = A._setArrayType(makeConstList([200, 198]), type$.JSArray_int);
    B.List_200_199 = A._setArrayType(makeConstList([200, 199]), type$.JSArray_int);
    B.List_200_200 = A._setArrayType(makeConstList([200, 200]), type$.JSArray_int);
    B.List_200_80 = A._setArrayType(makeConstList([200, 80]), type$.JSArray_int);
    B.List_20_32 = A._setArrayType(makeConstList([20, 32]), type$.JSArray_int);
    B.List_23 = A._setArrayType(makeConstList([23]), type$.JSArray_int);
    B.List_237 = A._setArrayType(makeConstList([237]), type$.JSArray_int);
    B.List_258 = A._setArrayType(makeConstList([258]), type$.JSArray_int);
    B.List_25_1 = A._setArrayType(makeConstList([25, 1]), type$.JSArray_int);
    B.List_28_184 = A._setArrayType(makeConstList([28, 184]), type$.JSArray_int);
    B.List_28_186 = A._setArrayType(makeConstList([28, 186]), type$.JSArray_int);
    B.List_28_189 = A._setArrayType(makeConstList([28, 189]), type$.JSArray_int);
    B.List_29_37 = A._setArrayType(makeConstList([29, 37]), type$.JSArray_int);
    B.List_2bH = A._setArrayType(makeConstList([1, 32898, 32906, 2147516416, 32907, 2147483649, 2147516545, 32777, 138, 136, 2147516425, 2147483658, 2147516555, 139, 32905, 32771, 32770, 128, 32778, 2147483658, 2147516545, 32896, 2147483649, 2147516424]), type$.JSArray_dynamic);
    B.List_2jN = A._setArrayType(makeConstList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]), type$.JSArray_int);
    B.SubstrateCoins_acalaEd25519 = new A.SubstrateCoins("acalaEd25519");
    B.SubstrateCoins_acalaSecp256k1 = new A.SubstrateCoins("acalaSecp256k1");
    B.SubstrateCoins_acalaSr25519 = new A.SubstrateCoins("acalaSr25519");
    B.SubstrateCoins_bifrostEd25519 = new A.SubstrateCoins("bifrostEd25519");
    B.SubstrateCoins_bifrostSecp256k1 = new A.SubstrateCoins("bifrostSecp256k1");
    B.SubstrateCoins_bifrostSr25519 = new A.SubstrateCoins("bifrostSr25519");
    B.SubstrateCoins_chainxEd25519 = new A.SubstrateCoins("chainxEd25519");
    B.SubstrateCoins_chainxSecp256k1 = new A.SubstrateCoins("chainxSecp256k1");
    B.SubstrateCoins_chainxSr25519 = new A.SubstrateCoins("chainxSr25519");
    B.SubstrateCoins_edgewareEd25519 = new A.SubstrateCoins("edgewareEd25519");
    B.SubstrateCoins_edgewareSecp256k1 = new A.SubstrateCoins("edgewareSecp256k1");
    B.SubstrateCoins_edgewareSr25519 = new A.SubstrateCoins("edgewareSr25519");
    B.SubstrateCoins_genericEd25519 = new A.SubstrateCoins("genericEd25519");
    B.SubstrateCoins_genericSecp256k1 = new A.SubstrateCoins("genericSecp256k1");
    B.SubstrateCoins_genericSr25519 = new A.SubstrateCoins("genericSr25519");
    B.SubstrateCoins_karuraEd25519 = new A.SubstrateCoins("karuraEd25519");
    B.SubstrateCoins_karuraSecp256k1 = new A.SubstrateCoins("karuraSecp256k1");
    B.SubstrateCoins_karuraSr25519 = new A.SubstrateCoins("karuraSr25519");
    B.SubstrateCoins_kusamaEd25519 = new A.SubstrateCoins("kusamaEd25519");
    B.SubstrateCoins_kusamaSecp256k1 = new A.SubstrateCoins("kusamaSecp256k1");
    B.SubstrateCoins_kusamaSr25519 = new A.SubstrateCoins("kusamaSr25519");
    B.SubstrateCoins_moonbeamEd25519 = new A.SubstrateCoins("moonbeamEd25519");
    B.SubstrateCoins_moonbeamSecp256k1 = new A.SubstrateCoins("moonbeamSecp256k1");
    B.SubstrateCoins_moonbeamSr25519 = new A.SubstrateCoins("moonbeamSr25519");
    B.SubstrateCoins_moonriverEd25519 = new A.SubstrateCoins("moonriverEd25519");
    B.SubstrateCoins_moonriverSecp256k1 = new A.SubstrateCoins("moonriverSecp256k1");
    B.SubstrateCoins_moonriverSr25519 = new A.SubstrateCoins("moonriverSr25519");
    B.SubstrateCoins_phalaEd25519 = new A.SubstrateCoins("phalaEd25519");
    B.SubstrateCoins_phalaSecp256k1 = new A.SubstrateCoins("phalaSecp256k1");
    B.SubstrateCoins_phalaSr25519 = new A.SubstrateCoins("phalaSr25519");
    B.SubstrateCoins_plasmEd25519 = new A.SubstrateCoins("plasmEd25519");
    B.SubstrateCoins_plasmSecp256k1 = new A.SubstrateCoins("plasmSecp256k1");
    B.SubstrateCoins_plasmSr25519 = new A.SubstrateCoins("plasmSr25519");
    B.SubstrateCoins_polkadotEd25519 = new A.SubstrateCoins("polkadotEd25519");
    B.SubstrateCoins_polkadotSecp256k1 = new A.SubstrateCoins("polkadotSecp256k1");
    B.SubstrateCoins_polkadotSr25519 = new A.SubstrateCoins("polkadotSr25519");
    B.SubstrateCoins_soraEd25519 = new A.SubstrateCoins("soraEd25519");
    B.SubstrateCoins_soraSecp256k1 = new A.SubstrateCoins("soraSecp256k1");
    B.SubstrateCoins_soraSr25519 = new A.SubstrateCoins("soraSr25519");
    B.SubstrateCoins_stafiEd25519 = new A.SubstrateCoins("stafiEd25519");
    B.SubstrateCoins_stafiSecp256k1 = new A.SubstrateCoins("stafiSecp256k1");
    B.SubstrateCoins_stafiSr25519 = new A.SubstrateCoins("stafiSr25519");
    B.List_2lW = A._setArrayType(makeConstList([B.SubstrateCoins_acalaEd25519, B.SubstrateCoins_acalaSecp256k1, B.SubstrateCoins_acalaSr25519, B.SubstrateCoins_bifrostEd25519, B.SubstrateCoins_bifrostSecp256k1, B.SubstrateCoins_bifrostSr25519, B.SubstrateCoins_chainxEd25519, B.SubstrateCoins_chainxSecp256k1, B.SubstrateCoins_chainxSr25519, B.SubstrateCoins_edgewareEd25519, B.SubstrateCoins_edgewareSecp256k1, B.SubstrateCoins_edgewareSr25519, B.SubstrateCoins_genericEd25519, B.SubstrateCoins_genericSecp256k1, B.SubstrateCoins_genericSr25519, B.SubstrateCoins_karuraEd25519, B.SubstrateCoins_karuraSecp256k1, B.SubstrateCoins_karuraSr25519, B.SubstrateCoins_kusamaEd25519, B.SubstrateCoins_kusamaSecp256k1, B.SubstrateCoins_kusamaSr25519, B.SubstrateCoins_moonbeamEd25519, B.SubstrateCoins_moonbeamSecp256k1, B.SubstrateCoins_moonbeamSr25519, B.SubstrateCoins_moonriverEd25519, B.SubstrateCoins_moonriverSecp256k1, B.SubstrateCoins_moonriverSr25519, B.SubstrateCoins_phalaEd25519, B.SubstrateCoins_phalaSecp256k1, B.SubstrateCoins_phalaSr25519, B.SubstrateCoins_plasmEd25519, B.SubstrateCoins_plasmSecp256k1, B.SubstrateCoins_plasmSr25519, B.SubstrateCoins_polkadotEd25519, B.SubstrateCoins_polkadotSecp256k1, B.SubstrateCoins_polkadotSr25519, B.SubstrateCoins_soraEd25519, B.SubstrateCoins_soraSecp256k1, B.SubstrateCoins_soraSr25519, B.SubstrateCoins_stafiEd25519, B.SubstrateCoins_stafiSecp256k1, B.SubstrateCoins_stafiSr25519]), A.findType("JSArray<SubstrateCoins>"));
    B.List_2yZ = A._setArrayType(makeConstList([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]), type$.JSArray_dynamic);
    B.List_3 = A._setArrayType(makeConstList([3]), type$.JSArray_int);
    B.List_32 = A._setArrayType(makeConstList([32]), type$.JSArray_int);
    B.List_35 = A._setArrayType(makeConstList([35]), type$.JSArray_int);
    B.List_4 = A._setArrayType(makeConstList([4]), type$.JSArray_int);
    B.List_42A = A._setArrayType(makeConstList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]), type$.JSArray_int);
    B.List_46_47 = A._setArrayType(makeConstList([46, 47]), type$.JSArray_int);
    B.List_4AN = A._setArrayType(makeConstList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]), type$.JSArray_int);
    B.List_4_147 = A._setArrayType(makeConstList([4, 147]), type$.JSArray_int);
    B.List_50_1 = A._setArrayType(makeConstList([50, 1]), type$.JSArray_int);
    B.List_5Nm = A._setArrayType(makeConstList(["RawSocketEvent.read", "RawSocketEvent.write", "RawSocketEvent.readClosed", "RawSocketEvent.closed"]), type$.JSArray_String);
    B.List_5_68 = A._setArrayType(makeConstList([5, 68]), type$.JSArray_int);
    B.List_60_12 = A._setArrayType(makeConstList([60, 12]), type$.JSArray_int);
    B.List_60_3 = A._setArrayType(makeConstList([60, 3]), type$.JSArray_int);
    B.List_65 = A._setArrayType(makeConstList([65]), type$.JSArray_int);
    B.List_6yO = A._setArrayType(makeConstList([B.ADANetwork_1_764824073_mainnet, B.ADANetwork_0_1097911063_testnet, B.ADANetwork_0_2_testnetPreview, B.ADANetwork_0_1_testnetPreprod]), A.findType("JSArray<ADANetwork>"));
    B.List_80 = A._setArrayType(makeConstList([80]), type$.JSArray_int);
    B.List_80_0_1 = A._setArrayType(makeConstList([80, 0, 1]), type$.JSArray_int);
    B.List_80_0_10 = A._setArrayType(makeConstList([80, 0, 10]), type$.JSArray_int);
    B.List_80_0_11 = A._setArrayType(makeConstList([80, 0, 11]), type$.JSArray_int);
    B.List_80_0_12 = A._setArrayType(makeConstList([80, 0, 12]), type$.JSArray_int);
    B.List_80_0_13 = A._setArrayType(makeConstList([80, 0, 13]), type$.JSArray_int);
    B.List_80_0_2 = A._setArrayType(makeConstList([80, 0, 2]), type$.JSArray_int);
    B.List_80_0_3 = A._setArrayType(makeConstList([80, 0, 3]), type$.JSArray_int);
    B.List_80_0_4 = A._setArrayType(makeConstList([80, 0, 4]), type$.JSArray_int);
    B.List_80_0_5 = A._setArrayType(makeConstList([80, 0, 5]), type$.JSArray_int);
    B.List_80_0_6 = A._setArrayType(makeConstList([80, 0, 6]), type$.JSArray_int);
    B.List_80_0_7 = A._setArrayType(makeConstList([80, 0, 7]), type$.JSArray_int);
    B.List_80_1_1 = A._setArrayType(makeConstList([80, 1, 1]), type$.JSArray_int);
    B.List_80_1_2 = A._setArrayType(makeConstList([80, 1, 2]), type$.JSArray_int);
    B.List_80_1_3 = A._setArrayType(makeConstList([80, 1, 3]), type$.JSArray_int);
    B.List_80_1_4 = A._setArrayType(makeConstList([80, 1, 4]), type$.JSArray_int);
    B.List_80_1_5 = A._setArrayType(makeConstList([80, 1, 5]), type$.JSArray_int);
    B.List_80_1_6 = A._setArrayType(makeConstList([80, 1, 6]), type$.JSArray_int);
    B.List_80_1_7 = A._setArrayType(makeConstList([80, 1, 7]), type$.JSArray_int);
    B.List_80_1_8 = A._setArrayType(makeConstList([80, 1, 8]), type$.JSArray_int);
    B.List_80_1_9 = A._setArrayType(makeConstList([80, 1, 9]), type$.JSArray_int);
    B.List_8cU = A._setArrayType(makeConstList([0, 0, 2147483648, 2147483648, 0, 0, 2147483648, 2147483648, 0, 0, 0, 0, 0, 2147483648, 2147483648, 2147483648, 2147483648, 2147483648, 0, 2147483648, 2147483648, 2147483648, 0, 2147483648]), type$.JSArray_dynamic);
    B.List_90_0 = A._setArrayType(makeConstList([90, 0]), type$.JSArray_int);
    B.List_90_1 = A._setArrayType(makeConstList([90, 1]), type$.JSArray_int);
    B.List_90_10 = A._setArrayType(makeConstList([90, 10]), type$.JSArray_int);
    B.List_90_2 = A._setArrayType(makeConstList([90, 2]), type$.JSArray_int);
    B.List_90_3 = A._setArrayType(makeConstList([90, 3]), type$.JSArray_int);
    B.List_90_4 = A._setArrayType(makeConstList([90, 4]), type$.JSArray_int);
    B.List_90_5 = A._setArrayType(makeConstList([90, 5]), type$.JSArray_int);
    B.List_90_6 = A._setArrayType(makeConstList([90, 6]), type$.JSArray_int);
    B.List_90_7 = A._setArrayType(makeConstList([90, 7]), type$.JSArray_int);
    B.List_90_8 = A._setArrayType(makeConstList([90, 8]), type$.JSArray_int);
    B.List_90_9 = A._setArrayType(makeConstList([90, 9]), type$.JSArray_int);
    B.ResourceCode_0_BANDWIDTH = new A.ResourceCode(0, "BANDWIDTH");
    B.ResourceCode_1_ENERGY = new A.ResourceCode(1, "ENERGY");
    B.ResourceCode_2_TRON_POWER = new A.ResourceCode(2, "TRON_POWER");
    B.List_B8J = A._setArrayType(makeConstList([B.ResourceCode_0_BANDWIDTH, B.ResourceCode_1_ENERGY, B.ResourceCode_2_TRON_POWER]), A.findType("JSArray<ResourceCode>"));
    B.List_Cpl1 = A._setArrayType(makeConstList([200, 192, 1, 0, 0]), type$.JSArray_int);
    B.List_Cpl0 = A._setArrayType(makeConstList([200, 193, 1, 0, 0]), type$.JSArray_int);
    B.List_Cpl = A._setArrayType(makeConstList([200, 195, 1, 0, 0]), type$.JSArray_int);
    B.List_empty1 = A._setArrayType(makeConstList([]), type$.JSArray_String);
    B.Web3EthereumRequestMethods_0_eth_sendTransaction_List_empty = new A.Web3EthereumRequestMethods(0, "eth_sendTransaction", B.List_empty1);
    B.Web3EthereumRequestMethods_1_personal_sign_List_empty = new A.Web3EthereumRequestMethods(1, "personal_sign", B.List_empty1);
    B.List_Aij = A._setArrayType(makeConstList(["eth_signTypedData_v3", "eth_signTypedData_v4"]), type$.JSArray_String);
    B.Web3EthereumRequestMethods_MEg = new A.Web3EthereumRequestMethods(2, "eth_signTypedData", B.List_Aij);
    B.Web3EthereumRequestMethods_7xV = new A.Web3EthereumRequestMethods(3, "wallet_addEthereumChain", B.List_empty1);
    B.Web3EthereumRequestMethods_EuK = new A.Web3EthereumRequestMethods(4, "wallet_switchEthereumChain", B.List_empty1);
    B.Web3EthereumRequestMethods_5_eth_requestAccounts_List_empty = new A.Web3EthereumRequestMethods(5, "eth_requestAccounts", B.List_empty1);
    B.List_EUu = A._setArrayType(makeConstList([B.Web3EthereumRequestMethods_0_eth_sendTransaction_List_empty, B.Web3EthereumRequestMethods_1_personal_sign_List_empty, B.Web3EthereumRequestMethods_MEg, B.Web3EthereumRequestMethods_7xV, B.Web3EthereumRequestMethods_EuK, B.Web3EthereumRequestMethods_5_eth_requestAccounts_List_empty]), A.findType("JSArray<Web3EthereumRequestMethods>"));
    B.List_GVy = A._setArrayType(makeConstList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]), type$.JSArray_int);
    B.List_Gbr = A._setArrayType(makeConstList([B.EIP712Version_1, B.EIP712Version_3, B.EIP712Version_4]), A.findType("JSArray<EIP712Version>"));
    B.List_0_10_100_0 = A._setArrayType(makeConstList([0, 10, 100, 0]), type$.JSArray_int);
    B.Web3MessageTypes_eYh = new A.Web3MessageTypes(B.List_0_10_100_0, "chain");
    B.List_0_10_100_1 = A._setArrayType(makeConstList([0, 10, 100, 1]), type$.JSArray_int);
    B.Web3MessageTypes_n9E = new A.Web3MessageTypes(B.List_0_10_100_1, "chains");
    B.Web3MessageTypes_359 = new A.Web3MessageTypes(B.List_0_10_100_2, "walletRequest");
    B.Web3MessageTypes_fvN = new A.Web3MessageTypes(B.List_0_10_100_3, "requestResponse");
    B.Web3MessageTypes_L6o = new A.Web3MessageTypes(B.List_0_10_100_4, "error");
    B.List_HjA = A._setArrayType(makeConstList([B.Web3MessageTypes_eYh, B.Web3MessageTypes_n9E, B.Web3MessageTypes_359, B.Web3MessageTypes_fvN, B.Web3MessageTypes_L6o]), A.findType("JSArray<Web3MessageTypes>"));
    B.List_M2I = A._setArrayType(makeConstList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]), type$.JSArray_int);
    B.PermissionType_Owner_0 = new A.PermissionType("Owner", 0);
    B.PermissionType_Witness_1 = new A.PermissionType("Witness", 1);
    B.PermissionType_Active_2 = new A.PermissionType("Active", 2);
    B.List_OLT = A._setArrayType(makeConstList([B.PermissionType_Owner_0, B.PermissionType_Witness_1, B.PermissionType_Active_2]), A.findType("JSArray<PermissionType>"));
    B.List_R2g = A._setArrayType(makeConstList([B.CosmosNetworkTypes_0, B.CosmosNetworkTypes_1, B.CosmosNetworkTypes_2]), A.findType("JSArray<CosmosNetworkTypes>"));
    B.List_Tre = A._setArrayType(makeConstList([B.BipProposal_bip44, B.BipProposal_bip49, B.BipProposal_bip84, B.BipProposal_bip86]), A.findType("JSArray<BipProposal>"));
    B.List_VOY = A._setArrayType(makeConstList([0, 0, 32776, 33792, 1, 10240, 0, 0]), type$.JSArray_int);
    B.List_Vul = A._setArrayType(makeConstList([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]), type$.JSArray_int);
    B.List_Vul1 = A._setArrayType(makeConstList([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]), type$.JSArray_int);
    B.List_Vul2 = A._setArrayType(makeConstList([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]), type$.JSArray_int);
    B.List_Vul0 = A._setArrayType(makeConstList([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]), type$.JSArray_int);
    B.ProviderAuthType_0 = new A.ProviderAuthType("header");
    B.ProviderAuthType_1 = new A.ProviderAuthType("path");
    B.ProviderAuthType_2 = new A.ProviderAuthType("query");
    B.List_XC3 = A._setArrayType(makeConstList([B.ProviderAuthType_0, B.ProviderAuthType_1, B.ProviderAuthType_2]), A.findType("JSArray<ProviderAuthType>"));
    B.List_YyJ = A._setArrayType(makeConstList([0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918000, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117]), type$.JSArray_int);
    B.List_adS = A._setArrayType(makeConstList([B.AppPlatform_0, B.AppPlatform_1, B.AppPlatform_2, B.AppPlatform_3, B.AppPlatform_4]), type$.JSArray_AppPlatform);
    B.List_ah9 = A._setArrayType(makeConstList([B.P2shAddressType_sc9, B.P2shAddressType_hK7, B.P2shAddressType_lhG, B.P2shAddressType_0]), A.findType("JSArray<P2shAddressType>"));
    B.List_akr = A._setArrayType(makeConstList([B.EllipticCurveTypes_ed25519, B.EllipticCurveTypes_ed25519Blake2b, B.EllipticCurveTypes_ed25519Kholaw, B.EllipticCurveTypes_ed25519Monero, B.EllipticCurveTypes_nist256p1, B.EllipticCurveTypes_secp256k1, B.EllipticCurveTypes_sr25519]), A.findType("JSArray<EllipticCurveTypes>"));
    B.List_bdS = A._setArrayType(makeConstList(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"]), type$.JSArray_String);
    B.List_cL3 = A._setArrayType(makeConstList([404, 400, 401, 403, 405, 408, 500, 503]), type$.JSArray_int);
    B.List_empty14 = A._setArrayType(makeConstList([]), A.findType("JSArray<ContactCore<0&>>"));
    B.List_empty3 = A._setArrayType(makeConstList([]), type$.JSArray_List_BigInt);
    B.List_empty2 = A._setArrayType(makeConstList([]), A.findType("JSArray<Web3Permission<ADAAddress>>"));
    B.List_empty12 = A._setArrayType(makeConstList([]), A.findType("JSArray<Web3Permission<BitcoinBaseAddress>>"));
    B.List_empty9 = A._setArrayType(makeConstList([]), A.findType("JSArray<Web3Permission<CosmosBaseAddress>>"));
    B.List_empty10 = A._setArrayType(makeConstList([]), A.findType("JSArray<Web3Permission<ETHAddress>>"));
    B.List_empty5 = A._setArrayType(makeConstList([]), A.findType("JSArray<Web3Permission<SolAddress>>"));
    B.List_empty11 = A._setArrayType(makeConstList([]), A.findType("JSArray<Web3Permission<SubstrateAddress>>"));
    B.List_empty8 = A._setArrayType(makeConstList([]), A.findType("JSArray<Web3Permission<TonAddress>>"));
    B.List_empty7 = A._setArrayType(makeConstList([]), A.findType("JSArray<Web3Permission<TronAddress>>"));
    B.List_empty6 = A._setArrayType(makeConstList([]), A.findType("JSArray<Web3Permission<XRPAddress>>"));
    B.List_empty15 = A._setArrayType(makeConstList([]), A.findType("JSArray<Web3Permission<0&>>"));
    B.List_empty4 = A._setArrayType(makeConstList([]), type$.JSArray_int);
    B.List_empty13 = A._setArrayType(makeConstList([]), A.findType("JSArray<0&>"));
    B.List_empty = A._setArrayType(makeConstList([]), type$.JSArray_dynamic);
    B.List_gQW = A._setArrayType(makeConstList([B.AddressDerivationType_List_200_81_bip32, B.AddressDerivationType_List_200_84_substrate, B.AddressDerivationType_List_200_83_multisig]), A.findType("JSArray<AddressDerivationType>"));
    B.TonApiType_tonApi = new A.TonApiType("tonApi");
    B.TonApiType_tonCenter = new A.TonApiType("tonCenter");
    B.List_ivT = A._setArrayType(makeConstList([B.TonApiType_tonApi, B.TonApiType_tonCenter]), A.findType("JSArray<TonApiType>"));
    B.SeedTypes_Bip39_bip39 = new A.SeedTypes("Bip39", "bip39");
    B.SeedTypes_Bip39Entropy_bip39Entropy = new A.SeedTypes("Bip39Entropy", "bip39Entropy");
    B.SeedTypes_ByronLegacySeed_byronLegacySeed = new A.SeedTypes("ByronLegacySeed", "byronLegacySeed");
    B.SeedTypes_icarus_icarus = new A.SeedTypes("icarus", "icarus");
    B.List_jnD = A._setArrayType(makeConstList([B.SeedTypes_Bip39_bip39, B.SeedTypes_Bip39Entropy_bip39Entropy, B.SeedTypes_ByronLegacySeed_byronLegacySeed, B.SeedTypes_icarus_icarus]), A.findType("JSArray<SeedTypes>"));
    B.WalletVersion_v1R1 = new A.WalletVersion("v1R1");
    B.WalletVersion_v1R2 = new A.WalletVersion("v1R2");
    B.WalletVersion_v1R3 = new A.WalletVersion("v1R3");
    B.WalletVersion_v2R1 = new A.WalletVersion("v2R1");
    B.WalletVersion_v2R2 = new A.WalletVersion("v2R2");
    B.WalletVersion_v3R1 = new A.WalletVersion("v3R1");
    B.WalletVersion_v3R2 = new A.WalletVersion("v3R2");
    B.WalletVersion_v4 = new A.WalletVersion("v4");
    B.List_oOy = A._setArrayType(makeConstList([B.WalletVersion_v1R1, B.WalletVersion_v1R2, B.WalletVersion_v1R3, B.WalletVersion_v2R1, B.WalletVersion_v2R2, B.WalletVersion_v3R1, B.WalletVersion_v3R2, B.WalletVersion_v4]), A.findType("JSArray<WalletVersion>"));
    B.SegwitAddresType_P2TR = new A.SegwitAddresType("P2TR");
    B.List_oyU = A._setArrayType(makeConstList([B.P2pkhAddressType_P2PKH, B.SegwitAddresType_P2WPKH, B.SegwitAddresType_P2TR, B.SegwitAddresType_P2WSH, B.P2shAddressType_qI5, B.P2shAddressType_SfU, B.P2shAddressType_sc9, B.P2shAddressType_g2q, B.P2shAddressType_hK7, B.P2shAddressType_Q9u, B.P2shAddressType_0, B.P2shAddressType_TLC, B.P2shAddressType_lhG, B.P2shAddressType_CXi, B.P2pkhAddressType_P2PKHWT]), type$.JSArray_BitcoinAddressType);
    B.List_piR = A._setArrayType(makeConstList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]), type$.JSArray_int);
    B.List_s8b = A._setArrayType(makeConstList([256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 256, 256, 256, 256, 256, 256, 256, 10, 11, 12, 13, 14, 15, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 10, 11, 12, 13, 14, 15, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256]), type$.JSArray_int);
    B.NetworkType_8eb = new A.NetworkType("Bitcoin", B.List_80_0_1);
    B.NetworkType_8eb0 = new A.NetworkType("Bitcoin", B.List_80_0_10);
    B.NetworkType_Oh2 = new A.NetworkType("XRPL", B.List_80_0_2);
    B.NetworkType_iDZ = new A.NetworkType("Ethereum", B.List_80_0_3);
    B.NetworkType_SkF = new A.NetworkType("Tron", B.List_80_0_4);
    B.NetworkType_4QF = new A.NetworkType("Solana", B.List_80_0_5);
    B.NetworkType_4ei = new A.NetworkType("Cardano", B.List_80_0_6);
    B.NetworkType_66M = new A.NetworkType("TON", B.List_80_0_11);
    B.NetworkType_QJm = new A.NetworkType("Cosmos", B.List_80_0_7);
    B.NetworkType_GRA = new A.NetworkType("Polkadot", B.List_80_0_12);
    B.NetworkType_0 = new A.NetworkType("Kusama", B.List_80_0_13);
    B.List_sAO = A._setArrayType(makeConstList([B.NetworkType_8eb, B.NetworkType_8eb0, B.NetworkType_Oh2, B.NetworkType_iDZ, B.NetworkType_SkF, B.NetworkType_4QF, B.NetworkType_4ei, B.NetworkType_66M, B.NetworkType_QJm, B.NetworkType_GRA, B.NetworkType_0]), A.findType("JSArray<NetworkType>"));
    B.List_swi = A._setArrayType(makeConstList([B.BitcoinExplorerProviderType_0, B.BitcoinExplorerProviderType_1]), A.findType("JSArray<BitcoinExplorerProviderType>"));
    B.ADAByronAddrTypes_2_redemption = new A.ADAByronAddrTypes(2, "redemption");
    B.List_ugX = A._setArrayType(makeConstList([B.ADAByronAddrTypes_0_publicKey, B.ADAByronAddrTypes_2_redemption]), A.findType("JSArray<ADAByronAddrTypes>"));
    B.List_34 = A._setArrayType(makeConstList([34]), type$.JSArray_int);
    B.CborBase64Types_List_34 = new A.CborBase64Types(B.List_34);
    B.List_33 = A._setArrayType(makeConstList([33]), type$.JSArray_int);
    B.CborBase64Types_List_33 = new A.CborBase64Types(B.List_33);
    B.List_21 = A._setArrayType(makeConstList([21]), type$.JSArray_int);
    B.CborBase64Types_List_21 = new A.CborBase64Types(B.List_21);
    B.CborBase64Types_List_22 = new A.CborBase64Types(B.List_22);
    B.CborBase64Types_List_23 = new A.CborBase64Types(B.List_23);
    B.List_ww8 = A._setArrayType(makeConstList([B.CborBase64Types_List_34, B.CborBase64Types_List_33, B.CborBase64Types_List_21, B.CborBase64Types_List_22, B.CborBase64Types_List_23]), A.findType("JSArray<CborBase64Types>"));
    B.List_yH3 = A._setArrayType(makeConstList([B.ADAAddressType_0_Base, B.ADAAddressType_14_Reward, B.ADAAddressType_6_Enterprise, B.ADAAddressType_4_Pointer, B.ADAAddressType_8_Byron]), A.findType("JSArray<ADAAddressType>"));
    B.ServiceProtocol_SSL_1_ssl = new A.ServiceProtocol("SSL", 1, "ssl");
    B.ServiceProtocol_TCP_2_tcp = new A.ServiceProtocol("TCP", 2, "tcp");
    B.ServiceProtocol_WebSocket_3_websocket = new A.ServiceProtocol("WebSocket", 3, "websocket");
    B.List_yX5 = A._setArrayType(makeConstList([B.ServiceProtocol_HTTP_0_http, B.ServiceProtocol_SSL_1_ssl, B.ServiceProtocol_TCP_2_tcp, B.ServiceProtocol_WebSocket_3_websocket]), A.findType("JSArray<ServiceProtocol>"));
    B.ContentType_1_extenal = new A.ContentType(1, "extenal");
    B.ContentType_2_memory = new A.ContentType(2, "memory");
    B.List_zvt = A._setArrayType(makeConstList([B.ContentType_0_local, B.ContentType_1_extenal, B.ContentType_2_memory]), A.findType("JSArray<ContentType>"));
    B.Map_2NhUP = new A.GeneralConstantMap([B.Bech32Encodings_0, 1, B.Bech32Encodings_1, 734539939], A.findType("GeneralConstantMap<Bech32Encodings,int>"));
    B.Object_0dL = {OP_0: 0, OP_FALSE: 1, OP_PUSHDATA1: 2, OP_PUSHDATA2: 3, OP_PUSHDATA4: 4, OP_1NEGATE: 5, OP_1: 6, OP_TRUE: 7, OP_2: 8, OP_3: 9, OP_4: 10, OP_5: 11, OP_6: 12, OP_7: 13, OP_8: 14, OP_9: 15, OP_10: 16, OP_11: 17, OP_12: 18, OP_13: 19, OP_14: 20, OP_15: 21, OP_16: 22, OP_NOP: 23, OP_IF: 24, OP_NOTIF: 25, OP_ELSE: 26, OP_ENDIF: 27, OP_VERIFY: 28, OP_RETURN: 29, OP_TOALTSTACK: 30, OP_FROMALTSTACK: 31, OP_IFDUP: 32, OP_DEPTH: 33, OP_DROP: 34, OP_DUP: 35, OP_NIP: 36, OP_OVER: 37, OP_PICK: 38, OP_ROLL: 39, OP_ROT: 40, OP_SWAP: 41, OP_TUCK: 42, OP_2DROP: 43, OP_2DUP: 44, OP_3DUP: 45, OP_2OVER: 46, OP_2ROT: 47, OP_2SWAP: 48, OP_SIZE: 49, OP_EQUAL: 50, OP_EQUALVERIFY: 51, OP_1ADD: 52, OP_1SUB: 53, OP_NEGATE: 54, OP_ABS: 55, OP_NOT: 56, OP_0NOTEQUAL: 57, OP_ADD: 58, OP_SUB: 59, OP_BOOLAND: 60, OP_BOOLOR: 61, OP_NUMEQUAL: 62, OP_NUMEQUALVERIFY: 63, OP_NUMNOTEQUAL: 64, OP_LESSTHAN: 65, OP_GREATERTHAN: 66, OP_LESSTHANOREQUAL: 67, OP_GREATERTHANOREQUAL: 68, OP_MIN: 69, OP_MAX: 70, OP_WITHIN: 71, OP_RIPEMD160: 72, OP_SHA1: 73, OP_SHA256: 74, OP_HASH160: 75, OP_HASH256: 76, OP_CODESEPARATOR: 77, OP_CHECKSIG: 78, OP_CHECKSIGVERIFY: 79, OP_CHECKMULTISIG: 80, OP_CHECKMULTISIGVERIFY: 81, OP_NOP2: 82, OP_CHECKLOCKTIMEVERIFY: 83, OP_NOP3: 84, OP_CHECKSEQUENCEVERIFY: 85};
    B.List_77 = A._setArrayType(makeConstList([77]), type$.JSArray_int);
    B.List_78 = A._setArrayType(makeConstList([78]), type$.JSArray_int);
    B.List_79 = A._setArrayType(makeConstList([79]), type$.JSArray_int);
    B.List_81 = A._setArrayType(makeConstList([81]), type$.JSArray_int);
    B.List_82 = A._setArrayType(makeConstList([82]), type$.JSArray_int);
    B.List_83 = A._setArrayType(makeConstList([83]), type$.JSArray_int);
    B.List_84 = A._setArrayType(makeConstList([84]), type$.JSArray_int);
    B.List_85 = A._setArrayType(makeConstList([85]), type$.JSArray_int);
    B.List_86 = A._setArrayType(makeConstList([86]), type$.JSArray_int);
    B.List_87 = A._setArrayType(makeConstList([87]), type$.JSArray_int);
    B.List_88 = A._setArrayType(makeConstList([88]), type$.JSArray_int);
    B.List_89 = A._setArrayType(makeConstList([89]), type$.JSArray_int);
    B.List_90 = A._setArrayType(makeConstList([90]), type$.JSArray_int);
    B.List_91 = A._setArrayType(makeConstList([91]), type$.JSArray_int);
    B.List_92 = A._setArrayType(makeConstList([92]), type$.JSArray_int);
    B.List_93 = A._setArrayType(makeConstList([93]), type$.JSArray_int);
    B.List_94 = A._setArrayType(makeConstList([94]), type$.JSArray_int);
    B.List_95 = A._setArrayType(makeConstList([95]), type$.JSArray_int);
    B.List_96 = A._setArrayType(makeConstList([96]), type$.JSArray_int);
    B.List_97 = A._setArrayType(makeConstList([97]), type$.JSArray_int);
    B.List_99 = A._setArrayType(makeConstList([99]), type$.JSArray_int);
    B.List_100 = A._setArrayType(makeConstList([100]), type$.JSArray_int);
    B.List_103 = A._setArrayType(makeConstList([103]), type$.JSArray_int);
    B.List_104 = A._setArrayType(makeConstList([104]), type$.JSArray_int);
    B.List_105 = A._setArrayType(makeConstList([105]), type$.JSArray_int);
    B.List_106 = A._setArrayType(makeConstList([106]), type$.JSArray_int);
    B.List_107 = A._setArrayType(makeConstList([107]), type$.JSArray_int);
    B.List_108 = A._setArrayType(makeConstList([108]), type$.JSArray_int);
    B.List_115 = A._setArrayType(makeConstList([115]), type$.JSArray_int);
    B.List_116 = A._setArrayType(makeConstList([116]), type$.JSArray_int);
    B.List_117 = A._setArrayType(makeConstList([117]), type$.JSArray_int);
    B.List_118 = A._setArrayType(makeConstList([118]), type$.JSArray_int);
    B.List_119 = A._setArrayType(makeConstList([119]), type$.JSArray_int);
    B.List_120 = A._setArrayType(makeConstList([120]), type$.JSArray_int);
    B.List_121 = A._setArrayType(makeConstList([121]), type$.JSArray_int);
    B.List_122 = A._setArrayType(makeConstList([122]), type$.JSArray_int);
    B.List_123 = A._setArrayType(makeConstList([123]), type$.JSArray_int);
    B.List_124 = A._setArrayType(makeConstList([124]), type$.JSArray_int);
    B.List_125 = A._setArrayType(makeConstList([125]), type$.JSArray_int);
    B.List_109 = A._setArrayType(makeConstList([109]), type$.JSArray_int);
    B.List_112 = A._setArrayType(makeConstList([112]), type$.JSArray_int);
    B.List_114 = A._setArrayType(makeConstList([114]), type$.JSArray_int);
    B.List_130 = A._setArrayType(makeConstList([130]), type$.JSArray_int);
    B.List_135 = A._setArrayType(makeConstList([135]), type$.JSArray_int);
    B.List_136 = A._setArrayType(makeConstList([136]), type$.JSArray_int);
    B.List_139 = A._setArrayType(makeConstList([139]), type$.JSArray_int);
    B.List_143 = A._setArrayType(makeConstList([143]), type$.JSArray_int);
    B.List_144 = A._setArrayType(makeConstList([144]), type$.JSArray_int);
    B.List_145 = A._setArrayType(makeConstList([145]), type$.JSArray_int);
    B.List_146 = A._setArrayType(makeConstList([146]), type$.JSArray_int);
    B.List_147 = A._setArrayType(makeConstList([147]), type$.JSArray_int);
    B.List_148 = A._setArrayType(makeConstList([148]), type$.JSArray_int);
    B.List_154 = A._setArrayType(makeConstList([154]), type$.JSArray_int);
    B.List_155 = A._setArrayType(makeConstList([155]), type$.JSArray_int);
    B.List_156 = A._setArrayType(makeConstList([156]), type$.JSArray_int);
    B.List_157 = A._setArrayType(makeConstList([157]), type$.JSArray_int);
    B.List_159 = A._setArrayType(makeConstList([159]), type$.JSArray_int);
    B.List_160 = A._setArrayType(makeConstList([160]), type$.JSArray_int);
    B.List_161 = A._setArrayType(makeConstList([161]), type$.JSArray_int);
    B.List_162 = A._setArrayType(makeConstList([162]), type$.JSArray_int);
    B.List_163 = A._setArrayType(makeConstList([163]), type$.JSArray_int);
    B.List_164 = A._setArrayType(makeConstList([164]), type$.JSArray_int);
    B.List_165 = A._setArrayType(makeConstList([165]), type$.JSArray_int);
    B.List_166 = A._setArrayType(makeConstList([166]), type$.JSArray_int);
    B.List_167 = A._setArrayType(makeConstList([167]), type$.JSArray_int);
    B.List_168 = A._setArrayType(makeConstList([168]), type$.JSArray_int);
    B.List_169 = A._setArrayType(makeConstList([169]), type$.JSArray_int);
    B.List_170 = A._setArrayType(makeConstList([170]), type$.JSArray_int);
    B.List_171 = A._setArrayType(makeConstList([171]), type$.JSArray_int);
    B.List_172 = A._setArrayType(makeConstList([172]), type$.JSArray_int);
    B.List_173 = A._setArrayType(makeConstList([173]), type$.JSArray_int);
    B.List_174 = A._setArrayType(makeConstList([174]), type$.JSArray_int);
    B.List_175 = A._setArrayType(makeConstList([175]), type$.JSArray_int);
    B.List_177 = A._setArrayType(makeConstList([177]), type$.JSArray_int);
    B.List_178 = A._setArrayType(makeConstList([178]), type$.JSArray_int);
    B.Map_8ICny = new A.ConstantStringMap(B.Object_0dL, [B.List_00, B.List_00, B.List_76, B.List_77, B.List_78, B.List_79, B.List_81, B.List_81, B.List_82, B.List_83, B.List_84, B.List_85, B.List_86, B.List_87, B.List_88, B.List_89, B.List_90, B.List_91, B.List_92, B.List_93, B.List_94, B.List_95, B.List_96, B.List_97, B.List_99, B.List_100, B.List_103, B.List_104, B.List_105, B.List_106, B.List_107, B.List_108, B.List_115, B.List_116, B.List_117, B.List_118, B.List_119, B.List_120, B.List_121, B.List_122, B.List_123, B.List_124, B.List_125, B.List_109, B.List_110, B.List_111, B.List_112, B.List_113, B.List_114, B.List_130, B.List_135, B.List_136, B.List_139, B.List_140, B.List_143, B.List_144, B.List_145, B.List_146, B.List_147, B.List_148, B.List_154, B.List_155, B.List_156, B.List_157, B.List_158, B.List_159, B.List_160, B.List_161, B.List_162, B.List_163, B.List_164, B.List_165, B.List_166, B.List_167, B.List_168, B.List_169, B.List_170, B.List_171, B.List_172, B.List_173, B.List_174, B.List_175, B.List_177, B.List_177, B.List_178, B.List_178], A.findType("ConstantStringMap<String,List<int>>"));
    B.Object_empty = {};
    B.Map_empty1 = new A.ConstantStringMap(B.Object_empty, [], A.findType("ConstantStringMap<String,String>"));
    B.Map_empty0 = new A.ConstantStringMap(B.Object_empty, [], A.findType("ConstantStringMap<String,@>"));
    B.Map_empty = new A.ConstantStringMap(B.Object_empty, [], A.findType("ConstantStringMap<Symbol0,@>"));
    B.Map_inkaS = new A.GeneralConstantMap([B.Base58Alphabets_0, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", B.Base58Alphabets_1, "rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"], A.findType("GeneralConstantMap<Base58Alphabets,String>"));
    B.Object_0 = {string: 0, bool: 1, address: 2, tuple: 3, array: 4, bytes: 5, function: 6, number: 7};
    B.C_StringCoder = new A.StringCoder();
    B.C_BooleanCoder = new A.BooleanCoder();
    B.C_AddressCoder = new A.AddressCoder();
    B.C_TupleCoder = new A.TupleCoder();
    B.C_ArrayCoder = new A.ArrayCoder();
    B.C_FunctionCoder = new A.FunctionCoder();
    B.Map_zPayp = new A.ConstantStringMap(B.Object_0, [B.C_StringCoder, B.C_BooleanCoder, B.C_AddressCoder, B.C_TupleCoder, B.C_ArrayCoder, B.C_BytesCoder, B.C_FunctionCoder, B.C_NumbersCoder], A.findType("ConstantStringMap<String,ABICoder<@>>"));
    B.MessageException_66y = new A.MessageException("SHA3: squeezing before padAndPermute", null);
    B.MessageException_GVQ = new A.MessageException("SHA3: can't update because hash was finished", null);
    B.MessageException_IMr = new A.MessageException("Invalid character in Base58 string", null);
    B.MessageException_NiJ = new A.MessageException("SHA512: can't update because hash was finished.", null);
    B.MessageException_O1c = new A.MessageException("Invalid simpleOrFloatTags", null);
    B.MessageException_Q5s = new A.MessageException("AES: encryption key is not available", null);
    B.MessageException_QW6 = new A.MessageException("SHA256: can't update because hash was finished.", null);
    B.MessageException_QWS = new A.MessageException("No suitable 'b' found.", null);
    B.MessageException_Zgr = new A.MessageException("Size is too large!", null);
    B.MessageException_asg = new A.MessageException("ChaCha: counter overflow", null);
    B.MessageException_j3V = new A.MessageException("invalid bigFloat array length", null);
    B.MessageException_kKo = new A.MessageException("Poly1305 was finished", null);
    B.MessageException_s43 = new A.MessageException("The variable size exceeds the limit for Nat Decode", null);
    B.MessageException_zLW = new A.MessageException("Nat Decode failed.", null);
    B.MoneroCoins_moneroMainnet = new A.MoneroCoins("moneroMainnet");
    B.MoneroCoins_moneroStagenet = new A.MoneroCoins("moneroStagenet");
    B.MoneroCoins_moneroTestnet = new A.MoneroCoins("moneroTestnet");
    B.NodeClientStatus_1 = new A.NodeClientStatus("disconnect");
    B.ProviderAuth_4br = new A.ProviderAuth("d3800f756738ac7b39599914b8a84465960ff869f555c2317664c9a62529baf3");
    B.ProviderAuth_86y = new A.ProviderAuth("preprodMVwzqm4PuBDBSfEULoMzoj5QZcy5o3z5");
    B.ProviderAuth_8Gl = new A.ProviderAuth("cc8597229bb486a012f29743732b56c2331aff7f87c3d2cb84d456a04213b3ac");
    B.ProviderAuth_u7S = new A.ProviderAuth("mainnetolePdeWQLX8TrfG9V6RVaAshQi4pWzbU");
    B.RawSocketEvent_0 = new A.RawSocketEvent(0);
    B.RawSocketEvent_1 = new A.RawSocketEvent(1);
    B.RawSocketEvent_2 = new A.RawSocketEvent(2);
    B.SocketStatus_0 = new A.SocketStatus("connect");
    B.SocketStatus_1 = new A.SocketStatus("disconnect");
    B.SolanaAPIProvider_AHc = new A.SolanaAPIProvider("https://api.mainnet-beta.solana.com", B.ServiceProtocol_HTTP_0_http, "solana", "solana.com");
    B.SolanaAPIProvider_yXb = new A.SolanaAPIProvider("https://api.testnet.solana.com", B.ServiceProtocol_HTTP_0_http, "solana", "solana.com");
    B.SolidityAbiException_1lF = new A.SolidityAbiException("Invalid bytes length");
    B.SolidityAbiException_Auo = new A.SolidityAbiException("Invalid argument length detected.");
    B.SolidityAbiException_Jx8 = new A.SolidityAbiException("Invalid array type name. size in invalid.");
    B.SolidityAbiException_knt = new A.SolidityAbiException("invalid EIP712 json struct.");
    B.SolidityAbiException_mOy = new A.SolidityAbiException("Invalid data provided for bytes codec.");
    B.SquareRootError_7FR = new A.SquareRootError("p is not prime");
    B.StakeCredType_key_0 = new A.StakeCredType("key", 0);
    B.StakeCredType_script_1 = new A.StakeCredType("script", 1);
    B.StringEncoding_1 = new A.StringEncoding("utf8");
    B.StringEncoding_2 = new A.StringEncoding("base64");
    B.StringEncoding_3 = new A.StringEncoding("base64UrlSafe");
    B.Symbol_call = new A.Symbol("call");
    B.Tuple_false_false = new A.Tuple(false, false, type$.Tuple_bool_bool);
    B.Tuple_false_true = new A.Tuple(false, true, type$.Tuple_bool_bool);
    B.Tuple_true_true = new A.Tuple(true, true, type$.Tuple_bool_bool);
    B.Type_ByteBuffer_EOZ = A.typeLiteral("ByteBuffer");
    B.Type_ByteData_mF8 = A.typeLiteral("ByteData");
    B.Type_CborMapValue_ezS = A.typeLiteral("CborMapValue<@,@>");
    B.Type_Float32List_Ymk = A.typeLiteral("Float32List");
    B.Type_Float64List_Ymk = A.typeLiteral("Float64List");
    B.Type_Int16List_cot = A.typeLiteral("Int16List");
    B.Type_Int32List_m1p = A.typeLiteral("Int32List");
    B.Type_Int8List_woc = A.typeLiteral("Int8List");
    B.Type_JSObject_0ua = A.typeLiteral("JSObject");
    B.Type_List_qco = A.typeLiteral("List<@>");
    B.Type_Map_G6F = A.typeLiteral("Map<@,@>");
    B.Type_Object_QJv = A.typeLiteral("Object");
    B.Type_String_J2O = A.typeLiteral("String");
    B.Type_Uint16List_2mh = A.typeLiteral("Uint16List");
    B.Type_Uint32List_2mh = A.typeLiteral("Uint32List");
    B.Type_Uint8ClampedList_9Bb = A.typeLiteral("Uint8ClampedList");
    B.Type_Uint8List_CSc = A.typeLiteral("Uint8List");
    B.Utf8Decoder_false = new A.Utf8Decoder(false);
    B.Utf8Decoder_true = new A.Utf8Decoder(true);
    B.Web3ArgsException_izi = new A.Web3ArgsException("Invalid request argruments. params must be a list contains typedData and account.");
    B.Web3ArgsException_soc = new A.Web3ArgsException("Invalid typedData argruments. params must be list for legacy and object for V3, v4");
    B.Web3ArgsTypes_0 = new A.Web3ArgsTypes("number");
    B.Web3ArgsTypes_1 = new A.Web3ArgsTypes("string");
    B.Web3ArgsTypes_4 = new A.Web3ArgsTypes("hex");
    B.Web3ArgsTypes_5 = new A.Web3ArgsTypes("address");
    B.Web3ArgsTypes_6 = new A.Web3ArgsTypes("message");
    B.Web3InternalException_86y = new A.Web3InternalException(null, null, null, "unsuported_network_request");
    B.Web3InternalException_izR = new A.Web3InternalException(null, -30, null, "internal_request_error_desc");
    B.Web3ResponseMessage_null = new A.Web3ResponseMessage(null);
  })();
  (function staticFields() {
    $._JS_INTEROP_INTERCEPTOR_TAG = null;
    $.toStringVisiting = A._setArrayType([], type$.JSArray_Object);
    $.Primitives__identityHashCodeProperty = null;
    $.BoundClosure__receiverFieldNameCache = null;
    $.BoundClosure__interceptorFieldNameCache = null;
    $.getTagFunction = null;
    $.alternateTagFunction = null;
    $.prototypeForTagFunction = null;
    $.dispatchRecordsForInstanceTags = null;
    $.interceptorsForUncacheableTags = null;
    $.initNativeDispatchFlag = null;
    $._nextCallback = null;
    $._lastCallback = null;
    $._lastPriorityCallback = null;
    $._isInCallbackLoop = false;
    $.Zone__current = B.C__RootZone;
    $._BigIntImpl__lastDividendDigits = null;
    $._BigIntImpl__lastDividendUsed = null;
    $._BigIntImpl__lastDivisorDigits = null;
    $._BigIntImpl__lastDivisorUsed = null;
    $._BigIntImpl____lastQuoRemDigits = A._Cell$named("_lastQuoRemDigits");
    $._BigIntImpl____lastQuoRemUsed = A._Cell$named("_lastQuoRemUsed");
    $._BigIntImpl____lastRemUsed = A._Cell$named("_lastRemUsed");
    $._BigIntImpl____lastRem_nsh = A._Cell$named("_lastRem_nsh");
    $.Uri__cachedBaseString = "";
    $.Uri__cachedBaseUri = null;
    $._sigma = function() {
      var t1 = type$.JSArray_int;
      return A._setArrayType([A._setArrayType([0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30], t1), A._setArrayType([28, 20, 8, 16, 18, 30, 26, 12, 2, 24, 0, 4, 22, 14, 10, 6], t1), A._setArrayType([22, 16, 24, 0, 10, 4, 30, 26, 20, 28, 6, 12, 14, 2, 18, 8], t1), A._setArrayType([14, 18, 6, 2, 26, 24, 22, 28, 4, 12, 10, 20, 8, 0, 30, 16], t1), A._setArrayType([18, 0, 10, 14, 4, 8, 20, 30, 28, 2, 22, 24, 12, 16, 6, 26], t1), A._setArrayType([4, 24, 12, 20, 0, 22, 16, 6, 8, 26, 14, 10, 30, 28, 2, 18], t1), A._setArrayType([24, 10, 2, 30, 28, 26, 8, 20, 0, 14, 12, 6, 18, 4, 16, 22], t1), A._setArrayType([26, 22, 14, 28, 24, 2, 6, 18, 10, 0, 30, 8, 16, 12, 4, 20], t1), A._setArrayType([12, 30, 28, 18, 22, 6, 0, 16, 24, 4, 26, 14, 2, 8, 20, 10], t1), A._setArrayType([20, 4, 16, 8, 14, 12, 2, 10, 30, 22, 18, 28, 6, 24, 26, 0], t1), A._setArrayType([0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30], t1), A._setArrayType([28, 20, 8, 16, 18, 30, 26, 12, 2, 24, 0, 4, 22, 14, 10, 6], t1)], A.findType("JSArray<List<int>>"));
    }();
    $.QuickCrypto__randomGenerator = null;
    $._currentUriBase = null;
    $._current = null;
  })();
  (function lazyInitializers() {
    var _lazyFinal = hunkHelpers.lazyFinal,
      _lazy = hunkHelpers.lazy;
    _lazyFinal($, "DART_CLOSURE_PROPERTY_NAME", "$get$DART_CLOSURE_PROPERTY_NAME", () => A.getIsolateAffinityTag("_$dart_dartClosure"));
    _lazyFinal($, "nullFuture", "$get$nullFuture", () => B.C__RootZone.run$1$1(new A.nullFuture_closure(), A.findType("Future<Null>")));
    _lazyFinal($, "TypeErrorDecoder_noSuchMethodPattern", "$get$TypeErrorDecoder_noSuchMethodPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokeCallErrorOn({
      toString: function() {
        return "$receiver$";
      }
    })));
    _lazyFinal($, "TypeErrorDecoder_notClosurePattern", "$get$TypeErrorDecoder_notClosurePattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokeCallErrorOn({$method$: null,
      toString: function() {
        return "$receiver$";
      }
    })));
    _lazyFinal($, "TypeErrorDecoder_nullCallPattern", "$get$TypeErrorDecoder_nullCallPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokeCallErrorOn(null)));
    _lazyFinal($, "TypeErrorDecoder_nullLiteralCallPattern", "$get$TypeErrorDecoder_nullLiteralCallPattern", () => A.TypeErrorDecoder_extractPattern(function() {
      var $argumentsExpr$ = "$arguments$";
      try {
        null.$method$($argumentsExpr$);
      } catch (e) {
        return e.message;
      }
    }()));
    _lazyFinal($, "TypeErrorDecoder_undefinedCallPattern", "$get$TypeErrorDecoder_undefinedCallPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokeCallErrorOn(void 0)));
    _lazyFinal($, "TypeErrorDecoder_undefinedLiteralCallPattern", "$get$TypeErrorDecoder_undefinedLiteralCallPattern", () => A.TypeErrorDecoder_extractPattern(function() {
      var $argumentsExpr$ = "$arguments$";
      try {
        (void 0).$method$($argumentsExpr$);
      } catch (e) {
        return e.message;
      }
    }()));
    _lazyFinal($, "TypeErrorDecoder_nullPropertyPattern", "$get$TypeErrorDecoder_nullPropertyPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokePropertyErrorOn(null)));
    _lazyFinal($, "TypeErrorDecoder_nullLiteralPropertyPattern", "$get$TypeErrorDecoder_nullLiteralPropertyPattern", () => A.TypeErrorDecoder_extractPattern(function() {
      try {
        null.$method$;
      } catch (e) {
        return e.message;
      }
    }()));
    _lazyFinal($, "TypeErrorDecoder_undefinedPropertyPattern", "$get$TypeErrorDecoder_undefinedPropertyPattern", () => A.TypeErrorDecoder_extractPattern(A.TypeErrorDecoder_provokePropertyErrorOn(void 0)));
    _lazyFinal($, "TypeErrorDecoder_undefinedLiteralPropertyPattern", "$get$TypeErrorDecoder_undefinedLiteralPropertyPattern", () => A.TypeErrorDecoder_extractPattern(function() {
      try {
        (void 0).$method$;
      } catch (e) {
        return e.message;
      }
    }()));
    _lazyFinal($, "_AsyncRun__scheduleImmediateClosure", "$get$_AsyncRun__scheduleImmediateClosure", () => A._AsyncRun__initializeScheduleImmediate());
    _lazyFinal($, "Future__nullFuture", "$get$Future__nullFuture", () => A.findType("_Future<Null>")._as($.$get$nullFuture()));
    _lazyFinal($, "_Utf8Decoder__reusableBuffer", "$get$_Utf8Decoder__reusableBuffer", () => A.NativeUint8List_NativeUint8List(4096));
    _lazyFinal($, "_Utf8Decoder__decoder", "$get$_Utf8Decoder__decoder", () => new A._Utf8Decoder__decoder_closure().call$0());
    _lazyFinal($, "_Utf8Decoder__decoderNonfatal", "$get$_Utf8Decoder__decoderNonfatal", () => new A._Utf8Decoder__decoderNonfatal_closure().call$0());
    _lazyFinal($, "_Base64Decoder__inverseAlphabet", "$get$_Base64Decoder__inverseAlphabet", () => A.NativeInt8List__create1(A._ensureNativeList(A._setArrayType([-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -1, -2, -2, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63, -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2], type$.JSArray_int))));
    _lazy($, "_Base64Decoder__emptyBuffer", "$get$_Base64Decoder__emptyBuffer", () => A.NativeUint8List_NativeUint8List(0));
    _lazyFinal($, "Encoding__nameToEncoding", "$get$Encoding__nameToEncoding", () => A.LinkedHashMap_LinkedHashMap$_literal(["iso_8859-1:1987", B.C_Latin1Codec, "iso-ir-100", B.C_Latin1Codec, "iso_8859-1", B.C_Latin1Codec, "iso-8859-1", B.C_Latin1Codec, "latin1", B.C_Latin1Codec, "l1", B.C_Latin1Codec, "ibm819", B.C_Latin1Codec, "cp819", B.C_Latin1Codec, "csisolatin1", B.C_Latin1Codec, "iso-ir-6", B.C_AsciiCodec, "ansi_x3.4-1968", B.C_AsciiCodec, "ansi_x3.4-1986", B.C_AsciiCodec, "iso_646.irv:1991", B.C_AsciiCodec, "iso646-us", B.C_AsciiCodec, "us-ascii", B.C_AsciiCodec, "us", B.C_AsciiCodec, "ibm367", B.C_AsciiCodec, "cp367", B.C_AsciiCodec, "csascii", B.C_AsciiCodec, "ascii", B.C_AsciiCodec, "csutf8", B.C_Utf8Codec, "utf-8", B.C_Utf8Codec], type$.String, A.findType("Encoding")));
    _lazyFinal($, "_dummyList", "$get$_dummyList", () => A.NativeUint16List_NativeUint16List(0));
    _lazyFinal($, "_BigIntImpl_zero", "$get$_BigIntImpl_zero", () => A._BigIntImpl__BigIntImpl$_fromInt(0));
    _lazyFinal($, "_BigIntImpl_one", "$get$_BigIntImpl_one", () => A._BigIntImpl__BigIntImpl$_fromInt(1));
    _lazyFinal($, "_BigIntImpl_two", "$get$_BigIntImpl_two", () => A._BigIntImpl__BigIntImpl$_fromInt(2));
    _lazyFinal($, "_BigIntImpl__minusOne", "$get$_BigIntImpl__minusOne", () => $.$get$_BigIntImpl_one().$negate(0));
    _lazyFinal($, "_BigIntImpl__bigInt10000", "$get$_BigIntImpl__bigInt10000", () => A._BigIntImpl__BigIntImpl$_fromInt(10000));
    _lazy($, "_BigIntImpl__parseRE", "$get$_BigIntImpl__parseRE", () => A.RegExp_RegExp("^\\s*([+-]?)((0x[a-f0-9]+)|(\\d+)|([a-z0-9]+))\\s*$", false));
    _lazyFinal($, "_BigIntImpl__bitsForFromDouble", "$get$_BigIntImpl__bitsForFromDouble", () => A.NativeUint8List_NativeUint8List(8));
    _lazyFinal($, "DateTime__parseFormat", "$get$DateTime__parseFormat", () => A.RegExp_RegExp("^([+-]?\\d{4,6})-?(\\d\\d)-?(\\d\\d)(?:[ T](\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d+))?)?)?( ?[zZ]| ?([-+])(\\d\\d)(?::?(\\d\\d))?)?)?$", true));
    _lazyFinal($, "_hashSeed", "$get$_hashSeed", () => A.objectHashCode(B.Type_Object_QJv));
    _lazyFinal($, "_scannerTables", "$get$_scannerTables", () => A._createTables());
    _lazyFinal($, "_ioOverridesToken", "$get$_ioOverridesToken", () => new A.Object());
    _lazyFinal($, "Random__secureRandom", "$get$Random__secureRandom", () => {
      var t1 = new A._JSSecureRandom(A.NativeByteData_NativeByteData(8));
      t1._JSSecureRandom$0();
      return t1;
    });
    _lazyFinal($, "_BchBech32Utils__mask5", "$get$_BchBech32Utils__mask5", () => A._BigIntImpl__BigIntImpl$from(31));
    _lazyFinal($, "ADAByronAddrConst_chacha20Poly1305AssocData", "$get$ADAByronAddrConst_chacha20Poly1305AssocData", () => A.List_List$empty(false, type$.int));
    _lazyFinal($, "ADAByronAddrConst_chacha20Poly1305Nonce", "$get$ADAByronAddrConst_chacha20Poly1305Nonce", () => A.List_List$from(A.CodeUnits$("serokellfore"), true, type$.int));
    _lazyFinal($, "AdaShelleyAddrConst_networkTagToAddrHrp", "$get$AdaShelleyAddrConst_networkTagToAddrHrp", () => A.LinkedHashMap_LinkedHashMap$_literal([B.ADANetwork_1_764824073_mainnet, "addr", B.ADANetwork_0_1097911063_testnet, "addr_test", B.ADANetwork_0_1_testnetPreprod, "addr_test", B.ADANetwork_0_2_testnetPreview, "addr_test"], type$.ADANetwork, type$.String));
    _lazyFinal($, "AdaShelleyAddrConst_networkTagToRewardAddrHrp", "$get$AdaShelleyAddrConst_networkTagToRewardAddrHrp", () => A.LinkedHashMap_LinkedHashMap$_literal([B.ADANetwork_1_764824073_mainnet, "stake", B.ADANetwork_0_1097911063_testnet, "stake_test", B.ADANetwork_0_1_testnetPreprod, "stake_test", B.ADANetwork_0_2_testnetPreview, "stake_test"], type$.ADANetwork, type$.String));
    _lazyFinal($, "TonAddressUtils__friendlyRegixAddress", "$get$TonAddressUtils__friendlyRegixAddress", () => A.RegExp_RegExp("[A-Za-z0-9+/_-]+", true));
    _lazyFinal($, "Bip32Const_mainNetKeyNetVersions", "$get$Bip32Const_mainNetKeyNetVersions", () => {
      var t1 = type$.int;
      return A.Bip32KeyNetVersions$(A.List_List$from([4, 136, 178, 30], true, t1), A.List_List$from([4, 136, 173, 228], true, t1));
    });
    _lazyFinal($, "Bip32Const_testNetKeyNetVersions", "$get$Bip32Const_testNetKeyNetVersions", () => {
      var t1 = type$.int;
      return A.Bip32KeyNetVersions$(A.List_List$from([4, 53, 135, 207], true, t1), A.List_List$from([4, 53, 131, 148], true, t1));
    });
    _lazy($, "Bip32Const_kholawKeyNetVersions", "$get$Bip32Const_kholawKeyNetVersions", () => {
      var t1 = type$.int;
      return A.Bip32KeyNetVersions$(A.List_List$from([4, 136, 178, 30], true, t1), A.List_List$from([15, 67, 49, 212], true, t1));
    });
    _lazyFinal($, "Bip44Coins__coinToConf", "$get$Bip44Coins__coinToConf", () => A.LinkedHashMap_LinkedHashMap$_literal([B.Bip44Coins_akashNetwork, $.$get$Bip44Conf_akashNetwork(), B.Bip44Coins_algorand, $.$get$Bip44Conf_algorand(), B.Bip44Coins_aptos, $.$get$Bip44Conf_aptos(), B.Bip44Coins_avaxCChain, $.$get$Bip44Conf_avaxCChain(), B.Bip44Coins_avaxPChain, $.$get$Bip44Conf_avaxPChain(), B.Bip44Coins_avaxXChain, $.$get$Bip44Conf_avaxXChain(), B.Bip44Coins_axelar, $.$get$Bip44Conf_axelar(), B.Bip44Coins_bandProtocol, $.$get$Bip44Conf_bandProtocol(), B.Bip44Coins_binanceChain, $.$get$Bip44Conf_binanceChain(), B.Bip44Coins_binanceSmartChain, $.$get$Bip44Conf_binanceSmartChain(), B.Bip44Coins_bitcoin, $.$get$Bip44Conf_bitcoinMainNet(), B.Bip44Coins_bitcoinTestnet, $.$get$Bip44Conf_bitcoinTestNet(), B.Bip44Coins_bitcoinCash, $.$get$Bip44Conf_bitcoinCashMainNet(), B.Bip44Coins_bitcoinCashTestnet, $.$get$Bip44Conf_bitcoinCashTestNet(), B.Bip44Coins_bitcoinCashSlp, $.$get$Bip44Conf_bitcoinCashSlpMainNet(), B.Bip44Coins_bitcoinCashSlpTestnet, $.$get$Bip44Conf_bitcoinCashSlpTestNet(), B.Bip44Coins_bitcoinSv, $.$get$Bip44Conf_bitcoinSvMainNet(), B.Bip44Coins_bitcoinSvTestnet, $.$get$Bip44Conf_bitcoinSvTestNet(), B.Bip44Coins_cardanoByronIcarus, $.$get$Bip44Conf_cardanoByronIcarus(), B.Bip44Coins_cardanoByronLedger, $.$get$Bip44Conf_cardanoByronLedger(), B.Bip44Coins_cardanoByronIcarusTestnet, $.$get$Bip44Conf_cardanoByronIcarusTestnet(), B.Bip44Coins_cardanoByronLedgerTestnet, $.$get$Bip44Conf_cardanoByronLedgerTestnet(), B.Bip44Coins_celo, $.$get$Bip44Conf_celo(), B.Bip44Coins_certik, $.$get$Bip44Conf_certik(), B.Bip44Coins_chihuahua, $.$get$Bip44Conf_chihuahua(), B.Bip44Coins_cosmos, $.$get$Bip44Conf_cosmos(), B.Bip44Coins_cosmosTestnet, $.$get$Bip44Conf_cosmosTestnet(), B.Bip44Coins_cosmosNist256p1, $.$get$Bip44Conf_cosmosNist256p1(), B.Bip44Coins_cosmosTestnetNist256p1, $.$get$Bip44Conf_cosmosTestnetNist256p1(), B.Bip44Coins_dash, $.$get$Bip44Conf_dashMainNet(), B.Bip44Coins_dashTestnet, $.$get$Bip44Conf_dashTestNet(), B.Bip44Coins_dogecoin, $.$get$Bip44Conf_dogecoinMainNet(), B.Bip44Coins_dogecoinTestnet, $.$get$Bip44Conf_dogecoinTestNet(), B.Bip44Coins_pepecoin, $.$get$Bip44Conf_pepeMainnet(), B.Bip44Coins_pepecoinTestnet, $.$get$Bip44Conf_pepeTestnet(), B.Bip44Coins_ecash, $.$get$Bip44Conf_ecashMainNet(), B.Bip44Coins_ecashTestnet, $.$get$Bip44Conf_ecashTestNet(), B.Bip44Coins_elrond, $.$get$Bip44Conf_elrond(), B.Bip44Coins_eos, $.$get$Bip44Conf_eos(), B.Bip44Coins_ergo, $.$get$Bip44Conf_ergoMainNet(), B.Bip44Coins_ergoTestnet, $.$get$Bip44Conf_ergoTestNet(), B.Bip44Coins_ethereum, $.$get$Bip44Conf_ethereum(), B.Bip44Coins_ethereumTestnet, $.$get$Bip44Conf_ethereumTestnet(), B.Bip44Coins_ethereumClassic, $.$get$Bip44Conf_ethereumClassic(), B.Bip44Coins_fantomOpera, $.$get$Bip44Conf_fantomOpera(), B.Bip44Coins_filecoin, $.$get$Bip44Conf_filecoin(), B.Bip44Coins_harmonyOneAtom, $.$get$Bip44Conf_harmonyOneAtom(), B.Bip44Coins_harmonyOneEth, $.$get$Bip44Conf_harmonyOneEth(), B.Bip44Coins_harmonyOneMetamask, $.$get$Bip44Conf_harmonyOneMetamask(), B.Bip44Coins_huobiChain, $.$get$Bip44Conf_huobiChain(), B.Bip44Coins_icon, $.$get$Bip44Conf_icon(), B.Bip44Coins_injective, $.$get$Bip44Conf_injective(), B.Bip44Coins_irisNet, $.$get$Bip44Conf_irisNet(), B.Bip44Coins_kava, $.$get$Bip44Conf_kava(), B.Bip44Coins_kusamaEd25519Slip, $.$get$Bip44Conf_kusamaEd25519Slip(), B.Bip44Coins_kusamaTestnetEd25519Slip, $.$get$Bip44Conf_kusamaTestnetEd25519Slip(), B.Bip44Coins_litecoin, $.$get$Bip44Conf_litecoinMainNet(), B.Bip44Coins_litecoinTestnet, $.$get$Bip44Conf_litecoinTestNet(), B.Bip44Coins_moneroEd25519Slip, $.$get$Bip44Conf_moneroEd25519Slip(), B.Bip44Coins_moneroSecp256k1, $.$get$Bip44Conf_moneroSecp256k1(), B.Bip44Coins_nano, $.$get$Bip44Conf_nano(), B.Bip44Coins_nearProtocol, $.$get$Bip44Conf_nearProtocol(), B.Bip44Coins_neo, $.$get$Bip44Conf_neo(), B.Bip44Coins_nineChroniclesGold, $.$get$Bip44Conf_nineChroniclesGold(), B.Bip44Coins_okexChainAtom, $.$get$Bip44Conf_okexChainAtom(), B.Bip44Coins_okexChainAtomOld, $.$get$Bip44Conf_okexChainAtomOld(), B.Bip44Coins_okexChainEth, $.$get$Bip44Conf_okexChainEth(), B.Bip44Coins_ontology, $.$get$Bip44Conf_ontology(), B.Bip44Coins_osmosis, $.$get$Bip44Conf_osmosis(), B.Bip44Coins_piNetwork, $.$get$Bip44Conf_piNetwork(), B.Bip44Coins_polkadotEd25519Slip, $.$get$Bip44Conf_polkadotEd25519Slip(), B.Bip44Coins_polkadotTestnetEd25519Slip, $.$get$Bip44Conf_polkadotTestnetEd25519Slip(), B.Bip44Coins_polygon, $.$get$Bip44Conf_polygon(), B.Bip44Coins_ripple, $.$get$Bip44Conf_ripple(), B.Bip44Coins_rippleTestnet, $.$get$Bip44Conf_rippleTestnet(), B.Bip44Coins_rippleED25519, $.$get$Bip44Conf_rippleEd25519(), B.Bip44Coins_rippleTestnetED25519, $.$get$Bip44Conf_rippleTestnetEd25519(), B.Bip44Coins_secretNetworkOld, $.$get$Bip44Conf_secretNetworkOld(), B.Bip44Coins_secretNetworkNew, $.$get$Bip44Conf_secretNetworkNew(), B.Bip44Coins_solana, $.$get$Bip44Conf_solana(), B.Bip44Coins_solanaTestnet, $.$get$Bip44Conf_solanaTestnet(), B.Bip44Coins_stellar, $.$get$Bip44Conf_stellar(), B.Bip44Coins_terra, $.$get$Bip44Conf_terra(), B.Bip44Coins_tezos, $.$get$Bip44Conf_tezos(), B.Bip44Coins_theta, $.$get$Bip44Conf_theta(), B.Bip44Coins_tron, $.$get$Bip44Conf_tron(), B.Bip44Coins_tronTestnet, $.$get$Bip44Conf_tronTestnet(), B.Bip44Coins_vechain, $.$get$Bip44Conf_vechain(), B.Bip44Coins_verge, $.$get$Bip44Conf_verge(), B.Bip44Coins_zcash, $.$get$Bip44Conf_zcashMainNet(), B.Bip44Coins_zcashTestnet, $.$get$Bip44Conf_zcashTestNet(), B.Bip44Coins_zilliqa, $.$get$Bip44Conf_zilliqa(), B.Bip44Coins_tonTestnet, $.$get$Bip44Conf_tonTestnet(), B.Bip44Coins_tonMainnet, $.$get$Bip44Conf_tonMainnet()], type$.Bip44Coins, type$.BipCoinConfig));
    _lazyFinal($, "Bip44Conf_bip44BtcKeyNetVerMain", "$get$Bip44Conf_bip44BtcKeyNetVerMain", () => $.$get$Bip32Const_mainNetKeyNetVersions());
    _lazyFinal($, "Bip44Conf_bip44BtcKeyNetVerTest", "$get$Bip44Conf_bip44BtcKeyNetVerTest", () => $.$get$Bip32Const_testNetKeyNetVersions());
    _lazyFinal($, "Bip44Conf_akashNetwork", "$get$Bip44Conf_akashNetwork", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "akash"], type$.String, type$.dynamic), new A.Bip44Conf_akashNetwork_closure(), 118, B.CoinNames_z8q, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_algorand", "$get$Bip44Conf_algorand", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_algorand_closure(), 283, B.CoinNames_Algorand, "0'/0'/0'", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_ed25519, null));
    _lazyFinal($, "Bip44Conf_aptos", "$get$Bip44Conf_aptos", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_aptos_closure(), 637, B.CoinNames_Aptos, "0'/0'/0'", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_ed25519, null));
    _lazyFinal($, "Bip44Conf_avaxCChain", "$get$Bip44Conf_avaxCChain", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_avaxCChain_closure(), 60, B.CoinNames_AdS1, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_avaxPChain", "$get$Bip44Conf_avaxPChain", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_avaxPChain_closure(), 9000, B.CoinNames_AdS0, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_avaxXChain", "$get$Bip44Conf_avaxXChain", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_avaxXChain_closure(), 9000, B.CoinNames_AdS, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_axelar", "$get$Bip44Conf_axelar", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "axelar"], type$.String, type$.dynamic), new A.Bip44Conf_axelar_closure(), 118, B.CoinNames_Axelar, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_bandProtocol", "$get$Bip44Conf_bandProtocol", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "band"], type$.String, type$.dynamic), new A.Bip44Conf_bandProtocol_closure(), 494, B.CoinNames_FCG0, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_binanceChain", "$get$Bip44Conf_binanceChain", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "bnb"], type$.String, type$.dynamic), new A.Bip44Conf_binanceChain_closure(), 714, B.CoinNames_D4j, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_binanceSmartChain", "$get$Bip44Conf_binanceSmartChain", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_binanceSmartChain_closure(), 60, B.CoinNames_Due, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_bitcoinMainNet", "$get$Bip44Conf_bitcoinMainNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_00], type$.String, type$.dynamic), new A.Bip44Conf_bitcoinMainNet_closure(), 0, B.CoinNames_Bitcoin, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip44Conf_bitcoinTestNet", "$get$Bip44Conf_bitcoinTestNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerTest();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_111], type$.String, type$.dynamic), new A.Bip44Conf_bitcoinTestNet_closure(), 1, B.CoinNames_tuc, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip44Conf_bitcoinCashMainNet", "$get$Bip44Conf_bitcoinCashMainNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain(),
        t2 = type$.String;
      return A.BipBitcoinCashConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_00, "hrp", "bitcoincash"], t2, type$.Object), "legacy", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_00], t2, type$.List_int)], t2, type$.dynamic), new A.Bip44Conf_bitcoinCashMainNet_closure(), 145, B.CoinNames_CDm, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip44Conf_bitcoinCashTestNet", "$get$Bip44Conf_bitcoinCashTestNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerTest(),
        t2 = type$.String;
      return A.BipBitcoinCashConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_00, "hrp", "bchtest"], t2, type$.Object), "legacy", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_111], t2, type$.List_int)], t2, type$.dynamic), new A.Bip44Conf_bitcoinCashTestNet_closure(), 1, B.CoinNames_Iot, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip44Conf_bitcoinCashSlpMainNet", "$get$Bip44Conf_bitcoinCashSlpMainNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain(),
        t2 = type$.String;
      return A.BipBitcoinCashConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_00, "hrp", "simpleledger"], t2, type$.nullable_Object), "legacy", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_00], t2, type$.List_int)], t2, type$.dynamic), new A.Bip44Conf_bitcoinCashSlpMainNet_closure(), 145, B.CoinNames_rCZ, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip44Conf_bitcoinCashSlpTestNet", "$get$Bip44Conf_bitcoinCashSlpTestNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerTest(),
        t2 = type$.String;
      return A.BipBitcoinCashConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_00, "hrp", "slptest"], t2, type$.Object), "legacy", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_111], t2, type$.List_int)], t2, type$.dynamic), new A.Bip44Conf_bitcoinCashSlpTestNet_closure(), 1, B.CoinNames_FCG, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip44Conf_bitcoinSvMainNet", "$get$Bip44Conf_bitcoinSvMainNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_00], type$.String, type$.dynamic), new A.Bip44Conf_bitcoinSvMainNet_closure(), 236, B.CoinNames_BitcoinSV, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip44Conf_bitcoinSvTestNet", "$get$Bip44Conf_bitcoinSvTestNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerTest();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_111], type$.String, type$.dynamic), new A.Bip44Conf_bitcoinSvTestNet_closure(), 1, B.CoinNames_B2l, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip44Conf_cardanoByronIcarus", "$get$Bip44Conf_cardanoByronIcarus", () => {
      var t1 = $.$get$Bip32Const_kholawKeyNetVersions();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["chain_code", true, "is_icarus", true], type$.String, type$.dynamic), new A.Bip44Conf_cardanoByronIcarus_closure(), 1815, B.CoinNames_Cardano, "0'/0/0", false, t1, B.EllipticCurveTypes_ed25519Kholaw, null);
    });
    _lazyFinal($, "Bip44Conf_cardanoByronLedger", "$get$Bip44Conf_cardanoByronLedger", () => {
      var t1 = $.$get$Bip32Const_kholawKeyNetVersions();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["chain_code", true], type$.String, type$.dynamic), new A.Bip44Conf_cardanoByronLedger_closure(), 1815, B.CoinNames_Cardano, "0'/0/0", false, t1, B.EllipticCurveTypes_ed25519Kholaw, null);
    });
    _lazyFinal($, "Bip44Conf_cardanoByronIcarusTestnet", "$get$Bip44Conf_cardanoByronIcarusTestnet", () => {
      var t1 = $.$get$Bip32Const_kholawKeyNetVersions();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["chain_code", true, "is_icarus", true], type$.String, type$.dynamic), new A.Bip44Conf_cardanoByronIcarusTestnet_closure(), 1, B.CoinNames_Cardano, "0'/0/0", true, t1, B.EllipticCurveTypes_ed25519Kholaw, null);
    });
    _lazyFinal($, "Bip44Conf_cardanoByronLedgerTestnet", "$get$Bip44Conf_cardanoByronLedgerTestnet", () => {
      var t1 = $.$get$Bip32Const_kholawKeyNetVersions();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["chain_code", true], type$.String, type$.dynamic), new A.Bip44Conf_cardanoByronLedgerTestnet_closure(), 1, B.CoinNames_Cardano, "0'/0/0", true, t1, B.EllipticCurveTypes_ed25519Kholaw, null);
    });
    _lazyFinal($, "Bip44Conf_celo", "$get$Bip44Conf_celo", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_celo_closure(), 52752, B.CoinNames_Celo, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_certik", "$get$Bip44Conf_certik", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "certik"], type$.String, type$.dynamic), new A.Bip44Conf_certik_closure(), 118, B.CoinNames_Certik, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_chihuahua", "$get$Bip44Conf_chihuahua", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "chihuahua"], type$.String, type$.dynamic), new A.Bip44Conf_chihuahua_closure(), 118, B.CoinNames_Chihuahua, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_cosmos", "$get$Bip44Conf_cosmos", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "cosmos"], type$.String, type$.dynamic), new A.Bip44Conf_cosmos_closure(), 118, B.CoinNames_Cosmos, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_cosmosTestnet", "$get$Bip44Conf_cosmosTestnet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "cosmos"], type$.String, type$.dynamic), new A.Bip44Conf_cosmosTestnet_closure(), 1, B.CoinNames_Cosmos, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_cosmosNist256p1", "$get$Bip44Conf_cosmosNist256p1", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "cosmos"], type$.String, type$.dynamic), new A.Bip44Conf_cosmosNist256p1_closure(), 118, B.CoinNames_Cosmos, "0'/0/0", false, t1, B.EllipticCurveTypes_nist256p1, null);
    });
    _lazyFinal($, "Bip44Conf_cosmosTestnetNist256p1", "$get$Bip44Conf_cosmosTestnetNist256p1", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "cosmos"], type$.String, type$.dynamic), new A.Bip44Conf_cosmosTestnetNist256p1_closure(), 1, B.CoinNames_Cosmos, "0'/0/0", false, t1, B.EllipticCurveTypes_nist256p1, null);
    });
    _lazyFinal($, "Bip44Conf_dashMainNet", "$get$Bip44Conf_dashMainNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_76], type$.String, type$.dynamic), new A.Bip44Conf_dashMainNet_closure(), 5, B.CoinNames_Dash, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_204);
    });
    _lazyFinal($, "Bip44Conf_dashTestNet", "$get$Bip44Conf_dashTestNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerTest();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_140], type$.String, type$.dynamic), new A.Bip44Conf_dashTestNet_closure(), 1, B.CoinNames_MUB, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip44Conf_dogecoinMainNet", "$get$Bip44Conf_dogecoinMainNet", () => {
      var t1 = type$.int;
      t1 = A.Bip32KeyNetVersions$(A.List_List$from([2, 250, 202, 253], true, t1), A.List_List$from([2, 250, 195, 152], true, t1));
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_30], type$.String, type$.dynamic), new A.Bip44Conf_dogecoinMainNet_closure(), 3, B.CoinNames_Dogecoin, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_158);
    });
    _lazyFinal($, "Bip44Conf_dogecoinTestNet", "$get$Bip44Conf_dogecoinTestNet", () => {
      var t1 = type$.int;
      t1 = A.Bip32KeyNetVersions$(A.List_List$from([4, 50, 169, 168], true, t1), A.List_List$from([4, 50, 162, 67], true, t1));
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_113], type$.String, type$.dynamic), new A.Bip44Conf_dogecoinTestNet_closure(), 1, B.CoinNames_OPN, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_241);
    });
    _lazyFinal($, "Bip44Conf_pepeMainnet", "$get$Bip44Conf_pepeMainnet", () => {
      var t1 = type$.int;
      t1 = A.Bip32KeyNetVersions$(A.List_List$from([2, 250, 202, 253], true, t1), A.List_List$from([2, 250, 195, 152], true, t1));
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_56], type$.String, type$.dynamic), new A.Bip44Conf_pepeMainnet_closure(), 3434, B.CoinNames_Pepecoin, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_158);
    });
    _lazyFinal($, "Bip44Conf_pepeTestnet", "$get$Bip44Conf_pepeTestnet", () => {
      var t1 = type$.int;
      t1 = A.Bip32KeyNetVersions$(A.List_List$from([4, 50, 169, 168], true, t1), A.List_List$from([4, 50, 162, 67], true, t1));
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_113], type$.String, type$.dynamic), new A.Bip44Conf_pepeTestnet_closure(), 1, B.CoinNames_QyU, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_241);
    });
    _lazyFinal($, "Bip44Conf_ecashMainNet", "$get$Bip44Conf_ecashMainNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain(),
        t2 = type$.String;
      return A.BipBitcoinCashConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_00, "hrp", "ecash"], t2, type$.Object), "legacy", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_00], t2, type$.List_int)], t2, type$.dynamic), new A.Bip44Conf_ecashMainNet_closure(), 145, B.CoinNames_eCash, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip44Conf_ecashTestNet", "$get$Bip44Conf_ecashTestNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerTest(),
        t2 = type$.String;
      return A.BipBitcoinCashConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_00, "hrp", "ectest"], t2, type$.Object), "legacy", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_111], t2, type$.List_int)], t2, type$.dynamic), new A.Bip44Conf_ecashTestNet_closure(), 1, B.CoinNames_HZw, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip44Conf_elrond", "$get$Bip44Conf_elrond", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_elrond_closure(), 508, B.CoinNames_qxe, "0'/0'/0'", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_ed25519, null));
    _lazyFinal($, "Bip44Conf_eos", "$get$Bip44Conf_eos", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_eos_closure(), 194, B.CoinNames_EOS, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_ergoMainNet", "$get$Bip44Conf_ergoMainNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_type", B.ErgoNetworkTypes_0], type$.String, type$.dynamic), new A.Bip44Conf_ergoMainNet_closure(), 429, B.CoinNames_Ergo, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_ergoTestNet", "$get$Bip44Conf_ergoTestNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerTest();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_type", B.ErgoNetworkTypes_16], type$.String, type$.dynamic), new A.Bip44Conf_ergoTestNet_closure(), 429, B.CoinNames_4N8, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_ethereum", "$get$Bip44Conf_ethereum", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_ethereum_closure(), 60, B.CoinNames_Ethereum, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_ethereumTestnet", "$get$Bip44Conf_ethereumTestnet", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_ethereumTestnet_closure(), 1, B.CoinNames_Ethereum, "0'/0/0", true, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_ethereumClassic", "$get$Bip44Conf_ethereumClassic", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_ethereumClassic_closure(), 61, B.CoinNames_mqm, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_fantomOpera", "$get$Bip44Conf_fantomOpera", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_fantomOpera_closure(), 60, B.CoinNames_JiH, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_filecoin", "$get$Bip44Conf_filecoin", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_filecoin_closure(), 461, B.CoinNames_Filecoin, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_harmonyOneMetamask", "$get$Bip44Conf_harmonyOneMetamask", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_harmonyOneMetamask_closure(), 60, B.CoinNames_eHw, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_harmonyOneEth", "$get$Bip44Conf_harmonyOneEth", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_harmonyOneEth_closure(), 1023, B.CoinNames_eHw, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_harmonyOneAtom", "$get$Bip44Conf_harmonyOneAtom", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_harmonyOneAtom_closure(), 1023, B.CoinNames_eHw, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_huobiChain", "$get$Bip44Conf_huobiChain", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_huobiChain_closure(), 60, B.CoinNames_MYA, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_icon", "$get$Bip44Conf_icon", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_icon_closure(), 74, B.CoinNames_Icon, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_injective", "$get$Bip44Conf_injective", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_injective_closure(), 60, B.CoinNames_Injective, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_irisNet", "$get$Bip44Conf_irisNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "iaa"], type$.String, type$.dynamic), new A.Bip44Conf_irisNet_closure(), 118, B.CoinNames_e9z, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_kava", "$get$Bip44Conf_kava", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "kava"], type$.String, type$.dynamic), new A.Bip44Conf_kava_closure(), 459, B.CoinNames_Kava, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_kusamaEd25519Slip", "$get$Bip44Conf_kusamaEd25519Slip", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["ss58_format", 2], type$.String, type$.dynamic), new A.Bip44Conf_kusamaEd25519Slip_closure(), 434, B.CoinNames_Kusama, "0'/0'/0'", false, t1, B.EllipticCurveTypes_ed25519, null);
    });
    _lazyFinal($, "Bip44Conf_kusamaTestnetEd25519Slip", "$get$Bip44Conf_kusamaTestnetEd25519Slip", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["ss58_format", 2], type$.String, type$.dynamic), new A.Bip44Conf_kusamaTestnetEd25519Slip_closure(), 1, B.CoinNames_Kusama, "0'/0'/0'", false, t1, B.EllipticCurveTypes_ed25519, null);
    });
    _lazyFinal($, "Bip44Conf_litecoinMainNet", "$get$Bip44Conf_litecoinMainNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain(),
        t2 = type$.int;
      t2 = A.Bip32KeyNetVersions$(A.List_List$from([1, 157, 164, 98], true, t2), A.List_List$from([1, 157, 156, 254], true, t2));
      return A.BipLitecoinConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std_net_ver", B.List_48, "depr_net_ver", B.List_00], type$.String, type$.dynamic), new A.Bip44Conf_litecoinMainNet_closure(), t2, 2, B.CoinNames_Litecoin, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_176);
    });
    _lazyFinal($, "Bip44Conf_litecoinTestNet", "$get$Bip44Conf_litecoinTestNet", () => {
      var t1 = type$.int,
        t2 = A.Bip32KeyNetVersions$(A.List_List$from([4, 54, 246, 225], true, t1), A.List_List$from([4, 54, 239, 125], true, t1));
      t1 = A.Bip32KeyNetVersions$(A.List_List$from([4, 54, 246, 225], true, t1), A.List_List$from([4, 54, 239, 125], true, t1));
      return A.BipLitecoinConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std_net_ver", B.List_111, "depr_net_ver", B.List_111], type$.String, type$.dynamic), new A.Bip44Conf_litecoinTestNet_closure(), t1, 1, B.CoinNames_IIS, "0'/0/0", true, t2, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip44Conf_moneroEd25519Slip", "$get$Bip44Conf_moneroEd25519Slip", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_moneroEd25519Slip_closure(), 128, B.CoinNames_Monero, "0'/0'/0'", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_ed25519, null));
    _lazyFinal($, "Bip44Conf_moneroSecp256k1", "$get$Bip44Conf_moneroSecp256k1", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_moneroSecp256k1_closure(), 128, B.CoinNames_Monero, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_nano", "$get$Bip44Conf_nano", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_nano_closure(), 165, B.CoinNames_Nano, "0'", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_ed25519Blake2b, null));
    _lazyFinal($, "Bip44Conf_nearProtocol", "$get$Bip44Conf_nearProtocol", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_nearProtocol_closure(), 397, B.CoinNames_OWX, "0'", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_ed25519, null));
    _lazyFinal($, "Bip44Conf_neo", "$get$Bip44Conf_neo", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["ver", B.List_23], type$.String, type$.dynamic), new A.Bip44Conf_neo_closure(), 888, B.CoinNames_NEO, "0'/0/0", false, t1, B.EllipticCurveTypes_nist256p1, null);
    });
    _lazyFinal($, "Bip44Conf_nineChroniclesGold", "$get$Bip44Conf_nineChroniclesGold", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_nineChroniclesGold_closure(), 567, B.CoinNames_NineChroniclesGold, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_okexChainEth", "$get$Bip44Conf_okexChainEth", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_okexChainEth_closure(), 60, B.CoinNames_OKExChain, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_okexChainAtom", "$get$Bip44Conf_okexChainAtom", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_okexChainAtom_closure(), 60, B.CoinNames_OKExChain, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_okexChainAtomOld", "$get$Bip44Conf_okexChainAtomOld", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_okexChainAtomOld_closure(), 996, B.CoinNames_OKExChain, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_ontology", "$get$Bip44Conf_ontology", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["ver", B.List_23], type$.String, type$.dynamic), new A.Bip44Conf_ontology_closure(), 1024, B.CoinNames_Ontology, "0'/0/0", false, t1, B.EllipticCurveTypes_nist256p1, null);
    });
    _lazyFinal($, "Bip44Conf_osmosis", "$get$Bip44Conf_osmosis", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "osmo"], type$.String, type$.dynamic), new A.Bip44Conf_osmosis_closure(), 118, B.CoinNames_Osmosis, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_piNetwork", "$get$Bip44Conf_piNetwork", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["addr_type", B.C_XlmAddrTypes], type$.String, type$.dynamic), new A.Bip44Conf_piNetwork_closure(), 314159, B.CoinNames_adc, "0'", false, t1, B.EllipticCurveTypes_ed25519, null);
    });
    _lazyFinal($, "Bip44Conf_polkadotEd25519Slip", "$get$Bip44Conf_polkadotEd25519Slip", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["ss58_format", 0], type$.String, type$.dynamic), new A.Bip44Conf_polkadotEd25519Slip_closure(), 354, B.CoinNames_Polkadot, "0'/0'/0'", false, t1, B.EllipticCurveTypes_ed25519, null);
    });
    _lazyFinal($, "Bip44Conf_polkadotTestnetEd25519Slip", "$get$Bip44Conf_polkadotTestnetEd25519Slip", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["ss58_format", 42], type$.String, type$.dynamic), new A.Bip44Conf_polkadotTestnetEd25519Slip_closure(), 1, B.CoinNames_Polkadot, "0'/0'/0'", true, t1, B.EllipticCurveTypes_ed25519, null);
    });
    _lazyFinal($, "Bip44Conf_polygon", "$get$Bip44Conf_polygon", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_polygon_closure(), 60, B.CoinNames_Polygon, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_ripple", "$get$Bip44Conf_ripple", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["prefix", B.List_5_68], type$.String, type$.dynamic), new A.Bip44Conf_ripple_closure(), 144, B.CoinNames_Ripple, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_rippleTestnet", "$get$Bip44Conf_rippleTestnet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["prefix", B.List_4_147], type$.String, type$.dynamic), new A.Bip44Conf_rippleTestnet_closure(), 1, B.CoinNames_Ripple, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_rippleEd25519", "$get$Bip44Conf_rippleEd25519", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["prefix", B.List_5_68, "curve_type", B.EllipticCurveTypes_ed25519], type$.String, type$.dynamic), new A.Bip44Conf_rippleEd25519_closure(), 144, B.CoinNames_Ripple, "0'/0'/0'", false, t1, B.EllipticCurveTypes_ed25519, null);
    });
    _lazyFinal($, "Bip44Conf_rippleTestnetEd25519", "$get$Bip44Conf_rippleTestnetEd25519", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["prefix", B.List_4_147, "curve_type", B.EllipticCurveTypes_ed25519], type$.String, type$.dynamic), new A.Bip44Conf_rippleTestnetEd25519_closure(), 1, B.CoinNames_Ripple, "0'/0'/0'", true, t1, B.EllipticCurveTypes_ed25519, null);
    });
    _lazyFinal($, "Bip44Conf_secretNetworkOld", "$get$Bip44Conf_secretNetworkOld", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "secret"], type$.String, type$.dynamic), new A.Bip44Conf_secretNetworkOld_closure(), 118, B.CoinNames_ki8, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_secretNetworkNew", "$get$Bip44Conf_secretNetworkNew", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "secret"], type$.String, type$.dynamic), new A.Bip44Conf_secretNetworkNew_closure(), 529, B.CoinNames_ki8, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_solana", "$get$Bip44Conf_solana", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_solana_closure(), 501, B.CoinNames_Solana, "0'", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_ed25519, null));
    _lazyFinal($, "Bip44Conf_solanaTestnet", "$get$Bip44Conf_solanaTestnet", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_solanaTestnet_closure(), 1, B.CoinNames_Solana, "0'", true, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_ed25519, null));
    _lazyFinal($, "Bip44Conf_stellar", "$get$Bip44Conf_stellar", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["addr_type", B.C_XlmAddrTypes], type$.String, type$.dynamic), new A.Bip44Conf_stellar_closure(), 148, B.CoinNames_Stellar, "0'", false, t1, B.EllipticCurveTypes_ed25519, null);
    });
    _lazyFinal($, "Bip44Conf_terra", "$get$Bip44Conf_terra", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "terra"], type$.String, type$.dynamic), new A.Bip44Conf_terra_closure(), 330, B.CoinNames_Terra, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, null);
    });
    _lazyFinal($, "Bip44Conf_tezos", "$get$Bip44Conf_tezos", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["prefix", B.C_XtzAddrPrefixes], type$.String, type$.dynamic), new A.Bip44Conf_tezos_closure(), 1729, B.CoinNames_Tezos, "0'/0'", false, t1, B.EllipticCurveTypes_ed25519, null);
    });
    _lazyFinal($, "Bip44Conf_theta", "$get$Bip44Conf_theta", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_theta_closure(), 500, B.CoinNames_qd4, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_tron", "$get$Bip44Conf_tron", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_tron_closure(), 195, B.CoinNames_Tron, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_tronTestnet", "$get$Bip44Conf_tronTestnet", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_tronTestnet_closure(), 1, B.CoinNames_Tron, "0'/0/0", true, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_vechain", "$get$Bip44Conf_vechain", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_vechain_closure(), 818, B.CoinNames_VeChain, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_verge", "$get$Bip44Conf_verge", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_30], type$.String, type$.dynamic), new A.Bip44Conf_verge_closure(), 77, B.CoinNames_Verge, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_158);
    });
    _lazyFinal($, "Bip44Conf_zcashMainNet", "$get$Bip44Conf_zcashMainNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_28_184], type$.String, type$.dynamic), new A.Bip44Conf_zcashMainNet_closure(), 133, B.CoinNames_Zcash, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip44Conf_zcashTestNet", "$get$Bip44Conf_zcashTestNet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerTest();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_29_37], type$.String, type$.dynamic), new A.Bip44Conf_zcashTestNet_closure(), 1, B.CoinNames_O1S, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip44Conf_zilliqa", "$get$Bip44Conf_zilliqa", () => A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.dynamic), new A.Bip44Conf_zilliqa_closure(), 313, B.CoinNames_Zilliqa, "0'/0/0", false, $.$get$Bip44Conf_bip44BtcKeyNetVerMain(), B.EllipticCurveTypes_secp256k1, null));
    _lazyFinal($, "Bip44Conf_tonMainnet", "$get$Bip44Conf_tonMainnet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["workchain", 0], type$.String, type$.dynamic), new A.Bip44Conf_tonMainnet_closure(), 607, B.CoinNames_aBy, "0'", false, t1, B.EllipticCurveTypes_ed25519, null);
    });
    _lazyFinal($, "Bip44Conf_tonTestnet", "$get$Bip44Conf_tonTestnet", () => {
      var t1 = $.$get$Bip44Conf_bip44BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["workchain", -1], type$.String, type$.dynamic), new A.Bip44Conf_tonTestnet_closure(), 1, B.CoinNames_aBy0, "0'", true, t1, B.EllipticCurveTypes_ed25519, null);
    });
    _lazyFinal($, "Bip49Coins__coinToConf", "$get$Bip49Coins__coinToConf", () => A.LinkedHashMap_LinkedHashMap$_literal([B.Bip49Coins_bitcoin, $.$get$Bip49Conf_bitcoinMainNet(), B.Bip49Coins_bitcoinTestnet, $.$get$Bip49Conf_bitcoinTestNet(), B.Bip49Coins_bitcoinCash, $.$get$Bip49Conf_bitcoinCashMainNet(), B.Bip49Coins_bitcoinCashTestnet, $.$get$Bip49Conf_bitcoinCashTestNet(), B.Bip49Coins_bitcoinCashSlp, $.$get$Bip49Conf_bitcoinCashSlpMainNet(), B.Bip49Coins_bitcoinCashSlpTestnet, $.$get$Bip49Conf_bitcoinCashSlpTestNet(), B.Bip49Coins_bitcoinSv, $.$get$Bip49Conf_bitcoinSvMainNet(), B.Bip49Coins_bitcoinSvTestnet, $.$get$Bip49Conf_bitcoinSvTestNet(), B.Bip49Coins_dash, $.$get$Bip49Conf_dashMainNet(), B.Bip49Coins_dashTestnet, $.$get$Bip49Conf_dashTestNet(), B.Bip49Coins_dogecoin, $.$get$Bip49Conf_dogecoinMainNet(), B.Bip49Coins_dogecoinTestnet, $.$get$Bip49Conf_dogecoinTestNet(), B.Bip49Coins_ecash, $.$get$Bip49Conf_ecashMainNet(), B.Bip49Coins_ecashTestnet, $.$get$Bip49Conf_ecashTestNet(), B.Bip49Coins_litecoin, $.$get$Bip49Conf_litecoinMainNet(), B.Bip49Coins_litecoinTestnet, $.$get$Bip49Conf_litecoinTestNet(), B.Bip49Coins_zcash, $.$get$Bip49Conf_zcashMainNet(), B.Bip49Coins_zcashTestnet, $.$get$Bip49Conf_zcashTestNet(), B.Bip49Coins_pepecoin, $.$get$Bip49Conf_pepeMainnet(), B.Bip49Coins_pepecoinTestnet, $.$get$Bip49Conf_pepeTestnet()], type$.Bip49Coins, type$.BipCoinConfig));
    _lazyFinal($, "Bip49Conf_bip49BtcKeyNetVerMain", "$get$Bip49Conf_bip49BtcKeyNetVerMain", () => {
      var t1 = type$.int;
      return A.Bip32KeyNetVersions$(A.List_List$from([4, 157, 124, 178], true, t1), A.List_List$from([4, 157, 120, 120], true, t1));
    });
    _lazyFinal($, "Bip49Conf_bip49BtcKeyNetVerTest", "$get$Bip49Conf_bip49BtcKeyNetVerTest", () => {
      var t1 = type$.int;
      return A.Bip32KeyNetVersions$(A.List_List$from([4, 74, 82, 98], true, t1), A.List_List$from([4, 74, 78, 40], true, t1));
    });
    _lazyFinal($, "Bip49Conf_dashMainNet", "$get$Bip49Conf_dashMainNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_16], type$.String, type$.dynamic), new A.Bip49Conf_dashMainNet_closure(), 5, B.CoinNames_Dash, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_204);
    });
    _lazyFinal($, "Bip49Conf_dashTestNet", "$get$Bip49Conf_dashTestNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerTest();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_19], type$.String, type$.dynamic), new A.Bip49Conf_dashTestNet_closure(), 1, B.CoinNames_MUB, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip49Conf_dogecoinMainNet", "$get$Bip49Conf_dogecoinMainNet", () => {
      var t1 = type$.int;
      t1 = A.Bip32KeyNetVersions$(A.List_List$from([2, 250, 202, 253], true, t1), A.List_List$from([2, 250, 195, 152], true, t1));
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_22], type$.String, type$.dynamic), new A.Bip49Conf_dogecoinMainNet_closure(), 3, B.CoinNames_Dogecoin, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_158);
    });
    _lazyFinal($, "Bip49Conf_dogecoinTestNet", "$get$Bip49Conf_dogecoinTestNet", () => {
      var t1 = type$.int;
      t1 = A.Bip32KeyNetVersions$(A.List_List$from([4, 50, 169, 168], true, t1), A.List_List$from([4, 50, 162, 67], true, t1));
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_196], type$.String, type$.dynamic), new A.Bip49Conf_dogecoinTestNet_closure(), 1, B.CoinNames_OPN, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_241);
    });
    _lazyFinal($, "Bip49Conf_litecoinMainNet", "$get$Bip49Conf_litecoinMainNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerMain(),
        t2 = type$.int;
      t2 = A.Bip32KeyNetVersions$(A.List_List$from([1, 178, 110, 246], true, t2), A.List_List$from([1, 178, 103, 146], true, t2));
      return A.BipLitecoinConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std_net_ver", B.List_50, "depr_net_ver", B.List_5], type$.String, type$.dynamic), new A.Bip49Conf_litecoinMainNet_closure(), t2, 2, B.CoinNames_Litecoin, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_176);
    });
    _lazyFinal($, "Bip49Conf_litecoinTestNet", "$get$Bip49Conf_litecoinTestNet", () => {
      var t1 = type$.int,
        t2 = A.Bip32KeyNetVersions$(A.List_List$from([4, 54, 246, 225], true, t1), A.List_List$from([4, 54, 239, 125], true, t1));
      t1 = A.Bip32KeyNetVersions$(A.List_List$from([4, 54, 246, 225], true, t1), A.List_List$from([4, 54, 239, 125], true, t1));
      return A.BipLitecoinConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std_net_ver", B.List_58, "depr_net_ver", B.List_196], type$.String, type$.dynamic), new A.Bip49Conf_litecoinTestNet_closure(), t1, 1, B.CoinNames_IIS, "0'/0/0", true, t2, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip49Conf_zcashMainNet", "$get$Bip49Conf_zcashMainNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_28_189], type$.String, type$.dynamic), new A.Bip49Conf_zcashMainNet_closure(), 133, B.CoinNames_Zcash, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip49Conf_zcashTestNet", "$get$Bip49Conf_zcashTestNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerTest();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_28_186], type$.String, type$.dynamic), new A.Bip49Conf_zcashTestNet_closure(), 1, B.CoinNames_O1S, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip49Conf_bitcoinMainNet", "$get$Bip49Conf_bitcoinMainNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_5], type$.String, type$.dynamic), new A.Bip49Conf_bitcoinMainNet_closure(), 0, B.CoinNames_Bitcoin, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip49Conf_bitcoinTestNet", "$get$Bip49Conf_bitcoinTestNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerTest();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_196], type$.String, type$.dynamic), new A.Bip49Conf_bitcoinTestNet_closure(), 1, B.CoinNames_tuc, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip49Conf_bitcoinSvMainNet", "$get$Bip49Conf_bitcoinSvMainNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerMain();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_5], type$.String, type$.dynamic), new A.Bip49Conf_bitcoinSvMainNet_closure(), 236, B.CoinNames_BitcoinSV, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip49Conf_bitcoinSvTestNet", "$get$Bip49Conf_bitcoinSvTestNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerTest();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_196], type$.String, type$.dynamic), new A.Bip49Conf_bitcoinSvTestNet_closure(), 1, B.CoinNames_B2l, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip49Conf_bitcoinCashMainNet", "$get$Bip49Conf_bitcoinCashMainNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerMain(),
        t2 = type$.String;
      return A.BipBitcoinCashConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_8, "hrp", "bitcoincash"], t2, type$.nullable_Object), "legacy", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_5], t2, type$.nullable_List_int)], t2, type$.dynamic), new A.Bip49Conf_bitcoinCashMainNet_closure(), 145, B.CoinNames_CDm, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip49Conf_bitcoinCashTestNet", "$get$Bip49Conf_bitcoinCashTestNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerTest(),
        t2 = type$.String;
      return A.BipBitcoinCashConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_8, "hrp", "bchtest"], t2, type$.Object), "legacy", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_196], t2, type$.List_int)], t2, type$.dynamic), new A.Bip49Conf_bitcoinCashTestNet_closure(), 1, B.CoinNames_Iot, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip49Conf_bitcoinCashSlpMainNet", "$get$Bip49Conf_bitcoinCashSlpMainNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerMain(),
        t2 = type$.String;
      return A.BipBitcoinCashConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_8, "hrp", "simpleledger"], t2, type$.Object), "legacy", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_5], t2, type$.List_int)], t2, type$.dynamic), new A.Bip49Conf_bitcoinCashSlpMainNet_closure(), 145, B.CoinNames_rCZ, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip49Conf_bitcoinCashSlpTestNet", "$get$Bip49Conf_bitcoinCashSlpTestNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerTest(),
        t2 = type$.String;
      return A.BipBitcoinCashConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_8, "hrp", "slptest"], t2, type$.Object), "legacy", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_196], t2, type$.List_int)], t2, type$.dynamic), new A.Bip49Conf_bitcoinCashSlpTestNet_closure(), 1, B.CoinNames_FCG, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip49Conf_ecashMainNet", "$get$Bip49Conf_ecashMainNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerMain(),
        t2 = type$.String;
      return A.BipBitcoinCashConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_8, "hrp", "ecash"], t2, type$.Object), "legacy", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_5], t2, type$.List_int)], t2, type$.dynamic), new A.Bip49Conf_ecashMainNet_closure(), 145, B.CoinNames_eCash, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip49Conf_ecashTestNet", "$get$Bip49Conf_ecashTestNet", () => {
      var t1 = $.$get$Bip49Conf_bip49BtcKeyNetVerTest(),
        t2 = type$.String;
      return A.BipBitcoinCashConf$(A.LinkedHashMap_LinkedHashMap$_literal(["std", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_8, "hrp", "ectest"], t2, type$.Object), "legacy", A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_196], t2, type$.List_int)], t2, type$.dynamic), new A.Bip49Conf_ecashTestNet_closure(), 1, B.CoinNames_HZw, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip49Conf_pepeMainnet", "$get$Bip49Conf_pepeMainnet", () => {
      var t1 = type$.int;
      t1 = A.Bip32KeyNetVersions$(A.List_List$from([2, 250, 202, 253], true, t1), A.List_List$from([2, 250, 195, 152], true, t1));
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_22], type$.String, type$.dynamic), new A.Bip49Conf_pepeMainnet_closure(), 3434, B.CoinNames_Pepecoin, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_158);
    });
    _lazyFinal($, "Bip49Conf_pepeTestnet", "$get$Bip49Conf_pepeTestnet", () => {
      var t1 = type$.int;
      t1 = A.Bip32KeyNetVersions$(A.List_List$from([4, 50, 169, 168], true, t1), A.List_List$from([4, 50, 162, 67], true, t1));
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_ver", B.List_196], type$.String, type$.dynamic), new A.Bip49Conf_pepeTestnet_closure(), 1, B.CoinNames_QyU, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_241);
    });
    _lazyFinal($, "Bip84Coins__coinToConf", "$get$Bip84Coins__coinToConf", () => A.LinkedHashMap_LinkedHashMap$_literal([B.Bip84Coins_bitcoin, $.$get$Bip84Conf_bitcoinMainNet(), B.Bip84Coins_bitcoinTestnet, $.$get$Bip84Conf_bitcoinTestNet(), B.Bip84Coins_litecoin, $.$get$Bip84Conf_litecoinMainNet(), B.Bip84Coins_litecoinTestnet, $.$get$Bip84Conf_litecoinTestNet()], type$.Bip84Coins, type$.BipCoinConfig));
    _lazyFinal($, "Bip84Conf_bip84BtcKeyNetVer", "$get$Bip84Conf_bip84BtcKeyNetVer", () => {
      var t1 = type$.int;
      return A.Bip32KeyNetVersions$(A.List_List$from([4, 178, 71, 70], true, t1), A.List_List$from([4, 178, 67, 12], true, t1));
    });
    _lazyFinal($, "Bip84Conf_bitcoinMainNet", "$get$Bip84Conf_bitcoinMainNet", () => {
      var t1 = $.$get$Bip84Conf_bip84BtcKeyNetVer();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "bc"], type$.String, type$.dynamic), new A.Bip84Conf_bitcoinMainNet_closure(), 0, B.CoinNames_Bitcoin, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazyFinal($, "Bip84Conf_bitcoinTestNet", "$get$Bip84Conf_bitcoinTestNet", () => {
      var t1 = type$.int;
      t1 = A.Bip32KeyNetVersions$(A.List_List$from([4, 95, 28, 246], true, t1), A.List_List$from([4, 95, 24, 188], true, t1));
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "tb"], type$.String, type$.dynamic), new A.Bip84Conf_bitcoinTestNet_closure(), 1, B.CoinNames_tuc, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip84Conf_litecoinMainNet", "$get$Bip84Conf_litecoinMainNet", () => {
      var t1 = $.$get$Bip84Conf_bip84BtcKeyNetVer();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "ltc"], type$.String, type$.dynamic), new A.Bip84Conf_litecoinMainNet_closure(), 2, B.CoinNames_Litecoin, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_176);
    });
    _lazyFinal($, "Bip84Conf_litecoinTestNet", "$get$Bip84Conf_litecoinTestNet", () => {
      var t1 = type$.int;
      t1 = A.Bip32KeyNetVersions$(A.List_List$from([4, 54, 246, 225], true, t1), A.List_List$from([4, 54, 239, 125], true, t1));
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "tltc"], type$.String, type$.dynamic), new A.Bip84Conf_litecoinTestNet_closure(), 1, B.CoinNames_IIS, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Bip86Coins__coinToConf", "$get$Bip86Coins__coinToConf", () => A.LinkedHashMap_LinkedHashMap$_literal([B.Bip86Coins_bitcoin, $.$get$Bip86Conf_bitcoinMainNet(), B.Bip86Coins_bitcoinTestnet, $.$get$Bip86Conf_bitcoinTestNet()], type$.Bip86Coins, type$.BipCoinConfig));
    _lazyFinal($, "Bip86Conf_bip86BtcKeyNetVer", "$get$Bip86Conf_bip86BtcKeyNetVer", () => $.$get$Bip32Const_mainNetKeyNetVersions());
    _lazyFinal($, "Bip86Conf_bip86BtcKeyNetVerTest", "$get$Bip86Conf_bip86BtcKeyNetVerTest", () => $.$get$Bip32Const_testNetKeyNetVersions());
    _lazy($, "Bip86Conf_bitcoinMainNet", "$get$Bip86Conf_bitcoinMainNet", () => {
      var t1 = $.$get$Bip86Conf_bip86BtcKeyNetVer();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "bc"], type$.String, type$.dynamic), new A.Bip86Conf_bitcoinMainNet_closure(), 0, B.CoinNames_Bitcoin, "0'/0/0", false, t1, B.EllipticCurveTypes_secp256k1, B.List_128);
    });
    _lazy($, "Bip86Conf_bitcoinTestNet", "$get$Bip86Conf_bitcoinTestNet", () => {
      var t1 = $.$get$Bip86Conf_bip86BtcKeyNetVerTest();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["hrp", "tb"], type$.String, type$.dynamic), new A.Bip86Conf_bitcoinTestNet_closure(), 1, B.CoinNames_tuc, "0'/0/0", true, t1, B.EllipticCurveTypes_secp256k1, B.List_239);
    });
    _lazyFinal($, "Cip1852Coins__coinToConf", "$get$Cip1852Coins__coinToConf", () => A.LinkedHashMap_LinkedHashMap$_literal([B.Cip1852Coins_cardanoIcarus, $.$get$Cip1852Conf_cardanoIcarusMainNet(), B.Cip1852Coins_cardanoLedger, $.$get$Cip1852Conf_cardanoLedgerMainNet(), B.Cip1852Coins_cardanoIcarusTestnet, $.$get$Cip1852Conf_cardanoIcarusTestNet(), B.Cip1852Coins_cardanoLedgerTestnet, $.$get$Cip1852Conf_cardanoLedgerTestNet()], type$.Cip1852Coins, type$.BipCoinConfig));
    _lazyFinal($, "Cip1852Conf_cardanoIcarusMainNet", "$get$Cip1852Conf_cardanoIcarusMainNet", () => {
      var t1 = $.$get$Bip32Const_kholawKeyNetVersions();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_tag", B.ADANetwork_1_764824073_mainnet, "is_icarus", true], type$.String, type$.dynamic), new A.Cip1852Conf_cardanoIcarusMainNet_closure(), 1815, B.CoinNames_Cardano, "0'/0/0", false, t1, B.EllipticCurveTypes_ed25519Kholaw, null);
    });
    _lazyFinal($, "Cip1852Conf_cardanoIcarusTestNet", "$get$Cip1852Conf_cardanoIcarusTestNet", () => {
      var t1 = $.$get$Bip32Const_testNetKeyNetVersions();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_tag", B.ADANetwork_0_2_testnetPreview, "is_icarus", true], type$.String, type$.dynamic), new A.Cip1852Conf_cardanoIcarusTestNet_closure(), 1, B.CoinNames_UiL, "0'/0/0", true, t1, B.EllipticCurveTypes_ed25519Kholaw, null);
    });
    _lazyFinal($, "Cip1852Conf_cardanoLedgerMainNet", "$get$Cip1852Conf_cardanoLedgerMainNet", () => {
      var t1 = $.$get$Bip32Const_kholawKeyNetVersions();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_tag", B.ADANetwork_1_764824073_mainnet], type$.String, type$.dynamic), new A.Cip1852Conf_cardanoLedgerMainNet_closure(), 1815, B.CoinNames_Cardano, "0'/0/0", false, t1, B.EllipticCurveTypes_ed25519Kholaw, null);
    });
    _lazyFinal($, "Cip1852Conf_cardanoLedgerTestNet", "$get$Cip1852Conf_cardanoLedgerTestNet", () => {
      var t1 = $.$get$Bip32Const_testNetKeyNetVersions();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["net_tag", B.ADANetwork_0_2_testnetPreview], type$.String, type$.dynamic), new A.Cip1852Conf_cardanoLedgerTestNet_closure(), 1, B.CoinNames_UiL, "0'/0/0", true, t1, B.EllipticCurveTypes_ed25519Kholaw, null);
    });
    _lazyFinal($, "MoneroCoins__coinToConf", "$get$MoneroCoins__coinToConf", () => A.LinkedHashMap_LinkedHashMap$_literal([B.MoneroCoins_moneroMainnet, $.$get$MoneroConf_mainNet(), B.MoneroCoins_moneroStagenet, $.$get$MoneroConf_stageNet(), B.MoneroCoins_moneroTestnet, $.$get$MoneroConf_testNet()], type$.MoneroCoins, A.findType("MoneroCoinConf")));
    _lazyFinal($, "MoneroConf_mainNet", "$get$MoneroConf_mainNet", () => A.MoneroCoinConf_MoneroCoinConf$fromCoinConf(B.CoinConf_Ktx));
    _lazyFinal($, "MoneroConf_stageNet", "$get$MoneroConf_stageNet", () => A.MoneroCoinConf_MoneroCoinConf$fromCoinConf(B.CoinConf_gWX));
    _lazyFinal($, "MoneroConf_testNet", "$get$MoneroConf_testNet", () => A.MoneroCoinConf_MoneroCoinConf$fromCoinConf(B.CoinConf_uUv));
    _lazyFinal($, "SubstrateCoins__coinToConf", "$get$SubstrateCoins__coinToConf", () => A.LinkedHashMap_LinkedHashMap$_literal([B.SubstrateCoins_acalaEd25519, $.$get$SubstrateConf_acalaEd25519(), B.SubstrateCoins_acalaSecp256k1, $.$get$SubstrateConf_acalaSecp256k1(), B.SubstrateCoins_acalaSr25519, $.$get$SubstrateConf_acalaSr25519(), B.SubstrateCoins_bifrostEd25519, $.$get$SubstrateConf_bifrostEd25519(), B.SubstrateCoins_bifrostSecp256k1, $.$get$SubstrateConf_bifrostSecp256k1(), B.SubstrateCoins_bifrostSr25519, $.$get$SubstrateConf_bifrostSr25519(), B.SubstrateCoins_chainxEd25519, $.$get$SubstrateConf_chainXEd25519(), B.SubstrateCoins_chainxSecp256k1, $.$get$SubstrateConf_chainXSecp256k1(), B.SubstrateCoins_chainxSr25519, $.$get$SubstrateConf_chainXSr25519(), B.SubstrateCoins_edgewareEd25519, $.$get$SubstrateConf_edgewareEd25519(), B.SubstrateCoins_edgewareSecp256k1, $.$get$SubstrateConf_edgewareSecp256k1(), B.SubstrateCoins_edgewareSr25519, $.$get$SubstrateConf_edgewareSr25519(), B.SubstrateCoins_genericEd25519, $.$get$SubstrateConf_genericEd25519(), B.SubstrateCoins_genericSecp256k1, $.$get$SubstrateConf_genericSecp256k1(), B.SubstrateCoins_genericSr25519, $.$get$SubstrateConf_genericSr25519(), B.SubstrateCoins_karuraEd25519, $.$get$SubstrateConf_karuraEd25519(), B.SubstrateCoins_karuraSecp256k1, $.$get$SubstrateConf_karuraSecp256k1(), B.SubstrateCoins_karuraSr25519, $.$get$SubstrateConf_karuraSr25519(), B.SubstrateCoins_kusamaEd25519, $.$get$SubstrateConf_kusamaEd25519(), B.SubstrateCoins_kusamaSecp256k1, $.$get$SubstrateConf_kusamaSecp256k1(), B.SubstrateCoins_kusamaSr25519, $.$get$SubstrateConf_kusamaSr25519(), B.SubstrateCoins_moonbeamEd25519, $.$get$SubstrateConf_moonbeamEd25519(), B.SubstrateCoins_moonbeamSecp256k1, $.$get$SubstrateConf_moonbeamSecp256k1(), B.SubstrateCoins_moonbeamSr25519, $.$get$SubstrateConf_moonbeamSr25519(), B.SubstrateCoins_moonriverEd25519, $.$get$SubstrateConf_moonriverEd25519(), B.SubstrateCoins_moonriverSecp256k1, $.$get$SubstrateConf_moonriverSecp256k1(), B.SubstrateCoins_moonriverSr25519, $.$get$SubstrateConf_moonriverSr25519(), B.SubstrateCoins_phalaEd25519, $.$get$SubstrateConf_phalaEd25519(), B.SubstrateCoins_phalaSecp256k1, $.$get$SubstrateConf_phalaSecp256k1(), B.SubstrateCoins_phalaSr25519, $.$get$SubstrateConf_phalaSr25519(), B.SubstrateCoins_plasmEd25519, $.$get$SubstrateConf_plasmEd25519(), B.SubstrateCoins_plasmSecp256k1, $.$get$SubstrateConf_plasmSecp256k1(), B.SubstrateCoins_plasmSr25519, $.$get$SubstrateConf_plasmSr25519(), B.SubstrateCoins_polkadotEd25519, $.$get$SubstrateConf_polkadotEd25519(), B.SubstrateCoins_polkadotSecp256k1, $.$get$SubstrateConf_polkadotSecp256k1(), B.SubstrateCoins_polkadotSr25519, $.$get$SubstrateConf_polkadotSr25519(), B.SubstrateCoins_soraEd25519, $.$get$SubstrateConf_soraEd25519(), B.SubstrateCoins_soraSecp256k1, $.$get$SubstrateConf_soraSecp256k1(), B.SubstrateCoins_soraSr25519, $.$get$SubstrateConf_soraSr25519(), B.SubstrateCoins_stafiEd25519, $.$get$SubstrateConf_stafiEd25519(), B.SubstrateCoins_stafiSecp256k1, $.$get$SubstrateConf_stafiSecp256k1(), B.SubstrateCoins_stafiSr25519, $.$get$SubstrateConf_stafiSr25519()], type$.SubstrateCoins, A.findType("SubstrateCoinConf")));
    _lazyFinal($, "SubstrateConf_acalaEd25519", "$get$SubstrateConf_acalaEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_acalaEd25519_closure(), B.CoinConf_oMr, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_acalaSecp256k1", "$get$SubstrateConf_acalaSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_acalaSecp256k1_closure(), B.CoinConf_oMr, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_acalaSr25519", "$get$SubstrateConf_acalaSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_acalaSr25519_closure(), B.CoinConf_oMr, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_bifrostEd25519", "$get$SubstrateConf_bifrostEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_bifrostEd25519_closure(), B.CoinConf_cOY, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_bifrostSecp256k1", "$get$SubstrateConf_bifrostSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_bifrostSecp256k1_closure(), B.CoinConf_cOY, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_bifrostSr25519", "$get$SubstrateConf_bifrostSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_bifrostSr25519_closure(), B.CoinConf_cOY, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_chainXEd25519", "$get$SubstrateConf_chainXEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_chainXEd25519_closure(), B.CoinConf_UEA, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_chainXSecp256k1", "$get$SubstrateConf_chainXSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_chainXSecp256k1_closure(), B.CoinConf_UEA, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_chainXSr25519", "$get$SubstrateConf_chainXSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_chainXSr25519_closure(), B.CoinConf_UEA, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_edgewareEd25519", "$get$SubstrateConf_edgewareEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_edgewareEd25519_closure(), B.CoinConf_CtR, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_edgewareSecp256k1", "$get$SubstrateConf_edgewareSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_edgewareSecp256k1_closure(), B.CoinConf_CtR, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_edgewareSr25519", "$get$SubstrateConf_edgewareSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_edgewareSr25519_closure(), B.CoinConf_CtR, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_genericEd25519", "$get$SubstrateConf_genericEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_genericEd25519_closure(), B.CoinConf_A0t, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_genericSecp256k1", "$get$SubstrateConf_genericSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_genericSecp256k1_closure(), B.CoinConf_A0t, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_genericSr25519", "$get$SubstrateConf_genericSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_genericSr25519_closure(), B.CoinConf_A0t, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_karuraEd25519", "$get$SubstrateConf_karuraEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_karuraEd25519_closure(), B.CoinConf_Xmb, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_karuraSecp256k1", "$get$SubstrateConf_karuraSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_karuraSecp256k1_closure(), B.CoinConf_Xmb, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_karuraSr25519", "$get$SubstrateConf_karuraSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_karuraSr25519_closure(), B.CoinConf_Xmb, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_kusamaEd25519", "$get$SubstrateConf_kusamaEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_kusamaEd25519_closure(), B.CoinConf_aWd, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_kusamaSecp256k1", "$get$SubstrateConf_kusamaSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_kusamaSecp256k1_closure(), B.CoinConf_aWd, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_kusamaSr25519", "$get$SubstrateConf_kusamaSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_kusamaSr25519_closure(), B.CoinConf_aWd, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_moonbeamEd25519", "$get$SubstrateConf_moonbeamEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_moonbeamEd25519_closure(), B.CoinConf_yvr, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_moonbeamSecp256k1", "$get$SubstrateConf_moonbeamSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_moonbeamSecp256k1_closure(), B.CoinConf_yvr, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_moonbeamSr25519", "$get$SubstrateConf_moonbeamSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_moonbeamSr25519_closure(), B.CoinConf_yvr, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_moonriverEd25519", "$get$SubstrateConf_moonriverEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_moonriverEd25519_closure(), B.CoinConf_Z8h, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_moonriverSecp256k1", "$get$SubstrateConf_moonriverSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_moonriverSecp256k1_closure(), B.CoinConf_Z8h, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_moonriverSr25519", "$get$SubstrateConf_moonriverSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_moonriverSr25519_closure(), B.CoinConf_Z8h, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_phalaEd25519", "$get$SubstrateConf_phalaEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_phalaEd25519_closure(), B.CoinConf_wcW, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_phalaSecp256k1", "$get$SubstrateConf_phalaSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_phalaSecp256k1_closure(), B.CoinConf_wcW, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_phalaSr25519", "$get$SubstrateConf_phalaSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_phalaSr25519_closure(), B.CoinConf_wcW, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_plasmEd25519", "$get$SubstrateConf_plasmEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_plasmEd25519_closure(), B.CoinConf_gT2, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_plasmSecp256k1", "$get$SubstrateConf_plasmSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_plasmSecp256k1_closure(), B.CoinConf_gT2, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_plasmSr25519", "$get$SubstrateConf_plasmSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_plasmSr25519_closure(), B.CoinConf_gT2, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_polkadotEd25519", "$get$SubstrateConf_polkadotEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_polkadotEd25519_closure(), B.CoinConf_UW6, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_polkadotSecp256k1", "$get$SubstrateConf_polkadotSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_polkadotSecp256k1_closure(), B.CoinConf_UW6, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_polkadotSr25519", "$get$SubstrateConf_polkadotSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_polkadotSr25519_closure(), B.CoinConf_UW6, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_soraEd25519", "$get$SubstrateConf_soraEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_soraEd25519_closure(), B.CoinConf_VjA, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_soraSecp256k1", "$get$SubstrateConf_soraSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_soraSecp256k1_closure(), B.CoinConf_VjA, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_soraSr25519", "$get$SubstrateConf_soraSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_soraSr25519_closure(), B.CoinConf_VjA, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "SubstrateConf_stafiEd25519", "$get$SubstrateConf_stafiEd25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_stafiEd25519_closure(), B.CoinConf_9R3, B.EllipticCurveTypes_ed25519));
    _lazyFinal($, "SubstrateConf_stafiSecp256k1", "$get$SubstrateConf_stafiSecp256k1", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_stafiSecp256k1_closure(), B.CoinConf_9R3, B.EllipticCurveTypes_secp256k1));
    _lazyFinal($, "SubstrateConf_stafiSr25519", "$get$SubstrateConf_stafiSr25519", () => A.SubstrateCoinConf_SubstrateCoinConf$fromCoinConf(new A.SubstrateConf_stafiSr25519_closure(), B.CoinConf_9R3, B.EllipticCurveTypes_sr25519));
    _lazyFinal($, "AES__lib", "$get$AES__lib", () => $.$get$AESLib__aes());
    _lazyFinal($, "AESLib__aes", "$get$AESLib__aes", () => {
      var t1 = type$.int;
      t1 = new A.AESLib(A.List_List$from([1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47], true, t1), A.List_List$from([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22], true, t1), A.List_List$from([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125], true, t1), A.List_List$filled(256, 0, false, t1), A.List_List$filled(256, 0, false, t1), A.List_List$filled(256, 0, false, t1), A.List_List$filled(256, 0, false, t1), A.List_List$filled(256, 0, false, t1), A.List_List$filled(256, 0, false, t1), A.List_List$filled(256, 0, false, t1), A.List_List$filled(256, 0, false, t1));
      t1.initialize$0();
      return t1;
    });
    _lazyFinal($, "Curves_curveEd25519", "$get$Curves_curveEd25519", () => {
      var t1 = A._BigIntImpl_parse("57896044618658097711785492504343953926634992332820282019728792003956564819949", null),
        t2 = A._BigIntImpl__BigIntImpl$from(-1),
        t3 = A._BigIntImpl_parse("37095705934669439343138083508754565189542113879843219016388785533085940283555", null),
        t4 = A._BigIntImpl__BigIntImpl$from(8);
      A._BigIntImpl_parse(string$.x3723700, null);
      return new A.CurveED(t1, t2, t3, t4);
    });
    _lazyFinal($, "Curves_generatorED25519", "$get$Curves_generatorED25519", () => {
      var _null = null,
        t1 = $.$get$Curves_curveEd25519(),
        t2 = A._BigIntImpl_parse("15112221349535400772501151409588531511454012693041857206046113283949847762202", _null),
        t3 = A._BigIntImpl_parse("46316835694926478169428394003475163141307993866256225615783033603165251855960", _null),
        t4 = $.$get$_BigIntImpl_one(),
        t5 = A._BigIntImpl_parse("46827403850823179245072216630277197565144205554125654976674165829533817101731", _null);
      return A.EDPoint$(t1, true, A._BigIntImpl_parse(string$.x3723700, _null), t5, t2, t3, t4);
    });
    _lazyFinal($, "Curves_curveSecp256k1", "$get$Curves_curveSecp256k1", () => {
      var t1 = A._BigIntImpl_parse("115792089237316195423570985008687907853269984665640564039457584007908834671663", null);
      return A.CurveFp$($.$get$_BigIntImpl_zero(), A._BigIntImpl__BigIntImpl$from(7), $.$get$_BigIntImpl_one(), t1);
    });
    _lazyFinal($, "Curves_generatorSecp256k1", "$get$Curves_generatorSecp256k1", () => {
      var t1 = $.$get$Curves_curveSecp256k1(),
        t2 = A._BigIntImpl_parse("79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", 16),
        t3 = A._BigIntImpl_parse("483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", 16),
        t4 = $.$get$_BigIntImpl_one();
      return A.ProjectiveECCPoint_ProjectiveECCPoint(t1, true, A._BigIntImpl_parse("115792089237316195423570985008687907852837564279074904382605163141518161494337", null), t2, t3, t4);
    });
    _lazyFinal($, "Curves_curve256", "$get$Curves_curve256", () => {
      var t1 = A._BigIntImpl_parse("115792089210356248762697446949407573530086143415290314195533631308867097853951", null);
      return A.CurveFp$(A._BigIntImpl__BigIntImpl$from(-3), A._BigIntImpl_parse("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B", 16), $.$get$_BigIntImpl_one(), t1);
    });
    _lazyFinal($, "Curves_generator256", "$get$Curves_generator256", () => {
      var t1 = $.$get$Curves_curve256(),
        t2 = A._BigIntImpl_parse("6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296", 16),
        t3 = A._BigIntImpl_parse("4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5", 16),
        t4 = $.$get$_BigIntImpl_one();
      return A.ProjectiveECCPoint_ProjectiveECCPoint(t1, true, A._BigIntImpl_parse("115792089210356248762697446949407573529996955224135760342422259061068512044369", null), t2, t3, t4);
    });
    _lazyFinal($, "sqrtM1", "$get$sqrtM1", () => A._BigIntImpl_parse("19681161376707505956807079304988542015446066515923890162744021073123829784752", null));
    _lazyFinal($, "_iv", "$get$_iv", () => A.List_List$unmodifiable(B.List_2yZ, type$.int));
    _lazyFinal($, "_hi", "$get$_hi", () => A.List_List$unmodifiable(B.List_8cU, type$.int));
    _lazyFinal($, "_lo", "$get$_lo", () => A.List_List$unmodifiable(B.List_2bH, type$.int));
    _lazy($, "QuickCrypto__generateRandom", "$get$QuickCrypto__generateRandom", () => new A.QuickCrypto__generateRandom_closure());
    _lazyFinal($, "_Ss58Const_checksumPrefix", "$get$_Ss58Const_checksumPrefix", () => A.List_List$unmodifiable(A._setArrayType([83, 83, 53, 56, 80, 82, 69], type$.JSArray_int), type$.int));
    _lazyFinal($, "maxU64", "$get$maxU64", () => A._BigIntImpl_parse("18446744073709551615", null));
    _lazyFinal($, "BigRational_ten", "$get$BigRational_ten", () => {
      var t1 = A._BigIntImpl__BigIntImpl$from(10);
      return A.BigRational_BigRational(t1, A._BigIntImpl__BigIntImpl$from(1));
    });
    _lazyFinal($, "BigRational__one", "$get$BigRational__one", () => $.$get$_BigIntImpl_one());
    _lazyFinal($, "BigRational__zero", "$get$BigRational__zero", () => $.$get$_BigIntImpl_zero());
    _lazyFinal($, "BigRational__ten", "$get$BigRational__ten", () => A._BigIntImpl__BigIntImpl$from(10));
    _lazyFinal($, "StringUtils__hexBytesRegex", "$get$StringUtils__hexBytesRegex", () => A.RegExp_RegExp("^(0x|0X)?([0-9A-Fa-f]{2})+$", true));
    _lazyFinal($, "StringUtils__hexaDecimalRegex", "$get$StringUtils__hexaDecimalRegex", () => A.RegExp_RegExp("^(0x|0X)?[0-9A-Fa-f]+$", true));
    _lazyFinal($, "BaseRequest__tokenRE", "$get$BaseRequest__tokenRE", () => A.RegExp_RegExp("^[\\w!#%&'*+\\-.^`|~]+$", true));
    _lazyFinal($, "_digitRegex", "$get$_digitRegex", () => A.RegExp_RegExp("^\\d+$", true));
    _lazyFinal($, "_escapedChar", "$get$_escapedChar", () => A.RegExp_RegExp('["\\x00-\\x1F\\x7F]', true));
    _lazyFinal($, "token", "$get$token", () => A.RegExp_RegExp('[^()<>@,;:"\\\\/[\\]?={} \\t\\x00-\\x1F\\x7F]+', true));
    _lazyFinal($, "_lws", "$get$_lws", () => A.RegExp_RegExp("(?:\\r\\n)?[ \\t]+", true));
    _lazyFinal($, "_quotedString", "$get$_quotedString", () => A.RegExp_RegExp('"(?:[^"\\x00-\\x1F\\x7F]|\\\\.)*"', true));
    _lazyFinal($, "_quotedPair", "$get$_quotedPair", () => A.RegExp_RegExp("\\\\(.)", true));
    _lazyFinal($, "nonToken", "$get$nonToken", () => A.RegExp_RegExp('[()<>@,;:"\\\\/\\[\\]?={} \\t\\x00-\\x1F\\x7F]', true));
    _lazyFinal($, "whitespace", "$get$whitespace", () => A.RegExp_RegExp("(?:" + $.$get$_lws().pattern + ")*", true));
    _lazyFinal($, "MrtPlatformInterface__token", "$get$MrtPlatformInterface__token", () => new A.Object());
    _lazyFinal($, "PlatformInterface_instance", "$get$PlatformInterface_instance", () => {
      A.createSentinel();
      var t1 = new A.MrtNativeWeb();
      t1.PlatformInterface$1$token($.$get$MrtPlatformInterface__token());
      return t1;
    });
    _lazy($, "RetionalConst_bigR8", "$get$RetionalConst_bigR8", () => A.BigRational_BigRational(A._BigIntImpl__BigIntImpl$from(10).pow$1(8), null));
    _lazy($, "RetionalConst_bigR18", "$get$RetionalConst_bigR18", () => A.BigRational_BigRational(A._BigIntImpl__BigIntImpl$from(10).pow$1(18), null));
    _lazy($, "RetionalConst_bigR6", "$get$RetionalConst_bigR6", () => A.BigRational_BigRational(A._BigIntImpl__BigIntImpl$from(10).pow$1(6), null));
    _lazyFinal($, "WalletExceptionConst_dataVerificationFailed", "$get$WalletExceptionConst_dataVerificationFailed", () => A.WalletException$("data_verification_failed"));
    _lazyFinal($, "WalletExceptionConst_invalidSerializationData", "$get$WalletExceptionConst_invalidSerializationData", () => A.WalletException$("invalid_serialization_data"));
    _lazyFinal($, "WalletExceptionConst_invalidAccountDetails", "$get$WalletExceptionConst_invalidAccountDetails", () => A.WalletException$("invalid_account_details"));
    _lazyFinal($, "WalletExceptionConst_invalidBitcoinAddressType", "$get$WalletExceptionConst_invalidBitcoinAddressType", () => A.WalletException$("invalid_bitcoin_address_type"));
    _lazyFinal($, "WalletExceptionConst_incorrectNetwork", "$get$WalletExceptionConst_incorrectNetwork", () => A.WalletException$("incorrect_network"));
    _lazyFinal($, "WalletExceptionConst_invalidProviderInformation", "$get$WalletExceptionConst_invalidProviderInformation", () => A.WalletException$("invalid_provider_infomarion"));
    _lazyFinal($, "WalletExceptionConst_invalidContactDetails", "$get$WalletExceptionConst_invalidContactDetails", () => A.WalletException$("invalid_contact_details"));
    _lazyFinal($, "WalletExceptionConst_invalidBalance", "$get$WalletExceptionConst_invalidBalance", () => A.WalletException$("invalid_balance"));
    _lazyFinal($, "WalletExceptionConst_invalidCoin", "$get$WalletExceptionConst_invalidCoin", () => A.WalletException$("invalid_coin"));
    _lazyFinal($, "WalletExceptionConst_coinNotFound", "$get$WalletExceptionConst_coinNotFound", () => A.WalletException$("coin_not_found"));
    _lazyFinal($, "WalletExceptionConst_invalidTokenInformation", "$get$WalletExceptionConst_invalidTokenInformation", () => A.WalletException$("invalid_token_information"));
    _lazyFinal($, "WalletExceptionConst_invalidNftInfromaation", "$get$WalletExceptionConst_invalidNftInfromaation", () => A.WalletException$("invalid_nft_information"));
    _lazyFinal($, "ProvidersConst__providers", "$get$ProvidersConst__providers", () => {
      var _s17_ = "142.93.6.38:50002",
        _s14_ = "104.198.149.61",
        _s21_ = "104.248.139.211:50002",
        _s21_0 = "testnet.aranguren.org",
        _s13_ = "aranguren.org",
        _s20_ = "electrum.qortal.link",
        _s12_ = "46.101.3.154",
        _s23_ = "backup.electrum-ltc.org",
        _s20_0 = "electrum-ltc.bysh.me",
        _s24_ = "electrum.ltc.xurious.com",
        _s22_ = "electrumx.bitcoinsv.io",
        _s23_0 = "electrum.imaginary.cash",
        _s14_0 = "bch.loping.net",
        _s30_ = "https://chipnet.imaginary.cash",
        _s30_0 = "https://mainnet.pepeblocks.com",
        _s28_ = "https://mainnet.pepelum.site",
        _s6_ = "Ripple",
        _s23_1 = "https://xrplcluster.com",
        _s22_0 = "https://rippletest.net",
        _s10_ = "blockfrost",
        _s13_0 = "blockfrost.io",
        _s10_0 = "publicnode",
        _s23_2 = "ethereum.publicnode.com",
        _s29_ = "wss://ethereum.publicnode.com",
        _s14_1 = "publicnode.com",
        _s39_ = "https://ethereum-sepolia.publicnode.com",
        _s34_ = "https://polygon-bor.publicnode.com",
        _s41_ = "https://polygon-mumbai-bor.publicnode.com",
        _s26_ = "https://bsc.publicnode.com",
        _s34_0 = "https://bsc-testnet.publicnode.com",
        _s37_ = "https://cosmos-rpc.publicnode.com:443",
        _null = null,
        _s12_0 = "osmosis.zone",
        _s33_ = "https://rpc.testnet.osmosis.zone/",
        _s24_0 = "https://rpc.osmosis.zone",
        _s48_ = "https://rpc.sentry-02.theta-testnet.polypore.xyz",
        _s33_0 = "https://tendermint.mayachain.info",
        _s12_1 = "polkachu.com",
        _s40_ = "https://kujira-testnet-rpc.polkachu.com/",
        _s32_ = "https://kujira-rpc.polkachu.com/",
        _s17_0 = "https://tonapi.io",
        _s9_ = "TonCenter",
        _s20_1 = "https://toncenter.io",
        _s19_ = "https://polkadot.io",
        _s8_ = "trongrid",
        _s19_0 = "https://trongrid.io",
        _s31_ = "https://api.trongrid.io/jsonrpc",
        _s11_ = "trongrid.io",
        _s38_ = "https://api.shasta.trongrid.io/jsonrpc",
        _s32_0 = "https://nile.trongrid.io/jsonrpc",
        t1 = type$.JSArray_APIProvider,
        t2 = type$.dynamic;
      return A.ConstantMap_ConstantMap$from(A.LinkedHashMap_LinkedHashMap$_literal([0, A._setArrayType([A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, _s17_, _s17_, _s17_), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_WebSocket_3_websocket, "aranguren", "wss://bitcoin.aranguren.org:50004", "bitcoin.aranguren.org"), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_WebSocket_3_websocket, _s14_, "wss://104.198.149.61:8443", _s14_), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, _s21_, _s21_, _s21_), B.BitcoinExplorerAPIProvider_SNI, B.BitcoinExplorerAPIProvider_iLh], t1), 1, A._setArrayType([A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_WebSocket_3_websocket, _s21_0, "wss://testnet.aranguren.org:51004", _s13_), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, _s21_0, "testnet.aranguren.org:51002", _s13_), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, "blockstream", "blockstream.info:700", "blockstream.info"), B.BitcoinExplorerAPIProvider_SNI, B.BitcoinExplorerAPIProvider_iLh], t1), 2, A._setArrayType([A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_WebSocket_3_websocket, "qortal", "wss://electrum.qortal.link:50004", _s20_), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_WebSocket_3_websocket, _s12_, "wss://46.101.3.154:50004", _s12_), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, _s12_, "46.101.3.154:50002", _s12_), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, _s23_, "backup.electrum-ltc.org:443", _s23_), B.BitcoinExplorerAPIProvider_iLh], t1), 7, A._setArrayType([A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, _s20_0, "electrum-ltc.bysh.me:51002", _s20_0), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, _s24_, "electrum.ltc.xurious.com:51002", _s24_)], t1), 3, A._setArrayType([A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, _s20_, "electrum.qortal.link:54002", _s20_), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_WebSocket_3_websocket, "qortal", "wss://electrum.qortal.link:54004", _s20_), B.BitcoinExplorerAPIProvider_iLh], t1), 8, A._setArrayType([], t1), 9, A._setArrayType([A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, _s22_, "electrumx.bitcoinsv.io:50002", _s22_)], t1), 4, A._setArrayType([B.BitcoinExplorerAPIProvider_iLh], t1), 10, A._setArrayType([A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_WebSocket_3_websocket, _s23_0, "wss://electrum.imaginary.cash:50004", _s23_0), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, _s23_0, "electrum.imaginary.cash:50002", _s23_0), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_WebSocket_3_websocket, _s14_0, "wss://bch.loping.net:50004", _s14_0), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, _s14_0, "bch.loping.net:50002", _s14_0)], t1), 11, A._setArrayType([A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_WebSocket_3_websocket, "Chipnet-Websocket", "wss://chipnet.imaginary.cash:50004", _s30_), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, "Chipnet-ssl", "chipnet.imaginary.cash:50002", _s30_)], t1), 12, A._setArrayType([A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, "pepeblocks-ssl", "mainnet.pepeblocks.com:50002", _s30_0), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_TCP_2_tcp, "pepeblocks-tcp", "mainnet.pepeblocks.com:50001", _s30_0), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_WebSocket_3_websocket, "pepeblocks-wss", "wss://mainnet.pepeblocks.com:50004", "mainnet.pepeblocks.com"), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_SSL_1_ssl, "pepelum-ssl", "mainnet.pepelum.site:50002", _s28_), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_TCP_2_tcp, "pepelum-tcp", "mainnet.pepelum.site:50001", _s28_), A.ElectrumAPIProvider_ElectrumAPIProvider(B.ServiceProtocol_WebSocket_3_websocket, "pepelum-wss", "wss://mainnet.pepelum.site:50004", "mainnet.pepelum.site")], t1), 30, A._setArrayType([A.RippleAPIProvider_RippleAPIProvider(_s6_, "https://xrplcluster.com/", _s23_1), A.RippleAPIProvider_RippleAPIProvider("Ripple-wss", "wss://xrplcluster.com/", _s23_1)], t1), 31, A._setArrayType([A.RippleAPIProvider_RippleAPIProvider(_s6_, "https://s.altnet.rippletest.net:51234/", _s22_0), A.RippleAPIProvider_RippleAPIProvider(_s6_, "wss://s.altnet.rippletest.net:51233", _s22_0)], t1), 32, A._setArrayType([A.RippleAPIProvider_RippleAPIProvider(_s6_, "https://s.devnet.rippletest.net:51234/", _s22_0), A.RippleAPIProvider_RippleAPIProvider(_s6_, "wss://s.devnet.rippletest.net:51233", _s22_0)], t1), 33, A._setArrayType([B.SolanaAPIProvider_AHc], t1), 34, A._setArrayType([B.SolanaAPIProvider_yXb], t1), 50, A._setArrayType([A.CardanoAPIProvider_CardanoAPIProvider(B.ProviderAuth_u7S, _s10_, "https://cardano-mainnet.blockfrost.io/api/v0/", _s13_0)], t1), 51, A._setArrayType([A.CardanoAPIProvider_CardanoAPIProvider(B.ProviderAuth_86y, _s10_, "https://cardano-preprod.blockfrost.io/api/v0/", _s13_0)], t1), 100, A._setArrayType([A.EthereumAPIProvider_EthereumAPIProvider(_s10_0, _s29_, _s23_2), A.EthereumAPIProvider_EthereumAPIProvider(_s10_0, _s29_, _s23_2)], t1), 101, A._setArrayType([A.EthereumAPIProvider_EthereumAPIProvider(_s14_1, _s39_, _s39_)], t1), 102, A._setArrayType([A.EthereumAPIProvider_EthereumAPIProvider(_s14_1, _s34_, _s34_)], t1), 103, A._setArrayType([A.EthereumAPIProvider_EthereumAPIProvider(_s14_1, _s41_, _s41_)], t1), 104, A._setArrayType([A.EthereumAPIProvider_EthereumAPIProvider(_s14_1, _s26_, _s26_)], t1), 105, A._setArrayType([A.EthereumAPIProvider_EthereumAPIProvider(_s14_1, _s34_0, _s34_0)], t1), 200, A._setArrayType([A.CosmosAPIProvider_CosmosAPIProvider(_null, "cosmos-rpc.publicnode.com", _s37_, _s37_)], t1), 206, A._setArrayType([A.CosmosAPIProvider_CosmosAPIProvider(_null, _s12_0, _s33_, _s33_)], t1), 207, A._setArrayType([A.CosmosAPIProvider_CosmosAPIProvider(_null, _s12_0, _s24_0, _s24_0)], t1), 201, A._setArrayType([A.CosmosAPIProvider_CosmosAPIProvider(_null, "polypore.xyz", _s48_, _s48_)], t1), 202, A._setArrayType([A.CosmosAPIProvider_CosmosAPIProvider("https://mayanode.mayachain.info/mayachain", "mayachain.info", _s33_0, _s33_0)], t1), 203, A._setArrayType([A.CosmosAPIProvider_CosmosAPIProvider("https://thornode.ninerealms.com/thorchain", "liquify.com", "https://rpc.thorchain.liquify.com/", "https://rpc.thorchain.liquify.com")], t1), 204, A._setArrayType([A.CosmosAPIProvider_CosmosAPIProvider(_s40_, _s12_1, _s40_, _s40_)], t1), 205, A._setArrayType([A.CosmosAPIProvider_CosmosAPIProvider(_s32_, _s12_1, _s32_, _s32_)], t1), 300, A._setArrayType([A.TonAPIProvider_TonAPIProvider(B.TonApiType_tonApi, _null, "TonAPI", _s17_0, _s17_0), A.TonAPIProvider_TonAPIProvider(B.TonApiType_tonCenter, B.ProviderAuth_8Gl, _s9_, "https://toncenter.com", _s20_1)], t1), 301, A._setArrayType([A.TonAPIProvider_TonAPIProvider(B.TonApiType_tonApi, _null, "TonAPI", "https://testnet.tonapi.io", _s17_0), A.TonAPIProvider_TonAPIProvider(B.TonApiType_tonCenter, B.ProviderAuth_4br, _s9_, "https://testnet.toncenter.com", _s20_1)], t1), 400, A._setArrayType([A.SubstrateAPIProvider_SubstrateAPIProvider("Polkadot", "https://rpc.polkadot.io", _s19_)], t1), 450, A._setArrayType([A.SubstrateAPIProvider_SubstrateAPIProvider("Kusama", "https://kusama-rpc.polkadot.io", _s19_)], t1), 451, A._setArrayType([A.SubstrateAPIProvider_SubstrateAPIProvider("Westend", "https://westend-rpc.polkadot.io", _s19_)], t1), 1001, A._setArrayType([A.TronAPIProvider$(_null, "https://api.trongrid.io", _s8_, A.EthereumAPIProvider_EthereumAPIProvider(_s31_, _s31_, _s11_), _s19_0)], t1), 1002, A._setArrayType([A.TronAPIProvider$(_null, "https://api.shasta.trongrid.io", _s8_, A.EthereumAPIProvider_EthereumAPIProvider(_s38_, _s38_, _s11_), _s19_0)], t1), 1003, A._setArrayType([A.TronAPIProvider$(_null, "https://nile.trongrid.io", _s8_, A.EthereumAPIProvider_EthereumAPIProvider(_s32_0, _s32_0, _s11_), _s19_0)], t1)], t2, t2), type$.int, type$.List_APIProvider);
    });
    _lazyFinal($, "HTTPService__client", "$get$HTTPService__client", () => new A.BrowserClient(A.LinkedHashSet_LinkedHashSet$_empty(type$.JSObject)));
    _lazyFinal($, "_DefaultAppCoins_bitcoinCashMainnet", "$get$_DefaultAppCoins_bitcoinCashMainnet", () => {
      var t1 = A.Token_Token(B.C_APPImage15, 8, B.CoingeckoCoin_wzg, "BitcoinCash", "BCH");
      return A.BitcoinParams$("https://bch.loping.net/address/#address", string$.x3000000, A._setArrayType([], type$.JSArray_BaseBitcoinAPIProvider), t1, B.BitcoinCashNetwork_q9y, "https://bch.loping.net/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_bitcoinCashChipnet", "$get$_DefaultAppCoins_bitcoinCashChipnet", () => {
      var t1 = A.Token_Token(B.C_APPImage15, 8, B.CoingeckoCoin_wzg, "BitcoinCash chipnet", "tBCH");
      return A.BitcoinParams$("https://cbch.loping.net/address/#address", "000000001dd410c49a788668ce26751718cc797474d3152a5fc073dd44fd9f7b", A._setArrayType([], type$.JSArray_BaseBitcoinAPIProvider), t1, B.BitcoinCashNetwork_69P, "https://cbch.loping.net/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_bitcoinMainnet", "$get$_DefaultAppCoins_bitcoinMainnet", () => {
      var t1 = A.Token_Token(B.C_APPImage20, 8, B.CoingeckoCoin_bitcoin_bitcoin_null, "Bitcoin", "BTC");
      return A.BitcoinParams$("https://live.blockcypher.com/btc/address/#address/", string$.x3000000, A._setArrayType([], type$.JSArray_BaseBitcoinAPIProvider), t1, B.BitcoinNetwork_qBr, "https://live.blockcypher.com/btc/tx/#txid/");
    });
    _lazyFinal($, "_DefaultAppCoins_bitcoinTestnet", "$get$_DefaultAppCoins_bitcoinTestnet", () => {
      var t1 = A.Token_Token(B.C_APPImage20, 8, B.CoingeckoCoin_bitcoin_bitcoin_null, "Bitcoin testnet", "tBTC");
      return A.BitcoinParams$("https://live.blockcypher.com/btc-testnet/address/#address/", "000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943", A._setArrayType([], type$.JSArray_BaseBitcoinAPIProvider), t1, B.BitcoinNetwork_DSc, "https://live.blockcypher.com/btc-testnet/tx/#txid/");
    });
    _lazyFinal($, "_DefaultAppCoins_litecoinMainnet", "$get$_DefaultAppCoins_litecoinMainnet", () => {
      var t1 = A.Token_Token(B.C_APPImage19, 8, B.CoingeckoCoin_litecoin_litecoin_null, "Litecoin", "LTC");
      return A.BitcoinParams$(string$.https_lla, "12a765e31ffd4059bada1e25190f6e98c99d9714d334efa41a195a7e7e04bfe2", A._setArrayType([], type$.JSArray_BaseBitcoinAPIProvider), t1, B.LitecoinNetwork_OXY, string$.https_llt);
    });
    _lazyFinal($, "_DefaultAppCoins_litecoinTestnet", "$get$_DefaultAppCoins_litecoinTestnet", () => {
      var t1 = A.Token_Token(B.C_APPImage19, 8, B.CoingeckoCoin_litecoin_litecoin_null, "Litecoin testnet", "tLTC");
      return A.BitcoinParams$(string$.https_lla, "4966625a4b2851d9fdee139e56211a0d88575f59ed816ff5e6a63deb4e3e29a0", A._setArrayType([], type$.JSArray_BaseBitcoinAPIProvider), t1, B.LitecoinNetwork_CiQ, string$.https_llt);
    });
    _lazyFinal($, "_DefaultAppCoins_dogecoinMainnet", "$get$_DefaultAppCoins_dogecoinMainnet", () => {
      var t1 = A.Token_Token(B.C_APPImage18, 8, B.CoingeckoCoin_dogecoin_dogecoin_null, "Dogecoin", "\u0189");
      return A.BitcoinParams$(string$.https_lda, "1a91e3dace36e2be3bf030a65679fe821aa1d6ef92e7c9902eb318182c355691", A._setArrayType([], type$.JSArray_BaseBitcoinAPIProvider), t1, B.DogecoinNetwork_6L0, string$.https_ldt);
    });
    _lazyFinal($, "_DefaultAppCoins_pepecoinMainnet", "$get$_DefaultAppCoins_pepecoinMainnet", () => {
      var t1 = A.Token_Token(B.C_APPImage14, 8, B.CoingeckoCoin_b1V, "Pepecoin", "\u20b1");
      return A.BitcoinParams$("https://pepeexplorer.com/address/#address", "37981c0c48b8d48965376c8a42ece9a0838daadb93ff975cb091f57f8c2a5faa", A._setArrayType([], type$.JSArray_BaseBitcoinAPIProvider), t1, B.C_PepeNetwork, "https://pepeexplorer.com/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_dogeTestnet", "$get$_DefaultAppCoins_dogeTestnet", () => {
      var t1 = A.Token_Token(B.C_APPImage18, 8, B.CoingeckoCoin_dogecoin_dogecoin_null, "Dogecoin testnet", "t\u0189");
      return A.BitcoinParams$(string$.https_lda, "bb0a78264637406b6360aad926284d544d7049f45189db5664f3c4d07350559e", A._setArrayType([], type$.JSArray_BaseBitcoinAPIProvider), t1, B.DogecoinNetwork_n3E, string$.https_ldt);
    });
    _lazyFinal($, "_DefaultAppCoins_bsvMainnet", "$get$_DefaultAppCoins_bsvMainnet", () => {
      var t1 = A.Token_Token(B.C_APPImage17, 8, B.CoingeckoCoin_QuN, "BitcoinSV", "BSV");
      return A.BitcoinParams$("https://whatsonchain.com/address/#address", string$.x3000000, A._setArrayType([], type$.JSArray_BaseBitcoinAPIProvider), t1, B.BitcoinSVNetwork_GZw, "https://whatsonchain.com/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_dashMainnet", "$get$_DefaultAppCoins_dashMainnet", () => {
      var t1 = A.Token_Token(B.C_APPImage16, 8, B.CoingeckoCoin_dash_dash_null, "Dash", "DASH");
      return A.BitcoinParams$("https://live.blockcypher.com/dash/address/#address/", "00000ffd590b1485b3caadc19b22e6379c733355108f107a430458cdf3407ab6", A._setArrayType([], type$.JSArray_BaseBitcoinAPIProvider), t1, B.DashNetwork_XbV, "https://live.blockcypher.com/dash/tx/#txid/");
    });
    _lazyFinal($, "_DefaultAppCoins_xrpMainnet", "$get$_DefaultAppCoins_xrpMainnet", () => {
      var t1 = A.Token_Token(B.C_APPImage13, 6, B.CoingeckoCoin_ripple_xrp_null, "Ripple", "XRP");
      return A.RippleNetworkParams$("https://livenet.xrpl.org/accounts/#address", true, A._setArrayType([], A.findType("JSArray<RippleAPIProvider>")), t1, "https://livenet.xrpl.org/transactions/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_xrpTestnet", "$get$_DefaultAppCoins_xrpTestnet", () => {
      var t1 = A.Token_Token(B.C_APPImage13, 6, B.CoingeckoCoin_ripple_xrp_null, "Ripple testnet", "tXRP");
      return A.RippleNetworkParams$("https://testnet.xrpl.org/accounts/#address", false, A._setArrayType([], A.findType("JSArray<RippleAPIProvider>")), t1, "https://testnet.xrpl.org/transactions/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_xrpDevnet", "$get$_DefaultAppCoins_xrpDevnet", () => {
      var t1 = A.Token_Token(B.C_APPImage13, 6, B.CoingeckoCoin_ripple_xrp_null, "Ripple devnet", "tXRP");
      return A.RippleNetworkParams$("https://devnet.xrpl.org/accounts/#address", false, A._setArrayType([], A.findType("JSArray<RippleAPIProvider>")), t1, "https://devnet.xrpl.org/transactions/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_ethreumMainnet", "$get$_DefaultAppCoins_ethreumMainnet", () => {
      var t1 = $.$get$_BigIntImpl_one(),
        t2 = A.Token_Token(B.C_APPImage10, 18, B.CoingeckoCoin_ethereum_ethereum_null, "Ethereum", "ETH");
      return A.EthereumNetworkParams$("https://etherscan.io/address/#address", null, t1, true, true, A._setArrayType([], type$.JSArray_EthereumAPIProvider), true, t2, "https://etherscan.io/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_ethreumTestnet", "$get$_DefaultAppCoins_ethreumTestnet", () => {
      var t1 = A._BigIntImpl__BigIntImpl$from(11155111),
        t2 = A.Token_Token(B.C_APPImage10, 18, B.CoingeckoCoin_ethereum_ethereum_null, "Ethereum Sepolia testnet", "tETH");
      return A.EthereumNetworkParams$("https://sepolia.etherscan.io/address/#address", null, t1, true, false, A._setArrayType([], type$.JSArray_EthereumAPIProvider), true, t2, "https://sepolia.etherscan.io/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_polygon", "$get$_DefaultAppCoins_polygon", () => {
      var t1 = A._BigIntImpl__BigIntImpl$from(137),
        t2 = A.Token_Token(B.C_APPImage9, 18, B.CoingeckoCoin_N1Q, "Polygon", "MATIC");
      return A.EthereumNetworkParams$("https://polygonscan.com/address/#address", null, t1, true, true, A._setArrayType([], type$.JSArray_EthereumAPIProvider), true, t2, "https://polygonscan.com/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_polygonTestnet", "$get$_DefaultAppCoins_polygonTestnet", () => {
      var t1 = A._BigIntImpl__BigIntImpl$from(80001),
        t2 = A.Token_Token(B.C_APPImage9, 18, B.CoingeckoCoin_N1Q, "Polygon mumbai testnet", "tMATIC");
      return A.EthereumNetworkParams$("https://mumbai.polygonscan.com/address/#address", null, t1, true, false, A._setArrayType([], type$.JSArray_EthereumAPIProvider), true, t2, "https://mumbai.polygonscan.com/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_bnb", "$get$_DefaultAppCoins_bnb", () => {
      var t1 = A._BigIntImpl__BigIntImpl$from(56),
        t2 = A.Token_Token(B.C_APPImage8, 18, B.CoingeckoCoin_binancecoin_bnb_null, "BNB Smart Chain", "BNB");
      return A.EthereumNetworkParams$("https://bscscan.com/address/#address", null, t1, true, true, A._setArrayType([], type$.JSArray_EthereumAPIProvider), false, t2, "https://bscscan.com/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_bnbTestnet", "$get$_DefaultAppCoins_bnbTestnet", () => {
      var t1 = A._BigIntImpl__BigIntImpl$from(97),
        t2 = A.Token_Token(B.C_APPImage8, 18, B.CoingeckoCoin_binancecoin_bnb_null, "BNB Smart chain testnet", "tBNB");
      return A.EthereumNetworkParams$("https://testnet.bscscan.com/address/#address", null, t1, true, false, A._setArrayType([], type$.JSArray_EthereumAPIProvider), false, t2, "https://testnet.bscscan.com/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_tronShasta", "$get$_DefaultAppCoins_tronShasta", () => {
      var t1 = A.Token_Token(B.C_APPImage, 6, B.CoingeckoCoin_tron_tron_null, "Tron shasta testnet", "tTRX"),
        t2 = A._setArrayType([], A.findType("JSArray<TronAPIProvider>"));
      return A.TronNetworkParams$("https://shasta.tronscan.org/#/address/#address", A._setArrayType([], type$.JSArray_EthereumAPIProvider), "0000000000000000de1aa88295e1fcf982742f773e0419c5a9c134c994a9059e", false, t2, t1, "https://shasta.tronscan.org/#/transaction/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_tronNile", "$get$_DefaultAppCoins_tronNile", () => {
      var t1 = A.Token_Token(B.C_APPImage, 6, B.CoingeckoCoin_tron_tron_null, "Tron nile testnet", "tTRX");
      return A.TronNetworkParams$("https://nile.tronscan.org/#/address/#address", A._setArrayType([], type$.JSArray_EthereumAPIProvider), "0000000000000000d698d4192c56cb6be724a558448e2684802de4d6cd8690dc", false, A._setArrayType([], A.findType("JSArray<TronAPIProvider>")), t1, "https://nile.tronscan.org/#/transaction/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_tron", "$get$_DefaultAppCoins_tron", () => {
      var t1 = A.Token_Token(B.C_APPImage, 6, B.CoingeckoCoin_tron_tron_null, "Tron", "TRX");
      return A.TronNetworkParams$("https://tronscan.org/#/address/#address", A._setArrayType([], type$.JSArray_EthereumAPIProvider), "00000000000000001ebf88508a03865c71d452e25f4d51194196a1d22b6653dc", true, A._setArrayType([], A.findType("JSArray<TronAPIProvider>")), t1, "https://tronscan.org/#/transaction/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_solana", "$get$_DefaultAppCoins_solana", () => {
      var t1 = A.Token_Token(B.C_APPImage12, 9, B.CoingeckoCoin_solana_solana_null, "Solana", "SOL");
      return A.SolanaNetworkParams$("https://explorer.solana.com/address/#address", "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d", true, A._setArrayType([], A.findType("JSArray<SolanaAPIProvider>")), t1, "https://explorer.solana.com/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_solanaTestnet", "$get$_DefaultAppCoins_solanaTestnet", () => {
      var t1 = A.Token_Token(B.C_APPImage12, 9, B.CoingeckoCoin_solana_solana_null, "Solana testnet", "tSOL");
      return A.SolanaNetworkParams$("https://explorer.solana.com/address/#address?cluster=testnet", "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY", false, A._setArrayType([], A.findType("JSArray<SolanaAPIProvider>")), t1, "https://explorer.solana.com/tx/#txid?cluster=testnet");
    });
    _lazyFinal($, "_DefaultAppCoins_cardanoTestnet", "$get$_DefaultAppCoins_cardanoTestnet", () => {
      var t1 = A.Token_Token(B.C_APPImage11, 6, B.CoingeckoCoin_cardano_cardano_null, "Cardano preprod", "tADA");
      return A.CardanoNetworkParams$("https://preprod.beta.explorer.cardano.org/en/address/#address", false, A._setArrayType([], A.findType("JSArray<CardanoAPIProvider>")), t1, "https://preprod.beta.explorer.cardano.org/en/transaction/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_cardano", "$get$_DefaultAppCoins_cardano", () => {
      var t1 = A.Token_Token(B.C_APPImage11, 6, B.CoingeckoCoin_cardano_cardano_null, "Cardano", "ADA");
      return A.CardanoNetworkParams$("https://beta.explorer.cardano.org/en/address/#address", true, A._setArrayType([], A.findType("JSArray<CardanoAPIProvider>")), t1, "https://beta.explorer.cardano.org/en/transaction/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_cosmosTestnet", "$get$_DefaultAppCoins_cosmosTestnet", () => {
      var t1 = A._setArrayType([B.C_CosmosNativeCoin3], type$.JSArray_CosmosNativeCoin),
        t2 = A.Token_Token(B.C_APPImage7, 6, B.CoingeckoCoin_5QF, "Cosmos hub testnet", "tATOM");
      return A.CosmosNetworkParams$("https://explorer.polypore.xyz/theta-testnet-001/account/#address", null, t1, "cosmos", B.C_CosmosNativeCoin3, false, B.CosmosNetworkTypes_0, A._setArrayType([], type$.JSArray_CosmosAPIProvider), t2, "https://explorer.polypore.xyz/theta-testnet-001/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_cosmos", "$get$_DefaultAppCoins_cosmos", () => {
      var t1 = A._setArrayType([B.C_CosmosNativeCoin3], type$.JSArray_CosmosNativeCoin),
        t2 = A.Token_Token(B.C_APPImage7, 6, B.CoingeckoCoin_5QF, "Cosmos hub", "ATOM");
      return A.CosmosNetworkParams$("https://ping.pub/cosmos/account/#address", null, t1, "cosmos", B.C_CosmosNativeCoin3, true, B.CosmosNetworkTypes_0, A._setArrayType([], type$.JSArray_CosmosAPIProvider), t2, "https://ping.pub/cosmos/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_maya", "$get$_DefaultAppCoins_maya", () => {
      var t1 = A._setArrayType([B.C_CosmosNativeCoin2], type$.JSArray_CosmosNativeCoin),
        t2 = A.Token_Token(B.C_APPImage6, 10, B.CoingeckoCoin_EW9, "Maya Protocol", "Cacao");
      return A.CosmosNetworkParams$("https://www.mayascan.org/address/#address", null, t1, "maya", B.C_CosmosNativeCoin2, true, B.CosmosNetworkTypes_2, A._setArrayType([], type$.JSArray_CosmosAPIProvider), t2, "https://www.mayascan.org/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_thorchain", "$get$_DefaultAppCoins_thorchain", () => {
      var t1 = A._setArrayType([B.C_CosmosNativeCoin1], type$.JSArray_CosmosNativeCoin),
        t2 = A.Token_Token(B.C_APPImage5, 8, B.CoingeckoCoin_thorchain_thorchain_null, "THORChain", "Rune");
      return A.CosmosNetworkParams$("https://www.thorscanner.org/address/#address", 931, t1, "thor", B.C_CosmosNativeCoin1, true, B.CosmosNetworkTypes_2, A._setArrayType([], type$.JSArray_CosmosAPIProvider), t2, "https://www.thorscanner.org/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_kujiraTestnet", "$get$_DefaultAppCoins_kujiraTestnet", () => {
      var t1 = A._setArrayType([B.C_CosmosNativeCoin0], type$.JSArray_CosmosNativeCoin),
        t2 = A.Token_Token(B.C_APPImage4, 6, B.CoingeckoCoin_kujira_kujira_null, "Kujira Testnet", "tKuji");
      return A.CosmosNetworkParams$("https://finder.kujira.network/harpoon-4/address/#address", null, t1, "kujira", B.C_CosmosNativeCoin0, false, B.CosmosNetworkTypes_1, A._setArrayType([], type$.JSArray_CosmosAPIProvider), t2, "https://finder.kujira.network/harpoon-4/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_kujira", "$get$_DefaultAppCoins_kujira", () => {
      var t1 = A._setArrayType([B.C_CosmosNativeCoin0], type$.JSArray_CosmosNativeCoin),
        t2 = A.Token_Token(B.C_APPImage4, 6, B.CoingeckoCoin_kujira_kujira_null, "Kujira", "Kuji");
      return A.CosmosNetworkParams$("https://finder.kujira.network/kaiyo-1/address/#address", null, t1, "kujira", B.C_CosmosNativeCoin0, true, B.CosmosNetworkTypes_1, A._setArrayType([], type$.JSArray_CosmosAPIProvider), t2, "https://finder.kujira.network/kaiyo-1/tx/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_osmosisTestnet", "$get$_DefaultAppCoins_osmosisTestnet", () => {
      var t1 = A._setArrayType([B.C_CosmosNativeCoin], type$.JSArray_CosmosNativeCoin),
        t2 = A.Token_Token(B.C_APPImage3, 6, B.CoingeckoCoin_osmosis_osmosis_null, "Osmo testnet", "tOsmo");
      return A.CosmosNetworkParams$("https://celatone.osmosis.zone/osmo-test-5/accounts/#address", null, t1, "osmo", B.C_CosmosNativeCoin, false, B.CosmosNetworkTypes_0, A._setArrayType([], type$.JSArray_CosmosAPIProvider), t2, "https://celatone.osmosis.zone/osmo-test-5/txs/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_osmosis", "$get$_DefaultAppCoins_osmosis", () => {
      var t1 = A._setArrayType([B.C_CosmosNativeCoin], type$.JSArray_CosmosNativeCoin),
        t2 = A.Token_Token(B.C_APPImage3, 6, B.CoingeckoCoin_osmosis_osmosis_null, "Osmosis", "Osmo");
      return A.CosmosNetworkParams$("https://celatone.osmosis.zone/osmosis-1/accounts/#address", null, t1, "osmo", B.C_CosmosNativeCoin, true, B.CosmosNetworkTypes_0, A._setArrayType([], type$.JSArray_CosmosAPIProvider), t2, "https://celatone.osmosis.zone/osmosis-1/txs/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_tonTestnet", "$get$_DefaultAppCoins_tonTestnet", () => {
      var t1 = A.Token_Token(B.C_APPImage2, 9, B.CoingeckoCoin_yLX, "TonCoin testnet", "tTon");
      return A.TonNetworkParams$("https://testnet.tonscan.org/address/#address", false, A._setArrayType([], A.findType("JSArray<TonAPIProvider>")), t1, "https://testnet.tonscan.org/tx/#txid", -1);
    });
    _lazyFinal($, "_DefaultAppCoins_tonMainnet", "$get$_DefaultAppCoins_tonMainnet", () => {
      var t1 = A.Token_Token(B.C_APPImage2, 9, B.CoingeckoCoin_yLX, "TonCoin", "Ton");
      return A.TonNetworkParams$("https://tonscan.org/address/#address", true, A._setArrayType([], A.findType("JSArray<TonAPIProvider>")), t1, "https://tonscan.org/tx/#txid", 0);
    });
    _lazyFinal($, "_DefaultAppCoins_westend", "$get$_DefaultAppCoins_westend", () => {
      var t1 = A.Token_Token(null, 12, null, "Westend", "WND");
      return A.SubstrateNetworkParams$("https://westend.subscan.io/account/#address", false, A._setArrayType([], A.findType("JSArray<SubstrateAPIProvider>")), 1014000, 42, t1, "https://westend.subscan.io/extrinsic/#txid");
    });
    _lazyFinal($, "_DefaultAppCoins_polkadot", "$get$_DefaultAppCoins_polkadot", () => {
      var t1 = A.Token_Token(B.C_APPImage1, 10, B.CoingeckoCoin_polkadot_polkadot_DOT, "Polkadot", "DOT");
      return A.SubstrateNetworkParams$(string$.https_pa, true, A._setArrayType([], A.findType("JSArray<SubstrateAPIProvider>")), 1002006, 0, t1, string$.https_pe);
    });
    _lazyFinal($, "_DefaultAppCoins_kusama", "$get$_DefaultAppCoins_kusama", () => {
      var t1 = A.Token_Token(B.C_APPImage0, 12, B.CoingeckoCoin_kusama_kusama_KSM, "Kusama", "KSM");
      return A.SubstrateNetworkParams$(string$.https_pa, true, A._setArrayType([], A.findType("JSArray<SubstrateAPIProvider>")), 1002006, 2, t1, string$.https_pe);
    });
    _lazyFinal($, "ChainConst_defaultCoins", "$get$ChainConst_defaultCoins", () => {
      var _null = null,
        t1 = type$.dynamic;
      return A.ConstantMap_ConstantMap$from(A.LinkedHashMap_LinkedHashMap$_literal([0, A.WalletBitcoinNetwork$(0, $.$get$_DefaultAppCoins_bitcoinMainnet()), 1, A.WalletBitcoinNetwork$(1, $.$get$_DefaultAppCoins_bitcoinTestnet()), 2, A.WalletBitcoinNetwork$(2, $.$get$_DefaultAppCoins_litecoinMainnet()), 7, A.WalletBitcoinNetwork$(7, $.$get$_DefaultAppCoins_litecoinTestnet()), 3, A.WalletBitcoinNetwork$(3, $.$get$_DefaultAppCoins_dogecoinMainnet()), 8, A.WalletBitcoinNetwork$(8, $.$get$_DefaultAppCoins_dogeTestnet()), 9, A.WalletBitcoinNetwork$(9, $.$get$_DefaultAppCoins_bsvMainnet()), 4, A.WalletBitcoinNetwork$(4, $.$get$_DefaultAppCoins_dashMainnet()), 10, A.WalletBitcoinCashNetwork$(10, $.$get$_DefaultAppCoins_bitcoinCashMainnet()), 11, A.WalletBitcoinCashNetwork$(11, $.$get$_DefaultAppCoins_bitcoinCashChipnet()), 12, A.WalletBitcoinNetwork$(12, $.$get$_DefaultAppCoins_pepecoinMainnet()), 30, A.WalletXRPNetwork$(30, $.$get$_DefaultAppCoins_xrpMainnet()), 31, A.WalletXRPNetwork$(31, $.$get$_DefaultAppCoins_xrpTestnet()), 32, A.WalletXRPNetwork$(32, $.$get$_DefaultAppCoins_xrpDevnet()), 33, A.WalletSolanaNetwork$(33, $.$get$_DefaultAppCoins_solana()), 34, A.WalletSolanaNetwork$(34, $.$get$_DefaultAppCoins_solanaTestnet()), 50, A.WalletCardanoNetwork$(50, $.$get$_DefaultAppCoins_cardano()), 51, A.WalletCardanoNetwork$(51, $.$get$_DefaultAppCoins_cardanoTestnet()), 100, A.WalletEthereumNetwork$(100, $.$get$_DefaultAppCoins_ethreumMainnet(), _null), 101, A.WalletEthereumNetwork$(101, $.$get$_DefaultAppCoins_ethreumTestnet(), _null), 102, A.WalletEthereumNetwork$(102, $.$get$_DefaultAppCoins_polygon(), _null), 103, A.WalletEthereumNetwork$(103, $.$get$_DefaultAppCoins_polygonTestnet(), _null), 104, A.WalletEthereumNetwork$(104, $.$get$_DefaultAppCoins_bnb(), _null), 105, A.WalletEthereumNetwork$(105, $.$get$_DefaultAppCoins_bnbTestnet(), _null), 200, A.WalletCosmosNetwork$(200, $.$get$_DefaultAppCoins_cosmos()), 201, A.WalletCosmosNetwork$(201, $.$get$_DefaultAppCoins_cosmosTestnet()), 202, A.WalletCosmosNetwork$(202, $.$get$_DefaultAppCoins_maya()), 203, A.WalletCosmosNetwork$(203, $.$get$_DefaultAppCoins_thorchain()), 204, A.WalletCosmosNetwork$(204, $.$get$_DefaultAppCoins_kujiraTestnet()), 205, A.WalletCosmosNetwork$(205, $.$get$_DefaultAppCoins_kujira()), 206, A.WalletCosmosNetwork$(206, $.$get$_DefaultAppCoins_osmosisTestnet()), 207, A.WalletCosmosNetwork$(207, $.$get$_DefaultAppCoins_osmosis()), 300, A.WalletTonNetwork$(300, $.$get$_DefaultAppCoins_tonMainnet()), 301, A.WalletTonNetwork$(301, $.$get$_DefaultAppCoins_tonTestnet()), 400, A.WalletPolkadotNetwork$(400, $.$get$_DefaultAppCoins_polkadot()), 450, A.WalletKusamaNetwork$(450, $.$get$_DefaultAppCoins_kusama()), 451, A.WalletKusamaNetwork$(451, $.$get$_DefaultAppCoins_westend()), 1001, A.WalletTronNetwork$(1001, $.$get$_DefaultAppCoins_tron()), 1002, A.WalletTronNetwork$(1002, $.$get$_DefaultAppCoins_tronShasta()), 1003, A.WalletTronNetwork$(1003, $.$get$_DefaultAppCoins_tronNile())], t1, t1), type$.int, type$.WalletNetwork_NetworkCoinParams_APIProvider);
    });
    _lazyFinal($, "CustomCoins_byronLegacy", "$get$CustomCoins_byronLegacy", () => A.CustomCoins$_("Byron legacy", $.$get$CustomCurrencyConf_byronLegacy()));
    _lazyFinal($, "CustomCoins_byronLegacyTestnet", "$get$CustomCoins_byronLegacyTestnet", () => A.CustomCoins$_("Byron legacy testnet", $.$get$CustomCurrencyConf_byronLegacyTestnet()));
    _lazyFinal($, "CustomCoins_values", "$get$CustomCoins_values", () => A._setArrayType([$.$get$CustomCoins_byronLegacy(), $.$get$CustomCoins_byronLegacyTestnet()], A.findType("JSArray<CustomCoins>")));
    _lazy($, "CustomCurrencyConf_byronLegacy", "$get$CustomCurrencyConf_byronLegacy", () => {
      var t1 = $.$get$Bip32Const_kholawKeyNetVersions();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["chain_code", true], type$.String, type$.dynamic), new A.CustomCurrencyConf_byronLegacy_closure(), 0, B.CoinNames_xw8, "0/0", false, t1, B.EllipticCurveTypes_ed25519Kholaw, null);
    });
    _lazy($, "CustomCurrencyConf_byronLegacyTestnet", "$get$CustomCurrencyConf_byronLegacyTestnet", () => {
      var t1 = $.$get$Bip32Const_kholawKeyNetVersions();
      return A.BipCoinConfig$(A.LinkedHashMap_LinkedHashMap$_literal(["chain_code", true], type$.String, type$.dynamic), new A.CustomCurrencyConf_byronLegacyTestnet_closure(), 1, B.CoinNames_PVK, "", true, t1, B.EllipticCurveTypes_ed25519Kholaw, null);
    });
    _lazyFinal($, "_EIP712Utils_typeRegex", "$get$_EIP712Utils_typeRegex", () => A.RegExp_RegExp("^\\w+", true));
    _lazyFinal($, "_EIP712Utils_arrayRegex", "$get$_EIP712Utils_arrayRegex", () => A.RegExp_RegExp("^(.*)\\[([0-9]*?)]$", true));
    _lazyFinal($, "_ABIValidator_sizeDetectRegex", "$get$_ABIValidator_sizeDetectRegex", () => A.RegExp_RegExp("\\d+", true));
    _lazyFinal($, "context", "$get$context", () => new A.Context($.$get$Style_platform()));
    _lazyFinal($, "Style_posix", "$get$Style_posix", () => new A.PosixStyle(A.RegExp_RegExp("/", true), A.RegExp_RegExp("[^/]$", true), A.RegExp_RegExp("^/", true)));
    _lazyFinal($, "Style_windows", "$get$Style_windows", () => new A.WindowsStyle(A.RegExp_RegExp("[/\\\\]", true), A.RegExp_RegExp("[^/\\\\]$", true), A.RegExp_RegExp("^(\\\\\\\\[^\\\\]+\\\\[^\\\\/]+|[a-zA-Z]:[/\\\\])", true), A.RegExp_RegExp("^[/\\\\](?![/\\\\])", true)));
    _lazyFinal($, "Style_url", "$get$Style_url", () => new A.UrlStyle(A.RegExp_RegExp("/", true), A.RegExp_RegExp("(^[a-zA-Z][-+.a-zA-Z\\d]*://|[^/])$", true), A.RegExp_RegExp("[a-zA-Z][-+.a-zA-Z\\d]*://[^/]*", true), A.RegExp_RegExp("^/", true)));
    _lazyFinal($, "Style_platform", "$get$Style_platform", () => A.Style__getPlatformStyle());
    _lazyFinal($, "PlatformInterface__instanceTokens", "$get$PlatformInterface__instanceTokens", () => new A.Expando(new WeakMap(), A.findType("Expando<Object>")));
    _lazyFinal($, "TonAddress__decoder", "$get$TonAddress__decoder", () => new A.TonAddrDecoder());
  })();
  (function nativeSupport() {
    !function() {
      var intern = function(s) {
        var o = {};
        o[s] = 1;
        return Object.keys(hunkHelpers.convertToFastObject(o))[0];
      };
      init.getIsolateTag = function(name) {
        return intern("___dart_" + name + init.isolateTag);
      };
      var tableProperty = "___dart_isolate_tags_";
      var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
      var rootProperty = "_ZxYxX";
      for (var i = 0;; i++) {
        var property = intern(rootProperty + "_" + i + "_");
        if (!(property in usedProperties)) {
          usedProperties[property] = 1;
          init.isolateTag = property;
          break;
        }
      }
      init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
    }();
    hunkHelpers.setOrUpdateInterceptorsByTag({ArrayBuffer: A.NativeByteBuffer, ArrayBufferView: A.NativeTypedData, DataView: A.NativeByteData, Float32Array: A.NativeFloat32List, Float64Array: A.NativeFloat64List, Int16Array: A.NativeInt16List, Int32Array: A.NativeInt32List, Int8Array: A.NativeInt8List, Uint16Array: A.NativeUint16List, Uint32Array: A.NativeUint32List, Uint8ClampedArray: A.NativeUint8ClampedList, CanvasPixelArray: A.NativeUint8ClampedList, Uint8Array: A.NativeUint8List});
    hunkHelpers.setOrUpdateLeafTags({ArrayBuffer: true, ArrayBufferView: false, DataView: true, Float32Array: true, Float64Array: true, Int16Array: true, Int32Array: true, Int8Array: true, Uint16Array: true, Uint32Array: true, Uint8ClampedArray: true, CanvasPixelArray: true, Uint8Array: false});
    A.NativeTypedArray.$nativeSuperclassTag = "ArrayBufferView";
    A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    A._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    A.NativeTypedArrayOfDouble.$nativeSuperclassTag = "ArrayBufferView";
    A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    A._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    A.NativeTypedArrayOfInt.$nativeSuperclassTag = "ArrayBufferView";
  })();
  Function.prototype.call$2 = function(a, b) {
    return this(a, b);
  };
  Function.prototype.call$0 = function() {
    return this();
  };
  Function.prototype.call$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$3 = function(a, b, c) {
    return this(a, b, c);
  };
  Function.prototype.call$4 = function(a, b, c, d) {
    return this(a, b, c, d);
  };
  Function.prototype.call$1$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$1$2 = function(a, b) {
    return this(a, b);
  };
  Function.prototype.call$6 = function(a, b, c, d, e, f) {
    return this(a, b, c, d, e, f);
  };
  Function.prototype.call$2$0 = function() {
    return this();
  };
  Function.prototype.call$1$0 = function() {
    return this();
  };
  convertAllToFastObject(holders);
  convertToFastObject($);
  (function(callback) {
    if (typeof document === "undefined") {
      callback(null);
      return;
    }
    if (typeof document.currentScript != "undefined") {
      callback(document.currentScript);
      return;
    }
    var scripts = document.scripts;
    function onLoad(event) {
      for (var i = 0; i < scripts.length; ++i) {
        scripts[i].removeEventListener("load", onLoad, false);
      }
      callback(event.target);
    }
    for (var i = 0; i < scripts.length; ++i) {
      scripts[i].addEventListener("load", onLoad, false);
    }
  })(function(currentScript) {
    init.currentScript = currentScript;
    var callMain = function(args) {
      return A.main(A.convertMainArgumentList(args));
    };
    if (typeof dartMainRunner === "function") {
      dartMainRunner(callMain, []);
    } else {
      callMain([]);
    }
  });
})();

//# sourceMappingURL=4.map
