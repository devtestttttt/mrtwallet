part of 'package:on_chain_wallet/wallet/models/chain/chain/chain.dart';

typedef NETWORKCHAINACCOUNT<NETWORKADDRESS>
    = ChainAccount<NETWORKADDRESS, TokenCore, NFTCore, ChainTransaction>;
typedef NFTCHAINACCOUNT<NFT extends NFTCore>
    = ChainAccount<dynamic, TokenCore, NFT, ChainTransaction>;

abstract final class ChainAccount<X, T extends TokenCore, N extends NFTCore,
    TRANSACTION extends ChainTransaction> with CborSerializable, Equatable {
  _WalletAddressStatus _status = _WalletAddressStatus.init;

  final AccountBalance address;
  final AddressDerivationIndex keyIndex;
  final int network;
  String? get type;
  final X networkAddress;
  final CryptoCoins coin;
  String get orginalAddress;
  List<int>? get publicKey;
  final String identifier;

  WalletAccountTransactions<TRANSACTION> _transaction =
      WalletAccountTransactions(transactions: []);

  List<TRANSACTION> get transactions => _transaction.transactions;

  ChainAccount({
    required this.address,
    required this.keyIndex,
    required this.network,
    required this.networkAddress,
    required this.coin,
    required String? accountName,
    required this.identifier,
  }) : _accountName = accountName;

  List<N> _nfts = [];
  List<N> get nfts => _nfts;
  List<T> _tokens = [];
  List<T> get tokens => _tokens;

  void _addToken(T newToken) {
    if (_tokens.contains(newToken)) {
      throw WalletExceptionConst.tokenAlreadyExist;
    }
    _tokens = [newToken, ..._tokens].immutable;
  }

  void _addTx(TRANSACTION tx) {
    _transaction.addTx(tx);
  }

  void _removeTx(TRANSACTION tx) {
    _transaction.removeTx(tx);
  }

  void _removeToken(T token) {
    if (!tokens.contains(token)) return;
    final existTokens = _tokens.clone();
    existTokens.removeWhere((element) => element == token);
    _tokens = existTokens.immutable;
  }

  void _addNFT(N newNft) {
    if (_nfts.contains(newNft)) {
      throw WalletExceptionConst.nftsAlreadyExist;
    }
    _nfts = List.unmodifiable([newNft, ..._nfts]);
  }

  void _removeNFT(N nft) {
    if (!_nfts.contains(nft)) return;
    final existNfts = List.from(_nfts);
    existNfts.removeWhere((element) => element == nft);
    _nfts = List.unmodifiable(_nfts);
  }

  String? _accountName;
  String? get accountName => _accountName;

  void _setAccountName(String? name) {
    _accountName = name;
  }

  NewAccountParams toAccountParams();
  List<AddressDerivationIndex> accessKeysIndexes() {
    if (multiSigAccount) {
      throw WalletExceptionConst.featureUnavailableForMultiSignature;
    }
    return signerKeyIndexes();
  }

  List<AddressDerivationIndex> signerKeyIndexes() {
    if (multiSigAccount) {
      throw WalletExceptionConst.featureUnavailableForMultiSignature;
    }
    return [keyIndex];
  }

  bool isEqual(ChainAccount other);
  IAdressType get iAddressType => IAdressType.singleKey;

  bool get multiSigAccount => iAddressType.isMultisig;
  String accountToString();
  C cast<C extends ChainAccount>() {
    if (this is C) return this as C;
    throw WalletExceptionConst.invalidArgruments("$runtimeType", "$C");
  }

  Future<void> _init({
    List<TRANSACTION> transactions = const [],
    List<N> nfts = const [],
    List<T> tokens = const [],
  }) async {
    if (_status.isInit) {
      _transaction = WalletAccountTransactions(transactions: transactions);

      _nfts = nfts.immutable;
      _tokens = tokens.immutable;
      _status = _WalletAddressStatus.ready;
    }
  }

  @override
  String toString() {
    return address.address;
  }
}

enum IAdressType {
  /// Simple address
  singleKey,

  /// multisig address thats work with main account. like tron and ripple
  multisigByAddress,

  /// multisig address. address generated by multiple public key like bitcoin, aptos, sui and ..
  multisigByPublicKey;

  bool get isMultisig => this != singleKey;

  bool get isMultisigByPublicKey => this == IAdressType.multisigByPublicKey;
}

abstract class MultiSigCryptoAccountAddress {
  abstract final List<(String, Bip32AddressIndex)> keyDetails;
}

class AccountBalance {
  AccountBalance({
    required this.address,
    BigInt? balance,
    required WalletNetwork network,
    DateTime? updated,
  })  : _updated = updated ?? DateTime.now(),
        balance = StreamValue.immutable(IntegerBalance.token(
            balance ?? BigInt.zero, network.token,
            immutable: true));

  factory AccountBalance.deserialize(WalletNetwork network,
      {List<int>? bytes, CborObject? obj}) {
    final CborListValue cbor =
        CborSerializable.decodeCborTags(bytes, obj, CborTagsConst.address);
    final String address = cbor.elementAs(0);
    final BigInt balance = cbor.elementAs(1);
    final DateTime updated = cbor.elementAs(2);
    return AccountBalance(
        address: address, network: network, balance: balance, updated: updated);
  }

  final String address;
  String get toAddress {
    return address;
  }

  final StreamValue<IntegerBalance> balance;
  BigInt get currencyBalance => balance.value.balance;
  bool get hasBalance => balance.value.largerThanZero;
  DateTime _updated;
  DateTime get updated => _updated;

  void _updateAddressBalance([BigInt? updateBalance]) {
    if (balance.value._internalUpdateBalance(updateBalance)) {
      balance.notify();
    }
  }

  CborTagValue toCbor() {
    return CborTagValue(
        CborListValue.fixedLength(
            [address, currencyBalance, CborEpochIntValue(updated)]),
        CborTagsConst.address);
  }
}
